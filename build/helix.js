(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define('HX', ['exports'], factory) :
	(factory((global.HX = {})));
}(this, (function (exports) { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var webvrPolyfill = createCommonjsModule(function (module, exports) {
	/**
	 * @license
	 * webvr-polyfill
	 * Copyright (c) 2015-2017 Google
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * @license
	 * cardboard-vr-display
	 * Copyright (c) 2015-2017 Google
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * @license
	 * webvr-polyfill-dpdb 
	 * Copyright (c) 2017 Google
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * @license
	 * wglu-preserve-state
	 * Copyright (c) 2016, Brandon Jones.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */

	/**
	 * @license
	 * nosleep.js
	 * Copyright (c) 2017, Rich Tibbett
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */

	(function (global, factory) {
		module.exports = factory();
	}(commonjsGlobal, (function () {
	var commonjsGlobal$$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};



	function unwrapExports$$1 (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule$$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var race = function race(promises) {
	  if (Promise.race) {
	    return Promise.race(promises);
	  }
	  return new Promise(function (resolve, reject) {
	    for (var i = 0; i < promises.length; i++) {
	      promises[i].then(resolve, reject);
	    }
	  });
	};

	var isMobile = function isMobile() {
	  return (/Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent)
	  );
	};
	var copyArray = function copyArray(source, dest) {
	  for (var i = 0, n = source.length; i < n; i++) {
	    dest[i] = source[i];
	  }
	};
	var extend = function extend(dest, src) {
	  for (var key in src) {
	    if (src.hasOwnProperty(key)) {
	      dest[key] = src[key];
	    }
	  }
	  return dest;
	};

	var cardboardVrDisplay = createCommonjsModule$$1(function (module, exports) {
	/**
	 * @license
	 * cardboard-vr-display
	 * Copyright (c) 2015-2017 Google
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * @license
	 * gl-preserve-state
	 * Copyright (c) 2016, Brandon Jones.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	/**
	 * @license
	 * webvr-polyfill-dpdb
	 * Copyright (c) 2015-2017 Google
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * @license
	 * nosleep.js
	 * Copyright (c) 2017, Rich Tibbett
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	(function (global, factory) {
		module.exports = factory();
	}(commonjsGlobal$$1, (function () { var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};
	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();
	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	    return _arr;
	  }
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();
	var MIN_TIMESTEP = 0.001;
	var MAX_TIMESTEP = 1;
	var base64 = function base64(mimeType, _base) {
	  return 'data:' + mimeType + ';base64,' + _base;
	};
	var lerp = function lerp(a, b, t) {
	  return a + (b - a) * t;
	};
	var isIOS = function () {
	  var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
	  return function () {
	    return isIOS;
	  };
	}();
	var isWebViewAndroid = function () {
	  var isWebViewAndroid = navigator.userAgent.indexOf('Version') !== -1 && navigator.userAgent.indexOf('Android') !== -1 && navigator.userAgent.indexOf('Chrome') !== -1;
	  return function () {
	    return isWebViewAndroid;
	  };
	}();
	var isSafari = function () {
	  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	  return function () {
	    return isSafari;
	  };
	}();
	var isFirefoxAndroid = function () {
	  var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 && navigator.userAgent.indexOf('Android') !== -1;
	  return function () {
	    return isFirefoxAndroid;
	  };
	}();
	var getChromeVersion = function () {
	  var match = navigator.userAgent.match(/.*Chrome\/([0-9]+)/);
	  var value = match ? parseInt(match[1], 10) : null;
	  return function () {
	    return value;
	  };
	}();
	var isChromeWithoutDeviceMotion = function () {
	  var value = false;
	  if (getChromeVersion() === 65) {
	    var match = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
	    if (match) {
	      var _match$1$split = match[1].split('.'),
	          _match$1$split2 = slicedToArray(_match$1$split, 4),
	          major = _match$1$split2[0],
	          minor = _match$1$split2[1],
	          branch = _match$1$split2[2],
	          build = _match$1$split2[3];
	      value = parseInt(branch, 10) === 3325 && parseInt(build, 10) < 148;
	    }
	  }
	  return function () {
	    return value;
	  };
	}();
	var isR7 = function () {
	  var isR7 = navigator.userAgent.indexOf('R7 Build') !== -1;
	  return function () {
	    return isR7;
	  };
	}();
	var isLandscapeMode = function isLandscapeMode() {
	  var rtn = window.orientation == 90 || window.orientation == -90;
	  return isR7() ? !rtn : rtn;
	};
	var isTimestampDeltaValid = function isTimestampDeltaValid(timestampDeltaS) {
	  if (isNaN(timestampDeltaS)) {
	    return false;
	  }
	  if (timestampDeltaS <= MIN_TIMESTEP) {
	    return false;
	  }
	  if (timestampDeltaS > MAX_TIMESTEP) {
	    return false;
	  }
	  return true;
	};
	var getScreenWidth = function getScreenWidth() {
	  return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
	};
	var getScreenHeight = function getScreenHeight() {
	  return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
	};
	var requestFullscreen = function requestFullscreen(element) {
	  if (isWebViewAndroid()) {
	    return false;
	  }
	  if (element.requestFullscreen) {
	    element.requestFullscreen();
	  } else if (element.webkitRequestFullscreen) {
	    element.webkitRequestFullscreen();
	  } else if (element.mozRequestFullScreen) {
	    element.mozRequestFullScreen();
	  } else if (element.msRequestFullscreen) {
	    element.msRequestFullscreen();
	  } else {
	    return false;
	  }
	  return true;
	};
	var exitFullscreen = function exitFullscreen() {
	  if (document.exitFullscreen) {
	    document.exitFullscreen();
	  } else if (document.webkitExitFullscreen) {
	    document.webkitExitFullscreen();
	  } else if (document.mozCancelFullScreen) {
	    document.mozCancelFullScreen();
	  } else if (document.msExitFullscreen) {
	    document.msExitFullscreen();
	  } else {
	    return false;
	  }
	  return true;
	};
	var getFullscreenElement = function getFullscreenElement() {
	  return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
	};
	var linkProgram = function linkProgram(gl, vertexSource, fragmentSource, attribLocationMap) {
	  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(vertexShader, vertexSource);
	  gl.compileShader(vertexShader);
	  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	  gl.shaderSource(fragmentShader, fragmentSource);
	  gl.compileShader(fragmentShader);
	  var program = gl.createProgram();
	  gl.attachShader(program, vertexShader);
	  gl.attachShader(program, fragmentShader);
	  for (var attribName in attribLocationMap) {
	    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);
	  }gl.linkProgram(program);
	  gl.deleteShader(vertexShader);
	  gl.deleteShader(fragmentShader);
	  return program;
	};
	var getProgramUniforms = function getProgramUniforms(gl, program) {
	  var uniforms = {};
	  var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	  var uniformName = '';
	  for (var i = 0; i < uniformCount; i++) {
	    var uniformInfo = gl.getActiveUniform(program, i);
	    uniformName = uniformInfo.name.replace('[0]', '');
	    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
	  }
	  return uniforms;
	};
	var orthoMatrix = function orthoMatrix(out, left, right, bottom, top, near, far) {
	  var lr = 1 / (left - right),
	      bt = 1 / (bottom - top),
	      nf = 1 / (near - far);
	  out[0] = -2 * lr;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = -2 * bt;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 2 * nf;
	  out[11] = 0;
	  out[12] = (left + right) * lr;
	  out[13] = (top + bottom) * bt;
	  out[14] = (far + near) * nf;
	  out[15] = 1;
	  return out;
	};
	var isMobile = function isMobile() {
	  var check = false;
	  (function (a) {
	    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
	  })(navigator.userAgent || navigator.vendor || window.opera);
	  return check;
	};
	var extend = function extend(dest, src) {
	  for (var key in src) {
	    if (src.hasOwnProperty(key)) {
	      dest[key] = src[key];
	    }
	  }
	  return dest;
	};
	var safariCssSizeWorkaround = function safariCssSizeWorkaround(canvas) {
	  if (isIOS()) {
	    var width = canvas.style.width;
	    var height = canvas.style.height;
	    canvas.style.width = parseInt(width) + 1 + 'px';
	    canvas.style.height = parseInt(height) + 'px';
	    setTimeout(function () {
	      canvas.style.width = width;
	      canvas.style.height = height;
	    }, 100);
	  }
	  window.canvas = canvas;
	};
	var frameDataFromPose = function () {
	  var piOver180 = Math.PI / 180.0;
	  var rad45 = Math.PI * 0.25;
	  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
	    var upTan = Math.tan(fov ? fov.upDegrees * piOver180 : rad45),
	        downTan = Math.tan(fov ? fov.downDegrees * piOver180 : rad45),
	        leftTan = Math.tan(fov ? fov.leftDegrees * piOver180 : rad45),
	        rightTan = Math.tan(fov ? fov.rightDegrees * piOver180 : rad45),
	        xScale = 2.0 / (leftTan + rightTan),
	        yScale = 2.0 / (upTan + downTan);
	    out[0] = xScale;
	    out[1] = 0.0;
	    out[2] = 0.0;
	    out[3] = 0.0;
	    out[4] = 0.0;
	    out[5] = yScale;
	    out[6] = 0.0;
	    out[7] = 0.0;
	    out[8] = -((leftTan - rightTan) * xScale * 0.5);
	    out[9] = (upTan - downTan) * yScale * 0.5;
	    out[10] = far / (near - far);
	    out[11] = -1.0;
	    out[12] = 0.0;
	    out[13] = 0.0;
	    out[14] = far * near / (near - far);
	    out[15] = 0.0;
	    return out;
	  }
	  function mat4_fromRotationTranslation(out, q, v) {
	    var x = q[0],
	        y = q[1],
	        z = q[2],
	        w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,
	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;
	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    return out;
	  }
	  function mat4_translate(out, a, v) {
	    var x = v[0],
	        y = v[1],
	        z = v[2],
	        a00,
	        a01,
	        a02,
	        a03,
	        a10,
	        a11,
	        a12,
	        a13,
	        a20,
	        a21,
	        a22,
	        a23;
	    if (a === out) {
	      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	      a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
	      a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
	      a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];
	      out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
	      out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
	      out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;
	      out[12] = a00 * x + a10 * y + a20 * z + a[12];
	      out[13] = a01 * x + a11 * y + a21 * z + a[13];
	      out[14] = a02 * x + a12 * y + a22 * z + a[14];
	      out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }
	    return out;
	  }
	  function mat4_invert(out, a) {
	    var a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11],
	        a30 = a[12],
	        a31 = a[13],
	        a32 = a[14],
	        a33 = a[15],
	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,
	    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	    if (!det) {
	      return null;
	    }
	    det = 1.0 / det;
	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	    return out;
	  }
	  var defaultOrientation = new Float32Array([0, 0, 0, 1]);
	  var defaultPosition = new Float32Array([0, 0, 0]);
	  function updateEyeMatrices(projection, view, pose, fov, offset, vrDisplay) {
	    mat4_perspectiveFromFieldOfView(projection, fov || null, vrDisplay.depthNear, vrDisplay.depthFar);
	    var orientation = pose.orientation || defaultOrientation;
	    var position = pose.position || defaultPosition;
	    mat4_fromRotationTranslation(view, orientation, position);
	    if (offset) mat4_translate(view, view, offset);
	    mat4_invert(view, view);
	  }
	  return function (frameData, pose, vrDisplay) {
	    if (!frameData || !pose) return false;
	    frameData.pose = pose;
	    frameData.timestamp = pose.timestamp;
	    updateEyeMatrices(frameData.leftProjectionMatrix, frameData.leftViewMatrix, pose, vrDisplay._getFieldOfView("left"), vrDisplay._getEyeOffset("left"), vrDisplay);
	    updateEyeMatrices(frameData.rightProjectionMatrix, frameData.rightViewMatrix, pose, vrDisplay._getFieldOfView("right"), vrDisplay._getEyeOffset("right"), vrDisplay);
	    return true;
	  };
	}();
	var isInsideCrossOriginIFrame = function isInsideCrossOriginIFrame() {
	  var isFramed = window.self !== window.top;
	  var refOrigin = getOriginFromUrl(document.referrer);
	  var thisOrigin = getOriginFromUrl(window.location.href);
	  return isFramed && refOrigin !== thisOrigin;
	};
	var getOriginFromUrl = function getOriginFromUrl(url) {
	  var domainIdx;
	  var protoSepIdx = url.indexOf("://");
	  if (protoSepIdx !== -1) {
	    domainIdx = protoSepIdx + 3;
	  } else {
	    domainIdx = 0;
	  }
	  var domainEndIdx = url.indexOf('/', domainIdx);
	  if (domainEndIdx === -1) {
	    domainEndIdx = url.length;
	  }
	  return url.substring(0, domainEndIdx);
	};
	var getQuaternionAngle = function getQuaternionAngle(quat) {
	  if (quat.w > 1) {
	    console.warn('getQuaternionAngle: w > 1');
	    return 0;
	  }
	  var angle = 2 * Math.acos(quat.w);
	  return angle;
	};
	var warnOnce = function () {
	  var observedWarnings = {};
	  return function (key, message) {
	    if (observedWarnings[key] === undefined) {
	      console.warn('webvr-polyfill: ' + message);
	      observedWarnings[key] = true;
	    }
	  };
	}();
	var deprecateWarning = function deprecateWarning(deprecated, suggested) {
	  var alternative = suggested ? 'Please use ' + suggested + ' instead.' : '';
	  warnOnce(deprecated, deprecated + ' has been deprecated. ' + 'This may not work on native WebVR displays. ' + alternative);
	};
	function WGLUPreserveGLState(gl, bindings, callback) {
	  if (!bindings) {
	    callback(gl);
	    return;
	  }
	  var boundValues = [];
	  var activeTexture = null;
	  for (var i = 0; i < bindings.length; ++i) {
	    var binding = bindings[i];
	    switch (binding) {
	      case gl.TEXTURE_BINDING_2D:
	      case gl.TEXTURE_BINDING_CUBE_MAP:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
	          console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
	          boundValues.push(null, null);
	          break;
	        }
	        if (!activeTexture) {
	          activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
	        }
	        gl.activeTexture(textureUnit);
	        boundValues.push(gl.getParameter(binding), null);
	        break;
	      case gl.ACTIVE_TEXTURE:
	        activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
	        boundValues.push(null);
	        break;
	      default:
	        boundValues.push(gl.getParameter(binding));
	        break;
	    }
	  }
	  callback(gl);
	  for (var i = 0; i < bindings.length; ++i) {
	    var binding = bindings[i];
	    var boundValue = boundValues[i];
	    switch (binding) {
	      case gl.ACTIVE_TEXTURE:
	        break;
	      case gl.ARRAY_BUFFER_BINDING:
	        gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
	        break;
	      case gl.COLOR_CLEAR_VALUE:
	        gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.COLOR_WRITEMASK:
	        gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.CURRENT_PROGRAM:
	        gl.useProgram(boundValue);
	        break;
	      case gl.ELEMENT_ARRAY_BUFFER_BINDING:
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
	        break;
	      case gl.FRAMEBUFFER_BINDING:
	        gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
	        break;
	      case gl.RENDERBUFFER_BINDING:
	        gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
	        break;
	      case gl.TEXTURE_BINDING_2D:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
	          break;
	        gl.activeTexture(textureUnit);
	        gl.bindTexture(gl.TEXTURE_2D, boundValue);
	        break;
	      case gl.TEXTURE_BINDING_CUBE_MAP:
	        var textureUnit = bindings[++i];
	        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
	          break;
	        gl.activeTexture(textureUnit);
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
	        break;
	      case gl.VIEWPORT:
	        gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
	        break;
	      case gl.BLEND:
	      case gl.CULL_FACE:
	      case gl.DEPTH_TEST:
	      case gl.SCISSOR_TEST:
	      case gl.STENCIL_TEST:
	        if (boundValue) {
	          gl.enable(binding);
	        } else {
	          gl.disable(binding);
	        }
	        break;
	      default:
	        console.log("No GL restore behavior for 0x" + binding.toString(16));
	        break;
	    }
	    if (activeTexture) {
	      gl.activeTexture(activeTexture);
	    }
	  }
	}
	var glPreserveState = WGLUPreserveGLState;
	var distortionVS = ['attribute vec2 position;', 'attribute vec3 texCoord;', 'varying vec2 vTexCoord;', 'uniform vec4 viewportOffsetScale[2];', 'void main() {', '  vec4 viewport = viewportOffsetScale[int(texCoord.z)];', '  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;', '  gl_Position = vec4( position, 1.0, 1.0 );', '}'].join('\n');
	var distortionFS = ['precision mediump float;', 'uniform sampler2D diffuse;', 'varying vec2 vTexCoord;', 'void main() {', '  gl_FragColor = texture2D(diffuse, vTexCoord);', '}'].join('\n');
	function CardboardDistorter(gl, cardboardUI, bufferScale, dirtySubmitFrameBindings) {
	  this.gl = gl;
	  this.cardboardUI = cardboardUI;
	  this.bufferScale = bufferScale;
	  this.dirtySubmitFrameBindings = dirtySubmitFrameBindings;
	  this.ctxAttribs = gl.getContextAttributes();
	  this.meshWidth = 20;
	  this.meshHeight = 20;
	  this.bufferWidth = gl.drawingBufferWidth;
	  this.bufferHeight = gl.drawingBufferHeight;
	  this.realBindFramebuffer = gl.bindFramebuffer;
	  this.realEnable = gl.enable;
	  this.realDisable = gl.disable;
	  this.realColorMask = gl.colorMask;
	  this.realClearColor = gl.clearColor;
	  this.realViewport = gl.viewport;
	  if (!isIOS()) {
	    this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'width');
	    this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'height');
	  }
	  this.isPatched = false;
	  this.lastBoundFramebuffer = null;
	  this.cullFace = false;
	  this.depthTest = false;
	  this.blend = false;
	  this.scissorTest = false;
	  this.stencilTest = false;
	  this.viewport = [0, 0, 0, 0];
	  this.colorMask = [true, true, true, true];
	  this.clearColor = [0, 0, 0, 0];
	  this.attribs = {
	    position: 0,
	    texCoord: 1
	  };
	  this.program = linkProgram(gl, distortionVS, distortionFS, this.attribs);
	  this.uniforms = getProgramUniforms(gl, this.program);
	  this.viewportOffsetScale = new Float32Array(8);
	  this.setTextureBounds();
	  this.vertexBuffer = gl.createBuffer();
	  this.indexBuffer = gl.createBuffer();
	  this.indexCount = 0;
	  this.renderTarget = gl.createTexture();
	  this.framebuffer = gl.createFramebuffer();
	  this.depthStencilBuffer = null;
	  this.depthBuffer = null;
	  this.stencilBuffer = null;
	  if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
	    this.depthStencilBuffer = gl.createRenderbuffer();
	  } else if (this.ctxAttribs.depth) {
	    this.depthBuffer = gl.createRenderbuffer();
	  } else if (this.ctxAttribs.stencil) {
	    this.stencilBuffer = gl.createRenderbuffer();
	  }
	  this.patch();
	  this.onResize();
	}
	CardboardDistorter.prototype.destroy = function () {
	  var gl = this.gl;
	  this.unpatch();
	  gl.deleteProgram(this.program);
	  gl.deleteBuffer(this.vertexBuffer);
	  gl.deleteBuffer(this.indexBuffer);
	  gl.deleteTexture(this.renderTarget);
	  gl.deleteFramebuffer(this.framebuffer);
	  if (this.depthStencilBuffer) {
	    gl.deleteRenderbuffer(this.depthStencilBuffer);
	  }
	  if (this.depthBuffer) {
	    gl.deleteRenderbuffer(this.depthBuffer);
	  }
	  if (this.stencilBuffer) {
	    gl.deleteRenderbuffer(this.stencilBuffer);
	  }
	  if (this.cardboardUI) {
	    this.cardboardUI.destroy();
	  }
	};
	CardboardDistorter.prototype.onResize = function () {
	  var gl = this.gl;
	  var self = this;
	  var glState = [gl.RENDERBUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0];
	  glPreserveState(gl, glState, function (gl) {
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);
	    if (self.scissorTest) {
	      self.realDisable.call(gl, gl.SCISSOR_TEST);
	    }
	    self.realColorMask.call(gl, true, true, true, true);
	    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	    self.realClearColor.call(gl, 0, 0, 0, 1);
	    gl.clear(gl.COLOR_BUFFER_BIT);
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.framebuffer);
	    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
	    gl.texImage2D(gl.TEXTURE_2D, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, self.bufferWidth, self.bufferHeight, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, gl.UNSIGNED_BYTE, null);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, self.renderTarget, 0);
	    if (self.ctxAttribs.depth && self.ctxAttribs.stencil) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthStencilBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, self.depthStencilBuffer);
	    } else if (self.ctxAttribs.depth) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, self.depthBuffer);
	    } else if (self.ctxAttribs.stencil) {
	      gl.bindRenderbuffer(gl.RENDERBUFFER, self.stencilBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, self.bufferWidth, self.bufferHeight);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, self.stencilBuffer);
	    }
	    if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
	      console.error('Framebuffer incomplete!');
	    }
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
	    if (self.scissorTest) {
	      self.realEnable.call(gl, gl.SCISSOR_TEST);
	    }
	    self.realColorMask.apply(gl, self.colorMask);
	    self.realViewport.apply(gl, self.viewport);
	    self.realClearColor.apply(gl, self.clearColor);
	  });
	  if (this.cardboardUI) {
	    this.cardboardUI.onResize();
	  }
	};
	CardboardDistorter.prototype.patch = function () {
	  if (this.isPatched) {
	    return;
	  }
	  var self = this;
	  var canvas = this.gl.canvas;
	  var gl = this.gl;
	  if (!isIOS()) {
	    canvas.width = getScreenWidth() * this.bufferScale;
	    canvas.height = getScreenHeight() * this.bufferScale;
	    Object.defineProperty(canvas, 'width', {
	      configurable: true,
	      enumerable: true,
	      get: function get() {
	        return self.bufferWidth;
	      },
	      set: function set(value) {
	        self.bufferWidth = value;
	        self.realCanvasWidth.set.call(canvas, value);
	        self.onResize();
	      }
	    });
	    Object.defineProperty(canvas, 'height', {
	      configurable: true,
	      enumerable: true,
	      get: function get() {
	        return self.bufferHeight;
	      },
	      set: function set(value) {
	        self.bufferHeight = value;
	        self.realCanvasHeight.set.call(canvas, value);
	        self.onResize();
	      }
	    });
	  }
	  this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
	  if (this.lastBoundFramebuffer == null) {
	    this.lastBoundFramebuffer = this.framebuffer;
	    this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
	  }
	  this.gl.bindFramebuffer = function (target, framebuffer) {
	    self.lastBoundFramebuffer = framebuffer ? framebuffer : self.framebuffer;
	    self.realBindFramebuffer.call(gl, target, self.lastBoundFramebuffer);
	  };
	  this.cullFace = gl.getParameter(gl.CULL_FACE);
	  this.depthTest = gl.getParameter(gl.DEPTH_TEST);
	  this.blend = gl.getParameter(gl.BLEND);
	  this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
	  this.stencilTest = gl.getParameter(gl.STENCIL_TEST);
	  gl.enable = function (pname) {
	    switch (pname) {
	      case gl.CULL_FACE:
	        self.cullFace = true;break;
	      case gl.DEPTH_TEST:
	        self.depthTest = true;break;
	      case gl.BLEND:
	        self.blend = true;break;
	      case gl.SCISSOR_TEST:
	        self.scissorTest = true;break;
	      case gl.STENCIL_TEST:
	        self.stencilTest = true;break;
	    }
	    self.realEnable.call(gl, pname);
	  };
	  gl.disable = function (pname) {
	    switch (pname) {
	      case gl.CULL_FACE:
	        self.cullFace = false;break;
	      case gl.DEPTH_TEST:
	        self.depthTest = false;break;
	      case gl.BLEND:
	        self.blend = false;break;
	      case gl.SCISSOR_TEST:
	        self.scissorTest = false;break;
	      case gl.STENCIL_TEST:
	        self.stencilTest = false;break;
	    }
	    self.realDisable.call(gl, pname);
	  };
	  this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
	  gl.colorMask = function (r, g, b, a) {
	    self.colorMask[0] = r;
	    self.colorMask[1] = g;
	    self.colorMask[2] = b;
	    self.colorMask[3] = a;
	    self.realColorMask.call(gl, r, g, b, a);
	  };
	  this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
	  gl.clearColor = function (r, g, b, a) {
	    self.clearColor[0] = r;
	    self.clearColor[1] = g;
	    self.clearColor[2] = b;
	    self.clearColor[3] = a;
	    self.realClearColor.call(gl, r, g, b, a);
	  };
	  this.viewport = gl.getParameter(gl.VIEWPORT);
	  gl.viewport = function (x, y, w, h) {
	    self.viewport[0] = x;
	    self.viewport[1] = y;
	    self.viewport[2] = w;
	    self.viewport[3] = h;
	    self.realViewport.call(gl, x, y, w, h);
	  };
	  this.isPatched = true;
	  safariCssSizeWorkaround(canvas);
	};
	CardboardDistorter.prototype.unpatch = function () {
	  if (!this.isPatched) {
	    return;
	  }
	  var gl = this.gl;
	  var canvas = this.gl.canvas;
	  if (!isIOS()) {
	    Object.defineProperty(canvas, 'width', this.realCanvasWidth);
	    Object.defineProperty(canvas, 'height', this.realCanvasHeight);
	  }
	  canvas.width = this.bufferWidth;
	  canvas.height = this.bufferHeight;
	  gl.bindFramebuffer = this.realBindFramebuffer;
	  gl.enable = this.realEnable;
	  gl.disable = this.realDisable;
	  gl.colorMask = this.realColorMask;
	  gl.clearColor = this.realClearColor;
	  gl.viewport = this.realViewport;
	  if (this.lastBoundFramebuffer == this.framebuffer) {
	    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	  }
	  this.isPatched = false;
	  setTimeout(function () {
	    safariCssSizeWorkaround(canvas);
	  }, 1);
	};
	CardboardDistorter.prototype.setTextureBounds = function (leftBounds, rightBounds) {
	  if (!leftBounds) {
	    leftBounds = [0, 0, 0.5, 1];
	  }
	  if (!rightBounds) {
	    rightBounds = [0.5, 0, 0.5, 1];
	  }
	  this.viewportOffsetScale[0] = leftBounds[0];
	  this.viewportOffsetScale[1] = leftBounds[1];
	  this.viewportOffsetScale[2] = leftBounds[2];
	  this.viewportOffsetScale[3] = leftBounds[3];
	  this.viewportOffsetScale[4] = rightBounds[0];
	  this.viewportOffsetScale[5] = rightBounds[1];
	  this.viewportOffsetScale[6] = rightBounds[2];
	  this.viewportOffsetScale[7] = rightBounds[3];
	};
	CardboardDistorter.prototype.submitFrame = function () {
	  var gl = this.gl;
	  var self = this;
	  var glState = [];
	  if (!this.dirtySubmitFrameBindings) {
	    glState.push(gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0);
	  }
	  glPreserveState(gl, glState, function (gl) {
	    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);
	    if (self.cullFace) {
	      self.realDisable.call(gl, gl.CULL_FACE);
	    }
	    if (self.depthTest) {
	      self.realDisable.call(gl, gl.DEPTH_TEST);
	    }
	    if (self.blend) {
	      self.realDisable.call(gl, gl.BLEND);
	    }
	    if (self.scissorTest) {
	      self.realDisable.call(gl, gl.SCISSOR_TEST);
	    }
	    if (self.stencilTest) {
	      self.realDisable.call(gl, gl.STENCIL_TEST);
	    }
	    self.realColorMask.call(gl, true, true, true, true);
	    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	    if (self.ctxAttribs.alpha || isIOS()) {
	      self.realClearColor.call(gl, 0, 0, 0, 1);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	    }
	    gl.useProgram(self.program);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.enableVertexAttribArray(self.attribs.position);
	    gl.enableVertexAttribArray(self.attribs.texCoord);
	    gl.vertexAttribPointer(self.attribs.position, 2, gl.FLOAT, false, 20, 0);
	    gl.vertexAttribPointer(self.attribs.texCoord, 3, gl.FLOAT, false, 20, 8);
	    gl.activeTexture(gl.TEXTURE0);
	    gl.uniform1i(self.uniforms.diffuse, 0);
	    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
	    gl.uniform4fv(self.uniforms.viewportOffsetScale, self.viewportOffsetScale);
	    gl.drawElements(gl.TRIANGLES, self.indexCount, gl.UNSIGNED_SHORT, 0);
	    if (self.cardboardUI) {
	      self.cardboardUI.renderNoState();
	    }
	    self.realBindFramebuffer.call(self.gl, gl.FRAMEBUFFER, self.framebuffer);
	    if (!self.ctxAttribs.preserveDrawingBuffer) {
	      self.realClearColor.call(gl, 0, 0, 0, 0);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	    }
	    if (!self.dirtySubmitFrameBindings) {
	      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
	    }
	    if (self.cullFace) {
	      self.realEnable.call(gl, gl.CULL_FACE);
	    }
	    if (self.depthTest) {
	      self.realEnable.call(gl, gl.DEPTH_TEST);
	    }
	    if (self.blend) {
	      self.realEnable.call(gl, gl.BLEND);
	    }
	    if (self.scissorTest) {
	      self.realEnable.call(gl, gl.SCISSOR_TEST);
	    }
	    if (self.stencilTest) {
	      self.realEnable.call(gl, gl.STENCIL_TEST);
	    }
	    self.realColorMask.apply(gl, self.colorMask);
	    self.realViewport.apply(gl, self.viewport);
	    if (self.ctxAttribs.alpha || !self.ctxAttribs.preserveDrawingBuffer) {
	      self.realClearColor.apply(gl, self.clearColor);
	    }
	  });
	  if (isIOS()) {
	    var canvas = gl.canvas;
	    if (canvas.width != self.bufferWidth || canvas.height != self.bufferHeight) {
	      self.bufferWidth = canvas.width;
	      self.bufferHeight = canvas.height;
	      self.onResize();
	    }
	  }
	};
	CardboardDistorter.prototype.updateDeviceInfo = function (deviceInfo) {
	  var gl = this.gl;
	  var self = this;
	  var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
	  glPreserveState(gl, glState, function (gl) {
	    var vertices = self.computeMeshVertices_(self.meshWidth, self.meshHeight, deviceInfo);
	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
	    if (!self.indexCount) {
	      var indices = self.computeMeshIndices_(self.meshWidth, self.meshHeight);
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
	      self.indexCount = indices.length;
	    }
	  });
	};
	CardboardDistorter.prototype.computeMeshVertices_ = function (width, height, deviceInfo) {
	  var vertices = new Float32Array(2 * width * height * 5);
	  var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
	  var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
	  var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
	  var vidx = 0;
	  for (var e = 0; e < 2; e++) {
	    for (var j = 0; j < height; j++) {
	      for (var i = 0; i < width; i++, vidx++) {
	        var u = i / (width - 1);
	        var v = j / (height - 1);
	        var s = u;
	        var t = v;
	        var x = lerp(lensFrustum[0], lensFrustum[2], u);
	        var y = lerp(lensFrustum[3], lensFrustum[1], v);
	        var d = Math.sqrt(x * x + y * y);
	        var r = deviceInfo.distortion.distortInverse(d);
	        var p = x * r / d;
	        var q = y * r / d;
	        u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
	        v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);
	        u = (viewport.x + u * viewport.width - 0.5) * 2.0;
	        v = (viewport.y + v * viewport.height - 0.5) * 2.0;
	        vertices[vidx * 5 + 0] = u;
	        vertices[vidx * 5 + 1] = v;
	        vertices[vidx * 5 + 2] = s;
	        vertices[vidx * 5 + 3] = t;
	        vertices[vidx * 5 + 4] = e;
	      }
	    }
	    var w = lensFrustum[2] - lensFrustum[0];
	    lensFrustum[0] = -(w + lensFrustum[0]);
	    lensFrustum[2] = w - lensFrustum[2];
	    w = noLensFrustum[2] - noLensFrustum[0];
	    noLensFrustum[0] = -(w + noLensFrustum[0]);
	    noLensFrustum[2] = w - noLensFrustum[2];
	    viewport.x = 1 - (viewport.x + viewport.width);
	  }
	  return vertices;
	};
	CardboardDistorter.prototype.computeMeshIndices_ = function (width, height) {
	  var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
	  var halfwidth = width / 2;
	  var halfheight = height / 2;
	  var vidx = 0;
	  var iidx = 0;
	  for (var e = 0; e < 2; e++) {
	    for (var j = 0; j < height; j++) {
	      for (var i = 0; i < width; i++, vidx++) {
	        if (i == 0 || j == 0) continue;
	        if (i <= halfwidth == j <= halfheight) {
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - width - 1;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx - width - 1;
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - 1;
	        } else {
	          indices[iidx++] = vidx - 1;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx;
	          indices[iidx++] = vidx - width;
	          indices[iidx++] = vidx - 1;
	          indices[iidx++] = vidx - width - 1;
	        }
	      }
	    }
	  }
	  return indices;
	};
	CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function (proto, attrName) {
	  var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
	  if (descriptor.get === undefined || descriptor.set === undefined) {
	    descriptor.configurable = true;
	    descriptor.enumerable = true;
	    descriptor.get = function () {
	      return this.getAttribute(attrName);
	    };
	    descriptor.set = function (val) {
	      this.setAttribute(attrName, val);
	    };
	  }
	  return descriptor;
	};
	var uiVS = ['attribute vec2 position;', 'uniform mat4 projectionMat;', 'void main() {', '  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );', '}'].join('\n');
	var uiFS = ['precision mediump float;', 'uniform vec4 color;', 'void main() {', '  gl_FragColor = color;', '}'].join('\n');
	var DEG2RAD = Math.PI / 180.0;
	var kAnglePerGearSection = 60;
	var kOuterRimEndAngle = 12;
	var kInnerRimBeginAngle = 20;
	var kOuterRadius = 1;
	var kMiddleRadius = 0.75;
	var kInnerRadius = 0.3125;
	var kCenterLineThicknessDp = 4;
	var kButtonWidthDp = 28;
	var kTouchSlopFactor = 1.5;
	function CardboardUI(gl) {
	  this.gl = gl;
	  this.attribs = {
	    position: 0
	  };
	  this.program = linkProgram(gl, uiVS, uiFS, this.attribs);
	  this.uniforms = getProgramUniforms(gl, this.program);
	  this.vertexBuffer = gl.createBuffer();
	  this.gearOffset = 0;
	  this.gearVertexCount = 0;
	  this.arrowOffset = 0;
	  this.arrowVertexCount = 0;
	  this.projMat = new Float32Array(16);
	  this.listener = null;
	  this.onResize();
	}
	CardboardUI.prototype.destroy = function () {
	  var gl = this.gl;
	  if (this.listener) {
	    gl.canvas.removeEventListener('click', this.listener, false);
	  }
	  gl.deleteProgram(this.program);
	  gl.deleteBuffer(this.vertexBuffer);
	};
	CardboardUI.prototype.listen = function (optionsCallback, backCallback) {
	  var canvas = this.gl.canvas;
	  this.listener = function (event) {
	    var midline = canvas.clientWidth / 2;
	    var buttonSize = kButtonWidthDp * kTouchSlopFactor;
	    if (event.clientX > midline - buttonSize && event.clientX < midline + buttonSize && event.clientY > canvas.clientHeight - buttonSize) {
	      optionsCallback(event);
	    }
	    else if (event.clientX < buttonSize && event.clientY < buttonSize) {
	        backCallback(event);
	      }
	  };
	  canvas.addEventListener('click', this.listener, false);
	};
	CardboardUI.prototype.onResize = function () {
	  var gl = this.gl;
	  var self = this;
	  var glState = [gl.ARRAY_BUFFER_BINDING];
	  glPreserveState(gl, glState, function (gl) {
	    var vertices = [];
	    var midline = gl.drawingBufferWidth / 2;
	    var physicalPixels = Math.max(screen.width, screen.height) * window.devicePixelRatio;
	    var scalingRatio = gl.drawingBufferWidth / physicalPixels;
	    var dps = scalingRatio * window.devicePixelRatio;
	    var lineWidth = kCenterLineThicknessDp * dps / 2;
	    var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
	    var buttonScale = kButtonWidthDp * dps / 2;
	    var buttonBorder = (kButtonWidthDp * kTouchSlopFactor - kButtonWidthDp) * dps;
	    vertices.push(midline - lineWidth, buttonSize);
	    vertices.push(midline - lineWidth, gl.drawingBufferHeight);
	    vertices.push(midline + lineWidth, buttonSize);
	    vertices.push(midline + lineWidth, gl.drawingBufferHeight);
	    self.gearOffset = vertices.length / 2;
	    function addGearSegment(theta, r) {
	      var angle = (90 - theta) * DEG2RAD;
	      var x = Math.cos(angle);
	      var y = Math.sin(angle);
	      vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
	      vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
	    }
	    for (var i = 0; i <= 6; i++) {
	      var segmentTheta = i * kAnglePerGearSection;
	      addGearSegment(segmentTheta, kOuterRadius);
	      addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
	      addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
	      addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
	      addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
	    }
	    self.gearVertexCount = vertices.length / 2 - self.gearOffset;
	    self.arrowOffset = vertices.length / 2;
	    function addArrowVertex(x, y) {
	      vertices.push(buttonBorder + x, gl.drawingBufferHeight - buttonBorder - y);
	    }
	    var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);
	    addArrowVertex(0, buttonScale);
	    addArrowVertex(buttonScale, 0);
	    addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
	    addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);
	    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
	    addArrowVertex(0, buttonScale);
	    addArrowVertex(buttonScale, buttonScale * 2);
	    addArrowVertex(buttonScale + angledLineWidth, buttonScale * 2 - angledLineWidth);
	    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
	    addArrowVertex(0, buttonScale);
	    addArrowVertex(angledLineWidth, buttonScale - lineWidth);
	    addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
	    addArrowVertex(angledLineWidth, buttonScale + lineWidth);
	    addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);
	    self.arrowVertexCount = vertices.length / 2 - self.arrowOffset;
	    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	  });
	};
	CardboardUI.prototype.render = function () {
	  var gl = this.gl;
	  var self = this;
	  var glState = [gl.CULL_FACE, gl.DEPTH_TEST, gl.BLEND, gl.SCISSOR_TEST, gl.STENCIL_TEST, gl.COLOR_WRITEMASK, gl.VIEWPORT, gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING];
	  glPreserveState(gl, glState, function (gl) {
	    gl.disable(gl.CULL_FACE);
	    gl.disable(gl.DEPTH_TEST);
	    gl.disable(gl.BLEND);
	    gl.disable(gl.SCISSOR_TEST);
	    gl.disable(gl.STENCIL_TEST);
	    gl.colorMask(true, true, true, true);
	    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	    self.renderNoState();
	  });
	};
	CardboardUI.prototype.renderNoState = function () {
	  var gl = this.gl;
	  gl.useProgram(this.program);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	  gl.enableVertexAttribArray(this.attribs.position);
	  gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);
	  gl.uniform4f(this.uniforms.color, 1.0, 1.0, 1.0, 1.0);
	  orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024.0);
	  gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);
	  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	  gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
	  gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
	};
	function Distortion(coefficients) {
	  this.coefficients = coefficients;
	}
	Distortion.prototype.distortInverse = function (radius) {
	  var r0 = 0;
	  var r1 = 1;
	  var dr0 = radius - this.distort(r0);
	  while (Math.abs(r1 - r0) > 0.0001             ) {
	    var dr1 = radius - this.distort(r1);
	    var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
	    r0 = r1;
	    r1 = r2;
	    dr0 = dr1;
	  }
	  return r1;
	};
	Distortion.prototype.distort = function (radius) {
	  var r2 = radius * radius;
	  var ret = 0;
	  for (var i = 0; i < this.coefficients.length; i++) {
	    ret = r2 * (ret + this.coefficients[i]);
	  }
	  return (ret + 1) * radius;
	};
	var degToRad = Math.PI / 180;
	var radToDeg = 180 / Math.PI;
	var Vector3 = function Vector3(x, y, z) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	};
	Vector3.prototype = {
	  constructor: Vector3,
	  set: function set(x, y, z) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    return this;
	  },
	  copy: function copy(v) {
	    this.x = v.x;
	    this.y = v.y;
	    this.z = v.z;
	    return this;
	  },
	  length: function length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	  },
	  normalize: function normalize() {
	    var scalar = this.length();
	    if (scalar !== 0) {
	      var invScalar = 1 / scalar;
	      this.multiplyScalar(invScalar);
	    } else {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	    }
	    return this;
	  },
	  multiplyScalar: function multiplyScalar(scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	  },
	  applyQuaternion: function applyQuaternion(q) {
	    var x = this.x;
	    var y = this.y;
	    var z = this.z;
	    var qx = q.x;
	    var qy = q.y;
	    var qz = q.z;
	    var qw = q.w;
	    var ix = qw * x + qy * z - qz * y;
	    var iy = qw * y + qz * x - qx * z;
	    var iz = qw * z + qx * y - qy * x;
	    var iw = -qx * x - qy * y - qz * z;
	    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return this;
	  },
	  dot: function dot(v) {
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	  },
	  crossVectors: function crossVectors(a, b) {
	    var ax = a.x,
	        ay = a.y,
	        az = a.z;
	    var bx = b.x,
	        by = b.y,
	        bz = b.z;
	    this.x = ay * bz - az * by;
	    this.y = az * bx - ax * bz;
	    this.z = ax * by - ay * bx;
	    return this;
	  }
	};
	var Quaternion = function Quaternion(x, y, z, w) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	  this.w = w !== undefined ? w : 1;
	};
	Quaternion.prototype = {
	  constructor: Quaternion,
	  set: function set(x, y, z, w) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	    return this;
	  },
	  copy: function copy(quaternion) {
	    this.x = quaternion.x;
	    this.y = quaternion.y;
	    this.z = quaternion.z;
	    this.w = quaternion.w;
	    return this;
	  },
	  setFromEulerXYZ: function setFromEulerXYZ(x, y, z) {
	    var c1 = Math.cos(x / 2);
	    var c2 = Math.cos(y / 2);
	    var c3 = Math.cos(z / 2);
	    var s1 = Math.sin(x / 2);
	    var s2 = Math.sin(y / 2);
	    var s3 = Math.sin(z / 2);
	    this.x = s1 * c2 * c3 + c1 * s2 * s3;
	    this.y = c1 * s2 * c3 - s1 * c2 * s3;
	    this.z = c1 * c2 * s3 + s1 * s2 * c3;
	    this.w = c1 * c2 * c3 - s1 * s2 * s3;
	    return this;
	  },
	  setFromEulerYXZ: function setFromEulerYXZ(x, y, z) {
	    var c1 = Math.cos(x / 2);
	    var c2 = Math.cos(y / 2);
	    var c3 = Math.cos(z / 2);
	    var s1 = Math.sin(x / 2);
	    var s2 = Math.sin(y / 2);
	    var s3 = Math.sin(z / 2);
	    this.x = s1 * c2 * c3 + c1 * s2 * s3;
	    this.y = c1 * s2 * c3 - s1 * c2 * s3;
	    this.z = c1 * c2 * s3 - s1 * s2 * c3;
	    this.w = c1 * c2 * c3 + s1 * s2 * s3;
	    return this;
	  },
	  setFromAxisAngle: function setFromAxisAngle(axis, angle) {
	    var halfAngle = angle / 2,
	        s = Math.sin(halfAngle);
	    this.x = axis.x * s;
	    this.y = axis.y * s;
	    this.z = axis.z * s;
	    this.w = Math.cos(halfAngle);
	    return this;
	  },
	  multiply: function multiply(q) {
	    return this.multiplyQuaternions(this, q);
	  },
	  multiplyQuaternions: function multiplyQuaternions(a, b) {
	    var qax = a.x,
	        qay = a.y,
	        qaz = a.z,
	        qaw = a.w;
	    var qbx = b.x,
	        qby = b.y,
	        qbz = b.z,
	        qbw = b.w;
	    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	    return this;
	  },
	  inverse: function inverse() {
	    this.x *= -1;
	    this.y *= -1;
	    this.z *= -1;
	    this.normalize();
	    return this;
	  },
	  normalize: function normalize() {
	    var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    if (l === 0) {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	      this.w = 1;
	    } else {
	      l = 1 / l;
	      this.x = this.x * l;
	      this.y = this.y * l;
	      this.z = this.z * l;
	      this.w = this.w * l;
	    }
	    return this;
	  },
	  slerp: function slerp(qb, t) {
	    if (t === 0) return this;
	    if (t === 1) return this.copy(qb);
	    var x = this.x,
	        y = this.y,
	        z = this.z,
	        w = this.w;
	    var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
	    if (cosHalfTheta < 0) {
	      this.w = -qb.w;
	      this.x = -qb.x;
	      this.y = -qb.y;
	      this.z = -qb.z;
	      cosHalfTheta = -cosHalfTheta;
	    } else {
	      this.copy(qb);
	    }
	    if (cosHalfTheta >= 1.0) {
	      this.w = w;
	      this.x = x;
	      this.y = y;
	      this.z = z;
	      return this;
	    }
	    var halfTheta = Math.acos(cosHalfTheta);
	    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
	    if (Math.abs(sinHalfTheta) < 0.001) {
	      this.w = 0.5 * (w + this.w);
	      this.x = 0.5 * (x + this.x);
	      this.y = 0.5 * (y + this.y);
	      this.z = 0.5 * (z + this.z);
	      return this;
	    }
	    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
	        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
	    this.w = w * ratioA + this.w * ratioB;
	    this.x = x * ratioA + this.x * ratioB;
	    this.y = y * ratioA + this.y * ratioB;
	    this.z = z * ratioA + this.z * ratioB;
	    return this;
	  },
	  setFromUnitVectors: function () {
	    var v1, r;
	    var EPS = 0.000001;
	    return function (vFrom, vTo) {
	      if (v1 === undefined) v1 = new Vector3();
	      r = vFrom.dot(vTo) + 1;
	      if (r < EPS) {
	        r = 0;
	        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
	          v1.set(-vFrom.y, vFrom.x, 0);
	        } else {
	          v1.set(0, -vFrom.z, vFrom.y);
	        }
	      } else {
	        v1.crossVectors(vFrom, vTo);
	      }
	      this.x = v1.x;
	      this.y = v1.y;
	      this.z = v1.z;
	      this.w = r;
	      this.normalize();
	      return this;
	    };
	  }()
	};
	function Device(params) {
	  this.width = params.width || getScreenWidth();
	  this.height = params.height || getScreenHeight();
	  this.widthMeters = params.widthMeters;
	  this.heightMeters = params.heightMeters;
	  this.bevelMeters = params.bevelMeters;
	}
	var DEFAULT_ANDROID = new Device({
	  widthMeters: 0.110,
	  heightMeters: 0.062,
	  bevelMeters: 0.004
	});
	var DEFAULT_IOS = new Device({
	  widthMeters: 0.1038,
	  heightMeters: 0.0584,
	  bevelMeters: 0.004
	});
	var Viewers = {
	  CardboardV1: new CardboardViewer({
	    id: 'CardboardV1',
	    label: 'Cardboard I/O 2014',
	    fov: 40,
	    interLensDistance: 0.060,
	    baselineLensDistance: 0.035,
	    screenLensDistance: 0.042,
	    distortionCoefficients: [0.441, 0.156],
	    inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 0.001559834]
	  }),
	  CardboardV2: new CardboardViewer({
	    id: 'CardboardV2',
	    label: 'Cardboard I/O 2015',
	    fov: 60,
	    interLensDistance: 0.064,
	    baselineLensDistance: 0.035,
	    screenLensDistance: 0.039,
	    distortionCoefficients: [0.34, 0.55],
	    inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 0.009177956, -9.904169E-4, 6.183535E-5, -1.6981803E-6]
	  })
	};
	function DeviceInfo(deviceParams, additionalViewers) {
	  this.viewer = Viewers.CardboardV2;
	  this.updateDeviceParams(deviceParams);
	  this.distortion = new Distortion(this.viewer.distortionCoefficients);
	  for (var i = 0; i < additionalViewers.length; i++) {
	    var viewer = additionalViewers[i];
	    Viewers[viewer.id] = new CardboardViewer(viewer);
	  }
	}
	DeviceInfo.prototype.updateDeviceParams = function (deviceParams) {
	  this.device = this.determineDevice_(deviceParams) || this.device;
	};
	DeviceInfo.prototype.getDevice = function () {
	  return this.device;
	};
	DeviceInfo.prototype.setViewer = function (viewer) {
	  this.viewer = viewer;
	  this.distortion = new Distortion(this.viewer.distortionCoefficients);
	};
	DeviceInfo.prototype.determineDevice_ = function (deviceParams) {
	  if (!deviceParams) {
	    if (isIOS()) {
	      console.warn('Using fallback iOS device measurements.');
	      return DEFAULT_IOS;
	    } else {
	      console.warn('Using fallback Android device measurements.');
	      return DEFAULT_ANDROID;
	    }
	  }
	  var METERS_PER_INCH = 0.0254;
	  var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
	  var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
	  var width = getScreenWidth();
	  var height = getScreenHeight();
	  return new Device({
	    widthMeters: metersPerPixelX * width,
	    heightMeters: metersPerPixelY * height,
	    bevelMeters: deviceParams.bevelMm * 0.001
	  });
	};
	DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function () {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;
	  var eyeToScreenDistance = viewer.screenLensDistance;
	  var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
	  var innerDist = viewer.interLensDistance / 2;
	  var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
	  var topDist = device.heightMeters - bottomDist;
	  var outerAngle = radToDeg * Math.atan(distortion.distort(outerDist / eyeToScreenDistance));
	  var innerAngle = radToDeg * Math.atan(distortion.distort(innerDist / eyeToScreenDistance));
	  var bottomAngle = radToDeg * Math.atan(distortion.distort(bottomDist / eyeToScreenDistance));
	  var topAngle = radToDeg * Math.atan(distortion.distort(topDist / eyeToScreenDistance));
	  return {
	    leftDegrees: Math.min(outerAngle, viewer.fov),
	    rightDegrees: Math.min(innerAngle, viewer.fov),
	    downDegrees: Math.min(bottomAngle, viewer.fov),
	    upDegrees: Math.min(topAngle, viewer.fov)
	  };
	};
	DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function () {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;
	  var fovLeft = Math.tan(-degToRad * viewer.fov);
	  var fovTop = Math.tan(degToRad * viewer.fov);
	  var fovRight = Math.tan(degToRad * viewer.fov);
	  var fovBottom = Math.tan(-degToRad * viewer.fov);
	  var halfWidth = device.widthMeters / 4;
	  var halfHeight = device.heightMeters / 2;
	  var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
	  var centerX = viewer.interLensDistance / 2 - halfWidth;
	  var centerY = -verticalLensOffset;
	  var centerZ = viewer.screenLensDistance;
	  var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
	  var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
	  var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
	  var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
	  var result = new Float32Array(4);
	  result[0] = Math.max(fovLeft, screenLeft);
	  result[1] = Math.min(fovTop, screenTop);
	  result[2] = Math.min(fovRight, screenRight);
	  result[3] = Math.max(fovBottom, screenBottom);
	  return result;
	};
	DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function () {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;
	  var result = new Float32Array(4);
	  var fovLeft = distortion.distortInverse(Math.tan(-degToRad * viewer.fov));
	  var fovTop = distortion.distortInverse(Math.tan(degToRad * viewer.fov));
	  var fovRight = distortion.distortInverse(Math.tan(degToRad * viewer.fov));
	  var fovBottom = distortion.distortInverse(Math.tan(-degToRad * viewer.fov));
	  var halfWidth = device.widthMeters / 4;
	  var halfHeight = device.heightMeters / 2;
	  var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
	  var centerX = viewer.interLensDistance / 2 - halfWidth;
	  var centerY = -verticalLensOffset;
	  var centerZ = viewer.screenLensDistance;
	  var screenLeft = (centerX - halfWidth) / centerZ;
	  var screenTop = (centerY + halfHeight) / centerZ;
	  var screenRight = (centerX + halfWidth) / centerZ;
	  var screenBottom = (centerY - halfHeight) / centerZ;
	  result[0] = Math.max(fovLeft, screenLeft);
	  result[1] = Math.min(fovTop, screenTop);
	  result[2] = Math.min(fovRight, screenRight);
	  result[3] = Math.max(fovBottom, screenBottom);
	  return result;
	};
	DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function (undistortedFrustum) {
	  var viewer = this.viewer;
	  var device = this.device;
	  var dist = viewer.screenLensDistance;
	  var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
	  var eyeY = viewer.baselineLensDistance - device.bevelMeters;
	  var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
	  var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
	  var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
	  var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
	  return {
	    x: left,
	    y: bottom,
	    width: right - left,
	    height: top - bottom
	  };
	};
	DeviceInfo.prototype.getFieldOfViewLeftEye = function (opt_isUndistorted) {
	  return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
	};
	DeviceInfo.prototype.getFieldOfViewRightEye = function (opt_isUndistorted) {
	  var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
	  return {
	    leftDegrees: fov.rightDegrees,
	    rightDegrees: fov.leftDegrees,
	    upDegrees: fov.upDegrees,
	    downDegrees: fov.downDegrees
	  };
	};
	DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function () {
	  var p = this.getUndistortedParams_();
	  return {
	    leftDegrees: radToDeg * Math.atan(p.outerDist),
	    rightDegrees: radToDeg * Math.atan(p.innerDist),
	    downDegrees: radToDeg * Math.atan(p.bottomDist),
	    upDegrees: radToDeg * Math.atan(p.topDist)
	  };
	};
	DeviceInfo.prototype.getUndistortedViewportLeftEye = function () {
	  var p = this.getUndistortedParams_();
	  var viewer = this.viewer;
	  var device = this.device;
	  var eyeToScreenDistance = viewer.screenLensDistance;
	  var screenWidth = device.widthMeters / eyeToScreenDistance;
	  var screenHeight = device.heightMeters / eyeToScreenDistance;
	  var xPxPerTanAngle = device.width / screenWidth;
	  var yPxPerTanAngle = device.height / screenHeight;
	  var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
	  var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
	  return {
	    x: x,
	    y: y,
	    width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
	    height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
	  };
	};
	DeviceInfo.prototype.getUndistortedParams_ = function () {
	  var viewer = this.viewer;
	  var device = this.device;
	  var distortion = this.distortion;
	  var eyeToScreenDistance = viewer.screenLensDistance;
	  var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
	  var screenWidth = device.widthMeters / eyeToScreenDistance;
	  var screenHeight = device.heightMeters / eyeToScreenDistance;
	  var eyePosX = screenWidth / 2 - halfLensDistance;
	  var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;
	  var maxFov = viewer.fov;
	  var viewerMax = distortion.distortInverse(Math.tan(degToRad * maxFov));
	  var outerDist = Math.min(eyePosX, viewerMax);
	  var innerDist = Math.min(halfLensDistance, viewerMax);
	  var bottomDist = Math.min(eyePosY, viewerMax);
	  var topDist = Math.min(screenHeight - eyePosY, viewerMax);
	  return {
	    outerDist: outerDist,
	    innerDist: innerDist,
	    topDist: topDist,
	    bottomDist: bottomDist,
	    eyePosX: eyePosX,
	    eyePosY: eyePosY
	  };
	};
	function CardboardViewer(params) {
	  this.id = params.id;
	  this.label = params.label;
	  this.fov = params.fov;
	  this.interLensDistance = params.interLensDistance;
	  this.baselineLensDistance = params.baselineLensDistance;
	  this.screenLensDistance = params.screenLensDistance;
	  this.distortionCoefficients = params.distortionCoefficients;
	  this.inverseCoefficients = params.inverseCoefficients;
	}
	DeviceInfo.Viewers = Viewers;
	var format = 1;
	var last_updated = "2018-02-20T22:55:10Z";
	var devices = [{"type":"android","rules":[{"mdmh":"asus/*/Nexus 7/*"},{"ua":"Nexus 7"}],"dpi":[320.8,323],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"asus/*/ASUS_Z00AD/*"},{"ua":"ASUS_Z00AD"}],"dpi":[403,404.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel XL/*"},{"ua":"Pixel XL"}],"dpi":[537.9,533],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel/*"},{"ua":"Pixel"}],"dpi":[432.6,436.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"HTC/*/HTC6435LVW/*"},{"ua":"HTC6435LVW"}],"dpi":[449.7,443.3],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One XL/*"},{"ua":"HTC One XL"}],"dpi":[315.3,314.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"htc/*/Nexus 9/*"},{"ua":"Nexus 9"}],"dpi":289,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One M9/*"},{"ua":"HTC One M9"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One_M8/*"},{"ua":"HTC One_M8"}],"dpi":[449.7,447.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One/*"},{"ua":"HTC One"}],"dpi":472.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Huawei/*/Nexus 6P/*"},{"ua":"Nexus 6P"}],"dpi":[515.1,518],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LENOVO/*/Lenovo PB2-690Y/*"},{"ua":"Lenovo PB2-690Y"}],"dpi":[457.2,454.713],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 5X/*"},{"ua":"Nexus 5X"}],"dpi":[422,419.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGMS345/*"},{"ua":"LGMS345"}],"dpi":[221.7,219.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/LG-D800/*"},{"ua":"LG-D800"}],"dpi":[422,424.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/LG-D850/*"},{"ua":"LG-D850"}],"dpi":[537.9,541.9],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/VS985 4G/*"},{"ua":"VS985 4G"}],"dpi":[537.9,535.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 5/*"},{"ua":"Nexus 5 B"}],"dpi":[442.4,444.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 4/*"},{"ua":"Nexus 4"}],"dpi":[319.8,318.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LG-P769/*"},{"ua":"LG-P769"}],"dpi":[240.6,247.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGMS323/*"},{"ua":"LGMS323"}],"dpi":[206.6,204.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGLS996/*"},{"ua":"LGLS996"}],"dpi":[403.4,401.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/4560MMX/*"},{"ua":"4560MMX"}],"dpi":[240,219.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/A250/*"},{"ua":"Micromax A250"}],"dpi":[480,446.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/Micromax AQ4501/*"},{"ua":"Micromax AQ4501"}],"dpi":240,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/G5/*"},{"ua":"Moto G (5) Plus"}],"dpi":[403.4,403],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/DROID RAZR/*"},{"ua":"DROID RAZR"}],"dpi":[368.1,256.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT830C/*"},{"ua":"XT830C"}],"dpi":[254,255.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1021/*"},{"ua":"XT1021"}],"dpi":[254,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1023/*"},{"ua":"XT1023"}],"dpi":[254,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1028/*"},{"ua":"XT1028"}],"dpi":[326.6,327.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1034/*"},{"ua":"XT1034"}],"dpi":[326.6,328.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1053/*"},{"ua":"XT1053"}],"dpi":[315.3,316.1],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1562/*"},{"ua":"XT1562"}],"dpi":[403.4,402.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/Nexus 6/*"},{"ua":"Nexus 6 B"}],"dpi":[494.3,489.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1063/*"},{"ua":"XT1063"}],"dpi":[295,296.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1064/*"},{"ua":"XT1064"}],"dpi":[295,295.6],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1092/*"},{"ua":"XT1092"}],"dpi":[422,424.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1095/*"},{"ua":"XT1095"}],"dpi":[422,423.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/G4/*"},{"ua":"Moto G (4)"}],"dpi":401,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/A0001/*"},{"ua":"A0001"}],"dpi":[403.4,401],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE E1005/*"},{"ua":"ONE E1005"}],"dpi":[442.4,441.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE A2005/*"},{"ua":"ONE A2005"}],"dpi":[391.9,405.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A5000/*"},{"ua":"ONEPLUS A5000 "}],"dpi":[403.411,399.737],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE A5010/*"},{"ua":"ONEPLUS A5010"}],"dpi":[403,400],"bw":2,"ac":1000},{"type":"android","rules":[{"mdmh":"OPPO/*/X909/*"},{"ua":"X909"}],"dpi":[442.4,444.1],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9082/*"},{"ua":"GT-I9082"}],"dpi":[184.7,185.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G360P/*"},{"ua":"SM-G360P"}],"dpi":[196.7,205.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/Nexus S/*"},{"ua":"Nexus S"}],"dpi":[234.5,229.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300/*"},{"ua":"GT-I9300"}],"dpi":[304.8,303.9],"bw":5,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-T230NU/*"},{"ua":"SM-T230NU"}],"dpi":216,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SGH-T399/*"},{"ua":"SGH-T399"}],"dpi":[217.7,231.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SGH-M919/*"},{"ua":"SGH-M919"}],"dpi":[440.8,437.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N9005/*"},{"ua":"SM-N9005"}],"dpi":[386.4,387],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SAMSUNG-SM-N900A/*"},{"ua":"SAMSUNG-SM-N900A"}],"dpi":[386.4,387.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9500/*"},{"ua":"GT-I9500"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9505/*"},{"ua":"GT-I9505"}],"dpi":439.4,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G900F/*"},{"ua":"SM-G900F"}],"dpi":[415.6,431.6],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G900M/*"},{"ua":"SM-G900M"}],"dpi":[415.6,431.6],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G800F/*"},{"ua":"SM-G800F"}],"dpi":326.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G906S/*"},{"ua":"SM-G906S"}],"dpi":[562.7,572.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300/*"},{"ua":"GT-I9300"}],"dpi":[306.7,304.8],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-T535/*"},{"ua":"SM-T535"}],"dpi":[142.6,136.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920C/*"},{"ua":"SM-N920C"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920P/*"},{"ua":"SM-N920P"}],"dpi":[386.3655,390.144],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920W8/*"},{"ua":"SM-N920W8"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300I/*"},{"ua":"GT-I9300I"}],"dpi":[304.8,305.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9195/*"},{"ua":"GT-I9195"}],"dpi":[249.4,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SPH-L520/*"},{"ua":"SPH-L520"}],"dpi":[249.4,255.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SAMSUNG-SGH-I717/*"},{"ua":"SAMSUNG-SGH-I717"}],"dpi":285.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SPH-D710/*"},{"ua":"SPH-D710"}],"dpi":[217.7,204.2],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-N7100/*"},{"ua":"GT-N7100"}],"dpi":265.1,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SCH-I605/*"},{"ua":"SCH-I605"}],"dpi":265.1,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/Galaxy Nexus/*"},{"ua":"Galaxy Nexus"}],"dpi":[315.3,314.2],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N910H/*"},{"ua":"SM-N910H"}],"dpi":[515.1,518],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N910C/*"},{"ua":"SM-N910C"}],"dpi":[515.2,520.2],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G130M/*"},{"ua":"SM-G130M"}],"dpi":[165.9,164.8],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G928I/*"},{"ua":"SM-G928I"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G920F/*"},{"ua":"SM-G920F"}],"dpi":580.6,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G920P/*"},{"ua":"SM-G920P"}],"dpi":[522.5,577],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G925F/*"},{"ua":"SM-G925F"}],"dpi":580.6,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G925V/*"},{"ua":"SM-G925V"}],"dpi":[522.5,576.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G930F/*"},{"ua":"SM-G930F"}],"dpi":576.6,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G935F/*"},{"ua":"SM-G935F"}],"dpi":533,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G950F/*"},{"ua":"SM-G950F"}],"dpi":[562.707,565.293],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G955U/*"},{"ua":"SM-G955U"}],"dpi":[522.514,525.762],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"Sony/*/C6903/*"},{"ua":"C6903"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"Sony/*/D6653/*"},{"ua":"D6653"}],"dpi":[428.6,427.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/E6653/*"},{"ua":"E6653"}],"dpi":[428.6,425.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/E6853/*"},{"ua":"E6853"}],"dpi":[403.4,401.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/SGP321/*"},{"ua":"SGP321"}],"dpi":[224.7,224.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"TCT/*/ALCATEL ONE TOUCH Fierce/*"},{"ua":"ALCATEL ONE TOUCH Fierce"}],"dpi":[240,247.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"THL/*/thl 5000/*"},{"ua":"thl 5000"}],"dpi":[480,443.3],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Fly/*/IQ4412/*"},{"ua":"IQ4412"}],"dpi":307.9,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"ZTE/*/ZTE Blade L2/*"},{"ua":"ZTE Blade L2"}],"dpi":240,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"BENEVE/*/VR518/*"},{"ua":"VR518"}],"dpi":480,"bw":3,"ac":500},{"type":"ios","rules":[{"res":[640,960]}],"dpi":[325.1,328.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[640,1136]}],"dpi":[317.1,320.2],"bw":3,"ac":1000},{"type":"ios","rules":[{"res":[750,1334]}],"dpi":326.4,"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1242,2208]}],"dpi":[453.6,458.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1125,2001]}],"dpi":[410.9,415.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1125,2436]}],"dpi":458,"bw":4,"ac":1000}];
	var DPDB_CACHE = {
		format: format,
		last_updated: last_updated,
		devices: devices
	};
	function Dpdb(url, onDeviceParamsUpdated) {
	  this.dpdb = DPDB_CACHE;
	  this.recalculateDeviceParams_();
	  if (url) {
	    this.onDeviceParamsUpdated = onDeviceParamsUpdated;
	    var xhr = new XMLHttpRequest();
	    var obj = this;
	    xhr.open('GET', url, true);
	    xhr.addEventListener('load', function () {
	      obj.loading = false;
	      if (xhr.status >= 200 && xhr.status <= 299) {
	        obj.dpdb = JSON.parse(xhr.response);
	        obj.recalculateDeviceParams_();
	      } else {
	        console.error('Error loading online DPDB!');
	      }
	    });
	    xhr.send();
	  }
	}
	Dpdb.prototype.getDeviceParams = function () {
	  return this.deviceParams;
	};
	Dpdb.prototype.recalculateDeviceParams_ = function () {
	  var newDeviceParams = this.calcDeviceParams_();
	  if (newDeviceParams) {
	    this.deviceParams = newDeviceParams;
	    if (this.onDeviceParamsUpdated) {
	      this.onDeviceParamsUpdated(this.deviceParams);
	    }
	  } else {
	    console.error('Failed to recalculate device parameters.');
	  }
	};
	Dpdb.prototype.calcDeviceParams_ = function () {
	  var db = this.dpdb;
	  if (!db) {
	    console.error('DPDB not available.');
	    return null;
	  }
	  if (db.format != 1) {
	    console.error('DPDB has unexpected format version.');
	    return null;
	  }
	  if (!db.devices || !db.devices.length) {
	    console.error('DPDB does not have a devices section.');
	    return null;
	  }
	  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
	  var width = getScreenWidth();
	  var height = getScreenHeight();
	  if (!db.devices) {
	    console.error('DPDB has no devices section.');
	    return null;
	  }
	  for (var i = 0; i < db.devices.length; i++) {
	    var device = db.devices[i];
	    if (!device.rules) {
	      console.warn('Device[' + i + '] has no rules section.');
	      continue;
	    }
	    if (device.type != 'ios' && device.type != 'android') {
	      console.warn('Device[' + i + '] has invalid type.');
	      continue;
	    }
	    if (isIOS() != (device.type == 'ios')) continue;
	    var matched = false;
	    for (var j = 0; j < device.rules.length; j++) {
	      var rule = device.rules[j];
	      if (this.matchRule_(rule, userAgent, width, height)) {
	        matched = true;
	        break;
	      }
	    }
	    if (!matched) continue;
	    var xdpi = device.dpi[0] || device.dpi;
	    var ydpi = device.dpi[1] || device.dpi;
	    return new DeviceParams({ xdpi: xdpi, ydpi: ydpi, bevelMm: device.bw });
	  }
	  console.warn('No DPDB device match.');
	  return null;
	};
	Dpdb.prototype.matchRule_ = function (rule, ua, screenWidth, screenHeight) {
	  if (!rule.ua && !rule.res) return false;
	  if (rule.ua && ua.indexOf(rule.ua) < 0) return false;
	  if (rule.res) {
	    if (!rule.res[0] || !rule.res[1]) return false;
	    var resX = rule.res[0];
	    var resY = rule.res[1];
	    if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) || Math.max(screenWidth, screenHeight) != Math.max(resX, resY)) {
	      return false;
	    }
	  }
	  return true;
	};
	function DeviceParams(params) {
	  this.xdpi = params.xdpi;
	  this.ydpi = params.ydpi;
	  this.bevelMm = params.bevelMm;
	}
	function SensorSample(sample, timestampS) {
	  this.set(sample, timestampS);
	}
	SensorSample.prototype.set = function (sample, timestampS) {
	  this.sample = sample;
	  this.timestampS = timestampS;
	};
	SensorSample.prototype.copy = function (sensorSample) {
	  this.set(sensorSample.sample, sensorSample.timestampS);
	};
	function ComplementaryFilter(kFilter, isDebug) {
	  this.kFilter = kFilter;
	  this.isDebug = isDebug;
	  this.currentAccelMeasurement = new SensorSample();
	  this.currentGyroMeasurement = new SensorSample();
	  this.previousGyroMeasurement = new SensorSample();
	  if (isIOS()) {
	    this.filterQ = new Quaternion(-1, 0, 0, 1);
	  } else {
	    this.filterQ = new Quaternion(1, 0, 0, 1);
	  }
	  this.previousFilterQ = new Quaternion();
	  this.previousFilterQ.copy(this.filterQ);
	  this.accelQ = new Quaternion();
	  this.isOrientationInitialized = false;
	  this.estimatedGravity = new Vector3();
	  this.measuredGravity = new Vector3();
	  this.gyroIntegralQ = new Quaternion();
	}
	ComplementaryFilter.prototype.addAccelMeasurement = function (vector, timestampS) {
	  this.currentAccelMeasurement.set(vector, timestampS);
	};
	ComplementaryFilter.prototype.addGyroMeasurement = function (vector, timestampS) {
	  this.currentGyroMeasurement.set(vector, timestampS);
	  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
	  if (isTimestampDeltaValid(deltaT)) {
	    this.run_();
	  }
	  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
	};
	ComplementaryFilter.prototype.run_ = function () {
	  if (!this.isOrientationInitialized) {
	    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
	    this.previousFilterQ.copy(this.accelQ);
	    this.isOrientationInitialized = true;
	    return;
	  }
	  var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;
	  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
	  this.gyroIntegralQ.multiply(gyroDeltaQ);
	  this.filterQ.copy(this.previousFilterQ);
	  this.filterQ.multiply(gyroDeltaQ);
	  var invFilterQ = new Quaternion();
	  invFilterQ.copy(this.filterQ);
	  invFilterQ.inverse();
	  this.estimatedGravity.set(0, 0, -1);
	  this.estimatedGravity.applyQuaternion(invFilterQ);
	  this.estimatedGravity.normalize();
	  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
	  this.measuredGravity.normalize();
	  var deltaQ = new Quaternion();
	  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
	  deltaQ.inverse();
	  if (this.isDebug) {
	    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)', radToDeg * getQuaternionAngle(deltaQ), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
	  }
	  var targetQ = new Quaternion();
	  targetQ.copy(this.filterQ);
	  targetQ.multiply(deltaQ);
	  this.filterQ.slerp(targetQ, 1 - this.kFilter);
	  this.previousFilterQ.copy(this.filterQ);
	};
	ComplementaryFilter.prototype.getOrientation = function () {
	  return this.filterQ;
	};
	ComplementaryFilter.prototype.accelToQuaternion_ = function (accel) {
	  var normAccel = new Vector3();
	  normAccel.copy(accel);
	  normAccel.normalize();
	  var quat = new Quaternion();
	  quat.setFromUnitVectors(new Vector3(0, 0, -1), normAccel);
	  quat.inverse();
	  return quat;
	};
	ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function (gyro, dt) {
	  var quat = new Quaternion();
	  var axis = new Vector3();
	  axis.copy(gyro);
	  axis.normalize();
	  quat.setFromAxisAngle(axis, gyro.length() * dt);
	  return quat;
	};
	function PosePredictor(predictionTimeS, isDebug) {
	  this.predictionTimeS = predictionTimeS;
	  this.isDebug = isDebug;
	  this.previousQ = new Quaternion();
	  this.previousTimestampS = null;
	  this.deltaQ = new Quaternion();
	  this.outQ = new Quaternion();
	}
	PosePredictor.prototype.getPrediction = function (currentQ, gyro, timestampS) {
	  if (!this.previousTimestampS) {
	    this.previousQ.copy(currentQ);
	    this.previousTimestampS = timestampS;
	    return currentQ;
	  }
	  var axis = new Vector3();
	  axis.copy(gyro);
	  axis.normalize();
	  var angularSpeed = gyro.length();
	  if (angularSpeed < degToRad * 20) {
	    if (this.isDebug) {
	      console.log('Moving slowly, at %s deg/s: no prediction', (radToDeg * angularSpeed).toFixed(1));
	    }
	    this.outQ.copy(currentQ);
	    this.previousQ.copy(currentQ);
	    return this.outQ;
	  }
	  var predictAngle = angularSpeed * this.predictionTimeS;
	  this.deltaQ.setFromAxisAngle(axis, predictAngle);
	  this.outQ.copy(this.previousQ);
	  this.outQ.multiply(this.deltaQ);
	  this.previousQ.copy(currentQ);
	  this.previousTimestampS = timestampS;
	  return this.outQ;
	};
	function FusionPoseSensor(kFilter, predictionTime, yawOnly, isDebug) {
	  this.yawOnly = yawOnly;
	  this.accelerometer = new Vector3();
	  this.gyroscope = new Vector3();
	  this.filter = new ComplementaryFilter(kFilter, isDebug);
	  this.posePredictor = new PosePredictor(predictionTime, isDebug);
	  this.isFirefoxAndroid = isFirefoxAndroid();
	  this.isIOS = isIOS();
	  var chromeVersion = getChromeVersion();
	  this.isDeviceMotionInRadians = !this.isIOS && chromeVersion && chromeVersion < 66;
	  this.isWithoutDeviceMotion = isChromeWithoutDeviceMotion();
	  this.filterToWorldQ = new Quaternion();
	  if (isIOS()) {
	    this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), Math.PI / 2);
	  } else {
	    this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
	  }
	  this.inverseWorldToScreenQ = new Quaternion();
	  this.worldToScreenQ = new Quaternion();
	  this.originalPoseAdjustQ = new Quaternion();
	  this.originalPoseAdjustQ.setFromAxisAngle(new Vector3(0, 0, 1), -window.orientation * Math.PI / 180);
	  this.setScreenTransform_();
	  if (isLandscapeMode()) {
	    this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
	  }
	  this.resetQ = new Quaternion();
	  this.orientationOut_ = new Float32Array(4);
	  this.start();
	}
	FusionPoseSensor.prototype.getPosition = function () {
	  return null;
	};
	FusionPoseSensor.prototype.getOrientation = function () {
	  var orientation = void 0;
	  if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
	    this.deviceOrientationFixQ = this.deviceOrientationFixQ || function () {
	      var z = new Quaternion().setFromAxisAngle(new Vector3(0, 0, -1), 0);
	      var y = new Quaternion();
	      if (window.orientation === -90) {
	        y.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / -2);
	      } else {
	        y.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
	      }
	      return z.multiply(y);
	    }();
	    this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function () {
	      var q = new Quaternion();
	      q.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
	      return q;
	    }();
	    orientation = this._deviceOrientationQ;
	    var out = new Quaternion();
	    out.copy(orientation);
	    out.multiply(this.deviceOrientationFilterToWorldQ);
	    out.multiply(this.resetQ);
	    out.multiply(this.worldToScreenQ);
	    out.multiplyQuaternions(this.deviceOrientationFixQ, out);
	    if (this.yawOnly) {
	      out.x = 0;
	      out.z = 0;
	      out.normalize();
	    }
	    this.orientationOut_[0] = out.x;
	    this.orientationOut_[1] = out.y;
	    this.orientationOut_[2] = out.z;
	    this.orientationOut_[3] = out.w;
	    return this.orientationOut_;
	  } else {
	    var filterOrientation = this.filter.getOrientation();
	    orientation = this.posePredictor.getPrediction(filterOrientation, this.gyroscope, this.previousTimestampS);
	  }
	  var out = new Quaternion();
	  out.copy(this.filterToWorldQ);
	  out.multiply(this.resetQ);
	  out.multiply(orientation);
	  out.multiply(this.worldToScreenQ);
	  if (this.yawOnly) {
	    out.x = 0;
	    out.z = 0;
	    out.normalize();
	  }
	  this.orientationOut_[0] = out.x;
	  this.orientationOut_[1] = out.y;
	  this.orientationOut_[2] = out.z;
	  this.orientationOut_[3] = out.w;
	  return this.orientationOut_;
	};
	FusionPoseSensor.prototype.resetPose = function () {
	  this.resetQ.copy(this.filter.getOrientation());
	  this.resetQ.x = 0;
	  this.resetQ.y = 0;
	  this.resetQ.z *= -1;
	  this.resetQ.normalize();
	  if (isLandscapeMode()) {
	    this.resetQ.multiply(this.inverseWorldToScreenQ);
	  }
	  this.resetQ.multiply(this.originalPoseAdjustQ);
	};
	FusionPoseSensor.prototype.onDeviceOrientation_ = function (e) {
	  this._deviceOrientationQ = this._deviceOrientationQ || new Quaternion();
	  var alpha = e.alpha,
	      beta = e.beta,
	      gamma = e.gamma;
	  alpha = (alpha || 0) * Math.PI / 180;
	  beta = (beta || 0) * Math.PI / 180;
	  gamma = (gamma || 0) * Math.PI / 180;
	  this._deviceOrientationQ.setFromEulerYXZ(beta, alpha, -gamma);
	};
	FusionPoseSensor.prototype.onDeviceMotion_ = function (deviceMotion) {
	  this.updateDeviceMotion_(deviceMotion);
	};
	FusionPoseSensor.prototype.updateDeviceMotion_ = function (deviceMotion) {
	  var accGravity = deviceMotion.accelerationIncludingGravity;
	  var rotRate = deviceMotion.rotationRate;
	  var timestampS = deviceMotion.timeStamp / 1000;
	  var deltaS = timestampS - this.previousTimestampS;
	  if (deltaS < 0) {
	    warnOnce('fusion-pose-sensor:invalid:non-monotonic', 'Invalid timestamps detected: non-monotonic timestamp from devicemotion');
	    this.previousTimestampS = timestampS;
	    return;
	  } else if (deltaS <= MIN_TIMESTEP || deltaS > MAX_TIMESTEP) {
	    warnOnce('fusion-pose-sensor:invalid:outside-threshold', 'Invalid timestamps detected: Timestamp from devicemotion outside expected range.');
	    this.previousTimestampS = timestampS;
	    return;
	  }
	  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
	  if (isR7()) {
	    this.gyroscope.set(-rotRate.beta, rotRate.alpha, rotRate.gamma);
	  } else {
	    this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
	  }
	  if (!this.isDeviceMotionInRadians) {
	    this.gyroscope.multiplyScalar(Math.PI / 180);
	  }
	  this.filter.addAccelMeasurement(this.accelerometer, timestampS);
	  this.filter.addGyroMeasurement(this.gyroscope, timestampS);
	  this.previousTimestampS = timestampS;
	};
	FusionPoseSensor.prototype.onOrientationChange_ = function (screenOrientation) {
	  this.setScreenTransform_();
	};
	FusionPoseSensor.prototype.onMessage_ = function (event) {
	  var message = event.data;
	  if (!message || !message.type) {
	    return;
	  }
	  var type = message.type.toLowerCase();
	  if (type !== 'devicemotion') {
	    return;
	  }
	  this.updateDeviceMotion_(message.deviceMotionEvent);
	};
	FusionPoseSensor.prototype.setScreenTransform_ = function () {
	  this.worldToScreenQ.set(0, 0, 0, 1);
	  switch (window.orientation) {
	    case 0:
	      break;
	    case 90:
	      this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), -Math.PI / 2);
	      break;
	    case -90:
	      this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), Math.PI / 2);
	      break;
	    case 180:
	      break;
	  }
	  this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
	  this.inverseWorldToScreenQ.inverse();
	};
	FusionPoseSensor.prototype.start = function () {
	  this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this);
	  this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this);
	  this.onMessageCallback_ = this.onMessage_.bind(this);
	  this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this);
	  if (isIOS() && isInsideCrossOriginIFrame()) {
	    window.addEventListener('message', this.onMessageCallback_);
	  }
	  window.addEventListener('orientationchange', this.onOrientationChangeCallback_);
	  if (this.isWithoutDeviceMotion) {
	    window.addEventListener('deviceorientation', this.onDeviceOrientationCallback_);
	  } else {
	    window.addEventListener('devicemotion', this.onDeviceMotionCallback_);
	  }
	};
	FusionPoseSensor.prototype.stop = function () {
	  window.removeEventListener('devicemotion', this.onDeviceMotionCallback_);
	  window.removeEventListener('deviceorientation', this.onDeviceOrientationCallback_);
	  window.removeEventListener('orientationchange', this.onOrientationChangeCallback_);
	  window.removeEventListener('message', this.onMessageCallback_);
	};
	var SENSOR_FREQUENCY = 60;
	var X_AXIS = new Vector3(1, 0, 0);
	var Z_AXIS = new Vector3(0, 0, 1);
	var orientation = {};
	if (screen.orientation) {
	  orientation = screen.orientation;
	} else if (screen.msOrientation) {
	  orientation = screen.msOrientation;
	} else {
	  Object.defineProperty(orientation, 'angle', {
	    get: function get$$1() {
	      return window.orientation || 0;
	    }
	  });
	}
	var SENSOR_TO_VR = new Quaternion();
	SENSOR_TO_VR.setFromAxisAngle(X_AXIS, -Math.PI / 2);
	SENSOR_TO_VR.multiply(new Quaternion().setFromAxisAngle(Z_AXIS, Math.PI / 2));
	var PoseSensor = function () {
	  function PoseSensor(config) {
	    classCallCheck(this, PoseSensor);
	    this.config = config;
	    this.sensor = null;
	    this.fusionSensor = null;
	    this._out = new Float32Array(4);
	    this.api = null;
	    this.errors = [];
	    this._sensorQ = new Quaternion();
	    this._worldToScreenQ = new Quaternion();
	    this._outQ = new Quaternion();
	    this._onSensorRead = this._onSensorRead.bind(this);
	    this._onSensorError = this._onSensorError.bind(this);
	    this._onOrientationChange = this._onOrientationChange.bind(this);
	    this._onOrientationChange();
	    this.init();
	  }
	  createClass(PoseSensor, [{
	    key: 'init',
	    value: function init() {
	      var sensor = null;
	      try {
	        sensor = new RelativeOrientationSensor({ frequency: SENSOR_FREQUENCY });
	        sensor.addEventListener('error', this._onSensorError);
	      } catch (error) {
	        this.errors.push(error);
	        if (error.name === 'SecurityError') {
	          console.error('Cannot construct sensors due to the Feature Policy');
	          console.warn('Attempting to fall back using "devicemotion"; however this will ' + 'fail in the future without correct permissions.');
	          this.useDeviceMotion();
	        } else if (error.name === 'ReferenceError') {
	          this.useDeviceMotion();
	        } else {
	          console.error(error);
	        }
	      }
	      if (sensor) {
	        this.api = 'sensor';
	        this.sensor = sensor;
	        this.sensor.addEventListener('reading', this._onSensorRead);
	        this.sensor.start();
	      }
	      window.addEventListener('orientationchange', this._onOrientationChange);
	    }
	  }, {
	    key: 'useDeviceMotion',
	    value: function useDeviceMotion() {
	      this.api = 'devicemotion';
	      this.fusionSensor = new FusionPoseSensor(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG);
	      if (this.sensor) {
	        this.sensor.removeEventListener('reading', this._onSensorRead);
	        this.sensor.removeEventListener('error', this._onSensorError);
	        this.sensor = null;
	      }
	    }
	  }, {
	    key: 'getOrientation',
	    value: function getOrientation() {
	      if (this.fusionSensor) {
	        return this.fusionSensor.getOrientation();
	      }
	      if (!this.sensor || !this.sensor.quaternion) {
	        this._out[0] = this._out[1] = this._out[2] = 0;
	        this._out[3] = 1;
	        return this._out;
	      }
	      var q = this.sensor.quaternion;
	      this._sensorQ.set(q[0], q[1], q[2], q[3]);
	      var out = this._outQ;
	      out.copy(SENSOR_TO_VR);
	      out.multiply(this._sensorQ);
	      out.multiply(this._worldToScreenQ);
	      if (this.config.YAW_ONLY) {
	        out.x = out.z = 0;
	        out.normalize();
	      }
	      this._out[0] = out.x;
	      this._out[1] = out.y;
	      this._out[2] = out.z;
	      this._out[3] = out.w;
	      return this._out;
	    }
	  }, {
	    key: '_onSensorError',
	    value: function _onSensorError(event) {
	      this.errors.push(event.error);
	      if (event.error.name === 'NotAllowedError') {
	        console.error('Permission to access sensor was denied');
	      } else if (event.error.name === 'NotReadableError') {
	        console.error('Sensor could not be read');
	      } else {
	        console.error(event.error);
	      }
	      this.useDeviceMotion();
	    }
	  }, {
	    key: '_onSensorRead',
	    value: function _onSensorRead() {}
	  }, {
	    key: '_onOrientationChange',
	    value: function _onOrientationChange() {
	      var angle = -orientation.angle * Math.PI / 180;
	      this._worldToScreenQ.setFromAxisAngle(Z_AXIS, angle);
	    }
	  }]);
	  return PoseSensor;
	}();
	var rotateInstructionsAsset = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5OHB4IiBoZWlnaHQ9IjI0MHB4IiB2aWV3Qm94PSIwIDAgMTk4IDI0MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpza2V0Y2g9Imh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9ucyI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDMuMy4zICgxMjA4MSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dHJhbnNpdGlvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHNrZXRjaDp0eXBlPSJNU1BhZ2UiPgogICAgICAgIDxnIGlkPSJ0cmFuc2l0aW9uIiBza2V0Y2g6dHlwZT0iTVNBcnRib2FyZEdyb3VwIj4KICAgICAgICAgICAgPGcgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTQtKy1JbXBvcnRlZC1MYXllcnMtQ29weS0rLUltcG9ydGVkLUxheWVycy1Db3B5LTItQ29weSIgc2tldGNoOnR5cGU9Ik1TTGF5ZXJHcm91cCI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHktNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwNy4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjYyNSwyLjUyNyBDMTQ5LjYyNSwyLjUyNyAxNTUuODA1LDYuMDk2IDE1Ni4zNjIsNi40MTggTDE1Ni4zNjIsNy4zMDQgQzE1Ni4zNjIsNy40ODEgMTU2LjM3NSw3LjY2NCAxNTYuNCw3Ljg1MyBDMTU2LjQxLDcuOTM0IDE1Ni40Miw4LjAxNSAxNTYuNDI3LDguMDk1IEMxNTYuNTY3LDkuNTEgMTU3LjQwMSwxMS4wOTMgMTU4LjUzMiwxMi4wOTQgTDE2NC4yNTIsMTcuMTU2IEwxNjQuMzMzLDE3LjA2NiBDMTY0LjMzMywxNy4wNjYgMTY4LjcxNSwxNC41MzYgMTY5LjU2OCwxNC4wNDIgQzE3MS4wMjUsMTQuODgzIDE5NS41MzgsMjkuMDM1IDE5NS41MzgsMjkuMDM1IEwxOTUuNTM4LDgzLjAzNiBDMTk1LjUzOCw4My44MDcgMTk1LjE1Miw4NC4yNTMgMTk0LjU5LDg0LjI1MyBDMTk0LjM1Nyw4NC4yNTMgMTk0LjA5NSw4NC4xNzcgMTkzLjgxOCw4NC4wMTcgTDE2OS44NTEsNzAuMTc5IEwxNjkuODM3LDcwLjIwMyBMMTQyLjUxNSw4NS45NzggTDE0MS42NjUsODQuNjU1IEMxMzYuOTM0LDgzLjEyNiAxMzEuOTE3LDgxLjkxNSAxMjYuNzE0LDgxLjA0NSBDMTI2LjcwOSw4MS4wNiAxMjYuNzA3LDgxLjA2OSAxMjYuNzA3LDgxLjA2OSBMMTIxLjY0LDk4LjAzIEwxMTMuNzQ5LDEwMi41ODYgTDExMy43MTIsMTAyLjUyMyBMMTEzLjcxMiwxMzAuMTEzIEMxMTMuNzEyLDEzMC44ODUgMTEzLjMyNiwxMzEuMzMgMTEyLjc2NCwxMzEuMzMgQzExMi41MzIsMTMxLjMzIDExMi4yNjksMTMxLjI1NCAxMTEuOTkyLDEzMS4wOTQgTDY5LjUxOSwxMDYuNTcyIEM2OC41NjksMTA2LjAyMyA2Ny43OTksMTA0LjY5NSA2Ny43OTksMTAzLjYwNSBMNjcuNzk5LDEwMi41NyBMNjcuNzc4LDEwMi42MTcgQzY3LjI3LDEwMi4zOTMgNjYuNjQ4LDEwMi4yNDkgNjUuOTYyLDEwMi4yMTggQzY1Ljg3NSwxMDIuMjE0IDY1Ljc4OCwxMDIuMjEyIDY1LjcwMSwxMDIuMjEyIEM2NS42MDYsMTAyLjIxMiA2NS41MTEsMTAyLjIxNSA2NS40MTYsMTAyLjIxOSBDNjUuMTk1LDEwMi4yMjkgNjQuOTc0LDEwMi4yMzUgNjQuNzU0LDEwMi4yMzUgQzY0LjMzMSwxMDIuMjM1IDYzLjkxMSwxMDIuMjE2IDYzLjQ5OCwxMDIuMTc4IEM2MS44NDMsMTAyLjAyNSA2MC4yOTgsMTAxLjU3OCA1OS4wOTQsMTAwLjg4MiBMMTIuNTE4LDczLjk5MiBMMTIuNTIzLDc0LjAwNCBMMi4yNDUsNTUuMjU0IEMxLjI0NCw1My40MjcgMi4wMDQsNTEuMDM4IDMuOTQzLDQ5LjkxOCBMNTkuOTU0LDE3LjU3MyBDNjAuNjI2LDE3LjE4NSA2MS4zNSwxNy4wMDEgNjIuMDUzLDE3LjAwMSBDNjMuMzc5LDE3LjAwMSA2NC42MjUsMTcuNjYgNjUuMjgsMTguODU0IEw2NS4yODUsMTguODUxIEw2NS41MTIsMTkuMjY0IEw2NS41MDYsMTkuMjY4IEM2NS45MDksMjAuMDAzIDY2LjQwNSwyMC42OCA2Ni45ODMsMjEuMjg2IEw2Ny4yNiwyMS41NTYgQzY5LjE3NCwyMy40MDYgNzEuNzI4LDI0LjM1NyA3NC4zNzMsMjQuMzU3IEM3Ni4zMjIsMjQuMzU3IDc4LjMyMSwyMy44NCA4MC4xNDgsMjIuNzg1IEM4MC4xNjEsMjIuNzg1IDg3LjQ2NywxOC41NjYgODcuNDY3LDE4LjU2NiBDODguMTM5LDE4LjE3OCA4OC44NjMsMTcuOTk0IDg5LjU2NiwxNy45OTQgQzkwLjg5MiwxNy45OTQgOTIuMTM4LDE4LjY1MiA5Mi43OTIsMTkuODQ3IEw5Ni4wNDIsMjUuNzc1IEw5Ni4wNjQsMjUuNzU3IEwxMDIuODQ5LDI5LjY3NCBMMTAyLjc0NCwyOS40OTIgTDE0OS42MjUsMi41MjcgTTE0OS42MjUsMC44OTIgQzE0OS4zNDMsMC44OTIgMTQ5LjA2MiwwLjk2NSAxNDguODEsMS4xMSBMMTAyLjY0MSwyNy42NjYgTDk3LjIzMSwyNC41NDIgTDk0LjIyNiwxOS4wNjEgQzkzLjMxMywxNy4zOTQgOTEuNTI3LDE2LjM1OSA4OS41NjYsMTYuMzU4IEM4OC41NTUsMTYuMzU4IDg3LjU0NiwxNi42MzIgODYuNjQ5LDE3LjE1IEM4My44NzgsMTguNzUgNzkuNjg3LDIxLjE2OSA3OS4zNzQsMjEuMzQ1IEM3OS4zNTksMjEuMzUzIDc5LjM0NSwyMS4zNjEgNzkuMzMsMjEuMzY5IEM3Ny43OTgsMjIuMjU0IDc2LjA4NCwyMi43MjIgNzQuMzczLDIyLjcyMiBDNzIuMDgxLDIyLjcyMiA2OS45NTksMjEuODkgNjguMzk3LDIwLjM4IEw2OC4xNDUsMjAuMTM1IEM2Ny43MDYsMTkuNjcyIDY3LjMyMywxOS4xNTYgNjcuMDA2LDE4LjYwMSBDNjYuOTg4LDE4LjU1OSA2Ni45NjgsMTguNTE5IDY2Ljk0NiwxOC40NzkgTDY2LjcxOSwxOC4wNjUgQzY2LjY5LDE4LjAxMiA2Ni42NTgsMTcuOTYgNjYuNjI0LDE3LjkxMSBDNjUuNjg2LDE2LjMzNyA2My45NTEsMTUuMzY2IDYyLjA1MywxNS4zNjYgQzYxLjA0MiwxNS4zNjYgNjAuMDMzLDE1LjY0IDU5LjEzNiwxNi4xNTggTDMuMTI1LDQ4LjUwMiBDMC40MjYsNTAuMDYxIC0wLjYxMyw1My40NDIgMC44MTEsNTYuMDQgTDExLjA4OSw3NC43OSBDMTEuMjY2LDc1LjExMyAxMS41MzcsNzUuMzUzIDExLjg1LDc1LjQ5NCBMNTguMjc2LDEwMi4yOTggQzU5LjY3OSwxMDMuMTA4IDYxLjQzMywxMDMuNjMgNjMuMzQ4LDEwMy44MDYgQzYzLjgxMiwxMDMuODQ4IDY0LjI4NSwxMDMuODcgNjQuNzU0LDEwMy44NyBDNjUsMTAzLjg3IDY1LjI0OSwxMDMuODY0IDY1LjQ5NCwxMDMuODUyIEM2NS41NjMsMTAzLjg0OSA2NS42MzIsMTAzLjg0NyA2NS43MDEsMTAzLjg0NyBDNjUuNzY0LDEwMy44NDcgNjUuODI4LDEwMy44NDkgNjUuODksMTAzLjg1MiBDNjUuOTg2LDEwMy44NTYgNjYuMDgsMTAzLjg2MyA2Ni4xNzMsMTAzLjg3NCBDNjYuMjgyLDEwNS40NjcgNjcuMzMyLDEwNy4xOTcgNjguNzAyLDEwNy45ODggTDExMS4xNzQsMTMyLjUxIEMxMTEuNjk4LDEzMi44MTIgMTEyLjIzMiwxMzIuOTY1IDExMi43NjQsMTMyLjk2NSBDMTE0LjI2MSwxMzIuOTY1IDExNS4zNDcsMTMxLjc2NSAxMTUuMzQ3LDEzMC4xMTMgTDExNS4zNDcsMTAzLjU1MSBMMTIyLjQ1OCw5OS40NDYgQzEyMi44MTksOTkuMjM3IDEyMy4wODcsOTguODk4IDEyMy4yMDcsOTguNDk4IEwxMjcuODY1LDgyLjkwNSBDMTMyLjI3OSw4My43MDIgMTM2LjU1Nyw4NC43NTMgMTQwLjYwNyw4Ni4wMzMgTDE0MS4xNCw4Ni44NjIgQzE0MS40NTEsODcuMzQ2IDE0MS45NzcsODcuNjEzIDE0Mi41MTYsODcuNjEzIEMxNDIuNzk0LDg3LjYxMyAxNDMuMDc2LDg3LjU0MiAxNDMuMzMzLDg3LjM5MyBMMTY5Ljg2NSw3Mi4wNzYgTDE5Myw4NS40MzMgQzE5My41MjMsODUuNzM1IDE5NC4wNTgsODUuODg4IDE5NC41OSw4NS44ODggQzE5Ni4wODcsODUuODg4IDE5Ny4xNzMsODQuNjg5IDE5Ny4xNzMsODMuMDM2IEwxOTcuMTczLDI5LjAzNSBDMTk3LjE3MywyOC40NTEgMTk2Ljg2MSwyNy45MTEgMTk2LjM1NSwyNy42MTkgQzE5Ni4zNTUsMjcuNjE5IDE3MS44NDMsMTMuNDY3IDE3MC4zODUsMTIuNjI2IEMxNzAuMTMyLDEyLjQ4IDE2OS44NSwxMi40MDcgMTY5LjU2OCwxMi40MDcgQzE2OS4yODUsMTIuNDA3IDE2OS4wMDIsMTIuNDgxIDE2OC43NDksMTIuNjI3IEMxNjguMTQzLDEyLjk3OCAxNjUuNzU2LDE0LjM1NyAxNjQuNDI0LDE1LjEyNSBMMTU5LjYxNSwxMC44NyBDMTU4Ljc5NiwxMC4xNDUgMTU4LjE1NCw4LjkzNyAxNTguMDU0LDcuOTM0IEMxNTguMDQ1LDcuODM3IDE1OC4wMzQsNy43MzkgMTU4LjAyMSw3LjY0IEMxNTguMDA1LDcuNTIzIDE1Ny45OTgsNy40MSAxNTcuOTk4LDcuMzA0IEwxNTcuOTk4LDYuNDE4IEMxNTcuOTk4LDUuODM0IDE1Ny42ODYsNS4yOTUgMTU3LjE4MSw1LjAwMiBDMTU2LjYyNCw0LjY4IDE1MC40NDIsMS4xMTEgMTUwLjQ0MiwxLjExMSBDMTUwLjE4OSwwLjk2NSAxNDkuOTA3LDAuODkyIDE0OS42MjUsMC44OTIiIGlkPSJGaWxsLTEiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTYuMDI3LDI1LjYzNiBMMTQyLjYwMyw1Mi41MjcgQzE0My44MDcsNTMuMjIyIDE0NC41ODIsNTQuMTE0IDE0NC44NDUsNTUuMDY4IEwxNDQuODM1LDU1LjA3NSBMNjMuNDYxLDEwMi4wNTcgTDYzLjQ2LDEwMi4wNTcgQzYxLjgwNiwxMDEuOTA1IDYwLjI2MSwxMDEuNDU3IDU5LjA1NywxMDAuNzYyIEwxMi40ODEsNzMuODcxIEw5Ni4wMjcsMjUuNjM2IiBpZD0iRmlsbC0yIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYzLjQ2MSwxMDIuMTc0IEM2My40NTMsMTAyLjE3NCA2My40NDYsMTAyLjE3NCA2My40MzksMTAyLjE3MiBDNjEuNzQ2LDEwMi4wMTYgNjAuMjExLDEwMS41NjMgNTguOTk4LDEwMC44NjMgTDEyLjQyMiw3My45NzMgQzEyLjM4Niw3My45NTIgMTIuMzY0LDczLjkxNCAxMi4zNjQsNzMuODcxIEMxMi4zNjQsNzMuODMgMTIuMzg2LDczLjc5MSAxMi40MjIsNzMuNzcgTDk1Ljk2OCwyNS41MzUgQzk2LjAwNCwyNS41MTQgOTYuMDQ5LDI1LjUxNCA5Ni4wODUsMjUuNTM1IEwxNDIuNjYxLDUyLjQyNiBDMTQzLjg4OCw1My4xMzQgMTQ0LjY4Miw1NC4wMzggMTQ0Ljk1Nyw1NS4wMzcgQzE0NC45Nyw1NS4wODMgMTQ0Ljk1Myw1NS4xMzMgMTQ0LjkxNSw1NS4xNjEgQzE0NC45MTEsNTUuMTY1IDE0NC44OTgsNTUuMTc0IDE0NC44OTQsNTUuMTc3IEw2My41MTksMTAyLjE1OCBDNjMuNTAxLDEwMi4xNjkgNjMuNDgxLDEwMi4xNzQgNjMuNDYxLDEwMi4xNzQgTDYzLjQ2MSwxMDIuMTc0IFogTTEyLjcxNCw3My44NzEgTDU5LjExNSwxMDAuNjYxIEM2MC4yOTMsMTAxLjM0MSA2MS43ODYsMTAxLjc4MiA2My40MzUsMTAxLjkzNyBMMTQ0LjcwNyw1NS4wMTUgQzE0NC40MjgsNTQuMTA4IDE0My42ODIsNTMuMjg1IDE0Mi41NDQsNTIuNjI4IEw5Ni4wMjcsMjUuNzcxIEwxMi43MTQsNzMuODcxIEwxMi43MTQsNzMuODcxIFoiIGlkPSJGaWxsLTMiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ4LjMyNyw1OC40NzEgQzE0OC4xNDUsNTguNDggMTQ3Ljk2Miw1OC40OCAxNDcuNzgxLDU4LjQ3MiBDMTQ1Ljg4Nyw1OC4zODkgMTQ0LjQ3OSw1Ny40MzQgMTQ0LjYzNiw1Ni4zNCBDMTQ0LjY4OSw1NS45NjcgMTQ0LjY2NCw1NS41OTcgMTQ0LjU2NCw1NS4yMzUgTDYzLjQ2MSwxMDIuMDU3IEM2NC4wODksMTAyLjExNSA2NC43MzMsMTAyLjEzIDY1LjM3OSwxMDIuMDk5IEM2NS41NjEsMTAyLjA5IDY1Ljc0MywxMDIuMDkgNjUuOTI1LDEwMi4wOTggQzY3LjgxOSwxMDIuMTgxIDY5LjIyNywxMDMuMTM2IDY5LjA3LDEwNC4yMyBMMTQ4LjMyNyw1OC40NzEiIGlkPSJGaWxsLTQiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjkuMDcsMTA0LjM0NyBDNjkuMDQ4LDEwNC4zNDcgNjkuMDI1LDEwNC4zNCA2OS4wMDUsMTA0LjMyNyBDNjguOTY4LDEwNC4zMDEgNjguOTQ4LDEwNC4yNTcgNjguOTU1LDEwNC4yMTMgQzY5LDEwMy44OTYgNjguODk4LDEwMy41NzYgNjguNjU4LDEwMy4yODggQzY4LjE1MywxMDIuNjc4IDY3LjEwMywxMDIuMjY2IDY1LjkyLDEwMi4yMTQgQzY1Ljc0MiwxMDIuMjA2IDY1LjU2MywxMDIuMjA3IDY1LjM4NSwxMDIuMjE1IEM2NC43NDIsMTAyLjI0NiA2NC4wODcsMTAyLjIzMiA2My40NSwxMDIuMTc0IEM2My4zOTksMTAyLjE2OSA2My4zNTgsMTAyLjEzMiA2My4zNDcsMTAyLjA4MiBDNjMuMzM2LDEwMi4wMzMgNjMuMzU4LDEwMS45ODEgNjMuNDAyLDEwMS45NTYgTDE0NC41MDYsNTUuMTM0IEMxNDQuNTM3LDU1LjExNiAxNDQuNTc1LDU1LjExMyAxNDQuNjA5LDU1LjEyNyBDMTQ0LjY0Miw1NS4xNDEgMTQ0LjY2OCw1NS4xNyAxNDQuNjc3LDU1LjIwNCBDMTQ0Ljc4MSw1NS41ODUgMTQ0LjgwNiw1NS45NzIgMTQ0Ljc1MSw1Ni4zNTcgQzE0NC43MDYsNTYuNjczIDE0NC44MDgsNTYuOTk0IDE0NS4wNDcsNTcuMjgyIEMxNDUuNTUzLDU3Ljg5MiAxNDYuNjAyLDU4LjMwMyAxNDcuNzg2LDU4LjM1NSBDMTQ3Ljk2NCw1OC4zNjMgMTQ4LjE0Myw1OC4zNjMgMTQ4LjMyMSw1OC4zNTQgQzE0OC4zNzcsNTguMzUyIDE0OC40MjQsNTguMzg3IDE0OC40MzksNTguNDM4IEMxNDguNDU0LDU4LjQ5IDE0OC40MzIsNTguNTQ1IDE0OC4zODUsNTguNTcyIEw2OS4xMjksMTA0LjMzMSBDNjkuMTExLDEwNC4zNDIgNjkuMDksMTA0LjM0NyA2OS4wNywxMDQuMzQ3IEw2OS4wNywxMDQuMzQ3IFogTTY1LjY2NSwxMDEuOTc1IEM2NS43NTQsMTAxLjk3NSA2NS44NDIsMTAxLjk3NyA2NS45MywxMDEuOTgxIEM2Ny4xOTYsMTAyLjAzNyA2OC4yODMsMTAyLjQ2OSA2OC44MzgsMTAzLjEzOSBDNjkuMDY1LDEwMy40MTMgNjkuMTg4LDEwMy43MTQgNjkuMTk4LDEwNC4wMjEgTDE0Ny44ODMsNTguNTkyIEMxNDcuODQ3LDU4LjU5MiAxNDcuODExLDU4LjU5MSAxNDcuNzc2LDU4LjU4OSBDMTQ2LjUwOSw1OC41MzMgMTQ1LjQyMiw1OC4xIDE0NC44NjcsNTcuNDMxIEMxNDQuNTg1LDU3LjA5MSAxNDQuNDY1LDU2LjcwNyAxNDQuNTIsNTYuMzI0IEMxNDQuNTYzLDU2LjAyMSAxNDQuNTUyLDU1LjcxNiAxNDQuNDg4LDU1LjQxNCBMNjMuODQ2LDEwMS45NyBDNjQuMzUzLDEwMi4wMDIgNjQuODY3LDEwMi4wMDYgNjUuMzc0LDEwMS45ODIgQzY1LjQ3MSwxMDEuOTc3IDY1LjU2OCwxMDEuOTc1IDY1LjY2NSwxMDEuOTc1IEw2NS42NjUsMTAxLjk3NSBaIiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIuMjA4LDU1LjEzNCBDMS4yMDcsNTMuMzA3IDEuOTY3LDUwLjkxNyAzLjkwNiw0OS43OTcgTDU5LjkxNywxNy40NTMgQzYxLjg1NiwxNi4zMzMgNjQuMjQxLDE2LjkwNyA2NS4yNDMsMTguNzM0IEw2NS40NzUsMTkuMTQ0IEM2NS44NzIsMTkuODgyIDY2LjM2OCwyMC41NiA2Ni45NDUsMjEuMTY1IEw2Ny4yMjMsMjEuNDM1IEM3MC41NDgsMjQuNjQ5IDc1LjgwNiwyNS4xNTEgODAuMTExLDIyLjY2NSBMODcuNDMsMTguNDQ1IEM4OS4zNywxNy4zMjYgOTEuNzU0LDE3Ljg5OSA5Mi43NTUsMTkuNzI3IEw5Ni4wMDUsMjUuNjU1IEwxMi40ODYsNzMuODg0IEwyLjIwOCw1NS4xMzQgWiIgaWQ9IkZpbGwtNiIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40ODYsNzQuMDAxIEMxMi40NzYsNzQuMDAxIDEyLjQ2NSw3My45OTkgMTIuNDU1LDczLjk5NiBDMTIuNDI0LDczLjk4OCAxMi4zOTksNzMuOTY3IDEyLjM4NCw3My45NCBMMi4xMDYsNTUuMTkgQzEuMDc1LDUzLjMxIDEuODU3LDUwLjg0NSAzLjg0OCw0OS42OTYgTDU5Ljg1OCwxNy4zNTIgQzYwLjUyNSwxNi45NjcgNjEuMjcxLDE2Ljc2NCA2Mi4wMTYsMTYuNzY0IEM2My40MzEsMTYuNzY0IDY0LjY2NiwxNy40NjYgNjUuMzI3LDE4LjY0NiBDNjUuMzM3LDE4LjY1NCA2NS4zNDUsMTguNjYzIDY1LjM1MSwxOC42NzQgTDY1LjU3OCwxOS4wODggQzY1LjU4NCwxOS4xIDY1LjU4OSwxOS4xMTIgNjUuNTkxLDE5LjEyNiBDNjUuOTg1LDE5LjgzOCA2Ni40NjksMjAuNDk3IDY3LjAzLDIxLjA4NSBMNjcuMzA1LDIxLjM1MSBDNjkuMTUxLDIzLjEzNyA3MS42NDksMjQuMTIgNzQuMzM2LDI0LjEyIEM3Ni4zMTMsMjQuMTIgNzguMjksMjMuNTgyIDgwLjA1MywyMi41NjMgQzgwLjA2NCwyMi41NTcgODAuMDc2LDIyLjU1MyA4MC4wODgsMjIuNTUgTDg3LjM3MiwxOC4zNDQgQzg4LjAzOCwxNy45NTkgODguNzg0LDE3Ljc1NiA4OS41MjksMTcuNzU2IEM5MC45NTYsMTcuNzU2IDkyLjIwMSwxOC40NzIgOTIuODU4LDE5LjY3IEw5Ni4xMDcsMjUuNTk5IEM5Ni4xMzgsMjUuNjU0IDk2LjExOCwyNS43MjQgOTYuMDYzLDI1Ljc1NiBMMTIuNTQ1LDczLjk4NSBDMTIuNTI2LDczLjk5NiAxMi41MDYsNzQuMDAxIDEyLjQ4Niw3NC4wMDEgTDEyLjQ4Niw3NC4wMDEgWiBNNjIuMDE2LDE2Ljk5NyBDNjEuMzEyLDE2Ljk5NyA2MC42MDYsMTcuMTkgNTkuOTc1LDE3LjU1NCBMMy45NjUsNDkuODk5IEMyLjA4Myw1MC45ODUgMS4zNDEsNTMuMzA4IDIuMzEsNTUuMDc4IEwxMi41MzEsNzMuNzIzIEw5NS44NDgsMjUuNjExIEw5Mi42NTMsMTkuNzgyIEM5Mi4wMzgsMTguNjYgOTAuODcsMTcuOTkgODkuNTI5LDE3Ljk5IEM4OC44MjUsMTcuOTkgODguMTE5LDE4LjE4MiA4Ny40ODksMTguNTQ3IEw4MC4xNzIsMjIuNzcyIEM4MC4xNjEsMjIuNzc4IDgwLjE0OSwyMi43ODIgODAuMTM3LDIyLjc4NSBDNzguMzQ2LDIzLjgxMSA3Ni4zNDEsMjQuMzU0IDc0LjMzNiwyNC4zNTQgQzcxLjU4OCwyNC4zNTQgNjkuMDMzLDIzLjM0NyA2Ny4xNDIsMjEuNTE5IEw2Ni44NjQsMjEuMjQ5IEM2Ni4yNzcsMjAuNjM0IDY1Ljc3NCwxOS45NDcgNjUuMzY3LDE5LjIwMyBDNjUuMzYsMTkuMTkyIDY1LjM1NiwxOS4xNzkgNjUuMzU0LDE5LjE2NiBMNjUuMTYzLDE4LjgxOSBDNjUuMTU0LDE4LjgxMSA2NS4xNDYsMTguODAxIDY1LjE0LDE4Ljc5IEM2NC41MjUsMTcuNjY3IDYzLjM1NywxNi45OTcgNjIuMDE2LDE2Ljk5NyBMNjIuMDE2LDE2Ljk5NyBaIiBpZD0iRmlsbC03IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQyLjQzNCw0OC44MDggTDQyLjQzNCw0OC44MDggQzM5LjkyNCw0OC44MDcgMzcuNzM3LDQ3LjU1IDM2LjU4Miw0NS40NDMgQzM0Ljc3MSw0Mi4xMzkgMzYuMTQ0LDM3LjgwOSAzOS42NDEsMzUuNzg5IEw1MS45MzIsMjguNjkxIEM1My4xMDMsMjguMDE1IDU0LjQxMywyNy42NTggNTUuNzIxLDI3LjY1OCBDNTguMjMxLDI3LjY1OCA2MC40MTgsMjguOTE2IDYxLjU3MywzMS4wMjMgQzYzLjM4NCwzNC4zMjcgNjIuMDEyLDM4LjY1NyA1OC41MTQsNDAuNjc3IEw0Ni4yMjMsNDcuNzc1IEM0NS4wNTMsNDguNDUgNDMuNzQyLDQ4LjgwOCA0Mi40MzQsNDguODA4IEw0Mi40MzQsNDguODA4IFogTTU1LjcyMSwyOC4xMjUgQzU0LjQ5NSwyOC4xMjUgNTMuMjY1LDI4LjQ2MSA1Mi4xNjYsMjkuMDk2IEwzOS44NzUsMzYuMTk0IEMzNi41OTYsMzguMDg3IDM1LjMwMiw0Mi4xMzYgMzYuOTkyLDQ1LjIxOCBDMzguMDYzLDQ3LjE3MyA0MC4wOTgsNDguMzQgNDIuNDM0LDQ4LjM0IEM0My42NjEsNDguMzQgNDQuODksNDguMDA1IDQ1Ljk5LDQ3LjM3IEw1OC4yODEsNDAuMjcyIEM2MS41NiwzOC4zNzkgNjIuODUzLDM0LjMzIDYxLjE2NCwzMS4yNDggQzYwLjA5MiwyOS4yOTMgNTguMDU4LDI4LjEyNSA1NS43MjEsMjguMTI1IEw1NS43MjEsMjguMTI1IFoiIGlkPSJGaWxsLTgiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjU4OCwyLjQwNyBDMTQ5LjU4OCwyLjQwNyAxNTUuNzY4LDUuOTc1IDE1Ni4zMjUsNi4yOTcgTDE1Ni4zMjUsNy4xODQgQzE1Ni4zMjUsNy4zNiAxNTYuMzM4LDcuNTQ0IDE1Ni4zNjIsNy43MzMgQzE1Ni4zNzMsNy44MTQgMTU2LjM4Miw3Ljg5NCAxNTYuMzksNy45NzUgQzE1Ni41Myw5LjM5IDE1Ny4zNjMsMTAuOTczIDE1OC40OTUsMTEuOTc0IEwxNjUuODkxLDE4LjUxOSBDMTY2LjA2OCwxOC42NzUgMTY2LjI0OSwxOC44MTQgMTY2LjQzMiwxOC45MzQgQzE2OC4wMTEsMTkuOTc0IDE2OS4zODIsMTkuNCAxNjkuNDk0LDE3LjY1MiBDMTY5LjU0MywxNi44NjggMTY5LjU1MSwxNi4wNTcgMTY5LjUxNywxNS4yMjMgTDE2OS41MTQsMTUuMDYzIEwxNjkuNTE0LDEzLjkxMiBDMTcwLjc4LDE0LjY0MiAxOTUuNTAxLDI4LjkxNSAxOTUuNTAxLDI4LjkxNSBMMTk1LjUwMSw4Mi45MTUgQzE5NS41MDEsODQuMDA1IDE5NC43MzEsODQuNDQ1IDE5My43ODEsODMuODk3IEwxNTEuMzA4LDU5LjM3NCBDMTUwLjM1OCw1OC44MjYgMTQ5LjU4OCw1Ny40OTcgMTQ5LjU4OCw1Ni40MDggTDE0OS41ODgsMjIuMzc1IiBpZD0iRmlsbC05IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE5NC41NTMsODQuMjUgQzE5NC4yOTYsODQuMjUgMTk0LjAxMyw4NC4xNjUgMTkzLjcyMiw4My45OTcgTDE1MS4yNSw1OS40NzYgQzE1MC4yNjksNTguOTA5IDE0OS40NzEsNTcuNTMzIDE0OS40NzEsNTYuNDA4IEwxNDkuNDcxLDIyLjM3NSBMMTQ5LjcwNSwyMi4zNzUgTDE0OS43MDUsNTYuNDA4IEMxNDkuNzA1LDU3LjQ1OSAxNTAuNDUsNTguNzQ0IDE1MS4zNjYsNTkuMjc0IEwxOTMuODM5LDgzLjc5NSBDMTk0LjI2Myw4NC4wNCAxOTQuNjU1LDg0LjA4MyAxOTQuOTQyLDgzLjkxNyBDMTk1LjIyNyw4My43NTMgMTk1LjM4NCw4My4zOTcgMTk1LjM4NCw4Mi45MTUgTDE5NS4zODQsMjguOTgyIEMxOTQuMTAyLDI4LjI0MiAxNzIuMTA0LDE1LjU0MiAxNjkuNjMxLDE0LjExNCBMMTY5LjYzNCwxNS4yMiBDMTY5LjY2OCwxNi4wNTIgMTY5LjY2LDE2Ljg3NCAxNjkuNjEsMTcuNjU5IEMxNjkuNTU2LDE4LjUwMyAxNjkuMjE0LDE5LjEyMyAxNjguNjQ3LDE5LjQwNSBDMTY4LjAyOCwxOS43MTQgMTY3LjE5NywxOS41NzggMTY2LjM2NywxOS4wMzIgQzE2Ni4xODEsMTguOTA5IDE2NS45OTUsMTguNzY2IDE2NS44MTQsMTguNjA2IEwxNTguNDE3LDEyLjA2MiBDMTU3LjI1OSwxMS4wMzYgMTU2LjQxOCw5LjQzNyAxNTYuMjc0LDcuOTg2IEMxNTYuMjY2LDcuOTA3IDE1Ni4yNTcsNy44MjcgMTU2LjI0Nyw3Ljc0OCBDMTU2LjIyMSw3LjU1NSAxNTYuMjA5LDcuMzY1IDE1Ni4yMDksNy4xODQgTDE1Ni4yMDksNi4zNjQgQzE1NS4zNzUsNS44ODMgMTQ5LjUyOSwyLjUwOCAxNDkuNTI5LDIuNTA4IEwxNDkuNjQ2LDIuMzA2IEMxNDkuNjQ2LDIuMzA2IDE1NS44MjcsNS44NzQgMTU2LjM4NCw2LjE5NiBMMTU2LjQ0Miw2LjIzIEwxNTYuNDQyLDcuMTg0IEMxNTYuNDQyLDcuMzU1IDE1Ni40NTQsNy41MzUgMTU2LjQ3OCw3LjcxNyBDMTU2LjQ4OSw3LjggMTU2LjQ5OSw3Ljg4MiAxNTYuNTA3LDcuOTYzIEMxNTYuNjQ1LDkuMzU4IDE1Ny40NTUsMTAuODk4IDE1OC41NzIsMTEuODg2IEwxNjUuOTY5LDE4LjQzMSBDMTY2LjE0MiwxOC41ODQgMTY2LjMxOSwxOC43MiAxNjYuNDk2LDE4LjgzNyBDMTY3LjI1NCwxOS4zMzYgMTY4LDE5LjQ2NyAxNjguNTQzLDE5LjE5NiBDMTY5LjAzMywxOC45NTMgMTY5LjMyOSwxOC40MDEgMTY5LjM3NywxNy42NDUgQzE2OS40MjcsMTYuODY3IDE2OS40MzQsMTYuMDU0IDE2OS40MDEsMTUuMjI4IEwxNjkuMzk3LDE1LjA2NSBMMTY5LjM5NywxMy43MSBMMTY5LjU3MiwxMy44MSBDMTcwLjgzOSwxNC41NDEgMTk1LjU1OSwyOC44MTQgMTk1LjU1OSwyOC44MTQgTDE5NS42MTgsMjguODQ3IEwxOTUuNjE4LDgyLjkxNSBDMTk1LjYxOCw4My40ODQgMTk1LjQyLDgzLjkxMSAxOTUuMDU5LDg0LjExOSBDMTk0LjkwOCw4NC4yMDYgMTk0LjczNyw4NC4yNSAxOTQuNTUzLDg0LjI1IiBpZD0iRmlsbC0xMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDUuNjg1LDU2LjE2MSBMMTY5LjgsNzAuMDgzIEwxNDMuODIyLDg1LjA4MSBMMTQyLjM2LDg0Ljc3NCBDMTM1LjgyNiw4Mi42MDQgMTI4LjczMiw4MS4wNDYgMTIxLjM0MSw4MC4xNTggQzExNi45NzYsNzkuNjM0IDExMi42NzgsODEuMjU0IDExMS43NDMsODMuNzc4IEMxMTEuNTA2LDg0LjQxNCAxMTEuNTAzLDg1LjA3MSAxMTEuNzMyLDg1LjcwNiBDMTEzLjI3LDg5Ljk3MyAxMTUuOTY4LDk0LjA2OSAxMTkuNzI3LDk3Ljg0MSBMMTIwLjI1OSw5OC42ODYgQzEyMC4yNiw5OC42ODUgOTQuMjgyLDExMy42ODMgOTQuMjgyLDExMy42ODMgTDcwLjE2Nyw5OS43NjEgTDE0NS42ODUsNTYuMTYxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05NC4yODIsMTEzLjgxOCBMOTQuMjIzLDExMy43ODUgTDY5LjkzMyw5OS43NjEgTDcwLjEwOCw5OS42NiBMMTQ1LjY4NSw1Ni4wMjYgTDE0NS43NDMsNTYuMDU5IEwxNzAuMDMzLDcwLjA4MyBMMTQzLjg0Miw4NS4yMDUgTDE0My43OTcsODUuMTk1IEMxNDMuNzcyLDg1LjE5IDE0Mi4zMzYsODQuODg4IDE0Mi4zMzYsODQuODg4IEMxMzUuNzg3LDgyLjcxNCAxMjguNzIzLDgxLjE2MyAxMjEuMzI3LDgwLjI3NCBDMTIwLjc4OCw4MC4yMDkgMTIwLjIzNiw4MC4xNzcgMTE5LjY4OSw4MC4xNzcgQzExNS45MzEsODAuMTc3IDExMi42MzUsODEuNzA4IDExMS44NTIsODMuODE5IEMxMTEuNjI0LDg0LjQzMiAxMTEuNjIxLDg1LjA1MyAxMTEuODQyLDg1LjY2NyBDMTEzLjM3Nyw4OS45MjUgMTE2LjA1OCw5My45OTMgMTE5LjgxLDk3Ljc1OCBMMTE5LjgyNiw5Ny43NzkgTDEyMC4zNTIsOTguNjE0IEMxMjAuMzU0LDk4LjYxNyAxMjAuMzU2LDk4LjYyIDEyMC4zNTgsOTguNjI0IEwxMjAuNDIyLDk4LjcyNiBMMTIwLjMxNyw5OC43ODcgQzEyMC4yNjQsOTguODE4IDk0LjU5OSwxMTMuNjM1IDk0LjM0LDExMy43ODUgTDk0LjI4MiwxMTMuODE4IEw5NC4yODIsMTEzLjgxOCBaIE03MC40MDEsOTkuNzYxIEw5NC4yODIsMTEzLjU0OSBMMTE5LjA4NCw5OS4yMjkgQzExOS42Myw5OC45MTQgMTE5LjkzLDk4Ljc0IDEyMC4xMDEsOTguNjU0IEwxMTkuNjM1LDk3LjkxNCBDMTE1Ljg2NCw5NC4xMjcgMTEzLjE2OCw5MC4wMzMgMTExLjYyMiw4NS43NDYgQzExMS4zODIsODUuMDc5IDExMS4zODYsODQuNDA0IDExMS42MzMsODMuNzM4IEMxMTIuNDQ4LDgxLjUzOSAxMTUuODM2LDc5Ljk0MyAxMTkuNjg5LDc5Ljk0MyBDMTIwLjI0Niw3OS45NDMgMTIwLjgwNiw3OS45NzYgMTIxLjM1NSw4MC4wNDIgQzEyOC43NjcsODAuOTMzIDEzNS44NDYsODIuNDg3IDE0Mi4zOTYsODQuNjYzIEMxNDMuMjMyLDg0LjgzOCAxNDMuNjExLDg0LjkxNyAxNDMuNzg2LDg0Ljk2NyBMMTY5LjU2Niw3MC4wODMgTDE0NS42ODUsNTYuMjk1IEw3MC40MDEsOTkuNzYxIEw3MC40MDEsOTkuNzYxIFoiIGlkPSJGaWxsLTEyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2Ny4yMywxOC45NzkgTDE2Ny4yMyw2OS44NSBMMTM5LjkwOSw4NS42MjMgTDEzMy40NDgsNzEuNDU2IEMxMzIuNTM4LDY5LjQ2IDEzMC4wMiw2OS43MTggMTI3LjgyNCw3Mi4wMyBDMTI2Ljc2OSw3My4xNCAxMjUuOTMxLDc0LjU4NSAxMjUuNDk0LDc2LjA0OCBMMTE5LjAzNCw5Ny42NzYgTDkxLjcxMiwxMTMuNDUgTDkxLjcxMiw2Mi41NzkgTDE2Ny4yMywxOC45NzkiIGlkPSJGaWxsLTEzIiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkxLjcxMiwxMTMuNTY3IEM5MS42OTIsMTEzLjU2NyA5MS42NzIsMTEzLjU2MSA5MS42NTMsMTEzLjU1MSBDOTEuNjE4LDExMy41MyA5MS41OTUsMTEzLjQ5MiA5MS41OTUsMTEzLjQ1IEw5MS41OTUsNjIuNTc5IEM5MS41OTUsNjIuNTM3IDkxLjYxOCw2Mi40OTkgOTEuNjUzLDYyLjQ3OCBMMTY3LjE3MiwxOC44NzggQzE2Ny4yMDgsMTguODU3IDE2Ny4yNTIsMTguODU3IDE2Ny4yODgsMTguODc4IEMxNjcuMzI0LDE4Ljg5OSAxNjcuMzQ3LDE4LjkzNyAxNjcuMzQ3LDE4Ljk3OSBMMTY3LjM0Nyw2OS44NSBDMTY3LjM0Nyw2OS44OTEgMTY3LjMyNCw2OS45MyAxNjcuMjg4LDY5Ljk1IEwxMzkuOTY3LDg1LjcyNSBDMTM5LjkzOSw4NS43NDEgMTM5LjkwNSw4NS43NDUgMTM5Ljg3Myw4NS43MzUgQzEzOS44NDIsODUuNzI1IDEzOS44MTYsODUuNzAyIDEzOS44MDIsODUuNjcyIEwxMzMuMzQyLDcxLjUwNCBDMTMyLjk2Nyw3MC42ODIgMTMyLjI4LDcwLjIyOSAxMzEuNDA4LDcwLjIyOSBDMTMwLjMxOSw3MC4yMjkgMTI5LjA0NCw3MC45MTUgMTI3LjkwOCw3Mi4xMSBDMTI2Ljg3NCw3My4yIDEyNi4wMzQsNzQuNjQ3IDEyNS42MDYsNzYuMDgyIEwxMTkuMTQ2LDk3LjcwOSBDMTE5LjEzNyw5Ny43MzggMTE5LjExOCw5Ny43NjIgMTE5LjA5Miw5Ny43NzcgTDkxLjc3LDExMy41NTEgQzkxLjc1MiwxMTMuNTYxIDkxLjczMiwxMTMuNTY3IDkxLjcxMiwxMTMuNTY3IEw5MS43MTIsMTEzLjU2NyBaIE05MS44MjksNjIuNjQ3IEw5MS44MjksMTEzLjI0OCBMMTE4LjkzNSw5Ny41OTggTDEyNS4zODIsNzYuMDE1IEMxMjUuODI3LDc0LjUyNSAxMjYuNjY0LDczLjA4MSAxMjcuNzM5LDcxLjk1IEMxMjguOTE5LDcwLjcwOCAxMzAuMjU2LDY5Ljk5NiAxMzEuNDA4LDY5Ljk5NiBDMTMyLjM3Nyw2OS45OTYgMTMzLjEzOSw3MC40OTcgMTMzLjU1NCw3MS40MDcgTDEzOS45NjEsODUuNDU4IEwxNjcuMTEzLDY5Ljc4MiBMMTY3LjExMywxOS4xODEgTDkxLjgyOSw2Mi42NDcgTDkxLjgyOSw2Mi42NDcgWiIgaWQ9IkZpbGwtMTQiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTY4LjU0MywxOS4yMTMgTDE2OC41NDMsNzAuMDgzIEwxNDEuMjIxLDg1Ljg1NyBMMTM0Ljc2MSw3MS42ODkgQzEzMy44NTEsNjkuNjk0IDEzMS4zMzMsNjkuOTUxIDEyOS4xMzcsNzIuMjYzIEMxMjguMDgyLDczLjM3NCAxMjcuMjQ0LDc0LjgxOSAxMjYuODA3LDc2LjI4MiBMMTIwLjM0Niw5Ny45MDkgTDkzLjAyNSwxMTMuNjgzIEw5My4wMjUsNjIuODEzIEwxNjguNTQzLDE5LjIxMyIgaWQ9IkZpbGwtMTUiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTMuMDI1LDExMy44IEM5My4wMDUsMTEzLjggOTIuOTg0LDExMy43OTUgOTIuOTY2LDExMy43ODUgQzkyLjkzMSwxMTMuNzY0IDkyLjkwOCwxMTMuNzI1IDkyLjkwOCwxMTMuNjg0IEw5Mi45MDgsNjIuODEzIEM5Mi45MDgsNjIuNzcxIDkyLjkzMSw2Mi43MzMgOTIuOTY2LDYyLjcxMiBMMTY4LjQ4NCwxOS4xMTIgQzE2OC41MiwxOS4wOSAxNjguNTY1LDE5LjA5IDE2OC42MDEsMTkuMTEyIEMxNjguNjM3LDE5LjEzMiAxNjguNjYsMTkuMTcxIDE2OC42NiwxOS4yMTIgTDE2OC42Niw3MC4wODMgQzE2OC42Niw3MC4xMjUgMTY4LjYzNyw3MC4xNjQgMTY4LjYwMSw3MC4xODQgTDE0MS4yOCw4NS45NTggQzE0MS4yNTEsODUuOTc1IDE0MS4yMTcsODUuOTc5IDE0MS4xODYsODUuOTY4IEMxNDEuMTU0LDg1Ljk1OCAxNDEuMTI5LDg1LjkzNiAxNDEuMTE1LDg1LjkwNiBMMTM0LjY1NSw3MS43MzggQzEzNC4yOCw3MC45MTUgMTMzLjU5Myw3MC40NjMgMTMyLjcyLDcwLjQ2MyBDMTMxLjYzMiw3MC40NjMgMTMwLjM1Nyw3MS4xNDggMTI5LjIyMSw3Mi4zNDQgQzEyOC4xODYsNzMuNDMzIDEyNy4zNDcsNzQuODgxIDEyNi45MTksNzYuMzE1IEwxMjAuNDU4LDk3Ljk0MyBDMTIwLjQ1LDk3Ljk3MiAxMjAuNDMxLDk3Ljk5NiAxMjAuNDA1LDk4LjAxIEw5My4wODMsMTEzLjc4NSBDOTMuMDY1LDExMy43OTUgOTMuMDQ1LDExMy44IDkzLjAyNSwxMTMuOCBMOTMuMDI1LDExMy44IFogTTkzLjE0Miw2Mi44ODEgTDkzLjE0MiwxMTMuNDgxIEwxMjAuMjQ4LDk3LjgzMiBMMTI2LjY5NSw3Ni4yNDggQzEyNy4xNCw3NC43NTggMTI3Ljk3Nyw3My4zMTUgMTI5LjA1Miw3Mi4xODMgQzEzMC4yMzEsNzAuOTQyIDEzMS41NjgsNzAuMjI5IDEzMi43Miw3MC4yMjkgQzEzMy42ODksNzAuMjI5IDEzNC40NTIsNzAuNzMxIDEzNC44NjcsNzEuNjQxIEwxNDEuMjc0LDg1LjY5MiBMMTY4LjQyNiw3MC4wMTYgTDE2OC40MjYsMTkuNDE1IEw5My4xNDIsNjIuODgxIEw5My4xNDIsNjIuODgxIFoiIGlkPSJGaWxsLTE2IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS44LDcwLjA4MyBMMTQyLjQ3OCw4NS44NTcgTDEzNi4wMTgsNzEuNjg5IEMxMzUuMTA4LDY5LjY5NCAxMzIuNTksNjkuOTUxIDEzMC4zOTMsNzIuMjYzIEMxMjkuMzM5LDczLjM3NCAxMjguNSw3NC44MTkgMTI4LjA2NCw3Ni4yODIgTDEyMS42MDMsOTcuOTA5IEw5NC4yODIsMTEzLjY4MyBMOTQuMjgyLDYyLjgxMyBMMTY5LjgsMTkuMjEzIEwxNjkuOCw3MC4wODMgWiIgaWQ9IkZpbGwtMTciIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTQuMjgyLDExMy45MTcgQzk0LjI0MSwxMTMuOTE3IDk0LjIwMSwxMTMuOTA3IDk0LjE2NSwxMTMuODg2IEM5NC4wOTMsMTEzLjg0NSA5NC4wNDgsMTEzLjc2NyA5NC4wNDgsMTEzLjY4NCBMOTQuMDQ4LDYyLjgxMyBDOTQuMDQ4LDYyLjczIDk0LjA5Myw2Mi42NTIgOTQuMTY1LDYyLjYxMSBMMTY5LjY4MywxOS4wMSBDMTY5Ljc1NSwxOC45NjkgMTY5Ljg0NCwxOC45NjkgMTY5LjkxNywxOS4wMSBDMTY5Ljk4OSwxOS4wNTIgMTcwLjAzMywxOS4xMjkgMTcwLjAzMywxOS4yMTIgTDE3MC4wMzMsNzAuMDgzIEMxNzAuMDMzLDcwLjE2NiAxNjkuOTg5LDcwLjI0NCAxNjkuOTE3LDcwLjI4NSBMMTQyLjU5NSw4Ni4wNiBDMTQyLjUzOCw4Ni4wOTIgMTQyLjQ2OSw4Ni4xIDE0Mi40MDcsODYuMDggQzE0Mi4zNDQsODYuMDYgMTQyLjI5Myw4Ni4wMTQgMTQyLjI2Niw4NS45NTQgTDEzNS44MDUsNzEuNzg2IEMxMzUuNDQ1LDcwLjk5NyAxMzQuODEzLDcwLjU4IDEzMy45NzcsNzAuNTggQzEzMi45MjEsNzAuNTggMTMxLjY3Niw3MS4yNTIgMTMwLjU2Miw3Mi40MjQgQzEyOS41NCw3My41MDEgMTI4LjcxMSw3NC45MzEgMTI4LjI4Nyw3Ni4zNDggTDEyMS44MjcsOTcuOTc2IEMxMjEuODEsOTguMDM0IDEyMS43NzEsOTguMDgyIDEyMS43Miw5OC4xMTIgTDk0LjM5OCwxMTMuODg2IEM5NC4zNjIsMTEzLjkwNyA5NC4zMjIsMTEzLjkxNyA5NC4yODIsMTEzLjkxNyBMOTQuMjgyLDExMy45MTcgWiBNOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDExMy4yNzkgTDEyMS40MDYsOTcuNzU0IEwxMjcuODQsNzYuMjE1IEMxMjguMjksNzQuNzA4IDEyOS4xMzcsNzMuMjQ3IDEzMC4yMjQsNzIuMTAzIEMxMzEuNDI1LDcwLjgzOCAxMzIuNzkzLDcwLjExMiAxMzMuOTc3LDcwLjExMiBDMTM0Ljk5NSw3MC4xMTIgMTM1Ljc5NSw3MC42MzggMTM2LjIzLDcxLjU5MiBMMTQyLjU4NCw4NS41MjYgTDE2OS41NjYsNjkuOTQ4IEwxNjkuNTY2LDE5LjYxNyBMOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDYyLjk0OCBaIiBpZD0iRmlsbC0xOCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMDkuODk0LDkyLjk0MyBMMTA5Ljg5NCw5Mi45NDMgQzEwOC4xMiw5Mi45NDMgMTA2LjY1Myw5Mi4yMTggMTA1LjY1LDkwLjgyMyBDMTA1LjU4Myw5MC43MzEgMTA1LjU5Myw5MC42MSAxMDUuNjczLDkwLjUyOSBDMTA1Ljc1Myw5MC40NDggMTA1Ljg4LDkwLjQ0IDEwNS45NzQsOTAuNTA2IEMxMDYuNzU0LDkxLjA1MyAxMDcuNjc5LDkxLjMzMyAxMDguNzI0LDkxLjMzMyBDMTEwLjA0Nyw5MS4zMzMgMTExLjQ3OCw5MC44OTQgMTEyLjk4LDkwLjAyNyBDMTE4LjI5MSw4Ni45NiAxMjIuNjExLDc5LjUwOSAxMjIuNjExLDczLjQxNiBDMTIyLjYxMSw3MS40ODkgMTIyLjE2OSw2OS44NTYgMTIxLjMzMyw2OC42OTIgQzEyMS4yNjYsNjguNiAxMjEuMjc2LDY4LjQ3MyAxMjEuMzU2LDY4LjM5MiBDMTIxLjQzNiw2OC4zMTEgMTIxLjU2Myw2OC4yOTkgMTIxLjY1Niw2OC4zNjUgQzEyMy4zMjcsNjkuNTM3IDEyNC4yNDcsNzEuNzQ2IDEyNC4yNDcsNzQuNTg0IEMxMjQuMjQ3LDgwLjgyNiAxMTkuODIxLDg4LjQ0NyAxMTQuMzgyLDkxLjU4NyBDMTEyLjgwOCw5Mi40OTUgMTExLjI5OCw5Mi45NDMgMTA5Ljg5NCw5Mi45NDMgTDEwOS44OTQsOTIuOTQzIFogTTEwNi45MjUsOTEuNDAxIEMxMDcuNzM4LDkyLjA1MiAxMDguNzQ1LDkyLjI3OCAxMDkuODkzLDkyLjI3OCBMMTA5Ljg5NCw5Mi4yNzggQzExMS4yMTUsOTIuMjc4IDExMi42NDcsOTEuOTUxIDExNC4xNDgsOTEuMDg0IEMxMTkuNDU5LDg4LjAxNyAxMjMuNzgsODAuNjIxIDEyMy43OCw3NC41MjggQzEyMy43OCw3Mi41NDkgMTIzLjMxNyw3MC45MjkgMTIyLjQ1NCw2OS43NjcgQzEyMi44NjUsNzAuODAyIDEyMy4wNzksNzIuMDQyIDEyMy4wNzksNzMuNDAyIEMxMjMuMDc5LDc5LjY0NSAxMTguNjUzLDg3LjI4NSAxMTMuMjE0LDkwLjQyNSBDMTExLjY0LDkxLjMzNCAxMTAuMTMsOTEuNzQyIDEwOC43MjQsOTEuNzQyIEMxMDguMDgzLDkxLjc0MiAxMDcuNDgxLDkxLjU5MyAxMDYuOTI1LDkxLjQwMSBMMTA2LjkyNSw5MS40MDEgWiIgaWQ9IkZpbGwtMTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjA5Nyw5MC4yMyBDMTE4LjQ4MSw4Ny4xMjIgMTIyLjg0NSw3OS41OTQgMTIyLjg0NSw3My40MTYgQzEyMi44NDUsNzEuMzY1IDEyMi4zNjIsNjkuNzI0IDEyMS41MjIsNjguNTU2IEMxMTkuNzM4LDY3LjMwNCAxMTcuMTQ4LDY3LjM2MiAxMTQuMjY1LDY5LjAyNiBDMTA4Ljg4MSw3Mi4xMzQgMTA0LjUxNyw3OS42NjIgMTA0LjUxNyw4NS44NCBDMTA0LjUxNyw4Ny44OTEgMTA1LDg5LjUzMiAxMDUuODQsOTAuNyBDMTA3LjYyNCw5MS45NTIgMTEwLjIxNCw5MS44OTQgMTEzLjA5Nyw5MC4yMyIgaWQ9IkZpbGwtMjAiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTA4LjcyNCw5MS42MTQgTDEwOC43MjQsOTEuNjE0IEMxMDcuNTgyLDkxLjYxNCAxMDYuNTY2LDkxLjQwMSAxMDUuNzA1LDkwLjc5NyBDMTA1LjY4NCw5MC43ODMgMTA1LjY2NSw5MC44MTEgMTA1LjY1LDkwLjc5IEMxMDQuNzU2LDg5LjU0NiAxMDQuMjgzLDg3Ljg0MiAxMDQuMjgzLDg1LjgxNyBDMTA0LjI4Myw3OS41NzUgMTA4LjcwOSw3MS45NTMgMTE0LjE0OCw2OC44MTIgQzExNS43MjIsNjcuOTA0IDExNy4yMzIsNjcuNDQ5IDExOC42MzgsNjcuNDQ5IEMxMTkuNzgsNjcuNDQ5IDEyMC43OTYsNjcuNzU4IDEyMS42NTYsNjguMzYyIEMxMjEuNjc4LDY4LjM3NyAxMjEuNjk3LDY4LjM5NyAxMjEuNzEyLDY4LjQxOCBDMTIyLjYwNiw2OS42NjIgMTIzLjA3OSw3MS4zOSAxMjMuMDc5LDczLjQxNSBDMTIzLjA3OSw3OS42NTggMTE4LjY1Myw4Ny4xOTggMTEzLjIxNCw5MC4zMzggQzExMS42NCw5MS4yNDcgMTEwLjEzLDkxLjYxNCAxMDguNzI0LDkxLjYxNCBMMTA4LjcyNCw5MS42MTQgWiBNMTA2LjAwNiw5MC41MDUgQzEwNi43OCw5MS4wMzcgMTA3LjY5NCw5MS4yODEgMTA4LjcyNCw5MS4yODEgQzExMC4wNDcsOTEuMjgxIDExMS40NzgsOTAuODY4IDExMi45OCw5MC4wMDEgQzExOC4yOTEsODYuOTM1IDEyMi42MTEsNzkuNDk2IDEyMi42MTEsNzMuNDAzIEMxMjIuNjExLDcxLjQ5NCAxMjIuMTc3LDY5Ljg4IDEyMS4zNTYsNjguNzE4IEMxMjAuNTgyLDY4LjE4NSAxMTkuNjY4LDY3LjkxOSAxMTguNjM4LDY3LjkxOSBDMTE3LjMxNSw2Ny45MTkgMTE1Ljg4Myw2OC4zNiAxMTQuMzgyLDY5LjIyNyBDMTA5LjA3MSw3Mi4yOTMgMTA0Ljc1MSw3OS43MzMgMTA0Ljc1MSw4NS44MjYgQzEwNC43NTEsODcuNzM1IDEwNS4xODUsODkuMzQzIDEwNi4wMDYsOTAuNTA1IEwxMDYuMDA2LDkwLjUwNSBaIiBpZD0iRmlsbC0yMSIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDkuMzE4LDcuMjYyIEwxMzkuMzM0LDE2LjE0IEwxNTUuMjI3LDI3LjE3MSBMMTYwLjgxNiwyMS4wNTkgTDE0OS4zMTgsNy4yNjIiIGlkPSJGaWxsLTIyIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS42NzYsMTMuODQgTDE1OS45MjgsMTkuNDY3IEMxNTYuMjg2LDIxLjU3IDE1MC40LDIxLjU4IDE0Ni43ODEsMTkuNDkxIEMxNDMuMTYxLDE3LjQwMiAxNDMuMTgsMTQuMDAzIDE0Ni44MjIsMTEuOSBMMTU2LjMxNyw2LjI5MiBMMTQ5LjU4OCwyLjQwNyBMNjcuNzUyLDQ5LjQ3OCBMMTEzLjY3NSw3NS45OTIgTDExNi43NTYsNzQuMjEzIEMxMTcuMzg3LDczLjg0OCAxMTcuNjI1LDczLjMxNSAxMTcuMzc0LDcyLjgyMyBDMTE1LjAxNyw2OC4xOTEgMTE0Ljc4MSw2My4yNzcgMTE2LjY5MSw1OC41NjEgQzEyMi4zMjksNDQuNjQxIDE0MS4yLDMzLjc0NiAxNjUuMzA5LDMwLjQ5MSBDMTczLjQ3OCwyOS4zODggMTgxLjk4OSwyOS41MjQgMTkwLjAxMywzMC44ODUgQzE5MC44NjUsMzEuMDMgMTkxLjc4OSwzMC44OTMgMTkyLjQyLDMwLjUyOCBMMTk1LjUwMSwyOC43NSBMMTY5LjY3NiwxMy44NCIgaWQ9IkZpbGwtMjMiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3Ni40NTkgQzExMy41OTQsNzYuNDU5IDExMy41MTQsNzYuNDM4IDExMy40NDIsNzYuMzk3IEw2Ny41MTgsNDkuODgyIEM2Ny4zNzQsNDkuNzk5IDY3LjI4NCw0OS42NDUgNjcuMjg1LDQ5LjQ3OCBDNjcuMjg1LDQ5LjMxMSA2Ny4zNzQsNDkuMTU3IDY3LjUxOSw0OS4wNzMgTDE0OS4zNTUsMi4wMDIgQzE0OS40OTksMS45MTkgMTQ5LjY3NywxLjkxOSAxNDkuODIxLDIuMDAyIEwxNTYuNTUsNS44ODcgQzE1Ni43NzQsNi4wMTcgMTU2Ljg1LDYuMzAyIDE1Ni43MjIsNi41MjYgQzE1Ni41OTIsNi43NDkgMTU2LjMwNyw2LjgyNiAxNTYuMDgzLDYuNjk2IEwxNDkuNTg3LDIuOTQ2IEw2OC42ODcsNDkuNDc5IEwxMTMuNjc1LDc1LjQ1MiBMMTE2LjUyMyw3My44MDggQzExNi43MTUsNzMuNjk3IDExNy4xNDMsNzMuMzk5IDExNi45NTgsNzMuMDM1IEMxMTQuNTQyLDY4LjI4NyAxMTQuMyw2My4yMjEgMTE2LjI1OCw1OC4zODUgQzExOS4wNjQsNTEuNDU4IDEyNS4xNDMsNDUuMTQzIDEzMy44NCw0MC4xMjIgQzE0Mi40OTcsMzUuMTI0IDE1My4zNTgsMzEuNjMzIDE2NS4yNDcsMzAuMDI4IEMxNzMuNDQ1LDI4LjkyMSAxODIuMDM3LDI5LjA1OCAxOTAuMDkxLDMwLjQyNSBDMTkwLjgzLDMwLjU1IDE5MS42NTIsMzAuNDMyIDE5Mi4xODYsMzAuMTI0IEwxOTQuNTY3LDI4Ljc1IEwxNjkuNDQyLDE0LjI0NCBDMTY5LjIxOSwxNC4xMTUgMTY5LjE0MiwxMy44MjkgMTY5LjI3MSwxMy42MDYgQzE2OS40LDEzLjM4MiAxNjkuNjg1LDEzLjMwNiAxNjkuOTA5LDEzLjQzNSBMMTk1LjczNCwyOC4zNDUgQzE5NS44NzksMjguNDI4IDE5NS45NjgsMjguNTgzIDE5NS45NjgsMjguNzUgQzE5NS45NjgsMjguOTE2IDE5NS44NzksMjkuMDcxIDE5NS43MzQsMjkuMTU0IEwxOTIuNjUzLDMwLjkzMyBDMTkxLjkzMiwzMS4zNSAxOTAuODksMzEuNTA4IDE4OS45MzUsMzEuMzQ2IEMxODEuOTcyLDI5Ljk5NSAxNzMuNDc4LDI5Ljg2IDE2NS4zNzIsMzAuOTU0IEMxNTMuNjAyLDMyLjU0MyAxNDIuODYsMzUuOTkzIDEzNC4zMDcsNDAuOTMxIEMxMjUuNzkzLDQ1Ljg0NyAxMTkuODUxLDUyLjAwNCAxMTcuMTI0LDU4LjczNiBDMTE1LjI3LDYzLjMxNCAxMTUuNTAxLDY4LjExMiAxMTcuNzksNzIuNjExIEMxMTguMTYsNzMuMzM2IDExNy44NDUsNzQuMTI0IDExNi45OSw3NC42MTcgTDExMy45MDksNzYuMzk3IEMxMTMuODM2LDc2LjQzOCAxMTMuNzU2LDc2LjQ1OSAxMTMuNjc1LDc2LjQ1OSIgaWQ9IkZpbGwtMjQiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUzLjMxNiwyMS4yNzkgQzE1MC45MDMsMjEuMjc5IDE0OC40OTUsMjAuNzUxIDE0Ni42NjQsMTkuNjkzIEMxNDQuODQ2LDE4LjY0NCAxNDMuODQ0LDE3LjIzMiAxNDMuODQ0LDE1LjcxOCBDMTQzLjg0NCwxNC4xOTEgMTQ0Ljg2LDEyLjc2MyAxNDYuNzA1LDExLjY5OCBMMTU2LjE5OCw2LjA5MSBDMTU2LjMwOSw2LjAyNSAxNTYuNDUyLDYuMDYyIDE1Ni41MTgsNi4xNzMgQzE1Ni41ODMsNi4yODQgMTU2LjU0Nyw2LjQyNyAxNTYuNDM2LDYuNDkzIEwxNDYuOTQsMTIuMTAyIEMxNDUuMjQ0LDEzLjA4MSAxNDQuMzEyLDE0LjM2NSAxNDQuMzEyLDE1LjcxOCBDMTQ0LjMxMiwxNy4wNTggMTQ1LjIzLDE4LjMyNiAxNDYuODk3LDE5LjI4OSBDMTUwLjQ0NiwyMS4zMzggMTU2LjI0LDIxLjMyNyAxNTkuODExLDE5LjI2NSBMMTY5LjU1OSwxMy42MzcgQzE2OS42NywxMy41NzMgMTY5LjgxMywxMy42MTEgMTY5Ljg3OCwxMy43MjMgQzE2OS45NDMsMTMuODM0IDE2OS45MDQsMTMuOTc3IDE2OS43OTMsMTQuMDQyIEwxNjAuMDQ1LDE5LjY3IEMxNTguMTg3LDIwLjc0MiAxNTUuNzQ5LDIxLjI3OSAxNTMuMzE2LDIxLjI3OSIgaWQ9IkZpbGwtMjUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3NS45OTIgTDY3Ljc2Miw0OS40ODQiIGlkPSJGaWxsLTI2IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMy42NzUsNzYuMzQyIEMxMTMuNjE1LDc2LjM0MiAxMTMuNTU1LDc2LjMyNyAxMTMuNSw3Ni4yOTUgTDY3LjU4Nyw0OS43ODcgQzY3LjQxOSw0OS42OSA2Ny4zNjIsNDkuNDc2IDY3LjQ1OSw0OS4zMDkgQzY3LjU1Niw0OS4xNDEgNjcuNzcsNDkuMDgzIDY3LjkzNyw0OS4xOCBMMTEzLjg1LDc1LjY4OCBDMTE0LjAxOCw3NS43ODUgMTE0LjA3NSw3NiAxMTMuOTc4LDc2LjE2NyBDMTEzLjkxNCw3Ni4yNzkgMTEzLjc5Niw3Ni4zNDIgMTEzLjY3NSw3Ni4zNDIiIGlkPSJGaWxsLTI3IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY3Ljc2Miw0OS40ODQgTDY3Ljc2MiwxMDMuNDg1IEM2Ny43NjIsMTA0LjU3NSA2OC41MzIsMTA1LjkwMyA2OS40ODIsMTA2LjQ1MiBMMTExLjk1NSwxMzAuOTczIEMxMTIuOTA1LDEzMS41MjIgMTEzLjY3NSwxMzEuMDgzIDExMy42NzUsMTI5Ljk5MyBMMTEzLjY3NSw3NS45OTIiIGlkPSJGaWxsLTI4IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMi43MjcsMTMxLjU2MSBDMTEyLjQzLDEzMS41NjEgMTEyLjEwNywxMzEuNDY2IDExMS43OCwxMzEuMjc2IEw2OS4zMDcsMTA2Ljc1NSBDNjguMjQ0LDEwNi4xNDIgNjcuNDEyLDEwNC43MDUgNjcuNDEyLDEwMy40ODUgTDY3LjQxMiw0OS40ODQgQzY3LjQxMiw0OS4yOSA2Ny41NjksNDkuMTM0IDY3Ljc2Miw0OS4xMzQgQzY3Ljk1Niw0OS4xMzQgNjguMTEzLDQ5LjI5IDY4LjExMyw0OS40ODQgTDY4LjExMywxMDMuNDg1IEM2OC4xMTMsMTA0LjQ0NSA2OC44MiwxMDUuNjY1IDY5LjY1NywxMDYuMTQ4IEwxMTIuMTMsMTMwLjY3IEMxMTIuNDc0LDEzMC44NjggMTEyLjc5MSwxMzAuOTEzIDExMywxMzAuNzkyIEMxMTMuMjA2LDEzMC42NzMgMTEzLjMyNSwxMzAuMzgxIDExMy4zMjUsMTI5Ljk5MyBMMTEzLjMyNSw3NS45OTIgQzExMy4zMjUsNzUuNzk4IDExMy40ODIsNzUuNjQxIDExMy42NzUsNzUuNjQxIEMxMTMuODY5LDc1LjY0MSAxMTQuMDI1LDc1Ljc5OCAxMTQuMDI1LDc1Ljk5MiBMMTE0LjAyNSwxMjkuOTkzIEMxMTQuMDI1LDEzMC42NDggMTEzLjc4NiwxMzEuMTQ3IDExMy4zNSwxMzEuMzk5IEMxMTMuMTYyLDEzMS41MDcgMTEyLjk1MiwxMzEuNTYxIDExMi43MjcsMTMxLjU2MSIgaWQ9IkZpbGwtMjkiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEyLjg2LDQwLjUxMiBDMTEyLjg2LDQwLjUxMiAxMTIuODYsNDAuNTEyIDExMi44NTksNDAuNTEyIEMxMTAuNTQxLDQwLjUxMiAxMDguMzYsMzkuOTkgMTA2LjcxNywzOS4wNDEgQzEwNS4wMTIsMzguMDU3IDEwNC4wNzQsMzYuNzI2IDEwNC4wNzQsMzUuMjkyIEMxMDQuMDc0LDMzLjg0NyAxMDUuMDI2LDMyLjUwMSAxMDYuNzU0LDMxLjUwNCBMMTE4Ljc5NSwyNC41NTEgQzEyMC40NjMsMjMuNTg5IDEyMi42NjksMjMuMDU4IDEyNS4wMDcsMjMuMDU4IEMxMjcuMzI1LDIzLjA1OCAxMjkuNTA2LDIzLjU4MSAxMzEuMTUsMjQuNTMgQzEzMi44NTQsMjUuNTE0IDEzMy43OTMsMjYuODQ1IDEzMy43OTMsMjguMjc4IEMxMzMuNzkzLDI5LjcyNCAxMzIuODQxLDMxLjA2OSAxMzEuMTEzLDMyLjA2NyBMMTE5LjA3MSwzOS4wMTkgQzExNy40MDMsMzkuOTgyIDExNS4xOTcsNDAuNTEyIDExMi44Niw0MC41MTIgTDExMi44Niw0MC41MTIgWiBNMTI1LjAwNywyMy43NTkgQzEyMi43OSwyMy43NTkgMTIwLjcwOSwyNC4yNTYgMTE5LjE0NiwyNS4xNTggTDEwNy4xMDQsMzIuMTEgQzEwNS42MDIsMzIuOTc4IDEwNC43NzQsMzQuMTA4IDEwNC43NzQsMzUuMjkyIEMxMDQuNzc0LDM2LjQ2NSAxMDUuNTg5LDM3LjU4MSAxMDcuMDY3LDM4LjQzNCBDMTA4LjYwNSwzOS4zMjMgMTEwLjY2MywzOS44MTIgMTEyLjg1OSwzOS44MTIgTDExMi44NiwzOS44MTIgQzExNS4wNzYsMzkuODEyIDExNy4xNTgsMzkuMzE1IDExOC43MjEsMzguNDEzIEwxMzAuNzYyLDMxLjQ2IEMxMzIuMjY0LDMwLjU5MyAxMzMuMDkyLDI5LjQ2MyAxMzMuMDkyLDI4LjI3OCBDMTMzLjA5MiwyNy4xMDYgMTMyLjI3OCwyNS45OSAxMzAuOCwyNS4xMzYgQzEyOS4yNjEsMjQuMjQ4IDEyNy4yMDQsMjMuNzU5IDEyNS4wMDcsMjMuNzU5IEwxMjUuMDA3LDIzLjc1OSBaIiBpZD0iRmlsbC0zMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjUuNjMsMTYuMjE5IEwxNTkuODk2LDE5LjUzIEMxNTYuNzI5LDIxLjM1OCAxNTEuNjEsMjEuMzY3IDE0OC40NjMsMTkuNTUgQzE0NS4zMTYsMTcuNzMzIDE0NS4zMzIsMTQuNzc4IDE0OC40OTksMTIuOTQ5IEwxNTQuMjMzLDkuNjM5IEwxNjUuNjMsMTYuMjE5IiBpZD0iRmlsbC0zMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNTQuMjMzLDEwLjQ0OCBMMTY0LjIyOCwxNi4yMTkgTDE1OS41NDYsMTguOTIzIEMxNTguMTEyLDE5Ljc1IDE1Ni4xOTQsMjAuMjA2IDE1NC4xNDcsMjAuMjA2IEMxNTIuMTE4LDIwLjIwNiAxNTAuMjI0LDE5Ljc1NyAxNDguODE0LDE4Ljk0MyBDMTQ3LjUyNCwxOC4xOTkgMTQ2LjgxNCwxNy4yNDkgMTQ2LjgxNCwxNi4yNjkgQzE0Ni44MTQsMTUuMjc4IDE0Ny41MzcsMTQuMzE0IDE0OC44NSwxMy41NTYgTDE1NC4yMzMsMTAuNDQ4IE0xNTQuMjMzLDkuNjM5IEwxNDguNDk5LDEyLjk0OSBDMTQ1LjMzMiwxNC43NzggMTQ1LjMxNiwxNy43MzMgMTQ4LjQ2MywxOS41NSBDMTUwLjAzMSwyMC40NTUgMTUyLjA4NiwyMC45MDcgMTU0LjE0NywyMC45MDcgQzE1Ni4yMjQsMjAuOTA3IDE1OC4zMDYsMjAuNDQ3IDE1OS44OTYsMTkuNTMgTDE2NS42MywxNi4yMTkgTDE1NC4yMzMsOS42MzkiIGlkPSJGaWxsLTMyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NS40NDUsNzIuNjY3IEwxNDUuNDQ1LDcyLjY2NyBDMTQzLjY3Miw3Mi42NjcgMTQyLjIwNCw3MS44MTcgMTQxLjIwMiw3MC40MjIgQzE0MS4xMzUsNzAuMzMgMTQxLjE0NSw3MC4xNDcgMTQxLjIyNSw3MC4wNjYgQzE0MS4zMDUsNjkuOTg1IDE0MS40MzIsNjkuOTQ2IDE0MS41MjUsNzAuMDExIEMxNDIuMzA2LDcwLjU1OSAxNDMuMjMxLDcwLjgyMyAxNDQuMjc2LDcwLjgyMiBDMTQ1LjU5OCw3MC44MjIgMTQ3LjAzLDcwLjM3NiAxNDguNTMyLDY5LjUwOSBDMTUzLjg0Miw2Ni40NDMgMTU4LjE2Myw1OC45ODcgMTU4LjE2Myw1Mi44OTQgQzE1OC4xNjMsNTAuOTY3IDE1Ny43MjEsNDkuMzMyIDE1Ni44ODQsNDguMTY4IEMxNTYuODE4LDQ4LjA3NiAxNTYuODI4LDQ3Ljk0OCAxNTYuOTA4LDQ3Ljg2NyBDMTU2Ljk4OCw0Ny43ODYgMTU3LjExNCw0Ny43NzQgMTU3LjIwOCw0Ny44NCBDMTU4Ljg3OCw0OS4wMTIgMTU5Ljc5OCw1MS4yMiAxNTkuNzk4LDU0LjA1OSBDMTU5Ljc5OCw2MC4zMDEgMTU1LjM3Myw2OC4wNDYgMTQ5LjkzMyw3MS4xODYgQzE0OC4zNiw3Mi4wOTQgMTQ2Ljg1LDcyLjY2NyAxNDUuNDQ1LDcyLjY2NyBMMTQ1LjQ0NSw3Mi42NjcgWiBNMTQyLjQ3Niw3MSBDMTQzLjI5LDcxLjY1MSAxNDQuMjk2LDcyLjAwMiAxNDUuNDQ1LDcyLjAwMiBDMTQ2Ljc2Nyw3Mi4wMDIgMTQ4LjE5OCw3MS41NSAxNDkuNyw3MC42ODIgQzE1NS4wMSw2Ny42MTcgMTU5LjMzMSw2MC4xNTkgMTU5LjMzMSw1NC4wNjUgQzE1OS4zMzEsNTIuMDg1IDE1OC44NjgsNTAuNDM1IDE1OC4wMDYsNDkuMjcyIEMxNTguNDE3LDUwLjMwNyAxNTguNjMsNTEuNTMyIDE1OC42Myw1Mi44OTIgQzE1OC42Myw1OS4xMzQgMTU0LjIwNSw2Ni43NjcgMTQ4Ljc2NSw2OS45MDcgQzE0Ny4xOTIsNzAuODE2IDE0NS42ODEsNzEuMjgzIDE0NC4yNzYsNzEuMjgzIEMxNDMuNjM0LDcxLjI4MyAxNDMuMDMzLDcxLjE5MiAxNDIuNDc2LDcxIEwxNDIuNDc2LDcxIFoiIGlkPSJGaWxsLTMzIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0OC42NDgsNjkuNzA0IEMxNTQuMDMyLDY2LjU5NiAxNTguMzk2LDU5LjA2OCAxNTguMzk2LDUyLjg5MSBDMTU4LjM5Niw1MC44MzkgMTU3LjkxMyw0OS4xOTggMTU3LjA3NCw0OC4wMyBDMTU1LjI4OSw0Ni43NzggMTUyLjY5OSw0Ni44MzYgMTQ5LjgxNiw0OC41MDEgQzE0NC40MzMsNTEuNjA5IDE0MC4wNjgsNTkuMTM3IDE0MC4wNjgsNjUuMzE0IEMxNDAuMDY4LDY3LjM2NSAxNDAuNTUyLDY5LjAwNiAxNDEuMzkxLDcwLjE3NCBDMTQzLjE3Niw3MS40MjcgMTQ1Ljc2NSw3MS4zNjkgMTQ4LjY0OCw2OS43MDQiIGlkPSJGaWxsLTM0IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NC4yNzYsNzEuMjc2IEwxNDQuMjc2LDcxLjI3NiBDMTQzLjEzMyw3MS4yNzYgMTQyLjExOCw3MC45NjkgMTQxLjI1Nyw3MC4zNjUgQzE0MS4yMzYsNzAuMzUxIDE0MS4yMTcsNzAuMzMyIDE0MS4yMDIsNzAuMzExIEMxNDAuMzA3LDY5LjA2NyAxMzkuODM1LDY3LjMzOSAxMzkuODM1LDY1LjMxNCBDMTM5LjgzNSw1OS4wNzMgMTQ0LjI2LDUxLjQzOSAxNDkuNyw0OC4yOTggQzE1MS4yNzMsNDcuMzkgMTUyLjc4NCw0Ni45MjkgMTU0LjE4OSw0Ni45MjkgQzE1NS4zMzIsNDYuOTI5IDE1Ni4zNDcsNDcuMjM2IDE1Ny4yMDgsNDcuODM5IEMxNTcuMjI5LDQ3Ljg1NCAxNTcuMjQ4LDQ3Ljg3MyAxNTcuMjYzLDQ3Ljg5NCBDMTU4LjE1Nyw0OS4xMzggMTU4LjYzLDUwLjg2NSAxNTguNjMsNTIuODkxIEMxNTguNjMsNTkuMTMyIDE1NC4yMDUsNjYuNzY2IDE0OC43NjUsNjkuOTA3IEMxNDcuMTkyLDcwLjgxNSAxNDUuNjgxLDcxLjI3NiAxNDQuMjc2LDcxLjI3NiBMMTQ0LjI3Niw3MS4yNzYgWiBNMTQxLjU1OCw3MC4xMDQgQzE0Mi4zMzEsNzAuNjM3IDE0My4yNDUsNzEuMDA1IDE0NC4yNzYsNzEuMDA1IEMxNDUuNTk4LDcxLjAwNSAxNDcuMDMsNzAuNDY3IDE0OC41MzIsNjkuNiBDMTUzLjg0Miw2Ni41MzQgMTU4LjE2Myw1OS4wMzMgMTU4LjE2Myw1Mi45MzkgQzE1OC4xNjMsNTEuMDMxIDE1Ny43MjksNDkuMzg1IDE1Ni45MDcsNDguMjIzIEMxNTYuMTMzLDQ3LjY5MSAxNTUuMjE5LDQ3LjQwOSAxNTQuMTg5LDQ3LjQwOSBDMTUyLjg2Nyw0Ny40MDkgMTUxLjQzNSw0Ny44NDIgMTQ5LjkzMyw0OC43MDkgQzE0NC42MjMsNTEuNzc1IDE0MC4zMDIsNTkuMjczIDE0MC4zMDIsNjUuMzY2IEMxNDAuMzAyLDY3LjI3NiAxNDAuNzM2LDY4Ljk0MiAxNDEuNTU4LDcwLjEwNCBMMTQxLjU1OCw3MC4xMDQgWiIgaWQ9IkZpbGwtMzUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUwLjcyLDY1LjM2MSBMMTUwLjM1Nyw2NS4wNjYgQzE1MS4xNDcsNjQuMDkyIDE1MS44NjksNjMuMDQgMTUyLjUwNSw2MS45MzggQzE1My4zMTMsNjAuNTM5IDE1My45NzgsNTkuMDY3IDE1NC40ODIsNTcuNTYzIEwxNTQuOTI1LDU3LjcxMiBDMTU0LjQxMiw1OS4yNDUgMTUzLjczMyw2MC43NDUgMTUyLjkxLDYyLjE3MiBDMTUyLjI2Miw2My4yOTUgMTUxLjUyNSw2NC4zNjggMTUwLjcyLDY1LjM2MSIgaWQ9IkZpbGwtMzYiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE1LjkxNyw4NC41MTQgTDExNS41NTQsODQuMjIgQzExNi4zNDQsODMuMjQ1IDExNy4wNjYsODIuMTk0IDExNy43MDIsODEuMDkyIEMxMTguNTEsNzkuNjkyIDExOS4xNzUsNzguMjIgMTE5LjY3OCw3Ni43MTcgTDEyMC4xMjEsNzYuODY1IEMxMTkuNjA4LDc4LjM5OCAxMTguOTMsNzkuODk5IDExOC4xMDYsODEuMzI2IEMxMTcuNDU4LDgyLjQ0OCAxMTYuNzIyLDgzLjUyMSAxMTUuOTE3LDg0LjUxNCIgaWQ9IkZpbGwtMzciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE0LDEzMC40NzYgTDExNCwxMzAuMDA4IEwxMTQsNzYuMDUyIEwxMTQsNzUuNTg0IEwxMTQsNzYuMDUyIEwxMTQsMTMwLjAwOCBMMTE0LDEzMC40NzYiIGlkPSJGaWxsLTM4IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyLjAwMDAwMCwgMC4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTkuODIyLDM3LjQ3NCBDMTkuODM5LDM3LjMzOSAxOS43NDcsMzcuMTk0IDE5LjU1NSwzNy4wODIgQzE5LjIyOCwzNi44OTQgMTguNzI5LDM2Ljg3MiAxOC40NDYsMzcuMDM3IEwxMi40MzQsNDAuNTA4IEMxMi4zMDMsNDAuNTg0IDEyLjI0LDQwLjY4NiAxMi4yNDMsNDAuNzkzIEMxMi4yNDUsNDAuOTI1IDEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQxLjM3MSBMMTIuMjQ1LDQxLjQxNCBMMTIuMjM4LDQxLjU0MiBDOC4xNDgsNDMuODg3IDUuNjQ3LDQ1LjMyMSA1LjY0Nyw0NS4zMjEgQzUuNjQ2LDQ1LjMyMSAzLjU3LDQ2LjM2NyAyLjg2LDUwLjUxMyBDMi44Niw1MC41MTMgMS45NDgsNTcuNDc0IDEuOTYyLDcwLjI1OCBDMS45NzcsODIuODI4IDIuNTY4LDg3LjMyOCAzLjEyOSw5MS42MDkgQzMuMzQ5LDkzLjI5MyA2LjEzLDkzLjczNCA2LjEzLDkzLjczNCBDNi40NjEsOTMuNzc0IDYuODI4LDkzLjcwNyA3LjIxLDkzLjQ4NiBMODIuNDgzLDQ5LjkzNSBDODQuMjkxLDQ4Ljg2NiA4NS4xNSw0Ni4yMTYgODUuNTM5LDQzLjY1MSBDODYuNzUyLDM1LjY2MSA4Ny4yMTQsMTAuNjczIDg1LjI2NCwzLjc3MyBDODUuMDY4LDMuMDggODQuNzU0LDIuNjkgODQuMzk2LDIuNDkxIEw4Mi4zMSwxLjcwMSBDODEuNTgzLDEuNzI5IDgwLjg5NCwyLjE2OCA4MC43NzYsMi4yMzYgQzgwLjYzNiwyLjMxNyA0MS44MDcsMjQuNTg1IDIwLjAzMiwzNy4wNzIgTDE5LjgyMiwzNy40NzQiIGlkPSJGaWxsLTEiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNODIuMzExLDEuNzAxIEw4NC4zOTYsMi40OTEgQzg0Ljc1NCwyLjY5IDg1LjA2OCwzLjA4IDg1LjI2NCwzLjc3MyBDODcuMjEzLDEwLjY3MyA4Ni43NTEsMzUuNjYgODUuNTM5LDQzLjY1MSBDODUuMTQ5LDQ2LjIxNiA4NC4yOSw0OC44NjYgODIuNDgzLDQ5LjkzNSBMNy4yMSw5My40ODYgQzYuODk3LDkzLjY2NyA2LjU5NSw5My43NDQgNi4zMTQsOTMuNzQ0IEw2LjEzMSw5My43MzMgQzYuMTMxLDkzLjczNCAzLjM0OSw5My4yOTMgMy4xMjgsOTEuNjA5IEMyLjU2OCw4Ny4zMjcgMS45NzcsODIuODI4IDEuOTYzLDcwLjI1OCBDMS45NDgsNTcuNDc0IDIuODYsNTAuNTEzIDIuODYsNTAuNTEzIEMzLjU3LDQ2LjM2NyA1LjY0Nyw0NS4zMjEgNS42NDcsNDUuMzIxIEM1LjY0Nyw0NS4zMjEgOC4xNDgsNDMuODg3IDEyLjIzOCw0MS41NDIgTDEyLjI0NSw0MS40MTQgTDEyLjI0NSw0MS4zNzEgQzEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQwLjkyNSAxMi4yNDMsNDAuNzkzIEMxMi4yNCw0MC42ODYgMTIuMzAyLDQwLjU4MyAxMi40MzQsNDAuNTA4IEwxOC40NDYsMzcuMDM2IEMxOC41NzQsMzYuOTYyIDE4Ljc0NiwzNi45MjYgMTguOTI3LDM2LjkyNiBDMTkuMTQ1LDM2LjkyNiAxOS4zNzYsMzYuOTc5IDE5LjU1NCwzNy4wODIgQzE5Ljc0NywzNy4xOTQgMTkuODM5LDM3LjM0IDE5LjgyMiwzNy40NzQgTDIwLjAzMywzNy4wNzIgQzQxLjgwNiwyNC41ODUgODAuNjM2LDIuMzE4IDgwLjc3NywyLjIzNiBDODAuODk0LDIuMTY4IDgxLjU4MywxLjcyOSA4Mi4zMTEsMS43MDEgTTgyLjMxMSwwLjcwNCBMODIuMjcyLDAuNzA1IEM4MS42NTQsMC43MjggODAuOTg5LDAuOTQ5IDgwLjI5OCwxLjM2MSBMODAuMjc3LDEuMzczIEM4MC4xMjksMS40NTggNTkuNzY4LDEzLjEzNSAxOS43NTgsMzYuMDc5IEMxOS41LDM1Ljk4MSAxOS4yMTQsMzUuOTI5IDE4LjkyNywzNS45MjkgQzE4LjU2MiwzNS45MjkgMTguMjIzLDM2LjAxMyAxNy45NDcsMzYuMTczIEwxMS45MzUsMzkuNjQ0IEMxMS40OTMsMzkuODk5IDExLjIzNiw0MC4zMzQgMTEuMjQ2LDQwLjgxIEwxMS4yNDcsNDAuOTYgTDUuMTY3LDQ0LjQ0NyBDNC43OTQsNDQuNjQ2IDIuNjI1LDQ1Ljk3OCAxLjg3Nyw1MC4zNDUgTDEuODcxLDUwLjM4NCBDMS44NjIsNTAuNDU0IDAuOTUxLDU3LjU1NyAwLjk2NSw3MC4yNTkgQzAuOTc5LDgyLjg3OSAxLjU2OCw4Ny4zNzUgMi4xMzcsOTEuNzI0IEwyLjEzOSw5MS43MzkgQzIuNDQ3LDk0LjA5NCA1LjYxNCw5NC42NjIgNS45NzUsOTQuNzE5IEw2LjAwOSw5NC43MjMgQzYuMTEsOTQuNzM2IDYuMjEzLDk0Ljc0MiA2LjMxNCw5NC43NDIgQzYuNzksOTQuNzQyIDcuMjYsOTQuNjEgNy43MSw5NC4zNSBMODIuOTgzLDUwLjc5OCBDODQuNzk0LDQ5LjcyNyA4NS45ODIsNDcuMzc1IDg2LjUyNSw0My44MDEgQzg3LjcxMSwzNS45ODcgODguMjU5LDEwLjcwNSA4Ni4yMjQsMy41MDIgQzg1Ljk3MSwyLjYwOSA4NS41MiwxLjk3NSA4NC44ODEsMS42MiBMODQuNzQ5LDEuNTU4IEw4Mi42NjQsMC43NjkgQzgyLjU1MSwwLjcyNSA4Mi40MzEsMC43MDQgODIuMzExLDAuNzA0IiBpZD0iRmlsbC0yIiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY2LjI2NywxMS41NjUgTDY3Ljc2MiwxMS45OTkgTDExLjQyMyw0NC4zMjUiIGlkPSJGaWxsLTMiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMjAyLDkwLjU0NSBDMTIuMDI5LDkwLjU0NSAxMS44NjIsOTAuNDU1IDExLjc2OSw5MC4yOTUgQzExLjYzMiw5MC4wNTcgMTEuNzEzLDg5Ljc1MiAxMS45NTIsODkuNjE0IEwzMC4zODksNzguOTY5IEMzMC42MjgsNzguODMxIDMwLjkzMyw3OC45MTMgMzEuMDcxLDc5LjE1MiBDMzEuMjA4LDc5LjM5IDMxLjEyNyw3OS42OTYgMzAuODg4LDc5LjgzMyBMMTIuNDUxLDkwLjQ3OCBMMTIuMjAyLDkwLjU0NSIgaWQ9IkZpbGwtNCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMy43NjQsNDIuNjU0IEwxMy42NTYsNDIuNTkyIEwxMy43MDIsNDIuNDIxIEwxOC44MzcsMzkuNDU3IEwxOS4wMDcsMzkuNTAyIEwxOC45NjIsMzkuNjczIEwxMy44MjcsNDIuNjM3IEwxMy43NjQsNDIuNjU0IiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTguNTIsOTAuMzc1IEw4LjUyLDQ2LjQyMSBMOC41ODMsNDYuMzg1IEw3NS44NCw3LjU1NCBMNzUuODQsNTEuNTA4IEw3NS43NzgsNTEuNTQ0IEw4LjUyLDkwLjM3NSBMOC41Miw5MC4zNzUgWiBNOC43Nyw0Ni41NjQgTDguNzcsODkuOTQ0IEw3NS41OTEsNTEuMzY1IEw3NS41OTEsNy45ODUgTDguNzcsNDYuNTY0IEw4Ljc3LDQ2LjU2NCBaIiBpZD0iRmlsbC02IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI0Ljk4Niw4My4xODIgQzI0Ljc1Niw4My4zMzEgMjQuMzc0LDgzLjU2NiAyNC4xMzcsODMuNzA1IEwxMi42MzIsOTAuNDA2IEMxMi4zOTUsOTAuNTQ1IDEyLjQyNiw5MC42NTggMTIuNyw5MC42NTggTDEzLjI2NSw5MC42NTggQzEzLjU0LDkwLjY1OCAxMy45NTgsOTAuNTQ1IDE0LjE5NSw5MC40MDYgTDI1LjcsODMuNzA1IEMyNS45MzcsODMuNTY2IDI2LjEyOCw4My40NTIgMjYuMTI1LDgzLjQ0OSBDMjYuMTIyLDgzLjQ0NyAyNi4xMTksODMuMjIgMjYuMTE5LDgyLjk0NiBDMjYuMTE5LDgyLjY3MiAyNS45MzEsODIuNTY5IDI1LjcwMSw4Mi43MTkgTDI0Ljk4Niw4My4xODIiIGlkPSJGaWxsLTciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuMjY2LDkwLjc4MiBMMTIuNyw5MC43ODIgQzEyLjUsOTAuNzgyIDEyLjM4NCw5MC43MjYgMTIuMzU0LDkwLjYxNiBDMTIuMzI0LDkwLjUwNiAxMi4zOTcsOTAuMzk5IDEyLjU2OSw5MC4yOTkgTDI0LjA3NCw4My41OTcgQzI0LjMxLDgzLjQ1OSAyNC42ODksODMuMjI2IDI0LjkxOCw4My4wNzggTDI1LjYzMyw4Mi42MTQgQzI1LjcyMyw4Mi41NTUgMjUuODEzLDgyLjUyNSAyNS44OTksODIuNTI1IEMyNi4wNzEsODIuNTI1IDI2LjI0NCw4Mi42NTUgMjYuMjQ0LDgyLjk0NiBDMjYuMjQ0LDgzLjE2IDI2LjI0NSw4My4zMDkgMjYuMjQ3LDgzLjM4MyBMMjYuMjUzLDgzLjM4NyBMMjYuMjQ5LDgzLjQ1NiBDMjYuMjQ2LDgzLjUzMSAyNi4yNDYsODMuNTMxIDI1Ljc2Myw4My44MTIgTDE0LjI1OCw5MC41MTQgQzE0LDkwLjY2NSAxMy41NjQsOTAuNzgyIDEzLjI2Niw5MC43ODIgTDEzLjI2Niw5MC43ODIgWiBNMTIuNjY2LDkwLjUzMiBMMTIuNyw5MC41MzMgTDEzLjI2Niw5MC41MzMgQzEzLjUxOCw5MC41MzMgMTMuOTE1LDkwLjQyNSAxNC4xMzIsOTAuMjk5IEwyNS42MzcsODMuNTk3IEMyNS44MDUsODMuNDk5IDI1LjkzMSw4My40MjQgMjUuOTk4LDgzLjM4MyBDMjUuOTk0LDgzLjI5OSAyNS45OTQsODMuMTY1IDI1Ljk5NCw4Mi45NDYgTDI1Ljg5OSw4Mi43NzUgTDI1Ljc2OCw4Mi44MjQgTDI1LjA1NCw4My4yODcgQzI0LjgyMiw4My40MzcgMjQuNDM4LDgzLjY3MyAyNC4yLDgzLjgxMiBMMTIuNjk1LDkwLjUxNCBMMTIuNjY2LDkwLjUzMiBMMTIuNjY2LDkwLjUzMiBaIiBpZD0iRmlsbC04IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjI2Niw4OS44NzEgTDEyLjcsODkuODcxIEMxMi41LDg5Ljg3MSAxMi4zODQsODkuODE1IDEyLjM1NCw4OS43MDUgQzEyLjMyNCw4OS41OTUgMTIuMzk3LDg5LjQ4OCAxMi41NjksODkuMzg4IEwyNC4wNzQsODIuNjg2IEMyNC4zMzIsODIuNTM1IDI0Ljc2OCw4Mi40MTggMjUuMDY3LDgyLjQxOCBMMjUuNjMyLDgyLjQxOCBDMjUuODMyLDgyLjQxOCAyNS45NDgsODIuNDc0IDI1Ljk3OCw4Mi41ODQgQzI2LjAwOCw4Mi42OTQgMjUuOTM1LDgyLjgwMSAyNS43NjMsODIuOTAxIEwxNC4yNTgsODkuNjAzIEMxNCw4OS43NTQgMTMuNTY0LDg5Ljg3MSAxMy4yNjYsODkuODcxIEwxMy4yNjYsODkuODcxIFogTTEyLjY2Niw4OS42MjEgTDEyLjcsODkuNjIyIEwxMy4yNjYsODkuNjIyIEMxMy41MTgsODkuNjIyIDEzLjkxNSw4OS41MTUgMTQuMTMyLDg5LjM4OCBMMjUuNjM3LDgyLjY4NiBMMjUuNjY3LDgyLjY2OCBMMjUuNjMyLDgyLjY2NyBMMjUuMDY3LDgyLjY2NyBDMjQuODE1LDgyLjY2NyAyNC40MTgsODIuNzc1IDI0LjIsODIuOTAxIEwxMi42OTUsODkuNjAzIEwxMi42NjYsODkuNjIxIEwxMi42NjYsODkuNjIxIFoiIGlkPSJGaWxsLTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzcsOTAuODAxIEwxMi4zNyw4OS41NTQgTDEyLjM3LDkwLjgwMSIgaWQ9IkZpbGwtMTAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4xMyw5My45MDEgQzUuMzc5LDkzLjgwOCA0LjgxNiw5My4xNjQgNC42OTEsOTIuNTI1IEMzLjg2LDg4LjI4NyAzLjU0LDgzLjc0MyAzLjUyNiw3MS4xNzMgQzMuNTExLDU4LjM4OSA0LjQyMyw1MS40MjggNC40MjMsNTEuNDI4IEM1LjEzNCw0Ny4yODIgNy4yMSw0Ni4yMzYgNy4yMSw0Ni4yMzYgQzcuMjEsNDYuMjM2IDgxLjY2NywzLjI1IDgyLjA2OSwzLjAxNyBDODIuMjkyLDIuODg4IDg0LjU1NiwxLjQzMyA4NS4yNjQsMy45NCBDODcuMjE0LDEwLjg0IDg2Ljc1MiwzNS44MjcgODUuNTM5LDQzLjgxOCBDODUuMTUsNDYuMzgzIDg0LjI5MSw0OS4wMzMgODIuNDgzLDUwLjEwMSBMNy4yMSw5My42NTMgQzYuODI4LDkzLjg3NCA2LjQ2MSw5My45NDEgNi4xMyw5My45MDEgQzYuMTMsOTMuOTAxIDMuMzQ5LDkzLjQ2IDMuMTI5LDkxLjc3NiBDMi41NjgsODcuNDk1IDEuOTc3LDgyLjk5NSAxLjk2Miw3MC40MjUgQzEuOTQ4LDU3LjY0MSAyLjg2LDUwLjY4IDIuODYsNTAuNjggQzMuNTcsNDYuNTM0IDUuNjQ3LDQ1LjQ4OSA1LjY0Nyw0NS40ODkgQzUuNjQ2LDQ1LjQ4OSA4LjA2NSw0NC4wOTIgMTIuMjQ1LDQxLjY3OSBMMTMuMTE2LDQxLjU2IEwxOS43MTUsMzcuNzMgTDE5Ljc2MSwzNy4yNjkgTDYuMTMsOTMuOTAxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjMxNyw5NC4xNjEgTDYuMTAyLDk0LjE0OCBMNi4xMDEsOTQuMTQ4IEw1Ljg1Nyw5NC4xMDEgQzUuMTM4LDkzLjk0NSAzLjA4NSw5My4zNjUgMi44ODEsOTEuODA5IEMyLjMxMyw4Ny40NjkgMS43MjcsODIuOTk2IDEuNzEzLDcwLjQyNSBDMS42OTksNTcuNzcxIDIuNjA0LDUwLjcxOCAyLjYxMyw1MC42NDggQzMuMzM4LDQ2LjQxNyA1LjQ0NSw0NS4zMSA1LjUzNSw0NS4yNjYgTDEyLjE2Myw0MS40MzkgTDEzLjAzMyw0MS4zMiBMMTkuNDc5LDM3LjU3OCBMMTkuNTEzLDM3LjI0NCBDMTkuNTI2LDM3LjEwNyAxOS42NDcsMzcuMDA4IDE5Ljc4NiwzNy4wMjEgQzE5LjkyMiwzNy4wMzQgMjAuMDIzLDM3LjE1NiAyMC4wMDksMzcuMjkzIEwxOS45NSwzNy44ODIgTDEzLjE5OCw0MS44MDEgTDEyLjMyOCw0MS45MTkgTDUuNzcyLDQ1LjcwNCBDNS43NDEsNDUuNzIgMy43ODIsNDYuNzcyIDMuMTA2LDUwLjcyMiBDMy4wOTksNTAuNzgyIDIuMTk4LDU3LjgwOCAyLjIxMiw3MC40MjQgQzIuMjI2LDgyLjk2MyAyLjgwOSw4Ny40MiAzLjM3Myw5MS43MjkgQzMuNDY0LDkyLjQyIDQuMDYyLDkyLjg4MyA0LjY4Miw5My4xODEgQzQuNTY2LDkyLjk4NCA0LjQ4Niw5Mi43NzYgNC40NDYsOTIuNTcyIEMzLjY2NSw4OC41ODggMy4yOTEsODQuMzcgMy4yNzYsNzEuMTczIEMzLjI2Miw1OC41MiA0LjE2Nyw1MS40NjYgNC4xNzYsNTEuMzk2IEM0LjkwMSw0Ny4xNjUgNy4wMDgsNDYuMDU5IDcuMDk4LDQ2LjAxNCBDNy4wOTQsNDYuMDE1IDgxLjU0MiwzLjAzNCA4MS45NDQsMi44MDIgTDgxLjk3MiwyLjc4NSBDODIuODc2LDIuMjQ3IDgzLjY5MiwyLjA5NyA4NC4zMzIsMi4zNTIgQzg0Ljg4NywyLjU3MyA4NS4yODEsMy4wODUgODUuNTA0LDMuODcyIEM4Ny41MTgsMTEgODYuOTY0LDM2LjA5MSA4NS43ODUsNDMuODU1IEM4NS4yNzgsNDcuMTk2IDg0LjIxLDQ5LjM3IDgyLjYxLDUwLjMxNyBMNy4zMzUsOTMuODY5IEM2Ljk5OSw5NC4wNjMgNi42NTgsOTQuMTYxIDYuMzE3LDk0LjE2MSBMNi4zMTcsOTQuMTYxIFogTTYuMTcsOTMuNjU0IEM2LjQ2Myw5My42OSA2Ljc3NCw5My42MTcgNy4wODUsOTMuNDM3IEw4Mi4zNTgsNDkuODg2IEM4NC4xODEsNDguODA4IDg0Ljk2LDQ1Ljk3MSA4NS4yOTIsNDMuNzggQzg2LjQ2NiwzNi4wNDkgODcuMDIzLDExLjA4NSA4NS4wMjQsNC4wMDggQzg0Ljg0NiwzLjM3NyA4NC41NTEsMi45NzYgODQuMTQ4LDIuODE2IEM4My42NjQsMi42MjMgODIuOTgyLDIuNzY0IDgyLjIyNywzLjIxMyBMODIuMTkzLDMuMjM0IEM4MS43OTEsMy40NjYgNy4zMzUsNDYuNDUyIDcuMzM1LDQ2LjQ1MiBDNy4zMDQsNDYuNDY5IDUuMzQ2LDQ3LjUyMSA0LjY2OSw1MS40NzEgQzQuNjYyLDUxLjUzIDMuNzYxLDU4LjU1NiAzLjc3NSw3MS4xNzMgQzMuNzksODQuMzI4IDQuMTYxLDg4LjUyNCA0LjkzNiw5Mi40NzYgQzUuMDI2LDkyLjkzNyA1LjQxMiw5My40NTkgNS45NzMsOTMuNjE1IEM2LjA4Nyw5My42NCA2LjE1OCw5My42NTIgNi4xNjksOTMuNjU0IEw2LjE3LDkzLjY1NCBMNi4xNyw5My42NTQgWiIgaWQ9IkZpbGwtMTIiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4zMTcsNjguOTgyIEM3LjgwNiw2OC43MDEgOC4yMDIsNjguOTI2IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNi44MjksNzEuMjk0IDYuNDMzLDcxLjA2OSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIiBpZD0iRmlsbC0xMyIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjkyLDcxLjEzMyBDNi42MzEsNzEuMTMzIDYuNDMzLDcwLjkwNSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIEM3LjQ2LDY4LjkgNy41OTUsNjguODYxIDcuNzE0LDY4Ljg2MSBDOC4wMDMsNjguODYxIDguMjAyLDY5LjA5IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNy4xNzQsNzEuMDk0IDcuMDM5LDcxLjEzMyA2LjkyLDcxLjEzMyBNNy43MTQsNjguNjc0IEM3LjU1Nyw2OC42NzQgNy4zOTIsNjguNzIzIDcuMjI0LDY4LjgyMSBDNi42NzYsNjkuMTM4IDYuMjQ2LDY5Ljg3OSA2LjI0Niw3MC41MDggQzYuMjQ2LDcwLjk5NCA2LjUxNyw3MS4zMiA2LjkyLDcxLjMyIEM3LjA3OCw3MS4zMiA3LjI0Myw3MS4yNzEgNy40MTEsNzEuMTc0IEM3Ljk1OSw3MC44NTcgOC4zODksNzAuMTE3IDguMzg5LDY5LjQ4NyBDOC4zODksNjkuMDAxIDguMTE3LDY4LjY3NCA3LjcxNCw2OC42NzQiIGlkPSJGaWxsLTE0IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYuOTIsNzAuOTQ3IEM2LjY0OSw3MC45NDcgNi42MjEsNzAuNjQgNi42MjEsNzAuNTA4IEM2LjYyMSw3MC4wMTcgNi45ODIsNjkuMzkyIDcuNDExLDY5LjE0NSBDNy41MjEsNjkuMDgyIDcuNjI1LDY5LjA0OSA3LjcxNCw2OS4wNDkgQzcuOTg2LDY5LjA0OSA4LjAxNSw2OS4zNTUgOC4wMTUsNjkuNDg3IEM4LjAxNSw2OS45NzggNy42NTIsNzAuNjAzIDcuMjI0LDcwLjg1MSBDNy4xMTUsNzAuOTE0IDcuMDEsNzAuOTQ3IDYuOTIsNzAuOTQ3IE03LjcxNCw2OC44NjEgQzcuNTk1LDY4Ljg2MSA3LjQ2LDY4LjkgNy4zMTcsNjguOTgyIEM2LjgyOSw2OS4yNjUgNi40MzMsNjkuOTQ4IDYuNDMzLDcwLjUwOCBDNi40MzMsNzAuOTA1IDYuNjMxLDcxLjEzMyA2LjkyLDcxLjEzMyBDNy4wMzksNzEuMTMzIDcuMTc0LDcxLjA5NCA3LjMxNyw3MS4wMTIgQzcuODA2LDcwLjczIDguMjAyLDcwLjA0NyA4LjIwMiw2OS40ODcgQzguMjAyLDY5LjA5IDguMDAzLDY4Ljg2MSA3LjcxNCw2OC44NjEiIGlkPSJGaWxsLTE1IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuNDQ0LDg1LjM1IEM3LjcwOCw4NS4xOTggNy45MjEsODUuMzE5IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuOTI1IDcuNzA4LDg2LjI5MiA3LjQ0NCw4Ni40NDQgQzcuMTgxLDg2LjU5NyA2Ljk2Nyw4Ni40NzUgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IiBpZD0iRmlsbC0xNiIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik03LjIzLDg2LjUxIEM3LjA3NCw4Ni41MSA2Ljk2Nyw4Ni4zODcgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IEM3LjUyMSw4NS4zMDUgNy41OTQsODUuMjg0IDcuNjU4LDg1LjI4NCBDNy44MTQsODUuMjg0IDcuOTIxLDg1LjQwOCA3LjkyMSw4NS42MjIgQzcuOTIxLDg1LjkyNSA3LjcwOCw4Ni4yOTIgNy40NDQsODYuNDQ0IEM3LjM2Nyw4Ni40ODkgNy4yOTQsODYuNTEgNy4yMyw4Ni41MSBNNy42NTgsODUuMDk4IEM3LjU1OCw4NS4wOTggNy40NTUsODUuMTI3IDcuMzUxLDg1LjE4OCBDNy4wMzEsODUuMzczIDYuNzgxLDg1LjgwNiA2Ljc4MSw4Ni4xNzMgQzYuNzgxLDg2LjQ4MiA2Ljk2Niw4Ni42OTcgNy4yMyw4Ni42OTcgQzcuMzMsODYuNjk3IDcuNDMzLDg2LjY2NiA3LjUzOCw4Ni42MDcgQzcuODU4LDg2LjQyMiA4LjEwOCw4NS45ODkgOC4xMDgsODUuNjIyIEM4LjEwOCw4NS4zMTMgNy45MjMsODUuMDk4IDcuNjU4LDg1LjA5OCIgaWQ9IkZpbGwtMTciIGZpbGw9IiM4MDk3QTIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4yMyw4Ni4zMjIgTDcuMTU0LDg2LjE3MyBDNy4xNTQsODUuOTM4IDcuMzMzLDg1LjYyOSA3LjUzOCw4NS41MTIgTDcuNjU4LDg1LjQ3MSBMNy43MzQsODUuNjIyIEM3LjczNCw4NS44NTYgNy41NTUsODYuMTY0IDcuMzUxLDg2LjI4MiBMNy4yMyw4Ni4zMjIgTTcuNjU4LDg1LjI4NCBDNy41OTQsODUuMjg0IDcuNTIxLDg1LjMwNSA3LjQ0NCw4NS4zNSBDNy4xODEsODUuNTAyIDYuOTY3LDg1Ljg3MSA2Ljk2Nyw4Ni4xNzMgQzYuOTY3LDg2LjM4NyA3LjA3NCw4Ni41MSA3LjIzLDg2LjUxIEM3LjI5NCw4Ni41MSA3LjM2Nyw4Ni40ODkgNy40NDQsODYuNDQ0IEM3LjcwOCw4Ni4yOTIgNy45MjEsODUuOTI1IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuNDA4IDcuODE0LDg1LjI4NCA3LjY1OCw4NS4yODQiIGlkPSJGaWxsLTE4IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTc3LjI3OCw3Ljc2OSBMNzcuMjc4LDUxLjQzNiBMMTAuMjA4LDkwLjE2IEwxMC4yMDgsNDYuNDkzIEw3Ny4yNzgsNy43NjkiIGlkPSJGaWxsLTE5IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjA4Myw5MC4zNzUgTDEwLjA4Myw0Ni40MjEgTDEwLjE0Niw0Ni4zODUgTDc3LjQwMyw3LjU1NCBMNzcuNDAzLDUxLjUwOCBMNzcuMzQxLDUxLjU0NCBMMTAuMDgzLDkwLjM3NSBMMTAuMDgzLDkwLjM3NSBaIE0xMC4zMzMsNDYuNTY0IEwxMC4zMzMsODkuOTQ0IEw3Ny4xNTQsNTEuMzY1IEw3Ny4xNTQsNy45ODUgTDEwLjMzMyw0Ni41NjQgTDEwLjMzMyw0Ni41NjQgWiIgaWQ9IkZpbGwtMjAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMjUuNzM3LDg4LjY0NyBMMTE4LjA5OCw5MS45ODEgTDExOC4wOTgsODQgTDEwNi42MzksODguNzEzIEwxMDYuNjM5LDk2Ljk4MiBMOTksMTAwLjMxNSBMMTEyLjM2OSwxMDMuOTYxIEwxMjUuNzM3LDg4LjY0NyIgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTIiIGZpbGw9IiM0NTVBNjQiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';
	function RotateInstructions() {
	  this.loadIcon_();
	  var overlay = document.createElement('div');
	  var s = overlay.style;
	  s.position = 'fixed';
	  s.top = 0;
	  s.right = 0;
	  s.bottom = 0;
	  s.left = 0;
	  s.backgroundColor = 'gray';
	  s.fontFamily = 'sans-serif';
	  s.zIndex = 1000000;
	  var img = document.createElement('img');
	  img.src = this.icon;
	  var s = img.style;
	  s.marginLeft = '25%';
	  s.marginTop = '25%';
	  s.width = '50%';
	  overlay.appendChild(img);
	  var text = document.createElement('div');
	  var s = text.style;
	  s.textAlign = 'center';
	  s.fontSize = '16px';
	  s.lineHeight = '24px';
	  s.margin = '24px 25%';
	  s.width = '50%';
	  text.innerHTML = 'Place your phone into your Cardboard viewer.';
	  overlay.appendChild(text);
	  var snackbar = document.createElement('div');
	  var s = snackbar.style;
	  s.backgroundColor = '#CFD8DC';
	  s.position = 'fixed';
	  s.bottom = 0;
	  s.width = '100%';
	  s.height = '48px';
	  s.padding = '14px 24px';
	  s.boxSizing = 'border-box';
	  s.color = '#656A6B';
	  overlay.appendChild(snackbar);
	  var snackbarText = document.createElement('div');
	  snackbarText.style.float = 'left';
	  snackbarText.innerHTML = 'No Cardboard viewer?';
	  var snackbarButton = document.createElement('a');
	  snackbarButton.href = 'https://www.google.com/get/cardboard/get-cardboard/';
	  snackbarButton.innerHTML = 'get one';
	  snackbarButton.target = '_blank';
	  var s = snackbarButton.style;
	  s.float = 'right';
	  s.fontWeight = 600;
	  s.textTransform = 'uppercase';
	  s.borderLeft = '1px solid gray';
	  s.paddingLeft = '24px';
	  s.textDecoration = 'none';
	  s.color = '#656A6B';
	  snackbar.appendChild(snackbarText);
	  snackbar.appendChild(snackbarButton);
	  this.overlay = overlay;
	  this.text = text;
	  this.hide();
	}
	RotateInstructions.prototype.show = function (parent) {
	  if (!parent && !this.overlay.parentElement) {
	    document.body.appendChild(this.overlay);
	  } else if (parent) {
	    if (this.overlay.parentElement && this.overlay.parentElement != parent) this.overlay.parentElement.removeChild(this.overlay);
	    parent.appendChild(this.overlay);
	  }
	  this.overlay.style.display = 'block';
	  var img = this.overlay.querySelector('img');
	  var s = img.style;
	  if (isLandscapeMode()) {
	    s.width = '20%';
	    s.marginLeft = '40%';
	    s.marginTop = '3%';
	  } else {
	    s.width = '50%';
	    s.marginLeft = '25%';
	    s.marginTop = '25%';
	  }
	};
	RotateInstructions.prototype.hide = function () {
	  this.overlay.style.display = 'none';
	};
	RotateInstructions.prototype.showTemporarily = function (ms, parent) {
	  this.show(parent);
	  this.timer = setTimeout(this.hide.bind(this), ms);
	};
	RotateInstructions.prototype.disableShowTemporarily = function () {
	  clearTimeout(this.timer);
	};
	RotateInstructions.prototype.update = function () {
	  this.disableShowTemporarily();
	  if (!isLandscapeMode() && isMobile()) {
	    this.show();
	  } else {
	    this.hide();
	  }
	};
	RotateInstructions.prototype.loadIcon_ = function () {
	  this.icon = base64('image/svg+xml', rotateInstructionsAsset);
	};
	var DEFAULT_VIEWER = 'CardboardV1';
	var VIEWER_KEY = 'WEBVR_CARDBOARD_VIEWER';
	var CLASS_NAME = 'webvr-polyfill-viewer-selector';
	function ViewerSelector(defaultViewer) {
	  try {
	    this.selectedKey = localStorage.getItem(VIEWER_KEY);
	  } catch (error) {
	    console.error('Failed to load viewer profile: %s', error);
	  }
	  if (!this.selectedKey) {
	    this.selectedKey = defaultViewer || DEFAULT_VIEWER;
	  }
	  this.dialog = this.createDialog_(DeviceInfo.Viewers);
	  this.root = null;
	  this.onChangeCallbacks_ = [];
	}
	ViewerSelector.prototype.show = function (root) {
	  this.root = root;
	  root.appendChild(this.dialog);
	  var selected = this.dialog.querySelector('#' + this.selectedKey);
	  selected.checked = true;
	  this.dialog.style.display = 'block';
	};
	ViewerSelector.prototype.hide = function () {
	  if (this.root && this.root.contains(this.dialog)) {
	    this.root.removeChild(this.dialog);
	  }
	  this.dialog.style.display = 'none';
	};
	ViewerSelector.prototype.getCurrentViewer = function () {
	  return DeviceInfo.Viewers[this.selectedKey];
	};
	ViewerSelector.prototype.getSelectedKey_ = function () {
	  var input = this.dialog.querySelector('input[name=field]:checked');
	  if (input) {
	    return input.id;
	  }
	  return null;
	};
	ViewerSelector.prototype.onChange = function (cb) {
	  this.onChangeCallbacks_.push(cb);
	};
	ViewerSelector.prototype.fireOnChange_ = function (viewer) {
	  for (var i = 0; i < this.onChangeCallbacks_.length; i++) {
	    this.onChangeCallbacks_[i](viewer);
	  }
	};
	ViewerSelector.prototype.onSave_ = function () {
	  this.selectedKey = this.getSelectedKey_();
	  if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
	    console.error('ViewerSelector.onSave_: this should never happen!');
	    return;
	  }
	  this.fireOnChange_(DeviceInfo.Viewers[this.selectedKey]);
	  try {
	    localStorage.setItem(VIEWER_KEY, this.selectedKey);
	  } catch (error) {
	    console.error('Failed to save viewer profile: %s', error);
	  }
	  this.hide();
	};
	ViewerSelector.prototype.createDialog_ = function (options) {
	  var container = document.createElement('div');
	  container.classList.add(CLASS_NAME);
	  container.style.display = 'none';
	  var overlay = document.createElement('div');
	  var s = overlay.style;
	  s.position = 'fixed';
	  s.left = 0;
	  s.top = 0;
	  s.width = '100%';
	  s.height = '100%';
	  s.background = 'rgba(0, 0, 0, 0.3)';
	  overlay.addEventListener('click', this.hide.bind(this));
	  var width = 280;
	  var dialog = document.createElement('div');
	  var s = dialog.style;
	  s.boxSizing = 'border-box';
	  s.position = 'fixed';
	  s.top = '24px';
	  s.left = '50%';
	  s.marginLeft = -width / 2 + 'px';
	  s.width = width + 'px';
	  s.padding = '24px';
	  s.overflow = 'hidden';
	  s.background = '#fafafa';
	  s.fontFamily = "'Roboto', sans-serif";
	  s.boxShadow = '0px 5px 20px #666';
	  dialog.appendChild(this.createH1_('Select your viewer'));
	  for (var id in options) {
	    dialog.appendChild(this.createChoice_(id, options[id].label));
	  }
	  dialog.appendChild(this.createButton_('Save', this.onSave_.bind(this)));
	  container.appendChild(overlay);
	  container.appendChild(dialog);
	  return container;
	};
	ViewerSelector.prototype.createH1_ = function (name) {
	  var h1 = document.createElement('h1');
	  var s = h1.style;
	  s.color = 'black';
	  s.fontSize = '20px';
	  s.fontWeight = 'bold';
	  s.marginTop = 0;
	  s.marginBottom = '24px';
	  h1.innerHTML = name;
	  return h1;
	};
	ViewerSelector.prototype.createChoice_ = function (id, name) {
	  var div = document.createElement('div');
	  div.style.marginTop = '8px';
	  div.style.color = 'black';
	  var input = document.createElement('input');
	  input.style.fontSize = '30px';
	  input.setAttribute('id', id);
	  input.setAttribute('type', 'radio');
	  input.setAttribute('value', id);
	  input.setAttribute('name', 'field');
	  var label = document.createElement('label');
	  label.style.marginLeft = '4px';
	  label.setAttribute('for', id);
	  label.innerHTML = name;
	  div.appendChild(input);
	  div.appendChild(label);
	  return div;
	};
	ViewerSelector.prototype.createButton_ = function (label, onclick) {
	  var button = document.createElement('button');
	  button.innerHTML = label;
	  var s = button.style;
	  s.float = 'right';
	  s.textTransform = 'uppercase';
	  s.color = '#1094f7';
	  s.fontSize = '14px';
	  s.letterSpacing = 0;
	  s.border = 0;
	  s.background = 'none';
	  s.marginTop = '16px';
	  button.addEventListener('click', onclick);
	  return button;
	};
	var commonjsGlobal$$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal$$1 !== 'undefined' ? commonjsGlobal$$1 : typeof self !== 'undefined' ? self : {};
	function unwrapExports$$1 (x) {
		return x && x.__esModule ? x['default'] : x;
	}
	function createCommonjsModule$$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}
	var NoSleep = createCommonjsModule$$1(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
		module.exports = factory();
	})(commonjsGlobal$$1, function() {
	return          (function(modules) {
	         	var installedModules = {};
	         	function __webpack_require__(moduleId) {
	         		if(installedModules[moduleId]) {
	         			return installedModules[moduleId].exports;
	         		}
	         		var module = installedModules[moduleId] = {
	         			i: moduleId,
	         			l: false,
	         			exports: {}
	         		};
	         		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	         		module.l = true;
	         		return module.exports;
	         	}
	         	__webpack_require__.m = modules;
	         	__webpack_require__.c = installedModules;
	         	__webpack_require__.d = function(exports, name, getter) {
	         		if(!__webpack_require__.o(exports, name)) {
	         			Object.defineProperty(exports, name, {
	         				configurable: false,
	         				enumerable: true,
	         				get: getter
	         			});
	         		}
	         	};
	         	__webpack_require__.n = function(module) {
	         		var getter = module && module.__esModule ?
	         			function getDefault() { return module['default']; } :
	         			function getModuleExports() { return module; };
	         		__webpack_require__.d(getter, 'a', getter);
	         		return getter;
	         	};
	         	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	         	__webpack_require__.p = "";
	         	return __webpack_require__(__webpack_require__.s = 0);
	         })
	         ([
	      (function(module, exports, __webpack_require__) {
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	var mediaFile = __webpack_require__(1);
	var oldIOS = typeof navigator !== 'undefined' && parseFloat(('' + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ''])[1]).replace('undefined', '3_2').replace('_', '.').replace('_', '')) < 10 && !window.MSStream;
	var NoSleep = function () {
	  function NoSleep() {
	    _classCallCheck(this, NoSleep);
	    if (oldIOS) {
	      this.noSleepTimer = null;
	    } else {
	      this.noSleepVideo = document.createElement('video');
	      this.noSleepVideo.setAttribute('playsinline', '');
	      this.noSleepVideo.setAttribute('src', mediaFile);
	      this.noSleepVideo.addEventListener('timeupdate', function (e) {
	        if (this.noSleepVideo.currentTime > 0.5) {
	          this.noSleepVideo.currentTime = Math.random();
	        }
	      }.bind(this));
	    }
	  }
	  _createClass(NoSleep, [{
	    key: 'enable',
	    value: function enable() {
	      if (oldIOS) {
	        this.disable();
	        this.noSleepTimer = window.setInterval(function () {
	          window.location.href = '/';
	          window.setTimeout(window.stop, 0);
	        }, 15000);
	      } else {
	        this.noSleepVideo.play();
	      }
	    }
	  }, {
	    key: 'disable',
	    value: function disable() {
	      if (oldIOS) {
	        if (this.noSleepTimer) {
	          window.clearInterval(this.noSleepTimer);
	          this.noSleepTimer = null;
	        }
	      } else {
	        this.noSleepVideo.pause();
	      }
	    }
	  }]);
	  return NoSleep;
	}();
	module.exports = NoSleep;
	      }),
	      (function(module, exports, __webpack_require__) {
	module.exports = 'data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=';
	      })
	         ]);
	});
	});
	var NoSleep$1 = unwrapExports$$1(NoSleep);
	var nextDisplayId = 1000;
	var defaultLeftBounds = [0, 0, 0.5, 1];
	var defaultRightBounds = [0.5, 0, 0.5, 1];
	var raf = window.requestAnimationFrame;
	var caf = window.cancelAnimationFrame;
	function VRFrameData() {
	  this.leftProjectionMatrix = new Float32Array(16);
	  this.leftViewMatrix = new Float32Array(16);
	  this.rightProjectionMatrix = new Float32Array(16);
	  this.rightViewMatrix = new Float32Array(16);
	  this.pose = null;
	}
	function VRDisplayCapabilities(config) {
	  Object.defineProperties(this, {
	    hasPosition: {
	      writable: false, enumerable: true, value: config.hasPosition
	    },
	    hasExternalDisplay: {
	      writable: false, enumerable: true, value: config.hasExternalDisplay
	    },
	    canPresent: {
	      writable: false, enumerable: true, value: config.canPresent
	    },
	    maxLayers: {
	      writable: false, enumerable: true, value: config.maxLayers
	    },
	    hasOrientation: {
	      enumerable: true, get: function get() {
	        deprecateWarning('VRDisplayCapabilities.prototype.hasOrientation', 'VRDisplay.prototype.getFrameData');
	        return config.hasOrientation;
	      }
	    }
	  });
	}
	function VRDisplay(config) {
	  config = config || {};
	  var USE_WAKELOCK = 'wakelock' in config ? config.wakelock : true;
	  this.isPolyfilled = true;
	  this.displayId = nextDisplayId++;
	  this.displayName = '';
	  this.depthNear = 0.01;
	  this.depthFar = 10000.0;
	  this.isPresenting = false;
	  Object.defineProperty(this, 'isConnected', {
	    get: function get() {
	      deprecateWarning('VRDisplay.prototype.isConnected', 'VRDisplayCapabilities.prototype.hasExternalDisplay');
	      return false;
	    }
	  });
	  this.capabilities = new VRDisplayCapabilities({
	    hasPosition: false,
	    hasOrientation: false,
	    hasExternalDisplay: false,
	    canPresent: false,
	    maxLayers: 1
	  });
	  this.stageParameters = null;
	  this.waitingForPresent_ = false;
	  this.layer_ = null;
	  this.originalParent_ = null;
	  this.fullscreenElement_ = null;
	  this.fullscreenWrapper_ = null;
	  this.fullscreenElementCachedStyle_ = null;
	  this.fullscreenEventTarget_ = null;
	  this.fullscreenChangeHandler_ = null;
	  this.fullscreenErrorHandler_ = null;
	  if (USE_WAKELOCK && isMobile()) {
	    this.wakelock_ = new NoSleep$1();
	  }
	}
	VRDisplay.prototype.getFrameData = function (frameData) {
	  return frameDataFromPose(frameData, this._getPose(), this);
	};
	VRDisplay.prototype.getPose = function () {
	  deprecateWarning('VRDisplay.prototype.getPose', 'VRDisplay.prototype.getFrameData');
	  return this._getPose();
	};
	VRDisplay.prototype.resetPose = function () {
	  deprecateWarning('VRDisplay.prototype.resetPose');
	  return this._resetPose();
	};
	VRDisplay.prototype.getImmediatePose = function () {
	  deprecateWarning('VRDisplay.prototype.getImmediatePose', 'VRDisplay.prototype.getFrameData');
	  return this._getPose();
	};
	VRDisplay.prototype.requestAnimationFrame = function (callback) {
	  return raf(callback);
	};
	VRDisplay.prototype.cancelAnimationFrame = function (id) {
	  return caf(id);
	};
	VRDisplay.prototype.wrapForFullscreen = function (element) {
	  if (isIOS()) {
	    return element;
	  }
	  if (!this.fullscreenWrapper_) {
	    this.fullscreenWrapper_ = document.createElement('div');
	    var cssProperties = ['height: ' + Math.min(screen.height, screen.width) + 'px !important', 'top: 0 !important', 'left: 0 !important', 'right: 0 !important', 'border: 0', 'margin: 0', 'padding: 0', 'z-index: 999999 !important', 'position: fixed'];
	    this.fullscreenWrapper_.setAttribute('style', cssProperties.join('; ') + ';');
	    this.fullscreenWrapper_.classList.add('webvr-polyfill-fullscreen-wrapper');
	  }
	  if (this.fullscreenElement_ == element) {
	    return this.fullscreenWrapper_;
	  }
	  if (this.fullscreenElement_) {
	    if (this.originalParent_) {
	      this.originalParent_.appendChild(this.fullscreenElement_);
	    } else {
	      this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_);
	    }
	  }
	  this.fullscreenElement_ = element;
	  this.originalParent_ = element.parentElement;
	  if (!this.originalParent_) {
	    document.body.appendChild(element);
	  }
	  if (!this.fullscreenWrapper_.parentElement) {
	    var parent = this.fullscreenElement_.parentElement;
	    parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
	    parent.removeChild(this.fullscreenElement_);
	  }
	  this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
	  this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute('style');
	  var self = this;
	  function applyFullscreenElementStyle() {
	    if (!self.fullscreenElement_) {
	      return;
	    }
	    var cssProperties = ['position: absolute', 'top: 0', 'left: 0', 'width: ' + Math.max(screen.width, screen.height) + 'px', 'height: ' + Math.min(screen.height, screen.width) + 'px', 'border: 0', 'margin: 0', 'padding: 0'];
	    self.fullscreenElement_.setAttribute('style', cssProperties.join('; ') + ';');
	  }
	  applyFullscreenElementStyle();
	  return this.fullscreenWrapper_;
	};
	VRDisplay.prototype.removeFullscreenWrapper = function () {
	  if (!this.fullscreenElement_) {
	    return;
	  }
	  var element = this.fullscreenElement_;
	  if (this.fullscreenElementCachedStyle_) {
	    element.setAttribute('style', this.fullscreenElementCachedStyle_);
	  } else {
	    element.removeAttribute('style');
	  }
	  this.fullscreenElement_ = null;
	  this.fullscreenElementCachedStyle_ = null;
	  var parent = this.fullscreenWrapper_.parentElement;
	  this.fullscreenWrapper_.removeChild(element);
	  if (this.originalParent_ === parent) {
	    parent.insertBefore(element, this.fullscreenWrapper_);
	  }
	  else if (this.originalParent_) {
	      this.originalParent_.appendChild(element);
	    }
	  parent.removeChild(this.fullscreenWrapper_);
	  return element;
	};
	VRDisplay.prototype.requestPresent = function (layers) {
	  var wasPresenting = this.isPresenting;
	  var self = this;
	  if (!(layers instanceof Array)) {
	    deprecateWarning('VRDisplay.prototype.requestPresent with non-array argument', 'an array of VRLayers as the first argument');
	    layers = [layers];
	  }
	  return new Promise(function (resolve, reject) {
	    if (!self.capabilities.canPresent) {
	      reject(new Error('VRDisplay is not capable of presenting.'));
	      return;
	    }
	    if (layers.length == 0 || layers.length > self.capabilities.maxLayers) {
	      reject(new Error('Invalid number of layers.'));
	      return;
	    }
	    var incomingLayer = layers[0];
	    if (!incomingLayer.source) {
	      resolve();
	      return;
	    }
	    var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
	    var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
	    if (wasPresenting) {
	      var layer = self.layer_;
	      if (layer.source !== incomingLayer.source) {
	        layer.source = incomingLayer.source;
	      }
	      for (var i = 0; i < 4; i++) {
	        layer.leftBounds[i] = leftBounds[i];
	        layer.rightBounds[i] = rightBounds[i];
	      }
	      self.wrapForFullscreen(self.layer_.source);
	      self.updatePresent_();
	      resolve();
	      return;
	    }
	    self.layer_ = {
	      predistorted: incomingLayer.predistorted,
	      source: incomingLayer.source,
	      leftBounds: leftBounds.slice(0),
	      rightBounds: rightBounds.slice(0)
	    };
	    self.waitingForPresent_ = false;
	    if (self.layer_ && self.layer_.source) {
	      var fullscreenElement = self.wrapForFullscreen(self.layer_.source);
	      var onFullscreenChange = function onFullscreenChange() {
	        var actualFullscreenElement = getFullscreenElement();
	        self.isPresenting = fullscreenElement === actualFullscreenElement;
	        if (self.isPresenting) {
	          if (screen.orientation && screen.orientation.lock) {
	            screen.orientation.lock('landscape-primary').catch(function (error) {
	              console.error('screen.orientation.lock() failed due to', error.message);
	            });
	          }
	          self.waitingForPresent_ = false;
	          self.beginPresent_();
	          resolve();
	        } else {
	          if (screen.orientation && screen.orientation.unlock) {
	            screen.orientation.unlock();
	          }
	          self.removeFullscreenWrapper();
	          self.disableWakeLock();
	          self.endPresent_();
	          self.removeFullscreenListeners_();
	        }
	        self.fireVRDisplayPresentChange_();
	      };
	      var onFullscreenError = function onFullscreenError() {
	        if (!self.waitingForPresent_) {
	          return;
	        }
	        self.removeFullscreenWrapper();
	        self.removeFullscreenListeners_();
	        self.disableWakeLock();
	        self.waitingForPresent_ = false;
	        self.isPresenting = false;
	        reject(new Error('Unable to present.'));
	      };
	      self.addFullscreenListeners_(fullscreenElement, onFullscreenChange, onFullscreenError);
	      if (requestFullscreen(fullscreenElement)) {
	        self.enableWakeLock();
	        self.waitingForPresent_ = true;
	      } else if (isIOS() || isWebViewAndroid()) {
	        self.enableWakeLock();
	        self.isPresenting = true;
	        self.beginPresent_();
	        self.fireVRDisplayPresentChange_();
	        resolve();
	      }
	    }
	    if (!self.waitingForPresent_ && !isIOS()) {
	      exitFullscreen();
	      reject(new Error('Unable to present.'));
	    }
	  });
	};
	VRDisplay.prototype.exitPresent = function () {
	  var wasPresenting = this.isPresenting;
	  var self = this;
	  this.isPresenting = false;
	  this.layer_ = null;
	  this.disableWakeLock();
	  return new Promise(function (resolve, reject) {
	    if (wasPresenting) {
	      if (!exitFullscreen() && isIOS()) {
	        self.endPresent_();
	        self.fireVRDisplayPresentChange_();
	      }
	      if (isWebViewAndroid()) {
	        self.removeFullscreenWrapper();
	        self.removeFullscreenListeners_();
	        self.endPresent_();
	        self.fireVRDisplayPresentChange_();
	      }
	      resolve();
	    } else {
	      reject(new Error('Was not presenting to VRDisplay.'));
	    }
	  });
	};
	VRDisplay.prototype.getLayers = function () {
	  if (this.layer_) {
	    return [this.layer_];
	  }
	  return [];
	};
	VRDisplay.prototype.fireVRDisplayPresentChange_ = function () {
	  var event = new CustomEvent('vrdisplaypresentchange', { detail: { display: this } });
	  window.dispatchEvent(event);
	};
	VRDisplay.prototype.fireVRDisplayConnect_ = function () {
	  var event = new CustomEvent('vrdisplayconnect', { detail: { display: this } });
	  window.dispatchEvent(event);
	};
	VRDisplay.prototype.addFullscreenListeners_ = function (element, changeHandler, errorHandler) {
	  this.removeFullscreenListeners_();
	  this.fullscreenEventTarget_ = element;
	  this.fullscreenChangeHandler_ = changeHandler;
	  this.fullscreenErrorHandler_ = errorHandler;
	  if (changeHandler) {
	    if (document.fullscreenEnabled) {
	      element.addEventListener('fullscreenchange', changeHandler, false);
	    } else if (document.webkitFullscreenEnabled) {
	      element.addEventListener('webkitfullscreenchange', changeHandler, false);
	    } else if (document.mozFullScreenEnabled) {
	      document.addEventListener('mozfullscreenchange', changeHandler, false);
	    } else if (document.msFullscreenEnabled) {
	      element.addEventListener('msfullscreenchange', changeHandler, false);
	    }
	  }
	  if (errorHandler) {
	    if (document.fullscreenEnabled) {
	      element.addEventListener('fullscreenerror', errorHandler, false);
	    } else if (document.webkitFullscreenEnabled) {
	      element.addEventListener('webkitfullscreenerror', errorHandler, false);
	    } else if (document.mozFullScreenEnabled) {
	      document.addEventListener('mozfullscreenerror', errorHandler, false);
	    } else if (document.msFullscreenEnabled) {
	      element.addEventListener('msfullscreenerror', errorHandler, false);
	    }
	  }
	};
	VRDisplay.prototype.removeFullscreenListeners_ = function () {
	  if (!this.fullscreenEventTarget_) return;
	  var element = this.fullscreenEventTarget_;
	  if (this.fullscreenChangeHandler_) {
	    var changeHandler = this.fullscreenChangeHandler_;
	    element.removeEventListener('fullscreenchange', changeHandler, false);
	    element.removeEventListener('webkitfullscreenchange', changeHandler, false);
	    document.removeEventListener('mozfullscreenchange', changeHandler, false);
	    element.removeEventListener('msfullscreenchange', changeHandler, false);
	  }
	  if (this.fullscreenErrorHandler_) {
	    var errorHandler = this.fullscreenErrorHandler_;
	    element.removeEventListener('fullscreenerror', errorHandler, false);
	    element.removeEventListener('webkitfullscreenerror', errorHandler, false);
	    document.removeEventListener('mozfullscreenerror', errorHandler, false);
	    element.removeEventListener('msfullscreenerror', errorHandler, false);
	  }
	  this.fullscreenEventTarget_ = null;
	  this.fullscreenChangeHandler_ = null;
	  this.fullscreenErrorHandler_ = null;
	};
	VRDisplay.prototype.enableWakeLock = function () {
	  if (this.wakelock_) {
	    this.wakelock_.enable();
	  }
	};
	VRDisplay.prototype.disableWakeLock = function () {
	  if (this.wakelock_) {
	    this.wakelock_.disable();
	  }
	};
	VRDisplay.prototype.beginPresent_ = function () {
	};
	VRDisplay.prototype.endPresent_ = function () {
	};
	VRDisplay.prototype.submitFrame = function (pose) {
	};
	VRDisplay.prototype.getEyeParameters = function (whichEye) {
	  return null;
	};
	var config = {
	  ADDITIONAL_VIEWERS: [],
	  DEFAULT_VIEWER: '',
	  MOBILE_WAKE_LOCK: true,
	  DEBUG: false,
	  DPDB_URL: 'https://dpdb.webvr.rocks/dpdb.json',
	  K_FILTER: 0.98,
	  PREDICTION_TIME_S: 0.040,
	  CARDBOARD_UI_DISABLED: false,
	  ROTATE_INSTRUCTIONS_DISABLED: false,
	  YAW_ONLY: false,
	  BUFFER_SCALE: 0.5,
	  DIRTY_SUBMIT_FRAME_BINDINGS: false
	};
	var Eye = {
	  LEFT: 'left',
	  RIGHT: 'right'
	};
	function CardboardVRDisplay(config$$1) {
	  var defaults = extend({}, config);
	  config$$1 = extend(defaults, config$$1 || {});
	  VRDisplay.call(this, {
	    wakelock: config$$1.MOBILE_WAKE_LOCK
	  });
	  this.config = config$$1;
	  this.displayName = 'Cardboard VRDisplay';
	  this.capabilities = new VRDisplayCapabilities({
	    hasPosition: false,
	    hasOrientation: true,
	    hasExternalDisplay: false,
	    canPresent: true,
	    maxLayers: 1
	  });
	  this.stageParameters = null;
	  this.bufferScale_ = this.config.BUFFER_SCALE;
	  this.poseSensor_ = new PoseSensor(this.config);
	  this.distorter_ = null;
	  this.cardboardUI_ = null;
	  this.dpdb_ = new Dpdb(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this));
	  this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams(), config$$1.ADDITIONAL_VIEWERS);
	  this.viewerSelector_ = new ViewerSelector(config$$1.DEFAULT_VIEWER);
	  this.viewerSelector_.onChange(this.onViewerChanged_.bind(this));
	  this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());
	  if (!this.config.ROTATE_INSTRUCTIONS_DISABLED) {
	    this.rotateInstructions_ = new RotateInstructions();
	  }
	  if (isIOS()) {
	    window.addEventListener('resize', this.onResize_.bind(this));
	  }
	}
	CardboardVRDisplay.prototype = Object.create(VRDisplay.prototype);
	CardboardVRDisplay.prototype._getPose = function () {
	  return {
	    position: null,
	    orientation: this.poseSensor_.getOrientation(),
	    linearVelocity: null,
	    linearAcceleration: null,
	    angularVelocity: null,
	    angularAcceleration: null
	  };
	};
	CardboardVRDisplay.prototype._resetPose = function () {
	  if (this.poseSensor_.resetPose) {
	    this.poseSensor_.resetPose();
	  }
	};
	CardboardVRDisplay.prototype._getFieldOfView = function (whichEye) {
	  var fieldOfView;
	  if (whichEye == Eye.LEFT) {
	    fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
	  } else if (whichEye == Eye.RIGHT) {
	    fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
	  } else {
	    console.error('Invalid eye provided: %s', whichEye);
	    return null;
	  }
	  return fieldOfView;
	};
	CardboardVRDisplay.prototype._getEyeOffset = function (whichEye) {
	  var offset;
	  if (whichEye == Eye.LEFT) {
	    offset = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
	  } else if (whichEye == Eye.RIGHT) {
	    offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
	  } else {
	    console.error('Invalid eye provided: %s', whichEye);
	    return null;
	  }
	  return offset;
	};
	CardboardVRDisplay.prototype.getEyeParameters = function (whichEye) {
	  var offset = this._getEyeOffset(whichEye);
	  var fieldOfView = this._getFieldOfView(whichEye);
	  var eyeParams = {
	    offset: offset,
	    renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
	    renderHeight: this.deviceInfo_.device.height * this.bufferScale_
	  };
	  Object.defineProperty(eyeParams, 'fieldOfView', {
	    enumerable: true,
	    get: function get() {
	      deprecateWarning('VRFieldOfView', 'VRFrameData\'s projection matrices');
	      return fieldOfView;
	    }
	  });
	  return eyeParams;
	};
	CardboardVRDisplay.prototype.onDeviceParamsUpdated_ = function (newParams) {
	  if (this.config.DEBUG) {
	    console.log('DPDB reported that device params were updated.');
	  }
	  this.deviceInfo_.updateDeviceParams(newParams);
	  if (this.distorter_) {
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	  }
	};
	CardboardVRDisplay.prototype.updateBounds_ = function () {
	  if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
	    this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
	  }
	};
	CardboardVRDisplay.prototype.beginPresent_ = function () {
	  var gl = this.layer_.source.getContext('webgl');
	  if (!gl) gl = this.layer_.source.getContext('experimental-webgl');
	  if (!gl) gl = this.layer_.source.getContext('webgl2');
	  if (!gl) return;
	  if (this.layer_.predistorted) {
	    if (!this.config.CARDBOARD_UI_DISABLED) {
	      gl.canvas.width = getScreenWidth() * this.bufferScale_;
	      gl.canvas.height = getScreenHeight() * this.bufferScale_;
	      this.cardboardUI_ = new CardboardUI(gl);
	    }
	  } else {
	    if (!this.config.CARDBOARD_UI_DISABLED) {
	      this.cardboardUI_ = new CardboardUI(gl);
	    }
	    this.distorter_ = new CardboardDistorter(gl, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS);
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	  }
	  if (this.cardboardUI_) {
	    this.cardboardUI_.listen(function (e) {
	      this.viewerSelector_.show(this.layer_.source.parentElement);
	      e.stopPropagation();
	      e.preventDefault();
	    }.bind(this), function (e) {
	      this.exitPresent();
	      e.stopPropagation();
	      e.preventDefault();
	    }.bind(this));
	  }
	  if (this.rotateInstructions_) {
	    if (isLandscapeMode() && isMobile()) {
	      this.rotateInstructions_.showTemporarily(3000, this.layer_.source.parentElement);
	    } else {
	      this.rotateInstructions_.update();
	    }
	  }
	  this.orientationHandler = this.onOrientationChange_.bind(this);
	  window.addEventListener('orientationchange', this.orientationHandler);
	  this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
	  window.addEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
	  this.fireVRDisplayDeviceParamsChange_();
	};
	CardboardVRDisplay.prototype.endPresent_ = function () {
	  if (this.distorter_) {
	    this.distorter_.destroy();
	    this.distorter_ = null;
	  }
	  if (this.cardboardUI_) {
	    this.cardboardUI_.destroy();
	    this.cardboardUI_ = null;
	  }
	  if (this.rotateInstructions_) {
	    this.rotateInstructions_.hide();
	  }
	  this.viewerSelector_.hide();
	  window.removeEventListener('orientationchange', this.orientationHandler);
	  window.removeEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
	};
	CardboardVRDisplay.prototype.updatePresent_ = function () {
	  this.endPresent_();
	  this.beginPresent_();
	};
	CardboardVRDisplay.prototype.submitFrame = function (pose) {
	  if (this.distorter_) {
	    this.updateBounds_();
	    this.distorter_.submitFrame();
	  } else if (this.cardboardUI_ && this.layer_) {
	    var canvas = this.layer_.source.getContext('webgl').canvas;
	    if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
	      this.cardboardUI_.onResize();
	    }
	    this.lastWidth = canvas.width;
	    this.lastHeight = canvas.height;
	    this.cardboardUI_.render();
	  }
	};
	CardboardVRDisplay.prototype.onOrientationChange_ = function (e) {
	  this.viewerSelector_.hide();
	  if (this.rotateInstructions_) {
	    this.rotateInstructions_.update();
	  }
	  this.onResize_();
	};
	CardboardVRDisplay.prototype.onResize_ = function (e) {
	  if (this.layer_) {
	    var gl = this.layer_.source.getContext('webgl');
	    var cssProperties = ['position: absolute', 'top: 0', 'left: 0',
	    'width: 100vw', 'height: 100vh', 'border: 0', 'margin: 0',
	    'padding: 0px', 'box-sizing: content-box'];
	    gl.canvas.setAttribute('style', cssProperties.join('; ') + ';');
	    safariCssSizeWorkaround(gl.canvas);
	  }
	};
	CardboardVRDisplay.prototype.onViewerChanged_ = function (viewer) {
	  this.deviceInfo_.setViewer(viewer);
	  if (this.distorter_) {
	    this.distorter_.updateDeviceInfo(this.deviceInfo_);
	  }
	  this.fireVRDisplayDeviceParamsChange_();
	};
	CardboardVRDisplay.prototype.fireVRDisplayDeviceParamsChange_ = function () {
	  var event = new CustomEvent('vrdisplaydeviceparamschange', {
	    detail: {
	      vrdisplay: this,
	      deviceInfo: this.deviceInfo_
	    }
	  });
	  window.dispatchEvent(event);
	};
	CardboardVRDisplay.VRFrameData = VRFrameData;
	CardboardVRDisplay.VRDisplay = VRDisplay;
	return CardboardVRDisplay;
	})));
	});
	var CardboardVRDisplay = unwrapExports$$1(cardboardVrDisplay);

	var version = "0.10.6";

	var DefaultConfig = {
	  ADDITIONAL_VIEWERS: [],
	  DEFAULT_VIEWER: '',
	  PROVIDE_MOBILE_VRDISPLAY: true,
	  GET_VR_DISPLAYS_TIMEOUT: 1000,
	  MOBILE_WAKE_LOCK: true,
	  DEBUG: false,
	  DPDB_URL: 'https://dpdb.webvr.rocks/dpdb.json',
	  K_FILTER: 0.98,
	  PREDICTION_TIME_S: 0.040,
	  TOUCH_PANNER_DISABLED: true,
	  CARDBOARD_UI_DISABLED: false,
	  ROTATE_INSTRUCTIONS_DISABLED: false,
	  YAW_ONLY: false,
	  BUFFER_SCALE: 0.5,
	  DIRTY_SUBMIT_FRAME_BINDINGS: false
	};

	function WebVRPolyfill(config) {
	  this.config = extend(extend({}, DefaultConfig), config);
	  this.polyfillDisplays = [];
	  this.enabled = false;
	  this.hasNative = 'getVRDisplays' in navigator;
	  this.native = {};
	  this.native.getVRDisplays = navigator.getVRDisplays;
	  this.native.VRFrameData = window.VRFrameData;
	  this.native.VRDisplay = window.VRDisplay;
	  if (!this.hasNative || this.config.PROVIDE_MOBILE_VRDISPLAY && isMobile()) {
	    this.enable();
	    this.getVRDisplays().then(function (displays) {
	      if (displays && displays[0] && displays[0].fireVRDisplayConnect_) {
	        displays[0].fireVRDisplayConnect_();
	      }
	    });
	  }
	}
	WebVRPolyfill.prototype.getPolyfillDisplays = function () {
	  if (this._polyfillDisplaysPopulated) {
	    return this.polyfillDisplays;
	  }
	  if (isMobile()) {
	    var vrDisplay = new CardboardVRDisplay({
	      ADDITIONAL_VIEWERS: this.config.ADDITIONAL_VIEWERS,
	      DEFAULT_VIEWER: this.config.DEFAULT_VIEWER,
	      MOBILE_WAKE_LOCK: this.config.MOBILE_WAKE_LOCK,
	      DEBUG: this.config.DEBUG,
	      DPDB_URL: this.config.DPDB_URL,
	      CARDBOARD_UI_DISABLED: this.config.CARDBOARD_UI_DISABLED,
	      K_FILTER: this.config.K_FILTER,
	      PREDICTION_TIME_S: this.config.PREDICTION_TIME_S,
	      TOUCH_PANNER_DISABLED: this.config.TOUCH_PANNER_DISABLED,
	      ROTATE_INSTRUCTIONS_DISABLED: this.config.ROTATE_INSTRUCTIONS_DISABLED,
	      YAW_ONLY: this.config.YAW_ONLY,
	      BUFFER_SCALE: this.config.BUFFER_SCALE,
	      DIRTY_SUBMIT_FRAME_BINDINGS: this.config.DIRTY_SUBMIT_FRAME_BINDINGS
	    });
	    this.polyfillDisplays.push(vrDisplay);
	  }
	  this._polyfillDisplaysPopulated = true;
	  return this.polyfillDisplays;
	};
	WebVRPolyfill.prototype.enable = function () {
	  this.enabled = true;
	  if (this.hasNative && this.native.VRFrameData) {
	    var NativeVRFrameData = this.native.VRFrameData;
	    var nativeFrameData = new this.native.VRFrameData();
	    var nativeGetFrameData = this.native.VRDisplay.prototype.getFrameData;
	    window.VRDisplay.prototype.getFrameData = function (frameData) {
	      if (frameData instanceof NativeVRFrameData) {
	        nativeGetFrameData.call(this, frameData);
	        return;
	      }
	      nativeGetFrameData.call(this, nativeFrameData);
	      frameData.pose = nativeFrameData.pose;
	      copyArray(nativeFrameData.leftProjectionMatrix, frameData.leftProjectionMatrix);
	      copyArray(nativeFrameData.rightProjectionMatrix, frameData.rightProjectionMatrix);
	      copyArray(nativeFrameData.leftViewMatrix, frameData.leftViewMatrix);
	      copyArray(nativeFrameData.rightViewMatrix, frameData.rightViewMatrix);
	    };
	  }
	  navigator.getVRDisplays = this.getVRDisplays.bind(this);
	  window.VRDisplay = CardboardVRDisplay.VRDisplay;
	  window.VRFrameData = CardboardVRDisplay.VRFrameData;
	};
	WebVRPolyfill.prototype.getVRDisplays = function () {
	  var _this = this;
	  var config = this.config;
	  if (!this.hasNative) {
	    return Promise.resolve(this.getPolyfillDisplays());
	  }
	  var timeoutId;
	  var vrDisplaysNative = this.native.getVRDisplays.call(navigator);
	  var timeoutPromise = new Promise(function (resolve) {
	    timeoutId = setTimeout(function () {
	      console.warn('Native WebVR implementation detected, but `getVRDisplays()` failed to resolve. Falling back to polyfill.');
	      resolve([]);
	    }, config.GET_VR_DISPLAYS_TIMEOUT);
	  });
	  return race([vrDisplaysNative, timeoutPromise]).then(function (nativeDisplays) {
	    clearTimeout(timeoutId);
	    return nativeDisplays.length > 0 ? nativeDisplays : _this.getPolyfillDisplays();
	  });
	};
	WebVRPolyfill.version = version;
	WebVRPolyfill.VRFrameData = CardboardVRDisplay.VRFrameData;
	WebVRPolyfill.VRDisplay = CardboardVRDisplay.VRDisplay;


	var webvrPolyfill = Object.freeze({
		default: WebVRPolyfill
	});

	var require$$0 = ( webvrPolyfill && WebVRPolyfill ) || webvrPolyfill;

	if (typeof commonjsGlobal$$1 !== 'undefined' && commonjsGlobal$$1.window) {
	  if (!commonjsGlobal$$1.document) {
	    commonjsGlobal$$1.document = commonjsGlobal$$1.window.document;
	  }
	  if (!commonjsGlobal$$1.navigator) {
	    commonjsGlobal$$1.navigator = commonjsGlobal$$1.window.navigator;
	  }
	}
	var src = require$$0;

	return src;

	})));
	});

	var WebVRPolyfill = unwrapExports(webvrPolyfill);

	// Fix iOS Audio Context by Blake Kus https://gist.github.com/kus/3f01d60569eeadefe3a1
	// MIT license
	(function() {
	    window.AudioContext = window.AudioContext || window.webkitAudioContext;
	    if (window.AudioContext) {
	        window.hx_audioContext = new window.AudioContext();
	    }
	    else return;
	    var fixAudioContext = function (e) {
	        if (window.hx_audioContext) {
	            // Create empty buffer
	            var buffer = window.hx_audioContext.createBuffer(1, 1, 22050);
	            var source = window.hx_audioContext.createBufferSource();
	            source.buffer = buffer;
	            // Connect to output (speakers)
	            source.connect(window.hx_audioContext.destination);
	            // Play sound
	            if (source.start) {
	                source.start(0);
	            } else if (source.play) {
	                source.play(0);
	            } else if (source.noteOn) {
	                source.noteOn(0);
	            }
	        }
	        // Remove events
	        document.removeEventListener('touchstart', fixAudioContext);
	        document.removeEventListener('touchend', fixAudioContext);
	    };
	    // iOS 6-8
	    document.addEventListener('touchstart', fixAudioContext);
	    // iOS 9
	    document.addEventListener('touchend', fixAudioContext);
	})();

	/**
	 * ShaderLibrary is an object that will store shader code processed by the build process: contents of glsl files stored
	 * in the glsl folder will be stored here and can be retrieved using their original filename.
	 *
	 * @ignore
	 * @author derschmale <http://www.derschmale.com>
	 */
	var ShaderLibrary = {
	    _files: {},
	    /**
	     * Retrieves the shader code for a given filename.
	     * @param filename The filename of the glsl code to retrieve
	     * @param defines (Optional) An object containing variable names that need to be defined with the given value.
	     * This should not be used for macros, which should be explicitly prepended
	     * @param extensions (Optional) An array of extensions to be required
	     * @returns A string containing the shader code from the files with defines prepended
	     */
	    get: function(filename, defines)
	    {
	        var defineString = "";

	        for (var key in defines) {
	            if (defines.hasOwnProperty(key)) {
	                defineString += "#define " + key + " " + defines[key] + "\n";
	            }
	        }

	        return defineString + ShaderLibrary._files[filename];
	    }
	};

	ShaderLibrary._files['debug_bounds_fragment.glsl'] = 'uniform vec4 color;\n\nvoid main()\n{\n    hx_FragColor = color;\n}';

	ShaderLibrary._files['debug_bounds_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\n\nuniform mat4 hx_wvpMatrix;\n\nvoid main()\n{\n    gl_Position = hx_wvpMatrix * hx_position;\n}';

	ShaderLibrary._files['lighting_blinn_phong.glsl'] = '/*// schlick-beckman\nfloat hx_lightVisibility(vec3 normal, vec3 viewDir, float roughness, float nDotL)\n{\n	float nDotV = max(-dot(normal, viewDir), 0.0);\n	float r = roughness * roughness * 0.797896;\n	float g1 = nDotV * (1.0 - r) + r;\n	float g2 = nDotL * (1.0 - r) + r;\n    return .25 / (g1 * g2);\n}*/\n\nfloat hx_blinnPhongDistribution(float roughness, vec3 normal, vec3 halfVector)\n{\n	float roughnessSqr = clamp(roughness * roughness, 0.0001, .9999);\n//	roughnessSqr *= roughnessSqr;\n	float halfDotNormal = max(-dot(halfVector, normal), 0.0);\n	return pow(halfDotNormal, 2.0/roughnessSqr - 2.0) / roughnessSqr;\n}\n\nvoid hx_brdf(in HX_GeometryData geometry, in vec3 lightDir, in vec3 viewDir, in vec3 viewPos, in vec3 lightColor, vec3 normalSpecularReflectance, out vec3 diffuseColor, out vec3 specularColor)\n{\n	float nDotL = max(-dot(lightDir, geometry.normal), 0.0);\n	vec3 irradiance = nDotL * lightColor;	// in fact irradiance / PI\n\n	vec3 halfVector = normalize(lightDir + viewDir);\n\n	float distribution = hx_blinnPhongDistribution(geometry.roughness, geometry.normal, halfVector);\n\n	float halfDotLight = max(dot(halfVector, lightDir), 0.0);\n	float cosAngle = 1.0 - halfDotLight;\n	// to the 5th power\n	vec3 fresnel = normalSpecularReflectance + (1.0 - normalSpecularReflectance)*pow(cosAngle, 5.0);\n\n// / PI factor is encoded in light colour\n	diffuseColor = irradiance;\n	specularColor = irradiance * fresnel * distribution;\n\n//#ifdef HX_VISIBILITY\n//    specularColor *= hx_lightVisibility(normal, lightDir, geometry.roughness, nDotL);\n//#endif\n}';

	ShaderLibrary._files['lighting_debug.glsl'] = 'void hx_brdf(in HX_GeometryData geometry, in vec3 lightDir, in vec3 viewDir, in vec3 viewPos, in vec3 lightColor, vec3 normalSpecularReflectance, out vec3 diffuseColor, out vec3 specularColor)\n{\n	diffuseColor = vec3(0.0);\n	specularColor = vec3(0.0);\n}';

	ShaderLibrary._files['lighting_ggx.glsl'] = '#ifdef HX_VISIBILITY_TERM\nfloat hx_geometryTerm(vec3 normal, vec3 dir, float k)\n{\n    float d = max(-dot(normal, dir), 0.0);\n    return d / (d * (1.0 - k) + k);\n}\n\n// schlick-beckman\nfloat hx_lightVisibility(vec3 normal, vec3 viewDir, vec3 lightDir, float roughness)\n{\n	float k = roughness + 1.0;\n	k = k * k * .125;\n	return hx_geometryTerm(normal, viewDir, k) * hx_geometryTerm(normal, lightDir, k);\n}\n#endif\n\nfloat hx_ggxDistribution(float roughness, vec3 normal, vec3 halfVector)\n{\n    float roughSqr = roughness*roughness;\n    float halfDotNormal = max(-dot(halfVector, normal), 0.0);\n    float denom = (halfDotNormal * halfDotNormal) * (roughSqr - 1.0) + 1.0;\n    return roughSqr / (denom * denom);\n}\n\n// light dir is to the lit surface\n// view dir is to the lit surface\nvoid hx_brdf(in HX_GeometryData geometry, in vec3 lightDir, in vec3 viewDir, in vec3 viewPos, in vec3 lightColor, vec3 normalSpecularReflectance, out vec3 diffuseColor, out vec3 specularColor)\n{\n	float nDotL = max(-dot(lightDir, geometry.normal), 0.0);\n	vec3 irradiance = nDotL * lightColor;	// in fact irradiance / PI\n\n	vec3 halfVector = normalize(lightDir + viewDir);\n\n    float mappedRoughness =  geometry.roughness * geometry.roughness;\n\n	float distribution = hx_ggxDistribution(mappedRoughness, geometry.normal, halfVector);\n\n	float halfDotLight = max(dot(halfVector, lightDir), 0.0);\n	float cosAngle = 1.0 - halfDotLight;\n	vec3 fresnel = normalSpecularReflectance + (1.0 - normalSpecularReflectance) * pow(cosAngle, 5.0);\n\n	diffuseColor = irradiance;\n\n	specularColor = irradiance * fresnel * distribution;\n\n#ifdef HX_VISIBILITY_TERM\n    specularColor *= hx_lightVisibility(geometry.normal, viewDir, lightDir, geometry.roughness);\n#endif\n}';

	ShaderLibrary._files['directional_light.glsl'] = 'struct HX_DirectionalLight\n{\n    vec3 color;\n    vec3 direction; // in view space?\n\n    int castShadows;\n\n    mat4 shadowMapMatrices[4];\n    vec4 splitDistances;\n\n    float depthBias;\n    float maxShadowDistance;    // = light.splitDistances[light.numCascades - 1]\n};\n\nvoid hx_calculateLight(HX_DirectionalLight light, HX_GeometryData geometry, vec3 viewVector, vec3 viewPosition, vec3 normalSpecularReflectance, out vec3 diffuse, out vec3 specular)\n{\n	hx_brdf(geometry, light.direction, viewVector, viewPosition, light.color, normalSpecularReflectance, diffuse, specular);\n}\n\nmat4 hx_getShadowMatrix(HX_DirectionalLight light, vec3 viewPos)\n{\n    #if HX_NUM_SHADOW_CASCADES > 1\n        // not very efficient :(\n        for (int i = 0; i < HX_NUM_SHADOW_CASCADES - 1; ++i) {\n            if (viewPos.y < light.splitDistances[i])\n                return light.shadowMapMatrices[i];\n        }\n        return light.shadowMapMatrices[HX_NUM_SHADOW_CASCADES - 1];\n    #else\n        return light.shadowMapMatrices[0];\n    #endif\n}\n\n#ifdef HX_FRAGMENT_SHADER\nfloat hx_calculateShadows(HX_DirectionalLight light, sampler2D shadowMap, vec3 viewPos)\n{\n    mat4 shadowMatrix = hx_getShadowMatrix(light, viewPos);\n    vec4 shadowMapCoord = shadowMatrix * vec4(viewPos, 1.0);\n    float shadow = hx_readShadow(shadowMap, shadowMapCoord, light.depthBias);\n\n    // this can occur when meshInstance.castShadows = false, or using inherited bounds\n    bool isOutside = max(shadowMapCoord.x, shadowMapCoord.y) > 1.0 || min(shadowMapCoord.x, shadowMapCoord.y) < 0.0;\n    if (isOutside) shadow = 1.0;\n\n    // this makes sure that anything beyond the last cascade is unshadowed\n    return max(shadow, float(viewPos.y > light.maxShadowDistance));\n}\n#endif';

	ShaderLibrary._files['light_probe.glsl'] = '#define HX_PROBE_K0 .00098\n#define HX_PROBE_K1 .9921\n\n// really only used for clustered\nstruct HX_Probe\n{\n    int hasDiffuse;\n    int hasSpecular;\n    float numMipLevels;\n};\n\n/*\nvar minRoughness = 0.0014;\nvar maxPower = 2.0 / (minRoughness * minRoughness) - 2.0;\nvar maxMipFactor = (exp2(-10.0/Math.sqrt(maxPower)) - HX_PROBE_K0)/HX_PROBE_K1;\nvar HX_PROBE_SCALE = 1.0 / maxMipFactor\n*/\n\n#define HX_PROBE_SCALE\n\nvec3 hx_calculateDiffuseProbeLight(samplerCube texture, vec3 normal)\n{\n	return hx_gammaToLinear(textureCube(texture, normal.xzy).xyz);\n}\n\nvec3 hx_calculateSpecularProbeLight(samplerCube texture, float numMips, vec3 reflectedViewDir, vec3 fresnelColor, float roughness)\n{\n    #if defined(HX_TEXTURE_LOD) || defined (HX_GLSL_300_ES)\n    // knald method:\n        float power = 2.0/(roughness * roughness) - 2.0;\n        float factor = (exp2(-10.0/sqrt(power)) - HX_PROBE_K0)/HX_PROBE_K1;\n//        float mipLevel = numMips * (1.0 - clamp(factor * HX_PROBE_SCALE, 0.0, 1.0));\n        float mipLevel = numMips * (1.0 - clamp(factor, 0.0, 1.0));\n        #ifdef HX_GLSL_300_ES\n        vec4 specProbeSample = textureLod(texture, reflectedViewDir.xzy, mipLevel);\n        #else\n        vec4 specProbeSample = textureCubeLodEXT(texture, reflectedViewDir.xzy, mipLevel);\n        #endif\n    #else\n        vec4 specProbeSample = textureCube(texture, reflectedViewDir.xzy);\n    #endif\n	return hx_gammaToLinear(specProbeSample.xyz) * fresnelColor;\n}';

	ShaderLibrary._files['point_light.glsl'] = 'struct HX_PointLight\n{\n    vec3 color;\n    vec3 position;\n    float radius;\n    float rcpRadius;\n\n    float depthBias;\n    mat4 shadowMapMatrix;\n    int castShadows;\n    vec4 shadowTiles[6];    // for each cube face\n};\n\nvoid hx_calculateLight(HX_PointLight light, HX_GeometryData geometry, vec3 viewVector, vec3 viewPosition, vec3 normalSpecularReflectance, out vec3 diffuse, out vec3 specular)\n{\n    vec3 direction = viewPosition - light.position;\n    float attenuation = dot(direction, direction);  // distance squared\n    float distance = sqrt(attenuation);\n    // normalize\n    direction /= distance;\n    attenuation = max((1.0 - distance * light.rcpRadius) / attenuation, 0.0);\n	hx_brdf(geometry, direction, viewVector, viewPosition, light.color * attenuation, normalSpecularReflectance, diffuse, specular);\n}\n\n#ifdef HX_FRAGMENT_SHADER\nfloat hx_calculateShadows(HX_PointLight light, sampler2D shadowMap, vec3 viewPos)\n{\n    vec3 dir = viewPos - light.position;\n    // go from view space back to world space, as a vector\n    float dist = length(dir);\n    dir = mat3(light.shadowMapMatrix) * dir;\n\n    // swizzle to opengl cube map space\n    dir = dir.xzy;\n\n    vec3 absDir = abs(dir);\n    float maxDir = max(max(absDir.x, absDir.y), absDir.z);\n    vec2 uv;\n    vec4 tile;\n    if (absDir.x == maxDir) {\n        tile = dir.x > 0.0? light.shadowTiles[0]: light.shadowTiles[1];\n        // signs are important (hence division by either dir or absDir\n        uv = vec2(-dir.z / dir.x, -dir.y / absDir.x);\n    }\n    else if (absDir.y == maxDir) {\n        tile = dir.y > 0.0? light.shadowTiles[4]: light.shadowTiles[5];\n        uv = vec2(dir.x / absDir.y, dir.z / dir.y);\n    }\n    else {\n        tile = dir.z > 0.0? light.shadowTiles[2]: light.shadowTiles[3];\n        uv = vec2(dir.x / dir.z, -dir.y / absDir.z);\n    }\n\n    // match the scaling applied in the shadow map pass (used to reduce bleeding from filtering)\n    uv *= .95;\n\n    vec4 shadowMapCoord;\n    shadowMapCoord.xy = uv * tile.xy + tile.zw;\n    shadowMapCoord.z = dist * light.rcpRadius;\n    shadowMapCoord.w = 1.0;\n    return  hx_readShadow(shadowMap, shadowMapCoord, light.depthBias);\n}\n#endif';

	ShaderLibrary._files['spot_light.glsl'] = 'struct HX_SpotLight\n{\n    vec3 color;\n    vec3 position;\n    vec3 direction;\n    float radius;\n    float rcpRadius;\n\n    vec2 angleData;    // cos(inner), rcp(cos(outer) - cos(inner))\n\n    mat4 shadowMapMatrix;\n    float depthBias;\n    int castShadows;\n\n    vec4 shadowTile;    // xy = scale, zw = offset\n};\n\nvoid hx_calculateLight(HX_SpotLight light, HX_GeometryData geometry, vec3 viewVector, vec3 viewPosition, vec3 normalSpecularReflectance, out vec3 diffuse, out vec3 specular)\n{\n    vec3 direction = viewPosition - light.position;\n    float attenuation = dot(direction, direction);  // distance squared\n    float distance = sqrt(attenuation);\n    // normalize\n    direction /= distance;\n\n    float cosAngle = dot(light.direction, direction);\n\n    attenuation = max((1.0 - distance * light.rcpRadius) / attenuation, 0.0);\n    attenuation *=  saturate((cosAngle - light.angleData.x) * light.angleData.y);\n\n	hx_brdf(geometry, direction, viewVector, viewPosition, light.color * attenuation, normalSpecularReflectance, diffuse, specular);\n}\n\n#ifdef HX_FRAGMENT_SHADER\nfloat hx_calculateShadows(HX_SpotLight light, sampler2D shadowMap, vec3 viewPos)\n{\n    vec4 shadowMapCoord = light.shadowMapMatrix * vec4(viewPos, 1.0);\n    shadowMapCoord /= shadowMapCoord.w;\n    // *.9 --> match the scaling applied in the shadow map pass (used to reduce bleeding from filtering)\n    shadowMapCoord.xy = shadowMapCoord.xy * .95 * light.shadowTile.xy + light.shadowTile.zw;\n    shadowMapCoord.z = length(viewPos - light.position) * light.rcpRadius;\n    return hx_readShadow(shadowMap, shadowMapCoord, light.depthBias);\n}\n#endif';

	ShaderLibrary._files['default_geometry_fragment.glsl'] = 'uniform vec3 color;\nuniform vec3 emissiveColor;\nuniform float alpha;\n\n#if defined(COLOR_MAP) || defined(NORMAL_MAP)|| defined(SPECULAR_MAP)|| defined(ROUGHNESS_MAP) || defined(MASK_MAP) || defined(METALLIC_ROUGHNESS_MAP) || defined(OCCLUSION_MAP) || defined(EMISSION_MAP)\nvarying_in vec2 texCoords;\n#endif\n\n#ifdef COLOR_MAP\nuniform sampler2D colorMap;\n#endif\n\n#ifdef OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n\n#ifdef EMISSION_MAP\nuniform sampler2D emissionMap;\n#endif\n\n#ifdef MASK_MAP\nuniform sampler2D maskMap;\n#endif\n\n#ifndef HX_SKIP_NORMALS\n    varying_in vec3 normal;\n\n    #ifdef NORMAL_MAP\n    varying_in vec3 tangent;\n    varying_in vec3 bitangent;\n\n    uniform sampler2D normalMap;\n    #endif\n#endif\n\n#ifndef HX_SKIP_SPECULAR\nuniform float roughness;\nuniform float roughnessRange;\nuniform float normalSpecularReflectance;\nuniform float metallicness;\n\n#if defined(SPECULAR_MAP) || defined(ROUGHNESS_MAP) || defined(METALLIC_ROUGHNESS_MAP)\nuniform sampler2D specularMap;\n#endif\n\n#endif\n\n#if defined(ALPHA_THRESHOLD)\nuniform float alphaThreshold;\n#endif\n\n#ifdef VERTEX_COLORS\nvarying_in vec3 vertexColor;\n#endif\n\nHX_GeometryData hx_geometry()\n{\n    HX_GeometryData data;\n\n    vec4 outputColor = vec4(color, alpha);\n\n    #ifdef VERTEX_COLORS\n        outputColor.xyz *= vertexColor;\n    #endif\n\n    #ifdef COLOR_MAP\n        outputColor *= texture2D(colorMap, texCoords);\n    #endif\n\n    #ifdef MASK_MAP\n        outputColor.w *= texture2D(maskMap, texCoords).x;\n    #endif\n\n    #ifdef ALPHA_THRESHOLD\n        if (outputColor.w < alphaThreshold) discard;\n    #endif\n\n    data.color = hx_gammaToLinear(outputColor);\n\n#ifndef HX_SKIP_SPECULAR\n    float metallicnessOut = metallicness;\n    float specNormalReflOut = normalSpecularReflectance;\n    float roughnessOut = roughness;\n#endif\n\n#if defined(HX_SKIP_NORMALS) && defined(NORMAL_ROUGHNESS_MAP) && !defined(HX_SKIP_SPECULAR)\n    vec4 normalSample = texture2D(normalMap, texCoords);\n    roughnessOut -= roughnessRange * (normalSample.w - .5);\n#endif\n\n#ifndef HX_SKIP_NORMALS\n    vec3 fragNormal = normal;\n\n    #ifdef NORMAL_MAP\n        vec4 normalSample = texture2D(normalMap, texCoords);\n        mat3 TBN;\n        TBN[2] = normalize(normal);\n        TBN[0] = normalize(tangent);\n        TBN[1] = normalize(bitangent);\n\n        fragNormal = TBN * (normalSample.xyz - .5);\n\n        #ifdef NORMAL_ROUGHNESS_MAP\n            roughnessOut -= roughnessRange * (normalSample.w - .5);\n        #endif\n    #endif\n\n    #ifdef DOUBLE_SIDED\n        fragNormal *= gl_FrontFacing? 1.0 : -1.0;\n    #endif\n    data.normal = normalize(fragNormal);\n#endif\n\n#ifndef HX_SKIP_SPECULAR\n    #if defined(SPECULAR_MAP) || defined(ROUGHNESS_MAP) || defined(METALLIC_ROUGHNESS_MAP)\n          vec4 specSample = texture2D(specularMap, texCoords);\n\n          #ifdef METALLIC_ROUGHNESS_MAP\n              roughnessOut -= roughnessRange * (specSample.y - .5);\n              metallicnessOut *= specSample.z;\n\n          #else\n              roughnessOut -= roughnessRange * (specSample.x - .5);\n\n              #ifdef SPECULAR_MAP\n                  specNormalReflOut *= specSample.y;\n                  metallicnessOut *= specSample.z;\n              #endif\n          #endif\n    #endif\n\n    data.metallicness = metallicnessOut;\n    data.normalSpecularReflectance = specNormalReflOut;\n    data.roughness = roughnessOut;\n#endif\n\n    data.occlusion = 1.0;\n\n#ifdef OCCLUSION_MAP\n    data.occlusion = texture2D(occlusionMap, texCoords).x;\n#endif\n\n    vec3 emission = emissiveColor;\n#ifdef EMISSION_MAP\n    emission *= texture2D(emissionMap, texCoords).xyz;\n#endif\n\n    data.emission = hx_gammaToLinear(emission);\n    return data;\n}';

	ShaderLibrary._files['default_geometry_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\n\n// morph positions are offsets re the base position!\n#ifdef HX_USE_MORPHING\nvertex_attribute vec3 hx_morphPosition0;\nvertex_attribute vec3 hx_morphPosition1;\nvertex_attribute vec3 hx_morphPosition2;\nvertex_attribute vec3 hx_morphPosition3;\n\n#ifdef HX_USE_NORMAL_MORPHING\n    #ifndef HX_SKIP_NORMALS\n    vertex_attribute vec3 hx_morphNormal0;\n    vertex_attribute vec3 hx_morphNormal1;\n    vertex_attribute vec3 hx_morphNormal2;\n    vertex_attribute vec3 hx_morphNormal3;\n    #endif\n\nuniform float hx_morphWeights[4];\n#else\nvertex_attribute vec3 hx_morphPosition4;\nvertex_attribute vec3 hx_morphPosition5;\nvertex_attribute vec3 hx_morphPosition6;\nvertex_attribute vec3 hx_morphPosition7;\n\nuniform float hx_morphWeights[8];\n#endif\n\n#endif\n\n#ifdef HX_USE_SKINNING\nvertex_attribute vec4 hx_jointIndices;\nvertex_attribute vec4 hx_jointWeights;\n\n// WebGL doesn\'t support mat4x3 and I don\'t want to split the uniform either\n#ifdef HX_USE_SKINNING_TEXTURE\nuniform sampler2D hx_skinningTexture;\n#else\nuniform vec4 hx_skinningMatrices[HX_MAX_SKELETON_JOINTS * 3];\n#endif\n#endif\n\nuniform mat4 hx_wvpMatrix;\nuniform mat4 hx_worldViewMatrix;\n\n#if defined(COLOR_MAP) || defined(NORMAL_MAP)|| defined(SPECULAR_MAP)|| defined(ROUGHNESS_MAP) || defined(MASK_MAP) || defined(OCCLUSION_MAP) || defined(EMISSION_MAP)\nvertex_attribute vec2 hx_texCoord;\nvarying_out vec2 texCoords;\n#endif\n\n#ifdef VERTEX_COLORS\nvertex_attribute vec3 hx_vertexColor;\nvarying_out vec3 vertexColor;\n#endif\n\n#ifndef HX_SKIP_NORMALS\nvertex_attribute vec3 hx_normal;\nvarying_out vec3 normal;\n\nuniform mat3 hx_normalWorldViewMatrix;\n#ifdef NORMAL_MAP\nvertex_attribute vec4 hx_tangent;\n\nvarying_out vec3 tangent;\nvarying_out vec3 bitangent;\n#endif\n#endif\n\nvoid hx_geometry()\n{\n    vec4 morphedPosition = hx_position;\n\n    #ifndef HX_SKIP_NORMALS\n    vec3 morphedNormal = hx_normal;\n    #endif\n\n// TODO: Abstract this in functions for easier reuse in other materials\n#ifdef HX_USE_MORPHING\n    morphedPosition.xyz += hx_morphPosition0 * hx_morphWeights[0];\n    morphedPosition.xyz += hx_morphPosition1 * hx_morphWeights[1];\n    morphedPosition.xyz += hx_morphPosition2 * hx_morphWeights[2];\n    morphedPosition.xyz += hx_morphPosition3 * hx_morphWeights[3];\n    #ifdef HX_USE_NORMAL_MORPHING\n        #ifndef HX_SKIP_NORMALS\n        morphedNormal += hx_morphNormal0 * hx_morphWeights[0];\n        morphedNormal += hx_morphNormal1 * hx_morphWeights[1];\n        morphedNormal += hx_morphNormal2 * hx_morphWeights[2];\n        morphedNormal += hx_morphNormal3 * hx_morphWeights[3];\n        #endif\n    #else\n        morphedPosition.xyz += hx_morphPosition4 * hx_morphWeights[4];\n        morphedPosition.xyz += hx_morphPosition5 * hx_morphWeights[5];\n        morphedPosition.xyz += hx_morphPosition6 * hx_morphWeights[6];\n        morphedPosition.xyz += hx_morphPosition7 * hx_morphWeights[7];\n    #endif\n#endif\n\n#ifdef HX_USE_SKINNING\n    mat4 skinningMatrix = hx_getSkinningMatrix(0);\n\n    vec4 animPosition = morphedPosition * skinningMatrix;\n\n    #ifndef HX_SKIP_NORMALS\n        vec3 animNormal = morphedNormal * mat3(skinningMatrix);\n\n        #ifdef NORMAL_MAP\n        vec3 animTangent = hx_tangent.xyz * mat3(skinningMatrix);\n        #endif\n    #endif\n#else\n    vec4 animPosition = morphedPosition;\n\n    #ifndef HX_SKIP_NORMALS\n        vec3 animNormal = morphedNormal;\n\n        #ifdef NORMAL_MAP\n        vec3 animTangent = hx_tangent.xyz;\n        #endif\n    #endif\n#endif\n\n    // TODO: Should gl_position be handled by the shaders if we only return local position?\n    gl_Position = hx_wvpMatrix * animPosition;\n\n#ifndef HX_SKIP_NORMALS\n    normal = normalize(hx_normalWorldViewMatrix * animNormal);\n\n    #ifdef NORMAL_MAP\n        tangent = mat3(hx_worldViewMatrix) * animTangent;\n        bitangent = cross(tangent, normal) * hx_tangent.w;\n    #endif\n#endif\n\n#if defined(COLOR_MAP) || defined(NORMAL_MAP)|| defined(SPECULAR_MAP)|| defined(ROUGHNESS_MAP) || defined(MASK_MAP) || defined(OCCLUSION_MAP) || defined(EMISSION_MAP)\n    texCoords = hx_texCoord;\n#endif\n\n#ifdef VERTEX_COLORS\n    vertexColor = hx_vertexColor;\n#endif\n}';

	ShaderLibrary._files['default_skybox_fragment.glsl'] = 'varying_in vec3 viewWorldDir;\n\nuniform samplerCube hx_skybox;\n\nHX_GeometryData hx_geometry()\n{\n    HX_GeometryData data;\n    data.color = textureCube(hx_skybox, viewWorldDir.xzy);\n    data.emission = vec3(0.0);\n    data.color = hx_gammaToLinear(data.color);\n    return data;\n}';

	ShaderLibrary._files['default_skybox_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\n\nuniform vec3 hx_cameraWorldPosition;\nuniform float hx_cameraFarPlaneDistance;\nuniform mat4 hx_viewProjectionMatrix;\n\nvarying_out vec3 viewWorldDir;\n\n// using 2D quad for rendering skyboxes rather than 3D cube causes jittering of the skybox\nvoid hx_geometry()\n{\n    viewWorldDir = hx_position.xyz;\n    vec4 pos = hx_position;\n    // use a decent portion of the frustum to prevent FP issues\n    pos.xyz = pos.xyz * hx_cameraFarPlaneDistance + hx_cameraWorldPosition;\n    pos = hx_viewProjectionMatrix * pos;\n    // make sure it\'s drawn behind everything else, so z = 1.0\n    pos.z = pos.w;\n    gl_Position = pos;\n}';

	ShaderLibrary._files['material_dir_shadow_fragment.glsl'] = 'void main()\n{\n    // geometry is really only used for kil instructions if necessary\n    // hopefully the compiler optimizes the rest out for us\n    HX_GeometryData data = hx_geometry();\n    hx_FragColor = hx_getShadowMapValue(gl_FragCoord.z);\n}';

	ShaderLibrary._files['material_fwd_base_fragment.glsl'] = 'uniform vec3 hx_ambientColor;\n\n#ifdef HX_SSAO\nuniform sampler2D hx_ssao;\n#endif\n\nuniform vec2 hx_rcpRenderTargetResolution;\n\nvoid main()\n{\n    vec2 screenUV = gl_FragCoord.xy * hx_rcpRenderTargetResolution;\n\n    HX_GeometryData data = hx_geometry();\n    // simply override with emission\n    hx_FragColor = data.color;\n    #ifdef HX_SSAO\n    float ssao = texture2D(hx_ssao, screenUV).x;\n    #else\n    float ssao = 1.0;\n    #endif\n    hx_FragColor.xyz = hx_FragColor.xyz * hx_ambientColor * ssao + data.emission;\n}';

	ShaderLibrary._files['material_fwd_base_vertex.glsl'] = 'void main()\n{\n    hx_geometry();\n}';

	ShaderLibrary._files['material_fwd_clustered_fragment.glsl'] = 'struct HX_PointSpotLight\n{\n// the order here is ordered in function of packing\n    vec3 color;\n    float radius;\n\n    vec3 position;\n    float rcpRadius;\n\n    vec3 direction; // spot only\n    float depthBias;\n\n    mat4 shadowMapMatrix;\n\n    int isSpot;\n    int castShadows;\n    vec2 angleData;    // cos(inner), rcp(cos(outer) - cos(inner))\n\n    vec4 shadowTile;    // xy = scale, zw = offset\n\n    // points only\n    // the 5 missing tiles, share the first one with spots!\n    vec4 shadowTiles[5];    // for each cube face\n};\n\nHX_SpotLight hx_asSpotLight(HX_PointSpotLight light)\n{\n    HX_SpotLight spot;\n    spot.color = light.color;\n    spot.position = light.position;\n    spot.radius = light.radius;\n    spot.direction = light.direction;\n    spot.rcpRadius = light.rcpRadius;\n    spot.angleData = light.angleData;\n    spot.shadowMapMatrix = light.shadowMapMatrix;\n    spot.depthBias = light.depthBias;\n    spot.castShadows = light.castShadows;\n    spot.shadowTile = light.shadowTile;\n    return spot;\n}\n\nHX_PointLight hx_asPointLight(HX_PointSpotLight light)\n{\n    HX_PointLight point;\n    point.color = light.color;\n    point.position = light.position;\n    point.radius = light.radius;\n    point.rcpRadius = light.rcpRadius;\n    point.shadowMapMatrix = light.shadowMapMatrix;\n    point.depthBias = light.depthBias;\n    point.castShadows = light.castShadows;\n    point.shadowTiles[0] = light.shadowTile;\n    point.shadowTiles[1] = light.shadowTiles[0];\n    point.shadowTiles[2] = light.shadowTiles[1];\n    point.shadowTiles[3] = light.shadowTiles[2];\n    point.shadowTiles[4] = light.shadowTiles[3];\n    point.shadowTiles[5] = light.shadowTiles[4];\n    return point;\n}\n\nvarying_in vec3 hx_viewPosition;\n\nuniform vec3 hx_ambientColor;\nuniform vec2 hx_rcpRenderTargetResolution;\nuniform sampler2D hx_shadowMap;\n\n#ifdef HX_SSAO\nuniform sampler2D hx_ssao;\n#endif\n\nuniform hx_lightingCells\n{\n    // std140 layout specification dictates arrays of scalars have strides rounded up to the alignment of vec4\n    // meaning the array would be 4 times as big when using floats. Hence the use of vec4s.\n    ivec4 hx_cells[HX_CELL_ARRAY_LEN];\n};\n\nuniform hx_lights\n{\n    int hx_numDirLights;\n    int hx_numLightProbes;\n    int hx_numPointSpotLights;\n\n#if HX_NUM_DIR_LIGHTS > 0\n    HX_DirectionalLight hx_directionalLights[HX_NUM_DIR_LIGHTS];\n#endif\n\n#if HX_NUM_LIGHT_PROBES > 0\n    HX_Probe hx_probes[HX_NUM_LIGHT_PROBES];\n#endif\n\n#if HX_NUM_POINT_SPOT_LIGHTS > 0\n    HX_PointSpotLight hx_pointSpotLights[HX_NUM_POINT_SPOT_LIGHTS];\n#endif\n\n};\n\n#if HX_NUM_LIGHT_PROBES > 0\nuniform mat4 hx_cameraWorldMatrix;\n\nuniform samplerCube hx_diffuseProbes[HX_NUM_LIGHT_PROBES];\nuniform samplerCube hx_specularProbes[HX_NUM_LIGHT_PROBES];\n#endif\n\nivec2 getCurrentCell(vec2 screenUV)\n{\n    return ivec2(screenUV * vec2(float(HX_NUM_CELLS_X), float(HX_NUM_CELLS_Y)));\n}\n\nvoid main()\n{\n    HX_GeometryData data = hx_geometry();\n\n    // update the colours\n    vec3 specularColor = mix(vec3(data.normalSpecularReflectance), data.color.xyz, data.metallicness);\n    data.color.xyz *= 1.0 - data.metallicness;\n\n    vec3 diffuseAccum = vec3(0.0);\n    vec3 specularAccum = vec3(0.0);\n    vec3 viewVector = normalize(hx_viewPosition);\n\n    float ao = data.occlusion;\n    vec2 screenUV = gl_FragCoord.xy * hx_rcpRenderTargetResolution;\n\n    #ifdef HX_SSAO\n        ao = texture2D(hx_ssao, screenUV).x;\n    #endif\n\n    #if HX_NUM_DIR_LIGHTS > 0\n        for (int i = 0; i < hx_numDirLights; ++i) {\n            HX_DirectionalLight light = hx_directionalLights[i];\n            vec3 diffuse, specular;\n            hx_calculateLight(light, data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n\n            if (light.castShadows == 1) {\n                float shadow = hx_calculateShadows(light, hx_shadowMap, hx_viewPosition);\n                diffuse *= shadow;\n                specular *= shadow;\n            }\n\n            diffuseAccum += diffuse;\n            specularAccum += specular;\n        }\n    #endif\n\n    #if HX_NUM_LIGHT_PROBES > 0\n        vec3 worldNormal = mat3(hx_cameraWorldMatrix) * data.normal;\n        vec3 reflectedViewDir = reflect(viewVector, data.normal);\n        vec3 fresnel = hx_fresnelProbe(specularColor, reflectedViewDir, data.normal, data.roughness);\n\n        reflectedViewDir = mat3(hx_cameraWorldMatrix) * reflectedViewDir;\n\n        for (int i = 0; i < HX_NUM_LIGHT_PROBES; ++i) {\n            // this is a bit icky, but since the cube textures need to indexed using a literal, we can\'t loop over hx_numLightProbes\n            if (i < hx_numLightProbes) {\n                if (hx_probes[i].hasDiffuse == 1)\n                    diffuseAccum += hx_calculateDiffuseProbeLight(hx_diffuseProbes[i], worldNormal) * ao;\n\n                if (hx_probes[i].hasSpecular == 1)\n                    specularAccum += hx_calculateSpecularProbeLight(hx_specularProbes[i], hx_probes[i].numMipLevels, reflectedViewDir, fresnel, data.roughness) * ao;\n            }\n        }\n    #endif\n\n    #if HX_NUM_POINT_SPOT_LIGHTS > 0\n        ivec2 cell = getCurrentCell(screenUV);\n        int cellIndex = HX_CELL_STRIDE * (HX_NUM_CELLS_X * cell.y + cell.x);\n        int cellElm = cellIndex / 4;\n        int comp = cellIndex - cellElm * 4;\n\n        int numLights = hx_cells[cellElm][comp];\n\n//        specularAccum += float(numLights) / 5.0;\n\n        for (int i = 1; i <= numLights; ++i) {\n            vec3 diffuse, specular;\n            float shadow = 1.0;;\n            int lightIndex = cellIndex + i;\n            int cellElm = lightIndex / 4;\n            int comp = lightIndex - cellElm * 4;\n            lightIndex = hx_cells[cellElm][comp];\n\n            if (hx_pointSpotLights[lightIndex].isSpot == 1) {\n                HX_SpotLight spot = hx_asSpotLight(hx_pointSpotLights[lightIndex]);\n                hx_calculateLight(spot, data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n                if (spot.castShadows == 1)\n                    shadow = hx_calculateShadows(spot, hx_shadowMap, hx_viewPosition);\n            }\n            else {\n                HX_PointLight point = hx_asPointLight(hx_pointSpotLights[lightIndex]);\n                hx_calculateLight(point, data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n                if (point.castShadows == 1)\n                    shadow = hx_calculateShadows(point, hx_shadowMap, hx_viewPosition);\n            }\n\n            diffuseAccum += diffuse * shadow;\n            specularAccum += specular * shadow;\n        }\n    #endif\n\n    hx_FragColor = vec4((diffuseAccum + hx_ambientColor * ao) * data.color.xyz + specularAccum + data.emission, data.color.w);\n}';

	ShaderLibrary._files['material_fwd_clustered_vertex.glsl'] = 'varying_out vec3 hx_viewPosition;\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n    hx_geometry();\n    // we need to do an unprojection here to be sure to have skinning - or anything like that - support\n    hx_viewPosition = (hx_inverseProjectionMatrix * gl_Position).xyz;\n}';

	ShaderLibrary._files['material_fwd_dir_fragment.glsl'] = 'varying_in vec3 hx_viewPosition;\n\nuniform HX_DirectionalLight hx_directionalLight;\n\nuniform sampler2D hx_shadowMap;\n\nvoid main()\n{\n    HX_GeometryData data = hx_geometry();\n\n    vec3 viewVector = normalize(hx_viewPosition);\n    vec3 diffuse, specular;\n\n    vec3 specularColor = mix(vec3(data.normalSpecularReflectance), data.color.xyz, data.metallicness);\n    data.color.xyz *= 1.0 - data.metallicness;\n\n    hx_calculateLight(hx_directionalLight, data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n\n    hx_FragColor = vec4(diffuse * data.color.xyz + specular, data.color.w);\n\n    if (hx_directionalLight.castShadows == 1)\n        hx_FragColor.xyz *= hx_calculateShadows(hx_directionalLight, hx_shadowMap, hx_viewPosition);\n}';

	ShaderLibrary._files['material_fwd_dir_vertex.glsl'] = 'varying_out vec3 hx_viewPosition;\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n    hx_geometry();\n    hx_viewPosition = (hx_inverseProjectionMatrix * gl_Position).xyz;\n}';

	ShaderLibrary._files['material_fwd_fixed_fragment.glsl'] = 'varying_in vec3 hx_viewPosition;\n\nuniform vec3 hx_ambientColor;\n\nuniform sampler2D hx_shadowMap;\n\n#if HX_NUM_DIR_LIGHTS > 0\nuniform HX_DirectionalLight hx_directionalLights[HX_NUM_DIR_LIGHTS];\n#endif\n\n#if HX_NUM_POINT_LIGHTS > 0\nuniform HX_PointLight hx_pointLights[HX_NUM_POINT_LIGHTS];\n#endif\n\n#if HX_NUM_SPOT_LIGHTS > 0\nuniform HX_SpotLight hx_spotLights[HX_NUM_SPOT_LIGHTS];\n#endif\n\n#if HX_NUM_DIFFUSE_PROBES > 0 || HX_NUM_SPECULAR_PROBES > 0\nuniform mat4 hx_cameraWorldMatrix;\n#endif\n\n#if HX_NUM_DIFFUSE_PROBES > 0\nuniform samplerCube hx_diffuseProbeMaps[HX_NUM_DIFFUSE_PROBES];\n#endif\n\n#if HX_NUM_SPECULAR_PROBES > 0\nuniform samplerCube hx_specularProbeMaps[HX_NUM_SPECULAR_PROBES];\nuniform float hx_specularProbeNumMips[HX_NUM_SPECULAR_PROBES];\n#endif\n\n#ifdef HX_SSAO\nuniform sampler2D hx_ssao;\n\nuniform vec2 hx_rcpRenderTargetResolution;\n#endif\n\n\nvoid main()\n{\n    HX_GeometryData data = hx_geometry();\n\n    // update the colours\n    vec3 specularColor = mix(vec3(data.normalSpecularReflectance), data.color.xyz, data.metallicness);\n    data.color.xyz *= 1.0 - data.metallicness;\n\n    vec3 diffuseAccum = vec3(0.0);\n    vec3 specularAccum = vec3(0.0);\n    vec3 viewVector = normalize(hx_viewPosition);\n\n    float ao = data.occlusion;\n\n    #ifdef HX_SSAO\n        vec2 screenUV = gl_FragCoord.xy * hx_rcpRenderTargetResolution;\n        ao = texture2D(hx_ssao, screenUV).x;\n    #endif\n\n    #if HX_NUM_DIR_LIGHTS > 0\n    for (int i = 0; i < HX_NUM_DIR_LIGHTS; ++i) {\n        vec3 diffuse, specular;\n        hx_calculateLight(hx_directionalLights[i], data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n\n        if (hx_directionalLights[i].castShadows == 1) {\n            float shadow = hx_calculateShadows(hx_directionalLights[i], hx_shadowMap, hx_viewPosition);\n            diffuse *= shadow;\n            specular *= shadow;\n        }\n\n        diffuseAccum += diffuse;\n        specularAccum += specular;\n    }\n    #endif\n\n    #if HX_NUM_POINT_LIGHTS > 0\n    for (int i = 0; i < HX_NUM_POINT_LIGHTS; ++i) {\n        vec3 diffuse, specular;\n        hx_calculateLight(hx_pointLights[i], data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n\n        if (hx_pointLights[i].castShadows == 1) {\n            float shadow = hx_calculateShadows(hx_pointLights[i], hx_shadowMap, hx_viewPosition);\n            diffuse *= shadow;\n            specular *= shadow;\n        }\n\n        diffuseAccum += diffuse;\n        specularAccum += specular;\n    }\n    #endif\n\n    #if HX_NUM_SPOT_LIGHTS > 0\n    for (int i = 0; i < HX_NUM_SPOT_LIGHTS; ++i) {\n        vec3 diffuse, specular;\n        hx_calculateLight(hx_spotLights[i], data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n\n        if (hx_spotLights[i].castShadows == 1) {\n            float shadow = hx_calculateShadows(hx_spotLights[i], hx_shadowMap, hx_viewPosition);\n            diffuse *= shadow;\n            specular *= shadow;\n        }\n\n        diffuseAccum += diffuse;\n        specularAccum += specular;\n    }\n    #endif\n\n// TODO: add support for local probes\n\n    #if HX_NUM_DIFFUSE_PROBES > 0\n    vec3 worldNormal = mat3(hx_cameraWorldMatrix) * data.normal;\n    for (int i = 0; i < HX_NUM_DIFFUSE_PROBES; ++i) {\n        diffuseAccum += hx_calculateDiffuseProbeLight(hx_diffuseProbeMaps[i], worldNormal) * ao;\n    }\n    #endif\n\n    #if HX_NUM_SPECULAR_PROBES > 0\n    vec3 reflectedViewDir = reflect(viewVector, data.normal);\n    vec3 fresnel = hx_fresnelProbe(specularColor, reflectedViewDir, data.normal, data.roughness);\n\n    reflectedViewDir = mat3(hx_cameraWorldMatrix) * reflectedViewDir;\n\n   for (int i = 0; i < HX_NUM_SPECULAR_PROBES; ++i) {\n        specularAccum += hx_calculateSpecularProbeLight(hx_specularProbeMaps[i], hx_specularProbeNumMips[i], reflectedViewDir, fresnel, data.roughness) * ao;\n    }\n    #endif\n\n    hx_FragColor = vec4((diffuseAccum + hx_ambientColor * ao) * data.color.xyz + specularAccum + data.emission, data.color.w);\n}';

	ShaderLibrary._files['material_fwd_fixed_vertex.glsl'] = 'varying_out vec3 hx_viewPosition;\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n    hx_geometry();\n    // we need to do an unprojection here to be sure to have skinning - or anything like that - support\n    hx_viewPosition = (hx_inverseProjectionMatrix * gl_Position).xyz;\n}';

	ShaderLibrary._files['material_fwd_point_fragment.glsl'] = 'varying_in vec3 hx_viewPosition;\n\nuniform HX_PointLight hx_pointLight;\n\nuniform sampler2D hx_shadowMap;\n\nvoid main()\n{\n    HX_GeometryData data = hx_geometry();\n\n    vec3 viewVector = normalize(hx_viewPosition);\n    vec3 diffuse, specular;\n\n    vec3 specularColor = mix(vec3(data.normalSpecularReflectance), data.color.xyz, data.metallicness);\n    data.color.xyz *= 1.0 - data.metallicness;\n\n    hx_calculateLight(hx_pointLight, data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n\n    hx_FragColor = vec4(diffuse * data.color.xyz + specular, data.color.w);\n\n    if (hx_pointLight.castShadows == 1)\n        hx_FragColor.xyz *= hx_calculateShadows(hx_pointLight, hx_shadowMap, hx_viewPosition);\n}';

	ShaderLibrary._files['material_fwd_point_vertex.glsl'] = 'varying_out vec3 hx_viewPosition;\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n    hx_geometry();\n    hx_viewPosition = (hx_inverseProjectionMatrix * gl_Position).xyz;\n}';

	ShaderLibrary._files['material_fwd_probe_fragment.glsl'] = 'varying_in vec3 hx_viewPosition;\nvarying_in vec3 hx_worldPosition;\n\nuniform samplerCube hx_diffuseProbeMap;\nuniform samplerCube hx_specularProbeMap;\nuniform float hx_specularProbeNumMips;\n\nuniform mat4 hx_cameraWorldMatrix;\n\n#ifdef HX_SSAO\nuniform vec2 hx_rcpRenderTargetResolution;\nuniform sampler2D hx_ssao;\n#endif\n\nuniform float hx_probeSize;\nuniform vec3 hx_probePosition;\nuniform float hx_probeLocal;\n\nvoid main()\n{\n    HX_GeometryData data = hx_geometry();\n\n    vec3 viewVector = normalize(hx_viewPosition);\n\n    vec3 specularColor = mix(vec3(data.normalSpecularReflectance), data.color.xyz, data.metallicness);\n    data.color.xyz *= 1.0 - data.metallicness;\n\n    // TODO: We should be able to change the base of TBN in vertex shader\n    vec3 worldNormal = mat3(hx_cameraWorldMatrix) * data.normal;\n    vec3 reflectedViewDir = reflect(viewVector, data.normal);\n    vec3 fresnel = hx_fresnelProbe(specularColor, reflectedViewDir, data.normal, data.roughness);\n    reflectedViewDir = mat3(hx_cameraWorldMatrix) * reflectedViewDir;\n    vec3 diffRay = hx_intersectCubeMap(hx_worldPosition, hx_probePosition, worldNormal, hx_probeSize);\n    vec3 specRay = hx_intersectCubeMap(hx_worldPosition, hx_probePosition, reflectedViewDir, hx_probeSize);\n    diffRay = mix(worldNormal, diffRay, hx_probeLocal);\n    specRay = mix(reflectedViewDir, specRay, hx_probeLocal);\n    vec3 diffuse = hx_calculateDiffuseProbeLight(hx_diffuseProbeMap, diffRay);\n    vec3 specular = hx_calculateSpecularProbeLight(hx_specularProbeMap, hx_specularProbeNumMips, specRay, fresnel, data.roughness);\n\n    hx_FragColor = vec4((diffuse * data.color.xyz + specular) * data.occlusion, data.color.w);\n\n    #ifdef HX_SSAO\n    vec2 screenUV = gl_FragCoord.xy * hx_rcpRenderTargetResolution;\n    hx_FragColor.xyz *= texture2D(hx_ssao, screenUV).x;\n    #endif\n}';

	ShaderLibrary._files['material_fwd_probe_vertex.glsl'] = 'varying_out vec3 hx_viewPosition;\nvarying_out vec3 hx_worldPosition;\nuniform mat4 hx_inverseProjectionMatrix;\nuniform mat4 hx_worldMatrix;\n\nvoid main()\n{\n    hx_geometry();\n    hx_worldPosition = (hx_worldMatrix * gl_Position).xyz;\n    hx_viewPosition = (hx_inverseProjectionMatrix * gl_Position).xyz;\n}';

	ShaderLibrary._files['material_fwd_spot_fragment.glsl'] = 'varying_in vec3 hx_viewPosition;\n\nuniform HX_SpotLight hx_spotLight;\n\nuniform sampler2D hx_shadowMap;\n\nvoid main()\n{\n    HX_GeometryData data = hx_geometry();\n\n    vec3 viewVector = normalize(hx_viewPosition);\n    vec3 diffuse, specular;\n\n    vec3 specularColor = mix(vec3(data.normalSpecularReflectance), data.color.xyz, data.metallicness);\n    data.color.xyz *= 1.0 - data.metallicness;\n\n    hx_calculateLight(hx_spotLight, data, viewVector, hx_viewPosition, specularColor, diffuse, specular);\n\n    hx_FragColor = vec4(diffuse * data.color.xyz + specular, data.color.w);\n\n    if (hx_spotLight.castShadows == 1)\n        hx_FragColor.xyz *= hx_calculateShadows(hx_spotLight, hx_shadowMap, hx_viewPosition);\n}';

	ShaderLibrary._files['material_fwd_spot_vertex.glsl'] = 'varying_out vec3 hx_viewPosition;\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n    hx_geometry();\n    hx_viewPosition = (hx_inverseProjectionMatrix * gl_Position).xyz;\n}';

	ShaderLibrary._files['material_normal_depth_fragment.glsl'] = 'varying_in float hx_linearDepth;\n\nvoid main()\n{\n    HX_GeometryData data = hx_geometry();\n    hx_FragColor.xy = hx_encodeNormal(data.normal);\n    hx_FragColor.zw = hx_floatToRG8(hx_linearDepth);\n}';

	ShaderLibrary._files['material_normal_depth_vertex.glsl'] = 'varying_out float hx_linearDepth;\n\nuniform float hx_rcpCameraFrustumRange;\nuniform float hx_cameraNearPlaneDistance;\n\nvoid main()\n{\n    hx_geometry();\n\n    hx_linearDepth = (gl_Position.w - hx_cameraNearPlaneDistance) * hx_rcpCameraFrustumRange;\n}';

	ShaderLibrary._files['material_point_shadow_fragment.glsl'] = 'varying_in vec3 hx_viewPosition;\n\nuniform float hx_rcpRadius;\n\nvoid main()\n{\n    // geometry is really only used for kil instructions if necessary\n    // hopefully the compiler optimizes the rest out for us\n    HX_GeometryData data = hx_geometry();\n\n    hx_FragColor = hx_getShadowMapValue(length(hx_viewPosition) * hx_rcpRadius);\n}';

	ShaderLibrary._files['material_point_shadow_vertex.glsl'] = 'varying_out vec3 hx_viewPosition;\n\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n    hx_geometry();\n    hx_viewPosition = (hx_inverseProjectionMatrix * gl_Position).xyz;\n\n    // this shrinks it down to leave some room for filtering\n    gl_Position.xy *= .95;\n}';

	ShaderLibrary._files['material_unlit_fragment.glsl'] = 'void main()\n{\n    HX_GeometryData data = hx_geometry();\n    hx_FragColor = data.color;\n    hx_FragColor.xyz += data.emission;\n}';

	ShaderLibrary._files['material_unlit_vertex.glsl'] = 'void main()\n{\n    hx_geometry();\n}';

	ShaderLibrary._files['blend_color_copy_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D sampler;\n\nuniform vec4 blendColor;\n\nvoid main()\n{\n    // extractChannel comes from a macro\n   hx_FragColor = texture2D(sampler, uv) * blendColor;\n}\n';

	ShaderLibrary._files['copy_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D sampler;\n\nvoid main()\n{\n    // extractChannel comes from a macro\n   hx_FragColor = vec4(extractChannels(texture2D(sampler, uv)));\n\n#ifndef COPY_ALPHA\n   hx_FragColor.a = 1.0;\n#endif\n}\n';

	ShaderLibrary._files['copy_to_gamma_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D sampler;\n\nvoid main()\n{\n   hx_FragColor = hx_linearToGamma(texture2D(sampler, uv));\n}';

	ShaderLibrary._files['copy_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\nvertex_attribute vec2 hx_texCoord;\n\nvarying_out vec2 uv;\n\nvoid main()\n{\n    uv = hx_texCoord;\n    gl_Position = hx_position;\n}';

	ShaderLibrary._files['null_fragment.glsl'] = 'void main()\n{\n   hx_FragColor = vec4(1.0);\n}\n';

	ShaderLibrary._files['null_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\n\nvoid main()\n{\n    gl_Position = hx_position;\n}';

	ShaderLibrary._files['bloom_composite_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D bloomTexture;\nuniform sampler2D hx_backbuffer;\nuniform float strength;\n\nvoid main()\n{\n	hx_FragColor = texture2D(hx_backbuffer, uv) + texture2D(bloomTexture, uv) * strength;\n}';

	ShaderLibrary._files['bloom_composite_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\nvertex_attribute vec2 hx_texCoord;\n\nvarying_out vec2 uv;\n\nvoid main()\n{\n	   uv = hx_texCoord;\n	   gl_Position = hx_position;\n}';

	ShaderLibrary._files['bloom_threshold_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D hx_backbuffer;\n\nuniform float threshold;\n\nvoid main()\n{\n        vec4 color = texture2D(hx_backbuffer, uv);\n        float originalLuminance = .05 + hx_luminance(color);\n        float targetLuminance = max(originalLuminance - threshold, 0.0);\n        hx_FragColor = color * targetLuminance / originalLuminance;\n}\n';

	ShaderLibrary._files['default_post_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\nvertex_attribute vec2 hx_texCoord;\n\nvarying_out vec2 uv;\n\nvoid main()\n{\n	uv = hx_texCoord;\n	gl_Position = hx_position;\n}';

	ShaderLibrary._files['fog_fragment.glsl'] = 'varying_in vec2 uv;\nvarying_in vec3 viewDir;\n\nuniform vec3 tint;\nuniform float density;\nuniform float startDistance;\nuniform float heightFallOff;\n\nuniform float hx_cameraFrustumRange;\nuniform float hx_cameraNearPlaneDistance;\nuniform vec3 hx_cameraWorldPosition;\n\nuniform sampler2D hx_normalDepthBuffer;\nuniform sampler2D hx_backbuffer;\n\nvoid main()\n{\n    vec4 normalDepth = texture2D(hx_normalDepthBuffer, uv);\n	vec4 color = texture2D(hx_backbuffer, uv);\n	float depth = hx_decodeLinearDepth(normalDepth);\n	// do not fog up skybox\n	if (normalDepth.z == 1.0 && normalDepth.w == 1.0) depth = 0.0;\n	float absViewY = hx_cameraNearPlaneDistance + depth * hx_cameraFrustumRange;\n	vec3 viewVec = viewDir * absViewY;\n	float fogFactor = max(length(viewVec) - startDistance, 0.0);// * exp(-heightFallOff * hx_cameraWorldPosition.y);\n//    if( abs( viewVec.y ) > 0.1 )\n//	{\n		float t = heightFallOff * (viewVec.z + hx_cameraWorldPosition.z);\n		fogFactor *= saturate(( 1.0 - exp( -t ) ) / t);\n//	}\n\n	float fog = clamp(exp(-fogFactor * density), 0.0, 1.0);\n	color.xyz = mix(tint, color.xyz, fog);\n	hx_FragColor = color;\n}';

	ShaderLibrary._files['fog_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\nvertex_attribute vec2 hx_texCoord;\n\nvarying_out vec2 uv;\nvarying_out vec3 viewDir;\n\nuniform mat4 hx_inverseProjectionMatrix;\nuniform mat4 hx_cameraWorldMatrix;\n\nvoid main()\n{\n    uv = hx_texCoord;\n    viewDir = mat3(hx_cameraWorldMatrix) * hx_getLinearDepthViewVector(hx_position.xy, hx_inverseProjectionMatrix);\n    gl_Position = hx_position;\n}';

	ShaderLibrary._files['fxaa_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D hx_backbuffer;\nuniform vec2 hx_rcpRenderTargetResolution;\nuniform float edgeThreshold;\nuniform float edgeThresholdMin;\nuniform float edgeSharpness;\n\nfloat luminanceHint(vec4 color)\n{\n	return .30/.59 * color.r + color.g;\n}\n\nvoid main()\n{\n	vec4 center = texture2D(hx_backbuffer, uv);\n	vec2 halfRes = vec2(hx_rcpRenderTargetResolution.x, hx_rcpRenderTargetResolution.y) * .5;\n	float topLeftLum = luminanceHint(texture2D(hx_backbuffer, uv + vec2(-halfRes.x, halfRes.y)));\n	float bottomLeftLum = luminanceHint(texture2D(hx_backbuffer, uv + vec2(-halfRes.x, -halfRes.y)));\n	float topRightLum = luminanceHint(texture2D(hx_backbuffer, uv + vec2(halfRes.x, halfRes.y)));\n	float bottomRightLum = luminanceHint(texture2D(hx_backbuffer, uv + vec2(halfRes.x, -halfRes.y)));\n\n	float centerLum = luminanceHint(center);\n	float minLum = min(min(topLeftLum, bottomLeftLum), min(topRightLum, bottomRightLum));\n	float maxLum = max(max(topLeftLum, bottomLeftLum), max(topRightLum, bottomRightLum));\n	float range = max(centerLum, maxLum) - min(centerLum, minLum);\n	float threshold = max(edgeThresholdMin, maxLum * edgeThreshold);\n	float applyFXAA = range < threshold? 0.0 : 1.0;\n\n	float diagDiff1 = bottomLeftLum - topRightLum;\n	float diagDiff2 = bottomRightLum - topLeftLum;\n	vec2 dir1 = normalize(vec2(diagDiff1 + diagDiff2, diagDiff1 - diagDiff2));\n	vec4 sampleNeg1 = texture2D(hx_backbuffer, uv - halfRes * dir1);\n	vec4 samplePos1 = texture2D(hx_backbuffer, uv + halfRes * dir1);\n\n	float minComp = min(abs(dir1.x), abs(dir1.y)) * edgeSharpness;\n	vec2 dir2 = clamp(dir1.xy / minComp, -2.0, 2.0) * 2.0;\n	vec4 sampleNeg2 = texture2D(hx_backbuffer, uv - hx_rcpRenderTargetResolution * dir2);\n	vec4 samplePos2 = texture2D(hx_backbuffer, uv + hx_rcpRenderTargetResolution * dir2);\n	vec4 tap1 = sampleNeg1 + samplePos1;\n	vec4 fxaa = (tap1 + sampleNeg2 + samplePos2) * .25;\n	float fxaaLum = luminanceHint(fxaa);\n	if ((fxaaLum < minLum) || (fxaaLum > maxLum))\n		fxaa = tap1 * .5;\n	hx_FragColor = mix(center, fxaa, applyFXAA);\n}';

	ShaderLibrary._files['gaussian_blur_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D sourceTexture;\n\nuniform vec2 stepSize;\n\nuniform float gaussianWeights[NUM_WEIGHTS];\n\nvoid main()\n{\n	vec4 total = texture2D(sourceTexture, uv) * gaussianWeights[0];\n    vec2 offset = vec2(0.0);\n\n	for (int i = 1; i <= RADIUS; ++i) {\n		offset += stepSize;\n	    vec4 s = texture2D(sourceTexture, uv + offset) + texture2D(sourceTexture, uv - offset);\n		total += s * gaussianWeights[i];\n	}\n\n	hx_FragColor = total;\n}';

	ShaderLibrary._files['gaussian_blur_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\nvertex_attribute vec2 hx_texCoord;\n\nvarying_out vec2 uv;\n\nvoid main()\n{\n	uv = hx_texCoord;\n	gl_Position = hx_position;\n}';

	ShaderLibrary._files['post_viewpos_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\nvertex_attribute vec2 hx_texCoord;\n\nvarying_out vec2 uv;\nvarying_out vec3 viewDir;\n\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n    uv = hx_texCoord;\n    viewDir = hx_getLinearDepthViewVector(hx_position.xy, hx_inverseProjectionMatrix);\n    gl_Position = hx_position;\n}';

	ShaderLibrary._files['ssr_fragment.glsl'] = '#derivatives\n\n// TODO: This won\'t work anymore\nuniform sampler2D hx_gbufferColor;\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D hx_gbufferSpecular;\nuniform sampler2D hx_gbufferDepth;\nuniform sampler2D hx_dither2D;\nuniform vec2 hx_renderTargetResolution;\n\nuniform sampler2D hx_frontbuffer;\n\nvarying_in vec2 uv;\nvarying_in vec3 viewDir;\n\nuniform vec2 ditherTextureScale;\nuniform float hx_cameraNearPlaneDistance;\nuniform float hx_cameraFrustumRange;\nuniform float hx_rcpCameraFrustumRange;\nuniform mat4 hx_projectionMatrix;\n\nuniform float maxDistance;\nuniform float stepSize;\nuniform float maxRoughness;\n\n// all in viewspace\n// 0 is start, 1 is end\nfloat raytrace(in vec3 ray0, in vec3 rayDir, out float hitZ, out vec2 hitUV)\n{\n    vec4 dither = hx_sampleDefaultDither(hx_dither2D, uv * ditherTextureScale);\n    // Clip to the near plane\n	float rayLength = ((ray0.z + rayDir.z * maxDistance) > -hx_cameraNearPlaneDistance) ?\n						(-hx_cameraNearPlaneDistance - ray0.z) / rayDir.z : maxDistance;\n\n    vec3 ray1 = ray0 + rayDir * rayLength;\n\n    // only need the w component for perspective correct interpolation\n    // need to get adjusted ray end\'s uv value\n    vec4 hom0 = hx_projectionMatrix * vec4(ray0, 1.0);\n    vec4 hom1 = hx_projectionMatrix * vec4(ray1, 1.0);\n    float rcpW0 = 1.0 / hom0.w;\n    float rcpW1 = 1.0 / hom1.w;\n\n    hom0 *= rcpW0;\n    hom1 *= rcpW1;\n\n    // expressed in pixels, so we can snap to 1\n    // need to figure out the ratio between 1 pixel and the entire line \"width\" (if primarily vertical, it\'s actually height)\n\n    // line dimensions in pixels:\n\n    vec2 pixelSize = (hom1.xy - hom0.xy) * hx_renderTargetResolution * .5;\n\n    // line-\"width\" = max(abs(pixelSize.x), abs(pixelSize.y))\n    // ratio pixel/width = 1 / max(abs(pixelSize.x), abs(pixelSize.y))\n\n    float stepRatio = 1.0 / max(abs(pixelSize.x), abs(pixelSize.y)) * stepSize;\n\n    vec2 uvEnd = hom1.xy * .5 + .5;\n\n    vec2 dUV = (uvEnd - uv) * stepRatio;\n    hitUV = uv;\n\n    // linear depth\n    float rayDepth = (-ray0.z - hx_cameraNearPlaneDistance) * hx_rcpCameraFrustumRange;\n    float rayPerspDepth0 = rayDepth * rcpW0;\n    float rayPerspDepth1 = (-ray1.z - hx_cameraNearPlaneDistance) * hx_rcpCameraFrustumRange * rcpW1;\n    float rayPerspDepth = rayPerspDepth0;\n    // could probably optimize this:\n    float dRayD = (rayPerspDepth1 - rayPerspDepth0) * stepRatio;\n\n    float rcpW = rcpW0;\n    float dRcpW = (rcpW1 - rcpW0) * stepRatio;\n    float sceneDepth = rayDepth;\n\n    float amount = 0.0;\n\n    hitUV += dUV * dither.z;\n    rayPerspDepth += dRayD * dither.z;\n    rcpW += dRcpW * dither.z;\n\n    float sampleCount;\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        rayDepth = rayPerspDepth / rcpW;\n\n        sceneDepth = hx_sampleLinearDepth(hx_gbufferDepth, hitUV);\n\n        if (rayDepth > sceneDepth + .001) {\n            amount = float(sceneDepth < 1.0);\n            sampleCount = float(i);\n            break;\n        }\n\n        hitUV += dUV;\n        rayPerspDepth += dRayD;\n        rcpW += dRcpW;\n    }\n\n    hitZ = -hx_cameraNearPlaneDistance - sceneDepth * hx_cameraFrustumRange;\n\n    amount *= clamp((1.0 - (sampleCount - float(NUM_SAMPLES)) / float(NUM_SAMPLES)) * 5.0, 0.0, 1.0);\n    return amount;\n}\n\nvoid main()\n{\n    vec4 colorSample = hx_gammaToLinear(texture2D(hx_gbufferColor, uv));\n    vec4 specularSample = texture2D(hx_gbufferSpecular, uv);\n    float depth = hx_sampleLinearDepth(hx_gbufferDepth, uv);\n    vec3 normalSpecularReflectance;\n    float roughness;\n    float metallicness;\n    hx_decodeReflectionData(colorSample, specularSample, normalSpecularReflectance, roughness, metallicness);\n    vec3 normal = hx_decodeNormal(texture2D(hx_gbufferNormals, uv));\n    vec3 reflDir = reflect(normalize(viewDir), normal);\n\n    vec3 fresnel = hx_fresnel(normalSpecularReflectance, reflDir, normal);\n    // not physically correct, but attenuation is required to look good\n\n    // step for every pixel\n\n    float absViewY = hx_cameraNearPlaneDistance + depth * hx_cameraFrustumRange;\n    vec3 viewSpacePos = absViewY * viewDir;\n\n    float hitY = 0.0;\n    vec2 hitUV;\n    float amount = raytrace(viewSpacePos, reflDir, hitY, hitUV);\n    float fadeFactor = 1.0 - clamp(reflDir.z * 2.0, 0.0, 1.0);\n\n    vec2 borderFactors = abs(hitUV * 2.0 - 1.0);\n    borderFactors = (1.0 - borderFactors) * 10.0;\n    fadeFactor *= clamp(borderFactors.x, 0.0, 1.0) * clamp(borderFactors.y, 0.0, 1.0);\n\n    float diff = viewSpacePos.y - hitY;\n    fadeFactor *= hx_linearStep(-1.0, 0.0, diff);\n    fadeFactor *= hx_linearStep(maxRoughness, 0.0, roughness);\n\n    vec4 reflColor = texture2D(hx_frontbuffer, hitUV);\n\n    float amountUsed = amount * fadeFactor;\n    hx_FragColor = vec4(fresnel * reflColor.xyz, amountUsed);\n}\n\n';

	ShaderLibrary._files['ssr_stencil_fragment.glsl'] = 'uniform sampler2D hx_gbufferSpecular;\n\nvarying_in vec2 uv;\n\nuniform float maxRoughness;\n\nvoid main()\n{\n    vec4 specularSample = texture2D(hx_gbufferSpecular, uv);\n    if (specularSample.x > maxRoughness)\n        discard;\n}\n\n';

	ShaderLibrary._files['tonemap_filmic_fragment.glsl'] = 'void main()\n{\n	vec3 x = hx_getToneMapScaledColor().xyz * 16.0;\n\n    // Uncharted 2 tonemapping (http://filmicworlds.com/blog/filmic-tonemapping-operators/)\n\n	float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    float W = 11.2;\n\n    hx_FragColor.xyz = hx_gammaToLinear(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);\n    hx_FragColor.w = 1.0;\n}';

	ShaderLibrary._files['tonemap_reference_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D hx_backbuffer;\n\nvoid main()\n{\n	vec4 color = texture2D(hx_backbuffer, uv);\n	float lum = clamp(hx_luminance(color), 0.0, 1000.0);\n	float l = log(1.0 + lum);\n	hx_FragColor = vec4(l, l, l, 1.0);\n}';

	ShaderLibrary._files['tonemap_reinhard_fragment.glsl'] = 'void main()\n{\n	vec4 color = hx_getToneMapScaledColor();\n	float lum = hx_luminance(color);\n	hx_FragColor = color / (1.0 + lum);\n}';

	ShaderLibrary._files['esm_blur_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D source;\nuniform vec2 direction; // this is 1/pixelSize\n\nfloat readValue(vec2 coord)\n{\n    float v = texture2D(source, coord).x;\n    return v;\n//    return exp(HX_ESM_CONSTANT * v);\n}\n\nvoid main()\n{\n    float total = readValue(uv);\n\n	for (int i = 1; i <= RADIUS; ++i) {\n	    vec2 offset = direction * float(i);\n		total += readValue(uv + offset) + readValue(uv - offset);\n	}\n\n//	hx_FragColor = vec4(log(total * RCP_NUM_SAMPLES) / HX_ESM_CONSTANT);\n	hx_FragColor = vec4(total * RCP_NUM_SAMPLES);\n}';

	ShaderLibrary._files['shadow_esm.glsl'] = 'vec4 hx_getShadowMapValue(float depth)\n{\n    // I wish we could write exp directly, but precision issues (can\'t encode real floats)\n    return vec4(exp(HX_ESM_CONSTANT * depth));\n// so when blurring, we\'ll need to do ln(sum(exp())\n//    return vec4(depth);\n}\n\nfloat hx_readShadow(sampler2D shadowMap, vec4 shadowMapCoord, float depthBias)\n{\n    float shadowSample = texture2D(shadowMap, shadowMapCoord.xy).x;\n    shadowMapCoord.z += depthBias;\n//    float diff = shadowSample - shadowMapCoord.z;\n//    return saturate(HX_ESM_DARKENING * exp(HX_ESM_CONSTANT * diff));\n    return saturate(HX_ESM_DARKENING * shadowSample * exp(-HX_ESM_CONSTANT * shadowMapCoord.z));\n}';

	ShaderLibrary._files['shadow_hard.glsl'] = 'vec4 hx_getShadowMapValue(float depth)\n{\n    return hx_floatToRGBA8(depth);\n}\n\nfloat hx_readShadow(sampler2D shadowMap, vec4 shadowMapCoord, float depthBias)\n{\n    float shadowSample = hx_RGBA8ToFloat(texture2D(shadowMap, shadowMapCoord.xy));\n    float diff = shadowMapCoord.z - shadowSample - depthBias;\n    return float(diff < 0.0);\n}';

	ShaderLibrary._files['shadow_pcf.glsl'] = '#ifdef HX_PCF_DITHER_SHADOWS\n    uniform sampler2D hx_dither2D;\n    uniform vec2 hx_dither2DTextureScale;\n#endif\n\nuniform vec2 hx_poissonDisk[32];\n\nvec4 hx_getShadowMapValue(float depth)\n{\n    return hx_floatToRGBA8(depth);\n}\n\nfloat hx_readShadow(sampler2D shadowMap, vec4 shadowMapCoord, float depthBias)\n{\n    float shadowTest = 0.0;\n\n    #ifdef HX_PCF_DITHER_SHADOWS\n        vec4 dither = hx_sampleDefaultDither(hx_dither2D, gl_FragCoord.xy * hx_dither2DTextureScale);\n        dither = vec4(dither.x, -dither.y, dither.y, dither.x) * HX_PCF_SOFTNESS;  // add radius scale\n    #endif\n\n    for (int i = 0; i < HX_PCF_NUM_SHADOW_SAMPLES; ++i) {\n        vec2 offset;\n        #ifdef HX_PCF_DITHER_SHADOWS\n        offset.x = dot(dither.xy, hx_poissonDisk[i]);\n        offset.y = dot(dither.zw, hx_poissonDisk[i]);\n        #else\n        offset = hx_poissonDisk[i] * HX_PCF_SOFTNESS;\n        #endif\n        float shadowSample = hx_RGBA8ToFloat(texture2D(shadowMap, shadowMapCoord.xy + offset));\n        float diff = shadowMapCoord.z - shadowSample - depthBias;\n        shadowTest += float(diff < 0.0);\n    }\n\n    return shadowTest * HX_PCF_RCP_NUM_SHADOW_SAMPLES;\n}';

	ShaderLibrary._files['shadow_vsm.glsl'] = '#derivatives\n\nvec4 hx_getShadowMapValue(float depth)\n{\n    float dx = dFdx(depth);\n    float dy = dFdy(depth);\n    float moment2 = depth * depth + 0.25*(dx*dx + dy*dy);\n\n    #if defined(HX_HALF_FLOAT_TEXTURES_LINEAR) || defined(HX_FLOAT_TEXTURES_LINEAR)\n    return vec4(depth, moment2, 0.0, 1.0);\n    #else\n    return vec4(hx_floatToRG8(depth), hx_floatToRG8(moment2));\n    #endif\n}\n\nfloat hx_readShadow(sampler2D shadowMap, vec4 shadowMapCoord, float depthBias)\n{\n    vec4 s = texture2D(shadowMap, shadowMapCoord.xy);\n    #if defined(HX_HALF_FLOAT_TEXTURES_LINEAR) || defined(HX_FLOAT_TEXTURES_LINEAR)\n    vec2 moments = s.xy;\n    #else\n    vec2 moments = vec2(hx_RG8ToFloat(s.xy), hx_RG8ToFloat(s.zw));\n    #endif\n    shadowMapCoord.z += depthBias;\n\n    float variance = moments.y - moments.x * moments.x;\n    variance = max(variance, HX_VSM_MIN_VARIANCE);\n\n    float diff = shadowMapCoord.z - moments.x;\n    float upperBound = 1.0;\n\n    // transparents could be closer to the light than casters\n    if (diff > 0.0)\n        upperBound = variance / (variance + diff*diff);\n\n    return saturate((upperBound - HX_VSM_LIGHT_BLEED_REDUCTION) * HX_VSM_RCP_LIGHT_BLEED_REDUCTION_RANGE);\n}';

	ShaderLibrary._files['vsm_blur_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D source;\nuniform vec2 direction; // this is 1/pixelSize\n\nvec2 readValues(vec2 coord)\n{\n    vec4 s = texture2D(source, coord);\n    #if defined(HX_HALF_FLOAT_TEXTURES_LINEAR) || defined(HX_FLOAT_TEXTURES_LINEAR)\n    return s.xy;\n    #else\n    return vec2(hx_RG8ToFloat(s.xy), hx_RG8ToFloat(s.zw));\n    #endif\n}\n\nvoid main()\n{\n    vec2 total = readValues(uv);\n\n	for (int i = 1; i <= RADIUS; ++i) {\n	    vec2 offset = direction * float(i);\n		total += readValues(uv + offset) + readValues(uv - offset);\n	}\n\n    total *= RCP_NUM_SAMPLES;\n\n#if defined(HX_HALF_FLOAT_TEXTURES_LINEAR) || defined(HX_FLOAT_TEXTURES_LINEAR)\n    hx_FragColor = vec4(total, 0.0, 1.0);\n#else\n	hx_FragColor.xy = hx_floatToRG8(total.x);\n	hx_FragColor.zw = hx_floatToRG8(total.y);\n#endif\n}';

	ShaderLibrary._files['snippets_general.glsl'] = '#define HX_LOG_10 2.302585093\n\n#ifdef HX_GLSL_300_ES\n// replace some outdated function names\nvec4 texture2D(sampler2D s, vec2 uv) { return texture(s, uv); }\nvec4 textureCube(samplerCube s, vec3 uvw) { return texture(s, uvw); }\n\n#define vertex_attribute in\n#define varying_in in\n#define varying_out out\n\n#ifdef HX_FRAGMENT_SHADER\nout vec4 hx_FragColor;\n#endif\n\n#else\n\n#define vertex_attribute attribute\n#define varying_in varying\n#define varying_out varying\n#define hx_FragColor gl_FragColor\n\n#endif\n\nfloat saturate(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\nvec2 saturate(vec2 value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\nvec4 saturate(vec4 value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\n// Only for 0 - 1\nvec4 hx_floatToRGBA8(float value)\n{\n    vec4 enc = value * vec4(1.0, 255.0, 65025.0, 16581375.0);\n    // cannot fract first value or 1 would not be encodable\n    enc.yzw = fract(enc.yzw);\n    return enc - enc.yzww * vec4(1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n}\n\nfloat hx_RGBA8ToFloat(vec4 rgba)\n{\n    return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0));\n}\n\nvec2 hx_floatToRG8(float value)\n{\n    vec2 enc = vec2(1.0, 255.0) * value;\n    enc.y = fract(enc.y);\n    enc.x -= enc.y / 255.0;\n    return enc;\n}\n\nfloat hx_RG8ToFloat(vec2 rg)\n{\n    return dot(rg, vec2(1.0, 1.0/255.0));\n}\n\nvec2 hx_encodeNormal(vec3 normal)\n{\n    vec2 data;\n    float p = sqrt(-normal.y*8.0 + 8.0);\n    data = normal.xz / p + .5;\n    return data;\n}\n\nvec3 hx_decodeNormal(vec4 data)\n{\n    vec3 normal;\n    data.xy = data.xy*4.0 - 2.0;\n    float f = dot(data.xy, data.xy);\n    float g = sqrt(1.0 - f * .25);\n    normal.xz = data.xy * g;\n    normal.y = -(1.0 - f * .5);\n    return normal;\n}\n\nfloat hx_log10(float val)\n{\n    return log(val) / HX_LOG_10;\n}\n\nvec4 hx_gammaToLinear(vec4 color)\n{\n    #if defined(HX_GAMMA_CORRECTION_PRECISE)\n        color.x = pow(color.x, 2.2);\n        color.y = pow(color.y, 2.2);\n        color.z = pow(color.z, 2.2);\n    #elif defined(HX_GAMMA_CORRECTION_FAST)\n        color.xyz *= color.xyz;\n    #endif\n    return color;\n}\n\nvec3 hx_gammaToLinear(vec3 color)\n{\n    #if defined(HX_GAMMA_CORRECTION_PRECISE)\n        color.x = pow(color.x, 2.2);\n        color.y = pow(color.y, 2.2);\n        color.z = pow(color.z, 2.2);\n    #elif defined(HX_GAMMA_CORRECTION_FAST)\n        color.xyz *= color.xyz;\n    #endif\n    return color;\n}\n\nvec4 hx_linearToGamma(vec4 linear)\n{\n    #if defined(HX_GAMMA_CORRECTION_PRECISE)\n        linear.x = pow(linear.x, 0.454545);\n        linear.y = pow(linear.y, 0.454545);\n        linear.z = pow(linear.z, 0.454545);\n    #elif defined(HX_GAMMA_CORRECTION_FAST)\n        linear.xyz = sqrt(linear.xyz);\n    #endif\n    return linear;\n}\n\nvec3 hx_linearToGamma(vec3 linear)\n{\n    #if defined(HX_GAMMA_CORRECTION_PRECISE)\n        linear.x = pow(linear.x, 0.454545);\n        linear.y = pow(linear.y, 0.454545);\n        linear.z = pow(linear.z, 0.454545);\n    #elif defined(HX_GAMMA_CORRECTION_FAST)\n        linear.xyz = sqrt(linear.xyz);\n    #endif\n    return linear;\n}\n\n/*float hx_sampleLinearDepth(sampler2D tex, vec2 uv)\n{\n    return hx_RGBA8ToFloat(texture2D(tex, uv));\n}*/\n\nfloat hx_decodeLinearDepth(vec4 samp)\n{\n    return hx_RG8ToFloat(samp.zw);\n}\n\nvec3 hx_getFrustumVector(vec2 position, mat4 unprojectionMatrix)\n{\n    vec4 unprojNear = unprojectionMatrix * vec4(position, -1.0, 1.0);\n    vec4 unprojFar = unprojectionMatrix * vec4(position, 1.0, 1.0);\n    return unprojFar.xyz/unprojFar.w - unprojNear.xyz/unprojNear.w;\n}\n\n// view vector with z = 1, so we can use nearPlaneDist + linearDepth * (farPlaneDist - nearPlaneDist) as a scale factor to find view space position\nvec3 hx_getLinearDepthViewVector(vec2 position, mat4 unprojectionMatrix)\n{\n    vec4 unproj = unprojectionMatrix * vec4(position, 0.0, 1.0);\n    unproj /= unproj.w;\n    return unproj.xyz / unproj.y;\n}\n\n// THIS IS FOR NON_LINEAR DEPTH!\nfloat hx_depthToViewY(float depthSample, mat4 projectionMatrix)\n{\n    // View Y maps to NDC Z!!!\n    // y = projectionMatrix[3][2] / (d * 2.0 - 1.0 + projectionMatrix[1][2])\n    return projectionMatrix[3][2] / (depthSample * 2.0 - 1.0 + projectionMatrix[1][2]);\n}\n\nvec3 hx_getNormalSpecularReflectance(float metallicness, float insulatorNormalSpecularReflectance, vec3 color)\n{\n    return mix(vec3(insulatorNormalSpecularReflectance), color, metallicness);\n}\n\nvec3 hx_fresnel(vec3 normalSpecularReflectance, vec3 lightDir, vec3 halfVector)\n{\n    float cosAngle = 1.0 - max(dot(halfVector, lightDir), 0.0);\n    // to the 5th power\n    float power = pow(cosAngle, 5.0);\n    return normalSpecularReflectance + (1.0 - normalSpecularReflectance) * power;\n}\n\n// https://seblagarde.wordpress.com/2011/08/17/hello-world/\nvec3 hx_fresnelProbe(vec3 normalSpecularReflectance, vec3 lightDir, vec3 normal, float roughness)\n{\n    float cosAngle = 1.0 - max(dot(normal, lightDir), 0.0);\n    // to the 5th power\n    float power = pow(cosAngle, 5.0);\n    float gloss = (1.0 - roughness) * (1.0 - roughness);\n    vec3 bound = max(vec3(gloss), normalSpecularReflectance);\n    return normalSpecularReflectance + (bound - normalSpecularReflectance) * power;\n}\n\n\nfloat hx_luminance(vec4 color)\n{\n    return dot(color.xyz, vec3(.30, 0.59, .11));\n}\n\nfloat hx_luminance(vec3 color)\n{\n    return dot(color, vec3(.30, 0.59, .11));\n}\n\n// linear variant of smoothstep\nfloat hx_linearStep(float lower, float upper, float x)\n{\n    return clamp((x - lower) / (upper - lower), 0.0, 1.0);\n}\n\nvec4 hx_sampleDefaultDither(sampler2D ditherTexture, vec2 uv)\n{\n    vec4 s = texture2D(ditherTexture, uv);\n\n    #ifndef HX_FLOAT_TEXTURES\n    s = s * 2.0 - 1.0;\n    #endif\n\n    return s;\n}\n\nvec3 hx_intersectCubeMap(vec3 rayOrigin, vec3 cubeCenter, vec3 rayDir, float cubeSize)\n{\n    vec3 t = (cubeSize * sign(rayDir) - (rayOrigin - cubeCenter)) / rayDir;\n    float minT = min(min(t.x, t.y), t.z);\n    return rayOrigin + minT * rayDir;\n}\n\n// sadly, need a parameter due to a bug in Internet Explorer / Edge. Just pass in 0.\n#ifdef HX_USE_SKINNING_TEXTURE\n#define HX_RCP_MAX_SKELETON_JOINTS 1.0 / float(HX_MAX_SKELETON_JOINTS - 1)\nmat4 hx_getSkinningMatrixImpl(vec4 weights, vec4 indices, sampler2D tex)\n{\n    mat4 m = mat4(0.0);\n    for (int i = 0; i < 4; ++i) {\n        mat4 t;\n        float index = indices[i] * HX_RCP_MAX_SKELETON_JOINTS;\n        t[0] = texture2D(tex, vec2(index, 0.0));\n        t[1] = texture2D(tex, vec2(index, 0.5));\n        t[2] = texture2D(tex, vec2(index, 1.0));\n        t[3] = vec4(0.0, 0.0, 0.0, 1.0);\n        m += weights[i] * t;\n    }\n    return m;\n}\n#define hx_getSkinningMatrix(v) hx_getSkinningMatrixImpl(hx_jointWeights, hx_jointIndices, hx_skinningTexture)\n#else\n#define hx_getSkinningMatrix(v) ( hx_jointWeights.x * mat4(hx_skinningMatrices[int(hx_jointIndices.x) * 3], hx_skinningMatrices[int(hx_jointIndices.x) * 3 + 1], hx_skinningMatrices[int(hx_jointIndices.x) * 3 + 2], vec4(0.0, 0.0, 0.0, 1.0)) + hx_jointWeights.y * mat4(hx_skinningMatrices[int(hx_jointIndices.y) * 3], hx_skinningMatrices[int(hx_jointIndices.y) * 3 + 1], hx_skinningMatrices[int(hx_jointIndices.y) * 3 + 2], vec4(0.0, 0.0, 0.0, 1.0)) + hx_jointWeights.z * mat4(hx_skinningMatrices[int(hx_jointIndices.z) * 3], hx_skinningMatrices[int(hx_jointIndices.z) * 3 + 1], hx_skinningMatrices[int(hx_jointIndices.z) * 3 + 2], vec4(0.0, 0.0, 0.0, 1.0)) + hx_jointWeights.w * mat4(hx_skinningMatrices[int(hx_jointIndices.w) * 3], hx_skinningMatrices[int(hx_jointIndices.w) * 3 + 1], hx_skinningMatrices[int(hx_jointIndices.w) * 3 + 2], vec4(0.0, 0.0, 0.0, 1.0)) )\n#endif';

	ShaderLibrary._files['snippets_geometry.glsl'] = 'struct HX_GeometryData\n{\n    vec4 color;\n    vec3 normal;\n    float metallicness;\n    float normalSpecularReflectance;\n    float roughness;\n    float occlusion;\n    vec3 emission;\n    vec4 data;  // this can be anything the lighting model requires (only works with forward rendering)\n};';

	ShaderLibrary._files['snippets_tonemap.glsl'] = 'varying_in vec2 uv;\n\n#ifdef HX_ADAPTIVE\nuniform sampler2D hx_luminanceMap;\nuniform float hx_luminanceMipLevel;\n#endif\n\nuniform float hx_exposure;\nuniform float hx_key;\n\nuniform sampler2D hx_backbuffer;\n\n\nvec4 hx_getToneMapScaledColor()\n{\n    #ifdef HX_ADAPTIVE\n    #ifdef HX_GLSL_300_ES\n    float referenceLuminance = textureLod(hx_luminanceMap, uv, hx_luminanceMipLevel).x;\n    #else\n    float referenceLuminance = texture2DLodEXT(hx_luminanceMap, uv, hx_luminanceMipLevel).x;\n    #endif\n    referenceLuminance = exp(referenceLuminance) - 1.0;\n    referenceLuminance = clamp(referenceLuminance, .08, 1000.0);\n	float exposure = hx_key / referenceLuminance * hx_exposure;\n	#else\n	float exposure = hx_exposure;\n	#endif\n    return texture2D(hx_backbuffer, uv) * exposure;\n}';

	ShaderLibrary._files['2d_to_cube_vertex.glsl'] = '// position to write to\nvertex_attribute vec4 hx_position;\n\n// the corner of the cube map\nvertex_attribute vec3 corner;\n\nvarying_out vec3 direction;\n\nvoid main()\n{\n    direction = corner;\n    gl_Position = hx_position;\n}\n';

	ShaderLibrary._files['equirectangular_to_cube_fragment.glsl'] = '#define RECIPROCAL_PI2 0.15915494\n\nvarying_in vec3 direction;\n\nuniform sampler2D source;\n\nvoid main()\n{\n    vec3 dir = normalize(direction);\n    vec2 uv;\n    uv.x = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	uv.y = dir.y * 0.5 + 0.5;\n    hx_FragColor = texture2D(source, uv);\n}\n';

	ShaderLibrary._files['greyscale_to_rgba8.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D source;\n\nvoid main()\n{\n    hx_FragColor = hx_floatToRGBA8(texture2D(source, uv).x);\n}\n';

	ShaderLibrary._files['smooth_heightmap_fragment.glsl'] = 'varying_in vec2 uv;\n\nuniform sampler2D reference;    // the source (8 bit) texture\nuniform sampler2D source;\n\nuniform vec2 stepSize;\n\nvoid main()\n{\n    float gauss[4];\n    gauss[0] = 0.201788613113303;\n    gauss[1] = 0.17755834971394;\n    gauss[2] = 0.120969095455128;\n    gauss[3] = 0.063811162332456;\n    float refHeight = texture2D(reference, uv).x;\n    float total = hx_RGBA8ToFloat(texture2D(source, uv)) * gauss[0];\n    float totalWeight = gauss[0];\n    float currentWeightL = 1.0;\n    float currentWeightR = 1.0;\n    vec2 offset = vec2(0.0);\n\n\n    for (int i = 0; i < 3; ++i) {\n        offset += stepSize;\n        float refLeft = texture2D(reference, uv - offset).x;\n        float refRight = texture2D(reference, uv + offset).x;\n        float heightLeft = hx_RGBA8ToFloat(texture2D(source, uv - offset));\n        float heightRight = hx_RGBA8ToFloat(texture2D(source, uv + offset));\n        // smooth out over N pixels that have the same reference height in the source image\n        currentWeightL = max(currentWeightL - abs(refLeft - refHeight) * 5.0, 0.0);\n        currentWeightR = max(currentWeightR - abs(refRight - refHeight) * 5.0, 0.0);\n        totalWeight += (currentWeightL + currentWeightR) * gauss[i + 1];\n        total += (heightLeft * currentWeightL + heightRight * currentWeightR) *  gauss[i + 1];\n    }\n\n    hx_FragColor = hx_floatToRGBA8(total / totalWeight);\n//    hx_FragColor = hx_floatToRGBA8(refHeight);\n}\n';

	ShaderLibrary._files['ao_blur_fragment.glsl'] = 'varying_in vec2 uv1;\nvarying_in vec2 uv2;\nvarying_in vec2 uv3;\nvarying_in vec2 uv4;\n\nuniform sampler2D source;\n\nvoid main()\n{\n    vec4 total = texture2D(source, uv1) + texture2D(source, uv2) + texture2D(source, uv3) + texture2D(source, uv4);\n	hx_FragColor = total * .25;\n}';

	ShaderLibrary._files['ao_blur_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\nvertex_attribute vec2 hx_texCoord;\n\nvarying_out vec2 uv1;\nvarying_out vec2 uv2;\nvarying_out vec2 uv3;\nvarying_out vec2 uv4;\n\nuniform vec2 pixelSize;\n\nvoid main()\n{\n	uv1 = hx_texCoord + vec2(-1.5, .5) * pixelSize;\n	uv2 = hx_texCoord + vec2(.5, .5) * pixelSize;\n	uv3 = hx_texCoord + vec2(.5, -1.5) * pixelSize;\n	uv4 = hx_texCoord + vec2(-1.5, -1.5) * pixelSize;\n	gl_Position = hx_position;\n}';

	ShaderLibrary._files['hbao_fragment.glsl'] = 'uniform float hx_cameraFrustumRange;\nuniform float hx_cameraNearPlaneDistance;\nuniform vec2 hx_rcpRenderTargetResolution;\nuniform mat4 hx_projectionMatrix;\n\nuniform float strengthPerRay;\nuniform float halfSampleRadius;\nuniform float bias;\nuniform float rcpFallOffDistance;\nuniform vec2 ditherScale;\n\nuniform sampler2D hx_normalDepthBuffer;\nuniform sampler2D sampleDirTexture;\nuniform sampler2D ditherTexture;\n\nvarying_in vec2 uv;\nvarying_in vec3 viewDir;\nvarying_in vec3 frustumCorner;\n\nvec3 getViewPos(vec2 sampleUV)\n{\n    vec4 smp = texture2D(hx_normalDepthBuffer, sampleUV);\n    float depth = hx_decodeLinearDepth(smp);\n    float viewY = hx_cameraNearPlaneDistance + depth * hx_cameraFrustumRange;\n    vec3 viewPos = frustumCorner * vec3(sampleUV.x * 2.0 - 1.0, 1.0, sampleUV.y * 2.0 - 1.0);\n    return viewPos * viewY;\n}\n\n// Retrieves the occlusion factor for a particular sample\nfloat getSampleOcclusion(vec2 sampleUV, vec3 centerViewPos, vec3 centerNormal, vec3 tangent, inout float topOcclusion)\n{\n    vec3 sampleViewPos = getViewPos(sampleUV);\n\n    // get occlusion factor based on candidate horizon elevation\n    vec3 horizonVector = sampleViewPos - centerViewPos;\n    float horizonVectorLength = length(horizonVector);\n\n    float occlusion;\n\n    // If the horizon vector points away from the tangent, make an estimate\n    if (dot(tangent, horizonVector) < 0.0)\n        occlusion = .5;\n    else\n        occlusion = dot(centerNormal, horizonVector) / horizonVectorLength;\n\n    // this adds occlusion only if angle of the horizon vector is higher than the previous highest one without branching\n    float diff = max(occlusion - topOcclusion, 0.0);\n    topOcclusion = max(occlusion, topOcclusion);\n\n    // attenuate occlusion contribution using distance function 1 - (d/f)^2\n    float distanceFactor = 1.0 - saturate(horizonVectorLength * rcpFallOffDistance);\n    return diff * distanceFactor;\n}\n\n// Retrieves the occlusion for a given ray\nfloat getRayOcclusion(vec2 direction, float jitter, vec2 projectedRadii, vec3 centerViewPos, vec3 centerNormal)\n{\n    // calculate the nearest neighbour sample along the direction vector\n    vec2 texelSizedStep = direction * hx_rcpRenderTargetResolution;\n    direction *= projectedRadii;\n\n    // gets the tangent for the current ray, this will be used to handle opposing horizon vectors\n    // Tangent is corrected with respect to face normal by projecting it onto the tangent plane defined by the normal\n    vec3 tangent = getViewPos(uv + texelSizedStep) - centerViewPos;\n    tangent -= dot(centerNormal, tangent) * centerNormal;\n\n    vec2 stepUV = direction.xy / float(NUM_SAMPLES_PER_RAY - 1);\n\n    // jitter the starting position for ray marching between the nearest neighbour and the sample step size\n    vec2 jitteredOffset = mix(texelSizedStep, stepUV, jitter);\n    //stepUV *= 1.0 + jitter * .1;\n    vec2 sampleUV = uv + jitteredOffset;\n\n    // top occlusion keeps track of the occlusion contribution of the last found occluder.\n    // set to bias value to avoid near-occluders\n    float topOcclusion = bias;\n    float occlusion = 0.0;\n\n    // march!\n    for (int step = 0; step < NUM_SAMPLES_PER_RAY; ++step) {\n        occlusion += getSampleOcclusion(sampleUV, centerViewPos, centerNormal, tangent, topOcclusion);\n        sampleUV += stepUV;\n    }\n\n    return occlusion;\n}\n\nvoid main()\n{\n    vec4 normalDepth = texture2D(hx_normalDepthBuffer, uv);\n    vec3 centerNormal = hx_decodeNormal(normalDepth);\n    float centerDepth = hx_decodeLinearDepth(normalDepth);\n    float viewY = hx_cameraNearPlaneDistance + centerDepth * hx_cameraFrustumRange;\n    vec3 centerViewPos = viewY * viewDir;\n\n    // clamp z to a minimum, so the radius does not get excessively large in screen-space\n    float projRadius = halfSampleRadius / max(centerViewPos.y, 7.0);\n    vec2 projectedRadii = projRadius * vec2(hx_projectionMatrix[0][0], hx_projectionMatrix[1][2]);\n\n    // do not take more steps than there are pixels\n    float totalOcclusion = 0.0;\n\n    vec2 randomFactors = texture2D(ditherTexture, uv * ditherScale).xy;\n\n    vec2 rayUV = vec2(0.0);\n    for (int i = 0; i < NUM_RAYS; ++i) {\n        rayUV.x = (float(i) + randomFactors.x) / float(NUM_RAYS);\n        vec2 sampleDir = texture2D(sampleDirTexture, rayUV).xy * 2.0 - 1.0;\n        totalOcclusion += getRayOcclusion(sampleDir, randomFactors.y, projectedRadii, centerViewPos, centerNormal);\n    }\n\n    totalOcclusion = 1.0 - clamp(strengthPerRay * totalOcclusion, 0.0, 1.0);\n    hx_FragColor = vec4(vec3(totalOcclusion), 1.0);\n}';

	ShaderLibrary._files['hbao_vertex.glsl'] = 'vertex_attribute vec4 hx_position;\nvertex_attribute vec2 hx_texCoord;\n\nuniform mat4 hx_inverseProjectionMatrix;\n\nvarying_out vec2 uv;\nvarying_out vec3 viewDir;\nvarying_out vec3 frustumCorner;\n\nvoid main()\n{\n    uv = hx_texCoord;\n    viewDir = hx_getLinearDepthViewVector(hx_position.xy, hx_inverseProjectionMatrix);\n    frustumCorner = hx_getLinearDepthViewVector(vec2(1.0, 1.0), hx_inverseProjectionMatrix);\n    gl_Position = hx_position;\n}';

	ShaderLibrary._files['ssao_fragment.glsl'] = 'uniform mat4 hx_projectionMatrix;\nuniform mat4 hx_cameraWorldMatrix;\nuniform float hx_cameraFrustumRange;\nuniform float hx_cameraNearPlaneDistance;\n\nuniform vec2 ditherScale;\nuniform float strengthPerSample;\nuniform float rcpFallOffDistance;\nuniform float sampleRadius;\nuniform vec3 samples[NUM_SAMPLES]; // w contains bias\n\nuniform sampler2D ditherTexture;\nuniform sampler2D hx_normalDepthBuffer;\n\nvarying_in vec2 uv;\n\nvoid main()\n{\n    vec4 normalDepth = texture2D(hx_normalDepthBuffer, uv);\n    vec3 centerNormal = hx_decodeNormal(normalDepth);\n    float centerDepth = hx_decodeLinearDepth(normalDepth);\n    float totalOcclusion = 0.0;\n    vec3 dither = texture2D(ditherTexture, uv * ditherScale).xyz;\n    vec3 randomPlaneNormal = normalize(dither - .5);\n    float w = hx_cameraNearPlaneDistance + centerDepth * hx_cameraFrustumRange;\n    float centerY = centerDepth * hx_cameraFrustumRange;    // can ignore nearDist\n    vec3 sampleRadii;\n    sampleRadii.xz = sampleRadius * .5 / w * vec2(hx_projectionMatrix[0][0], hx_projectionMatrix[1][2]);\n    sampleRadii.y = sampleRadius;\n\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        vec3 sampleOffset = reflect(samples[i], randomPlaneNormal);\n        vec3 normOffset = normalize(sampleOffset);\n\n        // mirror sample position to the positive side of the plane\n        float cosFactor = dot(normOffset, centerNormal);\n        float sign = sign(cosFactor);\n        sampleOffset *= sign;\n        cosFactor *= sign;\n\n        vec3 scaledOffset = sampleOffset * sampleRadii;\n\n        vec2 samplePos = uv + scaledOffset.xz;\n        normalDepth = texture2D(hx_normalDepthBuffer, samplePos);\n        float occluderDepth = hx_decodeLinearDepth(normalDepth);\n\n        // can ignore nearDist\n        float occluderY = hx_cameraFrustumRange * occluderDepth;\n        float sampleY = centerY + scaledOffset.y;\n\n        float distanceFactor = max(1.0 - (sampleY - occluderY) * rcpFallOffDistance, 0.0);\n\n        // at this point, occlusion really means occlusion, and not the output \"colour\" (ie 1 = completely occluded)\n        float sampleOcclusion = float(occluderY < sampleY);\n\n        // if cosFactor = 0, the sample is coplanar, and occludes less\n        totalOcclusion += sampleOcclusion * distanceFactor * cosFactor;\n    }\n    hx_FragColor = vec4(vec3(1.0 - totalOcclusion * strengthPerSample), 1.0);\n}';

	/**
	 * Some utilities for Arrays.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var ArrayUtils = {
	    /**
	     * Randomizes the order of the elements in the array.
	     */
	    shuffle: function(array)
	    {
	        var currentIndex = array.length, temporaryValue, randomIndex ;

	        // While there remain elements to shuffle...
	        while (0 !== currentIndex) {

	            // Pick a remaining element...
	            randomIndex = Math.floor(Math.random() * currentIndex);
	            currentIndex -= 1;

	            // And swap it with the current element.
	            temporaryValue = array[currentIndex];
	            array[currentIndex] = array[randomIndex];
	            array[randomIndex] = temporaryValue;
	        }

	        return array;
	    },

	    /**
	     * Loops over a collection (Array or Object) and calls a function(obj, key).
	     */
	    forEach: function(obj, func)
	    {
	        for (var key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                func(obj[key], key);
	            }
	        }
	    }
	};

	/**
	 * @classdesc
	 * <p>Signal provides an implementation of the Observer pattern. Functions can be bound to the Signal, and they will be
	 * called when the Signal is dispatched. This implementation allows for keeping scope.</p>
	 * <p>When dispatch has an object passed to it, this is called the "payload" and will be passed as a parameter to the
	 * listener functions</p>
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Signal()
	{
	    this._listeners = [];
	    this._lookUp = {};
	}

	/**
	 * Signals keep "this" of the caller, because having this refer to the signal itself would be silly
	 */
	Signal.prototype =
	{
	    /**
	     * Binds a function as a listener to the Signal
	     * @param {function(*):void} listener A function to be called when the function is dispatched.
	     * @param {Object} [thisRef] If provided, the object that will become "this" in the function. Used in a class as such:
	     *
	     * @example
	     * signal.bind(this.methodFunction, this);
	     */
	    bind: function(listener, thisRef)
	    {
	        this._lookUp[listener] = this._listeners.length;
	        var callback = thisRef? listener.bind(thisRef) : listener;
	        this._listeners.push(callback);
	    },

	    /**
	     * Removes a function as a listener.
	     */
	    unbind: function(listener)
	    {
	        var index = this._lookUp[listener];
	        if (index !== undefined) {
				this._listeners.splice(index, 1);
				delete this._lookUp[listener];
			}
	    },

	    /**
	     * Unbinds all bound functions.
	     */
	    unbindAll: function()
	    {
	        this._listeners = [];
	        this._lookUp = {};
	    },

	    /**
	     * Dispatches the signal, causing all the listening functions to be called.
	     *
	     * @param [payload] An optional amount of arguments to be passed in as a parameter to the listening functions. Can be used to provide data.
	     */
	    dispatch: function(payload)
	    {
	        var len = this._listeners.length;
	        for (var i = 0; i < len; ++i)
	            this._listeners[i].apply(null, arguments);
	    },

	    /**
	     * Returns whether there are any functions bound to the Signal or not.
	     */
	    get hasListeners()
	    {
	        return this._listeners.length > 0;
	    }
	};

	/**
	 * Encapsulates behaviour to handle frames and time differences.
	 * @constructor
	 *
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function FrameTicker()
	{
	    this._isRunning = false;
	    this._dt = 0;
	    this._currentTime = 0;
	    this._tickFunc = this._tick.bind(this);
	    this._animationFrame = undefined;
	    this.onTick = new Signal();
	}

	FrameTicker.prototype = {

	    /**
	     * Starts automatically calling a callback function every animation frame.
	     * @param callback Function to call when a frame needs to be processed.
	     */
	    start: function() {
	        if (this._isRunning) return;
	        this._currentTime = 0;
	        this._isRunning = true;

	        this._requestAnimationFrame();
	    },

	    /**
	     * Stops calling the function.
	     */
	    stop: function() {
	        this._isRunning = false;

	        if (META.VR_DISPLAY)
	            META.VR_DISPLAY.cancelAnimationFrame(this._animationFrame);
	        else
	            cancelAnimationFrame(this._animationFrame);
	    },

	    /**
	     * @returns {number} The time passed in between two frames
	     */
	    get dt() { return this._dt; },
	    get time() { return this._currentTime; },

	    /**
	     * @private
	     */
	    _tick: function(time) {
	        if (!this._isRunning) return;

	        this._requestAnimationFrame();

	        // difference with previous currentTime
	        // var currentTime = (performance || Date).now();
	        if (this._currentTime === 0)
	            this._dt = 16;
	        else
	            this._dt = time - this._currentTime;

	        this._currentTime = time;

	        // this happens when switching to VR
	        if (this._dt < 0) this._dt = 0;
	        this.onTick.dispatch(this._dt);
	    },

	    /**
	     * @private
	     */
	    _requestAnimationFrame: function()
	    {
	        if (capabilities.VR_CAN_PRESENT)
	            this._animationFrame = META.VR_DISPLAY.requestAnimationFrame(this._tickFunc);
	        else
	            this._animationFrame = requestAnimationFrame(this._tickFunc);
	    }
	};

	/**
	 * @classdesc
	 * Color is an object representing an RGBA color. It can contain HDR values (> 1).
	 *
	 * @param rOrHex The red component of the colour or a hexadecimal representation of the entire colour.
	 * @param g The green component of the colour or omitted in favor of the hexadecimal representation.
	 * @param b The blue component of the colour or omitted in favor of the hexadecimal representation.
	 * @param a The alpha component of the colour or omitted in favor of the hexadecimal representation.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Color(rOrHex, g, b, a)
	{
	    /**
	     * The green component of the colour.
	     * @type {number}
	     */
	    this.r = 0.0;

	    /**
	     * The green component of the colour.
	     * @type {number}
	     */
	    this.g = 0.0;

	    /**
	     * The blue component of the colour.
	     * @type {number}
	     */
	    this.b = 0.0;

	    /**
	     * The alpha component of the colour.
	     * @type {number}
	     */
	    this.a = 1.0;
	    this.set(rOrHex, g, b, a);
	}

	/**
	 * Linearly interpolates between two Colors.
	 * @param {Color} a The first color to interpolate from.
	 * @param {Color} b The second color to interpolate to.
	 * @param {Number} t The interpolation factor.
	 * @param {Color} [target] An optional target color. If not provided, a new Color object will be created and returned.
	 * @returns {Color} The interpolated color.
	 */
	Color.lerp = function(a, b, t, target)
	{
	    target = target || new Color();
	    var ar = a.r, ag = a.g, ab = a.b, aa = a.a;

	    target.r = ar + (b.r - ar) * t;
	    target.g = ag + (b.g - ag) * t;
	    target.b = ab + (b.b - ab) * t;
	    target.a = aa + (b.a - aa) * t;
	    return target;
	};

	Color.prototype =
	{
	    /**
	     * Sets the color values directly.
	     * @param rOrHex The red component of the colour or a hexadecimal representation of the entire colour.
	     * @param g The green component of the colour or omitted in favor of the hexadecimal representation.
	     * @param b The blue component of the colour or omitted in favor of the hexadecimal representation.
	     * @param a The alpha component of the colour or omitted in favor of the hexadecimal representation.
	     */
	    set: function (rOrHex, g, b, a)
	    {
	        if (rOrHex === undefined) {
	            this.a = 1.0;
	            this.r = 1.0;
	            this.g = 1.0;
	            this.b = 1.0;
	        }
	        else if (g === undefined) {
	            this.a = 1.0;
	            this.r = ((rOrHex & 0xff0000) >>> 16) / 255.0;
	            this.g = ((rOrHex & 0x00ff00) >>> 8) / 255.0;
	            this.b = (rOrHex & 0x0000ff) / 255.0;
	        }
	        else {
	            this.r = rOrHex;
	            this.g = g;
	            this.b = b;
	            this.a = a === undefined ? 1.0 : a;
	        }
	    },

	    /**
	     * Scales all components (except alpha).
	     */
	    scale: function(s)
	    {
	        this.r *= s;
	        this.g *= s;
	        this.b *= s;
	    },

	    /**
	     * Returns a numerical representation of the entire colour. Only works for non-HDR color values.
	     */
	    hex: function ()
	    {
	        var r = (Math.min(this.r, 1.0) * 0xff);
	        var g = (Math.min(this.g, 1.0) * 0xff);
	        var b = (Math.min(this.b, 1.0) * 0xff);

	        return (r << 16) | (g << 8) | b;
	    },

	    /**
	     * Returns the luminance value of the color.
	     */
	    luminance: function ()
	    {
	        return this.r * .30 + this.g * 0.59 + this.b * .11;
	    },

	    /**
	     * Converts the color from gamma space to linear space.
	     * @param [target] An optional target Color. If not provided, a new Color object will be created and returned.
	     * @returns {Color} The Color in linear space.
	     *
	     * @see {@link http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ}
	     */
	    gammaToLinear: function (target)
	    {
	        target = target || new Color();

	        if (META.OPTIONS.usePreciseGammaCorrection) {
	            target.r = Math.pow(this.r, 2.2);
	            target.g = Math.pow(this.g, 2.2);
	            target.b = Math.pow(this.b, 2.2);
	        }
	        else {
	            target.r = this.r * this.r;
	            target.g = this.g * this.g;
	            target.b = this.b * this.b;
	        }
	        target.a = this.a;

	        return target;
	    },

	    /**
	     * Converts the color from linear space to gamma space.
	     * @param [target] An optional target Color. If not provided, a new Color object will be created and returned.
	     * @returns {Color} The Color in linear space.
	     *
	     * @see {@link http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ}
	     */
	    linearToGamma: function (target)
	    {
	        target = target || new Color();

	        if (META.OPTIONS.usePreciseGammaCorrection) {
	            target.r = Math.pow(this.r, .454545);
	            target.g = Math.pow(this.g, .454545);
	            target.b = Math.pow(this.b, .454545);
	        }
	        else {
	            target.r = Math.sqrt(this.r);
	            target.g = Math.sqrt(this.g);
	            target.b = Math.sqrt(this.b);
	        }
	        target.a = this.a;

	        return target;
	    },

	    /**
	     * Copies the values from another Color object.
	     */
	    copyFrom: function (color)
	    {
	        this.r = color.r;
	        this.g = color.g;
	        this.b = color.b;
	        this.a = color.a;
	    },

	    /**
	     * @ignore
	     */
	    toString: function ()
	    {
	        return "Color(" + this.r + ", " + this.g + ", " + this.b + ", " + this.a + ")";
	    },

	    /**
	     * Returns a copy of this Color.
	     */
	    clone: function ()
	    {
	        var color = new Color();
	        color.r = this.r;
	        color.g = this.g;
	        color.b = this.b;
	        color.a = this.a;
	        return color;
	    }
	};

	/**
	 * Preset for black with alpha 1
	 */
	Color.BLACK = new Color(0, 0, 0, 1);
	/**
	 * Preset for black with alpha 0
	 */
	Color.ZERO = new Color(0, 0, 0, 0);
	/**
	 * Preset for red
	 */
	Color.RED = new Color(1, 0, 0, 1);
	/**
	 * Preset for green
	 */
	Color.GREEN = new Color(0, 1, 0, 1);
	/**
	 * Preset for blue
	 */
	Color.BLUE = new Color(0, 0, 1, 1);
	/**
	 * Preset for yellow
	 */
	Color.YELLOW = new Color(1, 1, 0, 1);
	/**
	 * Preset for magenta
	 */
	Color.MAGENTA = new Color(1, 0, 1, 1);
	/**
	 * Preset for cyan
	 */
	Color.CYAN = new Color(0, 1, 1, 1);
	/**
	 * Preset for white
	 */
	Color.WHITE = new Color(1, 1, 1, 1);

	// Just contains some convenience methods and GL management stuff that shouldn't be called directly
	// Will become an abstraction layer
	// properties to keep track of render state
	var _numActiveAttributes = 0;
	var _depthMask = true;
	var _colorMask = true;
	var _lockColorMask = false;
	var _cullMode = null;
	var _invertCullMode = false;
	var _depthTest = null;
	var _blendState = null;
	var _renderTarget = null;

	// this is so that effects can push states on the stack
	// the renderer at the root just pushes one single state and invalidates that constantly
	var _stencilState = null;

	var _glStats =
	    {
	        numDrawCalls: 0,
	        numTriangles: 0,
	        numClears: 0
	    };

	var _clearGLStats = function ()
	{
	    _glStats.numDrawCalls = 0;
	    _glStats.numTriangles = 0;
	    _glStats.numClears = 0;
	};

	var gl = null;


	/**
	 * GL forms a bridge to native WebGL. It's used to keep track of certain states. If the method is in here, use it instead of the raw gl calls.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var GL = {
	    gl: null,

	    _setGL: function (value)
	    {
	        GL.gl = gl = value;
	    },

	    /**
	     * Clears the current render target.
	     *
	     * @param [clearMask] One of {@linkcode ClearMask}. If omitted, all planes will be cleared.
	     */
	    clear: function (clearMask)
	    {
	        if (clearMask === undefined)
	            clearMask = ClearMask.COMPLETE;

	        gl.clear(clearMask);
	        ++_glStats.numClears;
	    },

	    /**
	     * Draws elements for the current index buffer bound.
	     * @param elementType One of {@linkcode ElementType}.
	     * @param numIndices The amount of indices in the index buffer
	     * @param offset The first index to start drawing from.
	     * @param [indexType] The data type of the index buffer/
	     */
	    drawElements: function (elementType, numIndices, offset, indexType)
	    {
	        indexType = indexType || gl.UNSIGNED_SHORT;
	        ++_glStats.numDrawCalls;
	        _glStats.numTriangles += numIndices / 3;
	        gl.drawElements(elementType, numIndices, indexType, offset * 2);
	    },


	    /**
	     * Sets the viewport to render into.
	     * @param {*} rect Any object with a width and height property, so it can be a {@linkcode Rect} or even a {linkcode FrameBuffer}. If x and y are present, it will use these too.
	     */
	    setViewport: function (rect)
	    {
	        if (rect)
	            gl.viewport(rect.x || 0, rect.y || 0, rect.width, rect.height);
	        else
	            gl.viewport(0, 0, META.TARGET_CANVAS.width, META.TARGET_CANVAS.height);
	    },

	    /**
	     * Gets the current render target.
	     */
	    getCurrentRenderTarget: function ()
	    {
	        return _renderTarget;
	    },

	    /**
	     * Specifies whether or not to write color. Uses all channels for efficiency (and the current lack of need for
	     * anything else).
	     */
	    setColorMask: function(value)
	    {
	        if (_lockColorMask || value === _colorMask) return;
	        _colorMask = value;
	        gl.colorMask(value, value, value, value);
	    },

	    /**
	     * Specifies any calls to setColorMask or states defined by material will have no effect until the first call to unlockColorMask
	     */
	    lockColorMask: function(state)
	    {
	        if (state !== undefined) {
	            GL.setColorMask(state);
	        }
	        _lockColorMask = true;
	    },

	    /**
	     * Specifies any calls to setColorMask or states defined by material will be applied.
	     */
	    unlockColorMask: function(state)
	    {
	        if (state !== undefined) {
	            GL.setColorMask(state);
	        }
	        _lockColorMask = false;
	    },

	    /**
	     * Sets the current render target. It's recommended to clear afterwards for certain platforms.
	     */
	    setRenderTarget: function (frameBuffer)
	    {
	        _renderTarget = frameBuffer;

	        var target = _renderTarget;

	        if (target) {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, target._fbo);

	            if (target._numColorTextures > 1) {
	                if (capabilities.WEBGL_2)
	                    gl.drawBuffers(target._drawBuffers);
	                else
	                    capabilities.EXT_DRAW_BUFFERS.drawBuffersWEBGL(target._drawBuffers);
				}
	        }
	        else
	            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	        GL.setViewport(frameBuffer);
	    },

	    /**
	     * Enables a given count of vertex attributes.
	     */
	    enableAttributes: function (count)
	    {
	        var numActiveAttribs = _numActiveAttributes;
	        var i;

	        if (numActiveAttribs < count) {
	            for (i = numActiveAttribs; i < count; ++i)
	                gl.enableVertexAttribArray(i);
	        }
	        else if (numActiveAttribs > count) {
	            // bug in WebGL/ANGLE? When rendering to a render target, disabling vertex attrib array 1 causes errors when using only up to the index below o_O
	            // so for now + 1
	            count += 1;
	            for (i = count; i < numActiveAttribs; ++i) {
	                gl.disableVertexAttribArray(i);
	            }
	        }

	        _numActiveAttributes = count;
	    },

	    /**
	     * Sets the clear color.
	     */
	    setClearColor: function (color)
	    {
	        color = color instanceof Color ? color : new Color(color);
	        gl.clearColor(color.r, color.g, color.b, color.a);
	    },

	    /**
	     * Sets the cull mode.
	     */
	    setCullMode: function (value)
	    {
	        if (_cullMode === value) return;

	        if (value === CullMode.NONE)
	            gl.disable(gl.CULL_FACE);
	        else {
	            // was disabled before
	            if (_cullMode === CullMode.NONE)
	                gl.enable(gl.CULL_FACE);

	            var cullMode = value;

	            if (_invertCullMode) {
	                if (cullMode === CullMode.BACK)
	                    cullMode = CullMode.FRONT;
	                else if (cullMode === CullMode.FRONT)
	                    cullMode = CullMode.BACK;
	            }

	            gl.cullFace(cullMode);
	        }

	        _cullMode = value;
	    },

	    setInvertCulling: function(value)
	    {
	        if (_invertCullMode === value) return;
	        _invertCullMode = value;

	        // just make sure it gets assigned next time
	        _cullMode = CullMode.NONE;
	    },

	    /**
	     * Sets the depth mask.
	     */
	    setDepthMask: function (value)
	    {
	        if (_depthMask === value) return;
	        _depthMask = value;
	        gl.depthMask(_depthMask);
	    },

	    /**
	     * Sets the depth test.
	     */
	    setDepthTest: function (value)
	    {
	        if (_depthTest === value) return;
	        _depthTest = value;

	        if (_depthTest === Comparison.DISABLED)
	            gl.disable(gl.DEPTH_TEST);
	        else {
	            gl.enable(gl.DEPTH_TEST);
	            gl.depthFunc(_depthTest);
	        }
	    },

	    /**
	     * Sets the blend state.
	     *
	     * @see {@linkcode BlendState}
	     */
	    setBlendState: function (value)
	    {
	        if (_blendState === value) return;
	        _blendState = value;

	        var blendState = _blendState;
	        if (!blendState || blendState.enabled === false)
	            gl.disable(gl.BLEND);
	        else {
	            gl.enable(gl.BLEND);

	            if (blendState.alphaSrcFactor === null || blendState.alphaSrcFactor === undefined)
	                gl.blendFunc(blendState.srcFactor, blendState.dstFactor);
	            else
	                gl.blendFuncSeparate(blendState.srcFactor, blendState.dstFactor, blendState.alphaSrcFactor, blendState.alphaDstFactor);

	            if (blendState.alphaOperator === null || blendState.alphaOperator === undefined)
	                gl.blendEquation(blendState.operator);
	            else
	                gl.blendEquationSeparate(blendState.operator, blendState.alphaOperator);

	            var color = blendState.color;
	            if (color)
	                gl.blendColor(color.r, color.g, color.b, color.a);
	        }
	    },

	    /**
	     * Sets a new stencil reference value for the current stencil state. This prevents resetting an entire state.
	     */
	    updateStencilReferenceValue: function (value)
	    {
	        var currentState = _stencilState;

	        if (!currentState || currentState.reference === value) return;

	        currentState.reference = value;

	        gl.stencilFunc(currentState.comparison, value, currentState.readMask);
	    },

	    /**
	     * Sets a new stencil state.
	     *
	     * @see {@linkcode StencilState}
	     */
	    setStencilState: function (value)
	    {
	        _stencilState = value;

	        var stencilState = _stencilState;
	        if (!stencilState || stencilState.enabled === false) {
	            gl.disable(gl.STENCIL_TEST);
	            gl.stencilFunc(Comparison.ALWAYS, 0, 0xff);
	            gl.stencilOp(StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP);
	        }
	        else {
	            gl.enable(gl.STENCIL_TEST);
	            gl.stencilFunc(stencilState.comparison, stencilState.reference, stencilState.readMask);
	            gl.stencilOp(stencilState.onStencilFail, stencilState.onDepthFail, stencilState.onPass);
	            gl.stencilMask(stencilState.writeMask);
	        }
	    },

	    /**
	     * Just inlined to reduce function calls in the render loop
	     *
	     * @ignore
	     */
	    setMaterialPassState: function(cullMode, depthTest, depthMask, colorMask, blendState)
	    {
	        if (_cullMode !== cullMode) {
	            if (cullMode === CullMode.NONE)
	                gl.disable(gl.CULL_FACE);
	            else {
	                // was disabled before
	                if (_cullMode === CullMode.NONE)
	                    gl.enable(gl.CULL_FACE);

	                var cullModeEff = cullMode;

	                if (_invertCullMode) {
	                    if (cullModeEff === CullMode.BACK)
	                        cullModeEff = CullMode.FRONT;
	                    else if (cullModeEff === CullMode.FRONT)
	                        cullModeEff = CullMode.BACK;
	                }

	                gl.cullFace(cullModeEff);
	            }

	            _cullMode = cullMode;
	        }

	        if (_depthTest !== depthTest) {
	            _depthTest = depthTest;

	            if (_depthTest === Comparison.DISABLED)
	                gl.disable(gl.DEPTH_TEST);
	            else {
	                gl.enable(gl.DEPTH_TEST);
	                gl.depthFunc(_depthTest);
	            }
	        }

	        if (_depthMask !== depthMask) {
	            _depthMask = depthMask;
	            gl.depthMask(_depthMask);
	        }

	        if (!_lockColorMask && colorMask !== _colorMask) {
	            _colorMask = colorMask;
	            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
	        }

	        if (_blendState !== blendState) {
	            _blendState = blendState;

	            if (!blendState || blendState.enabled === false)
	                gl.disable(gl.BLEND);
	            else {
	                gl.enable(gl.BLEND);
	                if (blendState.alphaSrcFactor === null || blendState.alphaSrcFactor === undefined)
	                    gl.blendFunc(blendState.srcFactor, blendState.dstFactor);
	                else 
	                    gl.blendFuncSeparate(blendState.srcFactor, blendState.dstFactor, blendState.alphaSrcFactor, blendState.alphaDstFactor);

	                if (blendState.alphaOperator === null || blendState.alphaOperator === undefined)
	                    gl.blendEquation(blendState.operator);
	                else
	                    gl.blendEquationSeparate(blendState.operator, blendState.alphaOperator);

	                var color = blendState.color;
	                if (color)
	                    gl.blendColor(color.r, color.g, color.b, color.a);
	            }
	        }
	    }
	};

	/**
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ShadowFilter()
	{
	    this._blurShader = null;
	    this._numBlurPasses = 1;
	    this._cullMode = CullMode.FRONT;
	}

	ShadowFilter.prototype =
	{
	    get shadowMapFilter() {
	        return TextureFilter.NEAREST_NOMIP
	    },

	    get cullMode() {
	        return this._cullMode;
	    },

	    set cullMode(value) {
	        this._cullMode = value;
	    },

	    getShadowMapFormat: function()
	    {
	        return TextureFormat.RGBA;
	    },

	    getShadowMapDataType: function()
	    {
	        return DataType.UNSIGNED_BYTE;
	    },

	    getGLSL: function()
	    {
	        throw new Error("Abstract method called");
	    },

	    get blurShader()
	    {
	        if (!this._blurShader)
	            this._blurShader = this._createBlurShader();

	        return this._blurShader;
	    },

	    // only for those methods that use a blurShader
	    get numBlurPasses()
	    {
	        return this._numBlurPasses;
	    },

	    set numBlurPasses(value)
	    {
	        this._numBlurPasses = value;
	    },

	    init: function()
	    {

	    },

	    _createBlurShader: function()
	    {

	    },

	    _invalidateBlurShader: function()
	    {
	        if (this._blurShader)
	            this._blurShader = null;
	    }
	};

	/**
	 * @classdesc
	 * HardShadowFilter is a shadow filter that doesn't apply any filtering at all.
	 *
	 * @see {@linkcode InitOptions#shadowFilter}
	 *
	 * @constructor
	 *
	 * @extends ShadowFilter
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function HardShadowFilter()
	{
	    ShadowFilter.call(this);
	}

	HardShadowFilter.prototype = Object.create(ShadowFilter.prototype);

	/**
	 * @ignore
	 */
	HardShadowFilter.prototype.getGLSL = function()
	{
	    return ShaderLibrary.get("shadow_hard.glsl");
	};

	/**
	 * <p>LightingModel defines a lighting model to be used by a {@Material}. A default lighting model can be assigned to
	 * {@linkcode InitOptions#defaultLightingModel}, which will mean any material will use it by default. </p>
	 *
	 * <p>You can add pass your own lighting models as a string into a material, as long as the glsl code contains the
	 * hx_brdf function</p>
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 *
	 */
	var LightingModel =
	{
	    /** No lighting applied when rendering */
	    Unlit: null,
	    /** Normalized Blinn-Phong shading applied */
	    BlinnPhong: ShaderLibrary.get("lighting_blinn_phong.glsl"),
	    /** GGX shading applied */
	    GGX: ShaderLibrary.get("lighting_ggx.glsl"),
	    /** Full GGX shading applied (includes visibility term) */
	    GGX_FULL: "#define HX_VISIBILITY_TERM\n" + ShaderLibrary.get("lighting_ggx.glsl"),
	    /** Empty brdf */
	    DEBUG: ShaderLibrary.get("lighting_debug.glsl")
	};

	/**
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var GLSLIncludes = {

	    GENERAL:
	        "precision highp float;\n\n" +
	        ShaderLibrary.get("snippets_general.glsl") + "\n\n",

	    VERSION: ""
	};

	/**
	 * @classdesc
	 * Float2 is a class describing 2-dimensional points.
	 *
	 * @constructor
	 * @param x The x-coordinate
	 * @param y The y-coordinate
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Float2(x, y)
	{
	    // x, y, z, w allowed to be accessed publicly for simplicity, changing this does not violate invariant. Ever.
	    this.x = x || 0;
	    this.y = y || 0;
	}

	/**
	 * Adds 2 vectors.
	 *
	 * @param a
	 * @param b
	 * @param [target] An optional target object. If omitted, a new object will be created.
	 * @returns The sum of a and b.
	 */
	Float2.add = function(a, b, target)
	{
	    target = target || new Float2();
	    target.x = a.x + b.x;
	    target.y = a.y + b.y;
	    return target;
	};

	/**
	 * Subtracts 2 vectors.
	 *
	 * @param a
	 * @param b
	 * @param [target] An optional target object. If omitted, a new object will be created.
	 * @returns The difference of a and b.
	 */
	Float2.subtract = function(a, b, target)
	{
	    target = target || new Float2();
	    target.x = a.x - b.x;
	    target.y = a.y - b.y;
	    return target;
	};

	/**
	 * Multiplies a vector with a scalar.
	 *
	 * @param a
	 * @param s
	 * @param [target] An optional target object. If omitted, a new object will be created.
	 * @returns The product of a * s
	 */
	Float2.scale = function(a, s, target)
	{
	    target = target || new Float2();
	    target.x = a.x * s;
	    target.y = a.y * s;
	    return target;
	};

	Float2.prototype =
	{

	    /**
	     * Sets the components explicitly.
	     */
	    set: function(x, y)
	    {
	        this.x = x;
	        this.y = y;
	    },

	    /**
	     * Returns the dot product with another vector.
	     */
	    dot: function(a)
	    {
	        return a.x * this.x + a.y * this.y;
	    },

	    /**
	     * The squared length of the vector.
	     */
	    get lengthSqr()
	    {
	        return this.x * this.x + this.y * this.y;
	    },

	    /**
	     * The length of the vector.
	     */
	    get length()
	    {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    },

	    /**
	     * Normalizes the vector.
	     */
	    normalize: function()
	    {
	        var rcpLength = 1.0/this.length;
	        this.x *= rcpLength;
	        this.y *= rcpLength;
	    },

	    /**
	     * Returns a copy of this object.
	     */
	    clone: function()
	    {
	        return new Float2(this.x, this.y);
	    },

	    /**
	     * Adds a vector to this one in place.
	     */
	    add: function(v)
	    {
	        this.x += v.x;
	        this.y += v.y;
	    },

	    /**
	     * Adds a scalar multiple of another vector in place.
	     * @param v The vector to scale and add.
		 * @param s The scale to apply to v
	     */
	    addScaled: function(v, s)
	    {
	        this.x += v.x * s;
	        this.y += v.y * s;
	    },

	    /**
	     * Subtracts a vector from this one in place.
	     */
	    subtract: function(v)
	    {
	        this.x -= v.x;
	        this.y -= v.y;
	    },

		/**
		 * Subtracts a scaled vector from this one in place.
		 *
		 * @param v The vector to scale and subtract.
		 * @param s The scale to apply to v
		 */
		subtractScaled: function (v, s)
		{
			this.x -= v.x * s;
			this.y -= v.y * s;
			return this;
		},

	    /**
	     * Multiplies the components of this vector with a scalar.
	     */
	    scale: function(s)
	    {
	        this.x *= s;
	        this.y *= s;
	    },

	    /**
	     * Negates the components of this vector.
	     */
	    negate: function()
	    {
	        this.x = -this.x;
	        this.y = -this.y;
	    },

	    /**
	     * Copies the negative of a vector
	     */
	    negativeOf: function(v)
	    {
	        this.x = -v.x;
	        this.y = -v.y;
	    },

	    /**
	     * Sets the components of this vector to their absolute values.
	     */
	    abs: function()
	    {
	        this.x = Math.abs(this.x);
	        this.y = Math.abs(this.y);
	    },

	    /**
	     * Sets the euclidian coordinates based on polar coordinates
	     * @param radius The radius coordinate
	     * @param angle The angle coordinate
	     */
	    fromPolarCoordinates: function(radius, angle)
	    {
	        this.x = radius*Math.cos(angle);
	        this.y = radius*Math.sin(angle);
	    },

	    /**
	     * Copies the values from a different Float2
	     */
	    copyFrom: function(b)
	    {
	        this.x = b.x;
	        this.y = b.y;
	    },

	    /**
	     * Returns the distance between this and another point.
	     */
	    distanceTo: function(a)
	    {
	        var dx = a.x - this.x;
	        var dy = a.y - this.y;
	        return Math.sqrt(dx * dx + dy * dy);
	    },

	    /**
	     * Returns the squared distance between this and another point.
	     */
	    squareDistanceTo: function(a)
	    {
	        var dx = a.x - this.x;
	        var dy = a.y - this.y;
	        return dx * dx + dy * dy;
	    },

	    /**
	     * Linearly interpolates two vectors.
	     * @param {Float2} a The first vector to interpolate from.
	     * @param {Float2} b The second vector to interpolate to.
	     * @param {Number} t The interpolation factor.
	     */
	    lerp: function(a, b, t)
	    {
	        var ax = a.x, ay = a.y;

	        this.x = ax + (b.x - ax) * t;
	        this.y = ay + (b.y - ay) * t;
	    },

	    /**
	     * Replaces the components' values if those of the other Float2 are higher, respectively
	     */
	    maximize: function(b)
	    {
	        if (b.x > this.x) this.x = b.x;
	        if (b.y > this.y) this.y = b.y;
	    },

	    /**
	     * Replaces the components' values if those of the other Float2 are lower, respectively
	     */
	    minimize: function(b)
	    {
	        if (b.x < this.x) this.x = b.x;
	        if (b.y < this.y) this.y = b.y;
	    },

	    /**
	     * Returns the angle between this and another vector.
	     */
	    angle: function(a)
	    {
	        return Math.acos(this.dot(a) / (this.length * a.length));
	    },

	    /**
	     * Returns the angle between two vectors, assuming they are normalized
	     */
	    angleNormalized: function(a)
	    {
	        return Math.acos(this.dot(a));
	    }
	};

	/**
	 * A preset for the origin
	 */
	Float2.ZERO = new Float2(0, 0);

	/**
	 * A preset for the X-axis
	 */
	Float2.X_AXIS = new Float2(1, 0);

	/**
	 * A preset for the Y-axis
	 */
	Float2.Y_AXIS = new Float2(0, 1);

	/**
	 * @classdesc
	 * PoissonDisk is a class that allows generating 2D points in a poisson distribution.
	 *
	 * @constructor
	 * @param [mode] Whether the points should be contained in a square ({@linkcode PoissonDisk#SQUARE}) or a circle ({@linkcode PoissonDisk#CIRCULAR}). Defaults to circular.
	 * @param [initialDistance]
	 * @param [decayFactor]
	 * @param [maxTests]
	 *
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PoissonDisk(mode, initialDistance, decayFactor, maxTests)
	{
	    this._mode = mode === undefined? PoissonDisk.CIRCULAR : mode;
	    this._initialDistance = initialDistance || 1.0;
	    this._decayFactor = decayFactor || .99;
	    this._maxTests = maxTests || 20000;
	    this._currentDistance = 0;
	    this._points = null;
	    this.reset();
	}

	/**
	 * Generates points in a square.
	 */
	PoissonDisk.SQUARE = 0;

	/**
	 * Generates points in a circle.
	 */
	PoissonDisk.CIRCULAR = 1;

	/**
	 * @ignore
	 */
	PoissonDisk._initDefault = function()
	{
	    PoissonDisk.DEFAULT = new PoissonDisk();
	    PoissonDisk.DEFAULT.generatePoints(64);
	    PoissonDisk.DEFAULT_FLOAT32 = new Float32Array(64 * 2);

	    var diskPoints = PoissonDisk.DEFAULT.getPoints();

	    for (var i = 0; i < 64; ++i) {
	        var p = diskPoints[i];
	        PoissonDisk.DEFAULT_FLOAT32[i * 2] = p.x;
	        PoissonDisk.DEFAULT_FLOAT32[i * 2 + 1] = p.y;
	    }
	};

	PoissonDisk.prototype =
	{
	    /**
	     * Gets all points currently generated.
	     */
	    getPoints: function()
	    {
	        return this._points;
	    },

	    /**
	     * Clears all generated points.
	     */
	    reset : function()
	    {
	        this._currentDistance = this._initialDistance;
	        this._points = [];
	    },

	    /**
	     * Generates new points and add them to the set. This does not return a set of points.
	     * @param numPoints The amount of points to generate.
	     */
	    generatePoints: function(numPoints)
	    {
	        for (var i = 0; i < numPoints; ++i)
	            this.generatePoint();
	    },

	    /**
	     * Generates a single point and adds it to the set.
	     */
	    generatePoint: function()
	    {
	        for (;;) {
	            var testCount = 0;
	            var sqrDistance = this._currentDistance*this._currentDistance;

	            while (testCount++ < this._maxTests) {
	                var candidate = this._getCandidate();
	                if (this._isValid(candidate, sqrDistance)) {
	                    this._points.push(candidate);
	                    return candidate;
	                }
	            }
	            this._currentDistance *= this._decayFactor;
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _getCandidate: function()
	    {
	        for (;;) {
	            var x = Math.random() * 2.0 - 1.0;
	            var y = Math.random() * 2.0 - 1.0;
	            if (this._mode === PoissonDisk.SQUARE || (x * x + y * y <= 1))
	                return new Float2(x, y);
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _isValid: function(candidate, sqrDistance)
	    {
	        var len = this._points.length;
	        for (var i = 0; i < len; ++i) {
	            var p = this._points[i];
	            var dx = candidate.x - p.x;
	            var dy = candidate.y - p.y;
	            if (dx*dx + dy*dy < sqrDistance)
	                return false;
	        }

	            return true;
	    }
	};

	/**
	 * @classdesc
	 * Float4 is a class describing 4-dimensional homogeneous points. These can represent points (w == 1), vectors (w == 0),
	 * points in homogeneous projective space, or planes (a, b, c = x, y, z), (w = d).
	 *
	 * @constructor
	 * @param x The x-coordinate
	 * @param y The y-coordinate
	 * @param z The z-coordinate
	 * @param w The w-coordinate
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Float4(x, y, z, w)
	{
		// x, y, z, w allowed to be accessed publicly for simplicity, changing this does not violate invariant. Ever.
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = w === undefined ? 1 : w;
	}

	/**
	 * Adds 2 vectors.
	 *
	 * @param a
	 * @param b
	 * @param [target] An optional target object. If omitted, a new object will be created.
	 * @returns The sum of a and b.
	 */
	Float4.add = function (a, b, target)
	{
		target = target || new Float4();
		target.x = a.x + b.x;
		target.y = a.y + b.y;
		target.z = a.z + b.z;
		target.w = a.w + b.w;
		return target;
	};

	/**
	 * Subtracts 2 vectors.
	 *
	 * @param a
	 * @param b
	 * @param [target] An optional target object. If omitted, a new object will be created.
	 * @returns The difference of a and b.
	 */
	Float4.subtract = function (a, b, target)
	{
		target = target || new Float4();
		target.x = a.x - b.x;
		target.y = a.y - b.y;
		target.z = a.z - b.z;
		target.w = a.w - b.w;
		return target;
	};

	/**
	 * Multiplies a vector with a scalar. The w-coordinate is not scaled, since that's generally not what is desired.
	 *
	 * @param a
	 * @param s
	 * @param [target] An optional target object. If omitted, a new object will be created.
	 * @returns The product of a * s
	 */
	Float4.scale = function (a, s, target)
	{
		target = target || new Float4();
		target.x = a.x * s;
		target.y = a.y * s;
		target.z = a.z * s;
		return target;
	};

	/**
	 * Multiplies a vector with a scalar, including the w-coordinate.
	 * @param a
	 * @param s
	 * @param [target] An optional target object. If omitted, a new object will be created.
	 * @returns The product of a * s
	 */
	Float4.scale4 = function (a, s, target)
	{
		target = target || new Float4();
		target.x = a.x * s;
		target.y = a.y * s;
		target.z = a.z * s;
		target.w = a.w * s;
		return target;
	};

	/**
	 * Returns the 3-component dot product of 2 vectors.
	 * @param a
	 * @param b
	 * @param [target] An optional target object. If omitted, a new object will be created.
	 * @returns The product of a x b
	 */
	Float4.cross = function (a, b, target)
	{
		target = target || new Float4();
		// safe to use either a and b parameter
		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		target.x = ay * bz - az * by;
		target.y = az * bx - ax * bz;
		target.z = ax * by - ay * bx;
		target.w = 0;
		return target;
	};

	Float4.prototype =
		{
			/**
			 * Sets the components explicitly.
			 */
			set: function (x, y, z, w)
			{
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w === undefined ? this.w : w;
				return this;
			},

			/**
			 * The squared length of the vector.
			 */
			get lengthSqr()
			{
				return this.x * this.x + this.y * this.y + this.z * this.z;
			},

			/**
			 * The length of the vector.
			 */
			get length()
			{
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
			},

			/**
			 * Normalizes the vector.
			 */
			normalize: function ()
			{
				var rcpLength = 1.0 / this.length;
				this.x *= rcpLength;
				this.y *= rcpLength;
				this.z *= rcpLength;
				return this;
			},

			/**
			 * Normalizes the vector as if it were a plane.
			 */
			normalizeAsPlane: function ()
			{
				var rcpLength = 1.0 / this.length;
				this.x *= rcpLength;
				this.y *= rcpLength;
				this.z *= rcpLength;
				this.w *= rcpLength;
				return this;
			},

			/**
			 * Returns a copy of this object.
			 */
			clone: function ()
			{
				return new Float4(this.x, this.y, this.z, this.w);
			},

			/**
			 * Adds a vector to this one in place.
			 */
			add: function (v)
			{
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;
				return this;
			},

			/**
			 * Adds a scalar multiple of another vector in place.
			 * @param v The vector to scale and add.
			 * @param s The scale to apply to v
			 */
			addScaled: function (v, s)
			{
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;
				return this;
			},

			/**
			 * Subtracts a vector from this one in place.
			 */
			subtract: function (v)
			{
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;
				return this;
			},

			/**
			 * Subtracts a scaled vector from this one in place.
			 *
			 * @param v The vector to scale and subtract.
			 * @param s The scale to apply to v
			 */
			subtractScaled: function (v, s)
			{
				this.x -= v.x * s;
				this.y -= v.y * s;
				this.z -= v.z * s;
				this.w -= v.w * s;
				return this;
			},

			/**
			 * Multiplies the components of this vector with a scalar, except the w-component.
			 */
			scale: function (s)
			{
				this.x *= s;
				this.y *= s;
				this.z *= s;
				return this;
			},

			/**
			 * Multiplies the components of this vector with a scalar, including the w-component.
			 */
			scale4: function (s)
			{
				this.x *= s;
				this.y *= s;
				this.z *= s;
				this.w *= s;
				return this;
			},

			/**
			 * Negates the components of this vector.
			 */
			negate: function ()
			{
				this.x = -this.x;
				this.y = -this.y;
				this.z = -this.z;
				this.w = -this.w;
				return this;
			},

			/**
			 * Copies the negative of a vector
			 */
			negativeOf: function (a)
			{
				this.x = -a.x;
				this.y = -a.y;
				this.z = -a.z;
				this.w = -a.w;
				return this;
			},

			/**
			 * Project a point in homogeneous projective space to carthesian 3D space by dividing by w
			 */
			homogeneousProject: function ()
			{
				var rcpW = 1.0 / this.w;
				this.x *= rcpW;
				this.y *= rcpW;
				this.z *= rcpW;
				this.w = 1.0;
				return this;
			},

			/**
			 * Sets the components of this vector to their absolute values.
			 */
			abs: function ()
			{
				this.x = Math.abs(this.x);
				this.y = Math.abs(this.y);
				this.z = Math.abs(this.z);
				this.w = Math.abs(this.w);
				return this;
			},

			/**
			 * Sets the euclidian coordinates based on spherical coordinates.
			 * @param radius The radius coordinate
			 * @param azimuthalAngle The azimuthal coordinate
			 * @param polarAngle The polar coordinate
			 */
			fromSphericalCoordinates: function (radius, azimuthalAngle, polarAngle)
			{
				this.x = radius * Math.sin(polarAngle) * Math.cos(azimuthalAngle);
				this.y = radius * Math.sin(polarAngle) * Math.sin(azimuthalAngle);
				this.z = radius * Math.cos(polarAngle);
				this.w = 1.0;
				return this;
			},

			/**
			 * Copies the values from a different Float4
			 */
			copyFrom: function (b)
			{
				this.x = b.x;
				this.y = b.y;
				this.z = b.z;
				this.w = b.w;
				return this;
			},

			/**
			 * Replaces the components' values if those of the other Float2 are higher, respectively
			 */
			maximize: function (b)
			{
				if (b.x > this.x) this.x = b.x;
				if (b.y > this.y) this.y = b.y;
				if (b.z > this.z) this.z = b.z;
				if (b.w > this.w) this.w = b.w;
				return this;
			},

			/**
			 * Replaces the components' values if those of the other Float2 are higher, respectively. Excludes the w-component.
			 */
			maximize3: function (b)
			{
				if (b.x > this.x) this.x = b.x;
				if (b.y > this.y) this.y = b.y;
				if (b.z > this.z) this.z = b.z;
				return this;
			},

			/**
			 * Replaces the components' values if those of the other Float2 are lower, respectively
			 */
			minimize: function (b)
			{
				if (b.x < this.x) this.x = b.x;
				if (b.y < this.y) this.y = b.y;
				if (b.z < this.z) this.z = b.z;
				if (b.w < this.w) this.w = b.w;
				return this;
			},

			/**
			 * Replaces the components' values if those of the other Float2 are lower, respectively. Excludes the w-component.
			 */
			minimize3: function (b)
			{
				if (b.x < this.x) this.x = b.x;
				if (b.y < this.y) this.y = b.y;
				if (b.z < this.z) this.z = b.z;
				return this;
			},

			/**
			 * Generates a plane representation from the normal vector and a point contained in the plane.
			 * @param normal The vector normal to the plane.
			 * @param point A point contained in the plane.
			 */
			planeFromNormalAndPoint: function (normal, point)
			{
				var nx = normal.x, ny = normal.y, nz = normal.z;
				this.x = nx;
				this.y = ny;
				this.z = nz;
				this.w = -(point.x * nx + point.y * ny + point.z * nz);
				return this;
			},

			/**
			 * Generates a plane representation from two contained vectors and a point contained in the plane.
			 * @param vector1 A vector contained in the plane.
			 * @param vector2 A vector contained in the plane.
			 * @param point A point contained in the plane.
			 */
			planeFromVectorsAndPoint: function (vector1, vector2, point)
			{
				this.cross(vector1, vector2);
				this.normalize();
				this.w = -(point.x * this.x + point.y * this.y + point.z * this.z);
			},

			/**
			 * Generates a plane representation from 3 contained points.
			 * @param p1 A point contained in the plane.
			 * @param p2 A point contained in the plane.
			 * @param p3 A point contained in the plane.
			 */
			planeFromPoints: function (p1, p2, p3)
			{
				var v1 = new Float4();
				var v2 = new Float4();

				return function(p1, p2, p3)
				{
					Float4.subtract(p1, p3, v1);
					Float4.subtract(p2, p3, v2);
					this.planeFromVectorsAndPoint(v1, v2, p3);
				}
			}(),

			/**
			 * Calculates the intersection with a ray (if any)
			 */
			planeIntersectRay: function(ray, target)
			{
				target = target || new HX.Float4();

				// assuming vectors are all normalized
				var denom = this.dot3(ray.direction);

				// must be traveling in opposite directions
				if (Math.abs(denom) > 0.00001) {
					var t = -(this.dot3(ray.origin) + this.w) / denom;
					if (t > 0) {
						target.copyFrom(ray.origin);
						target.addScaled(ray.direction, t);
						return true;
					}
				}

				return null;
			},

			/**
			 * Returns the angle between this and another vector.
			 */
			angle: function (a)
			{
				return Math.acos(this.dot3(a) / (this.length * a.length));
			},

			/**
			 * Returns the angle between two vectors, assuming they are normalized
			 */
			angleNormalized: function (a)
			{
				return Math.acos(this.dot3(a));
			},

			/**
			 * Returns the distance to a point.
			 */
			distanceTo: function (a)
			{
				var dx = a.x - this.x;
				var dy = a.y - this.y;
				var dz = a.z - this.z;
				return Math.sqrt(dx * dx + dy * dy + dz * dz);
			},

			/**
			 * Returns the squared distance to a point.
			 */
			squareDistanceTo: function (a)
			{
				var dx = a.x - this.x;
				var dy = a.y - this.y;
				var dz = a.z - this.z;
				return dx * dx + dy * dy + dz * dz;
			},

			/**
			 * Returns the 3-component dot product of 2 vectors.
			 */
			dot3: function (a)
			{
				return a.x * this.x + a.y * this.y + a.z * this.z;
			},

			/**
			 * Returns the 3-component dot product of 2 vectors.
			 */
			dot: function (a)
			{
				return a.x * this.x + a.y * this.y + a.z * this.z;
			},

			/**
			 * Returns the 4-component dot product of 2 vectors. This can be useful for signed distances to a plane.
			 */
			dot4: function (a)
			{
				return a.x * this.x + a.y * this.y + a.z * this.z + a.w * this.w;
			},

			/**
			 * Linearly interpolates two vectors.
			 * @param {Float4} a The first vector to interpolate from.
			 * @param {Float4} b The second vector to interpolate to.
			 * @param {Number} t The interpolation factor.
			 * @returns {Float4} The interpolated value.
			 */
			lerp: function (a, b, factor)
			{
				var ax = a.x, ay = a.y, az = a.z, aw = a.w;

				this.x = ax + (b.x - ax) * factor;
				this.y = ay + (b.y - ay) * factor;
				this.z = az + (b.z - az) * factor;
				this.w = aw + (b.w - aw) * factor;
				return this;
			},

			/**
			 * Store the cross product of two vectors.
			 */
			cross: function (a, b)
			{
				// safe to use either a and b parameter
				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;

				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;
				this.w = 0.0;
				return this;
			},

			/**
			 * @ignore
			 */
			toString: function ()
			{
				return "Float4(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
			}
		};

	/**
	 * A preset for the origin point (w = 1)
	 */
	Float4.ORIGIN_POINT = new Float4(0, 0, 0, 1);

	/**
	 * A preset for the zero vector (w = 0)
	 */
	Float4.ZERO = new Float4(0, 0, 0, 0);

	/**
	 * A preset for the X-axis
	 */
	Float4.X_AXIS = new Float4(1, 0, 0, 0);

	/**
	 * A preset for the Y-axis
	 */
	Float4.Y_AXIS = new Float4(0, 1, 0, 0);

	/**
	 * A preset for the Z-axis
	 */
	Float4.Z_AXIS = new Float4(0, 0, 1, 0);

	/**
	 * @classdesc
	 * PoissonSphere is a class that allows generating 3D points in a poisson distribution.
	 *
	 * @constructor
	 * @param [mode] Whether the points should be contained in a square ({@linkcode PoissonSphere#BOX}) or a circle ({@linkcode PoissonSphere#SPHERICAL}). Defaults to spherical.
	 * @param [initialDistance]
	 * @param [decayFactor]
	 * @param [maxTests]
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PoissonSphere(mode, initialDistance, decayFactor, maxTests)
	{
	    this._mode = mode === undefined? PoissonSphere.SPHERICAL : mode;
	    this._initialDistance = initialDistance || 1.0;
	    this._decayFactor = decayFactor || .99;
	    this._maxTests = maxTests || 20000;
	    this._currentDistance = 0;
	    this._points = null;
	    this.reset();
	}

	/**
	 * Generates points in a box.
	 */
	PoissonSphere.BOX = 0;

	/**
	 * Generates points in a sphere.
	 */
	PoissonSphere.SPHERICAL = 1;

	/**
	 * @ignore
	 * @private
	 */
	PoissonSphere._initDefault = function()
	{
	    PoissonSphere.DEFAULT = new PoissonSphere();
	    PoissonSphere.DEFAULT.generatePoints(64);
	    PoissonSphere.DEFAULT_FLOAT32 = new Float32Array(64 * 3);

	    var spherePoints = PoissonSphere.DEFAULT.getPoints();

	    for (var i = 0; i < 64; ++i) {
	        var p = spherePoints[i];
	        PoissonSphere.DEFAULT_FLOAT32[i * 3] = p.x;
	        PoissonSphere.DEFAULT_FLOAT32[i * 3 + 1] = p.y;
	        PoissonSphere.DEFAULT_FLOAT32[i * 3 + 2] = p.z;
	    }
	};

	PoissonSphere.prototype =

	    /**
	     * Gets all points currently generated.
	     */{
	    getPoints: function()
	    {
	        return this._points;
	    },

	    /**
	     * Clears all generated points.
	     */
	    reset : function()
	    {
	        this._currentDistance = this._initialDistance;
	        this._points = [];
	    },

	    /**
	     * Generates new points and add them to the set. This does not return a set of points.
	     * @param numPoints The amount of points to generate.
	     */
	    generatePoints: function(numPoints)
	    {
	        for (var i = 0; i < numPoints; ++i)
	            this.generatePoint();
	    },

	    /**
	     * Generates a single point and adds it to the set.
	     */
	    generatePoint: function()
	    {
	        for (;;) {
	            var testCount = 0;
	            var sqrDistance = this._currentDistance*this._currentDistance;

	            while (testCount++ < this._maxTests) {
	                var candidate = this._getCandidate();
	                if (this._isValid(candidate, sqrDistance)) {
	                    this._points.push(candidate);
	                    return candidate;
	                }
	            }
	            this._currentDistance *= this._decayFactor;
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _getCandidate: function()
	    {
	        for (;;) {
	            var x = Math.random() * 2.0 - 1.0;
	            var y = Math.random() * 2.0 - 1.0;
	            var z = Math.random() * 2.0 - 1.0;
	            if (this._mode === PoissonSphere.BOX || (x * x + y * y + z * z <= 1))
	                return new Float4(x, y, z, 0.0);
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _isValid: function(candidate, sqrDistance)
	    {
	        var len = this._points.length;
	        for (var i = 0; i < len; ++i) {
	            var p = this._points[i];
	            var dx = candidate.x - p.x;
	            var dy = candidate.y - p.y;
	            var dz = candidate.z - p.z;
	            if (dx*dx + dy*dy + dz*dz < sqrDistance)
	                return false;
	        }

	        return true;
	    }
	};

	var RCP_LOG_OF_2 = 1.0 / Math.log(2);

	/**
	 * Some extra Math functionality for your enjoyment.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var MathX = {
	    /**
	     * The factor to convert degrees to radians.
	     */
	    DEG_TO_RAD: Math.PI / 180.0,

	    /**
	     * The factor to convert radians to degrees.
	     */
	    RAD_TO_DEG: 180.0 / Math.PI,

	    /**
	     * Returns the sign of a given value.
	     * @returns {number} -1 if v < 0, 0 if v == 0, 1 if v > 1
	     */
	    sign: function(v)
	    {
	        return  v === 0.0? 0.0 :
	            v > 0.0? 1.0 : -1.0;
	    },

	    /**
	     * Verifies whether the value is a power of 2.
	     */
	    isPowerOfTwo: function(value)
	    {
	        return value? ((value & -value) === value) : false;
	    },

	    /**
	     * Return the base-2 logarithm.
	     */
	    log2: function(value)
	    {
	        return Math.log(value) * RCP_LOG_OF_2;
	    },

	    /**
	     * Clamps a value to a minimum and maximum.
	     */
	    clamp: function(value, min, max)
	    {
	        return  value < min?    min :
	            value > max?    max :
	                value;
	    },

	    /**
	     * Clamps a value to 0 and 1
	     */
	    saturate: function(value)
	    {
	        return MathX.clamp(value, 0.0, 1.0);
	    },

	    /**
	     * Linearly interpolates a number.
	     */
	    lerp: function(a, b, factor)
	    {
	        return a + (b - a) * factor;
	    },

	    /**
	     * Returns 0 if x < lower, 1 if x > lower, and linearly interpolates in between.
	     */
	    linearStep: function(lower, upper, x)
	    {
	        return MathX.saturate((x - lower) / (upper - lower));
	    },

	    /**
	     * Estimates the radius of a gaussian curve.
	     * @param variance The variance of the gaussian curve.
	     * @param epsilon The minimum value of the curve to still be considered within the radius.
	     */
	    estimateGaussianRadius: function (variance, epsilon)
	    {
	        return Math.sqrt(-2.0 * variance * Math.log(epsilon));
	    },

	    fract: function(value)
	    {
	        return value - Math.floor(value);
	    }
	};

	/**
	 * @classdesc
	 * Quaternion is a class to represent (in our case) rotations.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Quaternion(x, y, z, w)
	{
	    // x, y, z, w allowed to be accessed publicly for simplicity, changing this does not violate invariant. Ever.
	    this.x = x || 0;
	    this.y = y || 0;
	    this.z = z || 0;
	    this.w = w === undefined? 1 : w;
	}

	/**
	 * Creates a new Quaternion from an axis/angle rotation.
	 */
	Quaternion.fromAxisAngle = function(axis, radians)
	{
	    var q = new Quaternion();
	    q.fromAxisAngle(axis, radians);
	    return q;
	};

	/**
	 * Creates a new Quaternion from pitch/yaw/roll Tait Bryan angles.
	 */
	Quaternion.fromPitchYawRoll = function(pitch, yaw, roll)
	{
	    var q = new Quaternion();
	    q.fromPitchYawRoll(pitch, yaw, roll);
	    return q;
	};

	/**
	 * Creates a new Quaternion from Euler angles.
	 */
	Quaternion.fromEuler = function(x, y, z)
	{
	    var q = new Quaternion();
	    q.fromEuler(x, y, z);
	    return q;
	};

	/**
	 * Creates a new Quaternion from a rotation matrix.
	 */
	Quaternion.fromMatrix = function(m)
	{
	    var q = new Quaternion();
	    q.fromMatrix(m);
	    return q;
	};

	/**
	 * Creates a new Quaternion that rotates v1 to v2
	 */
	Quaternion.fromVectors = function(v1, v2)
	{
	    var q = new Quaternion();
	    q.fromVectors(v1, v2);
	    return q;
	};

	Quaternion.prototype =
	{
	    /**
	     * Initializes as an axis/angle rotation
	     */
	    fromAxisAngle: function (axis, radians)
	    {
	        var halfAngle = radians * .5;
	        var factor = Math.sin(halfAngle) / axis.length;
	        this.x = axis.x * factor;
	        this.y = axis.y * factor;
	        this.z = axis.z * factor;
	        this.w = Math.cos(halfAngle);
	        return this;
	    },

	    /**
	     * Initializes from Tait-Bryan angles
	     */
	    fromPitchYawRoll: function(pitch, yaw, roll)
	    {
	        var mtx = new Matrix4x4();
	        // wasteful. improve.
	        mtx.fromRotationPitchYawRoll(pitch, yaw, roll);
	        this.fromMatrix(mtx);
	        return this;
	    },

	    /**
	     * Initializes from Euler angles
	     */
	    fromEuler: function(x, y, z)
	    {
	    	if (y === undefined) {
	    		y = x.y;
	    		z = x.z;
	    		x = x.x;
			}
	        var cx = Math.cos(x * 0.5), cy = Math.cos(y * 0.5), cz = Math.cos(z * 0.5);
	        var sx = Math.sin(x * 0.5), sy = Math.sin(y * 0.5), sz = Math.sin(z * 0.5);

	        this.x = sx*cy*cz + cx*sy*sz;
	        this.y = cx*sy*cz - sx*cy*sz;
	        this.z = cx*cy*sz + sx*sy*cz;
	        this.w = cx*cy*cz - sx*sy*sz;
	        return this;
	    },

	    /**
	     * Stores the rotation as Euler angles in a Float4 object
	     */
	    toEuler: function(target)
	    {
	        target = target || new Float4();

	        var x = this.x, y = this.y, z = this.z, w = this.w;
	        var xx = x * x, yy = y * y, zz = z * z, ww = w * w;

	        target.x = Math.atan2( -2*(y*z - w*x), ww - xx - yy + zz );
	        target.y = Math.asin ( 2*(x*z + w*y) );
	        target.z = Math.atan2( -2*(x*y - w*z), ww + xx - yy - zz );

	        return target;
	    },

	    /**
	     * Initializes from a rotation matrix
	     */
	    fromMatrix: function(m)
	    {
	        var m00 = m._m[0];
	        var m11 = m._m[5];
	        var m22 = m._m[10];
	        var trace = m00 + m11 + m22;
	        var s;

	        if (trace > 0.0) {
	            trace += 1.0;
	            s = 1.0/Math.sqrt(trace)*.5;
	            this.x = s*(m._m[6] - m._m[9]);
	            this.y = s*(m._m[8] - m._m[2]);
	            this.z = s*(m._m[1] - m._m[4]);
	            this.w = s*trace;
	        }
	        else if (m00 > m11 && m00 > m22) {
	            trace = m00 - m11 - m22 + 1.0;
	            s = 1.0/Math.sqrt(trace)*.5;

	            this.x = s*trace;
	            this.y = s*(m._m[1] + m._m[4]);
	            this.z = s*(m._m[8] + m._m[2]);
	            this.w = s*(m._m[6] - m._m[9]);
	        }
	        else if (m11 > m22) {
	            trace = m11 - m00 - m22 + 1.0;
	            s = 1.0/Math.sqrt(trace)*.5;

	            this.x = s*(m._m[1] + m._m[4]);
	            this.y = s*trace;
	            this.z = s*(m._m[6] + m._m[9]);
	            this.w = s*(m._m[8] - m._m[2]);
	        }
	        else {
	            trace = m22 - m00 - m11 + 1.0;
	            s = 1.0/Math.sqrt(trace)*.5;

	            this.x = s*(m._m[8] + m._m[2]);
	            this.y = s*(m._m[6] + m._m[9]);
	            this.z = s*trace;
	            this.w = s*(m._m[1] - m._m[4]);
	        }

	        // this is to prevent non-normalized due to rounding errors
	        this.normalize();
	        return this;
	    },

	    // finds the rotation matrix that rotates v1 to v2
	    fromVectors: function(v1, v2)
	    {
	        Float4.cross(v1, v2, this);
	        // not using .length saves one sqrt
	        this.w = Math.sqrt(v1.lengthSqr * v2.lengthSqr) + v1.dot(v2);
	        this.normalize();
	    },

	    /**
	     * Rotates a Float4 point.
	     *
	     * @param {Float4} [target] An optional target object. If not provided, a new object will be created and returned.
	     */
	    rotate: function(v, target)
	    {
	        target = target || new Float4();

	        var vx = v.x, vy = v.y, vz = v.z;
	        var x = this.x, y = this.y, z = this.z, w = this.w;

	        // p*q'
	        var w1 = - x * vx - y * vy - z * vz;
	        var x1 = w * vx + y * vz - z * vy;
	        var y1 = w * vy - x * vz + z * vx;
	        var z1 = w * vz + x * vy - y * vx;

	        target.x = -w1 * x + x1 * w - y1 * z + z1 * y;
	        target.y = -w1 * y + x1 * z + y1 * w - z1 * x;
	        target.z = -w1 * z - x1 * y + y1 * x + z1 * w;
	        target.w = v.w;
	        return target;
	    },

	    /**
	     * Negates all the components. This results in the same net rotation, but with different orientation
	     */
	    negate: function()
	    {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        this.w = -this.w;
	        return this;
	    },

	    /**
	     * Sets all components explicitly
	     */
	    set: function(x, y, z, w)
	    {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	        return this;
	    },

	    /**
	     * Copies all components from another quaternion
	     */
	    copyFrom: function(b)
	    {
	        this.x = b.x;
	        this.y = b.y;
	        this.z = b.z;
	        this.w = b.w;
	        return this;
	    },

	    /**
	     * Gets the quaternion's squared norm
	     */
	    get normSquared()
	    {
	        return this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w;
	    },

	    /**
	     * Gets the quaternion's norm
	     */
	    get norm()
	    {
	        return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w);
	    },

	    /**
	     * Normalizes the quaternion.
	     */
	    normalize : function()
	    {
	        var rcpNorm = 1.0/Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w);
	        this.x *= rcpNorm;
	        this.y *= rcpNorm;
	        this.z *= rcpNorm;
	        this.w *= rcpNorm;
	        return this;
	    },

	    /**
	     * Converts to the conjugate.
	     */
	    conjugate: function()
	    {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        return this;
	    },

	    /**
	     * Stores the inverse of a given quaternion.
	     */
	    inverseOf: function(q)
	    {
	        var x = q.x, y = q.y, z = q.z, w = q.w;
	        var rcpSqrNorm = 1.0 / (x*x + y*y + z*z + w*w);
	        this.x = -x*rcpSqrNorm;
	        this.y = -y*rcpSqrNorm;
	        this.z = -z*rcpSqrNorm;
	        this.w = w*rcpSqrNorm;
	        return this;
	    },

	    /**
	     * Inverts the quaternion.
	     */
	    invert: function ()
	    {
	        var x = this.x, y = this.y, z = this.z, w = this.w;
	        var rcpSqrNorm = 1.0 / (x*x + y*y + z*z + w*w);
	        this.x = -x*rcpSqrNorm;
	        this.y = -y*rcpSqrNorm;
	        this.z = -z*rcpSqrNorm;
	        this.w = w*rcpSqrNorm;
	        return this;
	    },

	    /**
	     * Multiplies two quaternions and stores it in the current.
	     */
	    multiply: function(a, b)
	    {
	        var w1 = a.w, x1 = a.x, y1 = a.y, z1 = a.z;
	        var w2 = b.w, x2 = b.x, y2 = b.y, z2 = b.z;

	        this.x = w1*x2 + x1*w2 + y1*z2 - z1*y2;
	        this.y = w1*y2 - x1*z2 + y1*w2 + z1*x2;
	        this.z = w1*z2 + x1*y2 - y1*x2 + z1*w2;
	        this.w = w1*w2 - x1*x2 - y1*y2 - z1*z2;
	        return this;
	    },

	    /**
	     * Post-multiplies another quaternion to this one.
	     */
	    append: function(q)
	    {
	        return this.multiply(q, this);
	    },

	    /**
	     * Pre-multiplies another quaternion to this one.
	     */
	    prepend: function(q)
	    {
	        return this.multiply(this, q);
	    },

	    /**
	     * Linearly interpolates two quaternions.
	     * @param {Quaternion} a The first vector to interpolate from.
	     * @param {Quaternion} b The second vector to interpolate to.
	     * @param {Number} t The interpolation factor.
	     */
	    lerp: function(a, b, factor)
	    {
	        var w1 = a.w, x1 = a.x, y1 = a.y, z1 = a.z;
	        var w2 = b.w, x2 = b.x, y2 = b.y, z2 = b.z;

	        // use shortest direction
	        if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
	            w2 = -w2;
	            x2 = -x2;
	            y2 = -y2;
	            z2 = -z2;
	        }

	        this.x = x1 + factor * (x2 - x1);
	        this.y = y1 + factor * (y2 - y1);
	        this.z = z1 + factor * (z2 - z1);
	        this.w = w1 + factor * (w2 - w1);

	        this.normalize();
	        return this;
	    },

	    /**
	     * Spherical-linearly interpolates two quaternions.
	     * @param {Quaternion} a The first vector to interpolate from.
	     * @param {Quaternion} b The second vector to interpolate to.
	     * @param {Number} t The interpolation factor.
	     */
	    slerp: function(a, b, factor)
	    {
	        var w1 = a.w, x1 = a.x, y1 = a.y, z1 = a.z;
	        var w2 = b.w, x2 = b.x, y2 = b.y, z2 = b.z;
	        var dot = w1*w2 + x1*x2 + y1*y2 + z1*z2;

	        // shortest direction
	        if (dot < 0.0) {
	            dot = -dot;
	            w2 = -w2;
	            x2 = -x2;
	            y2 = -y2;
	            z2 = -z2;
	        }

	        if (dot < 0.95) {
	            // interpolate angle linearly
	            var angle = Math.acos(dot);
	            var interpolatedAngle = factor*angle;

	            var x = x2 - x1*dot;
	            var y = y2 - y1*dot;
	            var z = z2 - z1*dot;
	            var w = w2 - w1*dot;
	            var rcpNorm = 1.0/Math.sqrt(x*x + y*y + z*z + w*w);
	            x *= rcpNorm;
	            y *= rcpNorm;
	            z *= rcpNorm;
	            w *= rcpNorm;

	            var cos = Math.cos(interpolatedAngle);
	            var sin = Math.sin(interpolatedAngle);
	            this.x = x1 * cos + x * sin;
	            this.y = y1 * cos + y * sin;
	            this.z = z1 * cos + z * sin;
	            this.w = w1 * cos + w * sin;
	        }
	        else {
	            // nearly identical angle, interpolate linearly
	            this.x = x1 + factor * (x2 - x1);
	            this.y = y1 + factor * (y2 - y1);
	            this.z = z1 + factor * (z2 - z1);
	            this.w = w1 + factor * (w2 - w1);
	            this.normalize();
	        }

	        return this;
	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        return "Quaternion(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
	    }
	};

	/**
	 *
	 * PropertyListener allows listening to changes to other objects' properties. When a change occurs, the onChange signal will be dispatched.
	 * It's a bit hackish, but it prevents having to dispatch signals in performance-critical classes such as Float4.
	 *
	 * @constructor
	 *
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PropertyListener()
	{
	    this._enabled = true;
	    this.onChange = new Signal();
	    this._targets = [];
	}

	PropertyListener.prototype =
	{
	    /**
	     * If false, prevents the PropertyListener from dispatching change events.
	     */
	    get enabled()
	    {
	        return this._enabled;
	    },

	    set enabled(value)
	    {
	        this._enabled = value;
	    },

	    /**
	     * Starts listening to changes for an object's property for changes.
	     * @param targetObj The target object to monitor.
	     * @param propertyName The name of the property for which we'll be listening.
	     */
	    add: function(targetObj, propertyName)
	    {
	        var index = this._targets.length;
	        this._targets.push(
	            {
	                object: targetObj,
	                propertyName: propertyName,
	                value: targetObj[propertyName]
	            }
	        );

	        var wrapper = this;
	        var target = wrapper._targets[index];
	        Object.defineProperty(targetObj, propertyName, {
	            get: function() {
	                return target.value;
	            },
	            set: function(val) {
	                if (val !== target.value) {
	                    target.value = val;
	                    if (wrapper._enabled)
	                        wrapper.onChange.dispatch();
	                }
	            }
	        });
	    },

	    /**
	     * Stops listening to a property for changes.
	     * @param targetObj The object to stop monitoring.
	     * @param propertyName The name of the property for which we'll be listening.
	     */
	    remove: function(targetObj, propertyName)
	    {
	        for (var i = 0; i < this._targets.length; ++i) {
	            var target = this._targets[i];
	            if (target.object === targetObj && target.propertyName === propertyName) {
	                delete target.object[target.propertyName];
	                target.object[target.propertyName] = target.value;
	                this._targets.splice(i--, 1);
	            }
	        }
	    }
	};

	/**
	 * @classdesc
	 * Transform is a class to describe an object's transformation through position, rotation (as a quaternion) and scale.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Transform()
	{
	    this._position = new Float4(0.0, 0.0, 0.0, 1.0);
	    this._rotation = new Quaternion();
	    this._euler = new Float4(0.0, 0.0, 0.0, 0.0);
	    this._scale = new Float4(1.0, 1.0, 1.0, 1.0);
	    this._matrix = new Matrix4x4();

		this._eulerInvalid = true;
	    this._eulerChangeListener = new PropertyListener();
		this._eulerChangeListener.add(this._euler, "x");
		this._eulerChangeListener.add(this._euler, "y");
		this._eulerChangeListener.add(this._euler, "z");
		this._eulerChangeListener.onChange.bind(this._onEulerChanged, this);

	    this._changeListener = new PropertyListener();
	    this._changeListener.add(this._position, "x");
	    this._changeListener.add(this._position, "y");
	    this._changeListener.add(this._position, "z");
	    this._changeListener.add(this._scale, "x");
	    this._changeListener.add(this._scale, "y");
	    this._changeListener.add(this._scale, "z");
	    this._changeListener.onChange.bind(this._invalidateMatrix, this);

	    this._rotationChangeListener = new PropertyListener();
		this._rotationChangeListener.add(this._rotation, "x");
		this._rotationChangeListener.add(this._rotation, "y");
		this._rotationChangeListener.add(this._rotation, "z");
		this._rotationChangeListener.add(this._rotation, "w");
		this._rotationChangeListener.onChange.bind(this._onRotationChanged, this);
	}

	Transform.prototype =
	{
	    /**
	     * The position of the object.
	     */
	    get position() {
	        return this._position;
	    },


	    set position(value) {
	        // make sure position object never changes
	        this._position.copyFrom(value);
	    },

	    /**
	     * The rotation of the object.
	     */
	    get rotation() {
	        return this._rotation;
	    },

	    set rotation(value) {
	        // make sure position object never changes
	        this._rotationChangeListener.enabled = false;
	        this._rotation.copyFrom(value);
			this._rotationChangeListener.enabled = true;
			this._onRotationChanged();
	    },

	    /**
	     * The rotation of the object.
	     */
	    get euler() {
	        if (this._eulerInvalid) {
	            // this is a slave update, should not trigger an invalidation
				this._eulerChangeListener.enabled = false;
	            this._rotation.toEuler(this._euler);
				this._eulerChangeListener.enabled = true;
	        }
	        return this._euler;
	    },

	    set euler(value) {
	        this._eulerChangeListener.enabled = false;
	        this._euler.copyFrom(value);
			this._eulerChangeListener.enabled = true;
			this._onEulerChanged();
	    },

	    /**
	     * This disables listening to the position, rotation, etc. properties. If you need to change a lot of these properties,
	     * at once, it may be worth using this.
	     */
	    disableMatrixUpdates: function()
	    {
	        this._changeListener.enabled = false;
	        this._eulerChangeListener.enabled = false;
	    },

	    /**
	     * This re-enables automatic matrix updates.
	     */
	    enableMatrixUpdates: function()
	    {
	        this._changeListener.enabled = true;
	        this._eulerChangeListener.enabled = true;
	        this._invalidateMatrix();
	    },

	    /**
	     * The scale of the object.
	     */
	    get scale() {
	        return this._scale;
	    },

	    set scale(value) {
	        // make sure position object never changes
	        this._scale.copyFrom(value);
	    },

	    /**
	     * Orients the object in such a way as to face the target point.
	     */
	    lookAt: function(target)
	    {
	        this._matrix.lookAt(target, this._position);
	        this._matrix.appendScale(this._scale);
	        this._applyMatrix();
	    },

	    /**
	     * Copies the state of another Transform object
	     */
	    copyTransform: function(transform)
	    {
	        this._changeListener.enabled = false;
	        this._rotationChangeListener.enabled = false;
	        this._position.copyFrom(transform.position);
	        this._rotation.copyFrom(transform.rotation);
	        this._scale.copyFrom(transform.scale);
	        this._changeListener.enabled = true;
	        this._rotationChangeListener.enabled = true;
	        this._eulerInvalid = true;
	        this._invalidateMatrix();
	    },

	    /**
	     * The matrix representing the transform.
	     */
	    get matrix()
	    {
	        if (this._matrixInvalid)
	            this._updateMatrix();

	        return this._matrix;
	    },

	    set matrix(value)
	    {
	        this._matrix.copyFrom(value);
	        this._applyMatrix();
	    },

		/**
	     * @ignore
		 */
		_onEulerChanged: function()
	    {
	        this._rotationChangeListener.enabled = false;
	        this._rotation.fromEuler(this._euler);
			this._rotationChangeListener.enabled = true;
	        this._invalidateMatrix();
		},

		/**
	     * @ignore
		 */
		_onRotationChanged: function ()
		{
	        this._eulerInvalid = true;
	        this._invalidateMatrix();
		},

		/**
	     * @ignore
	     */
	    _invalidateMatrix: function ()
	    {
	        this._matrixInvalid = true;
	    },

	    /**
	     * @ignore
	     */
	    _updateMatrix: function()
	    {
	        this._matrix.compose(this);
	        this._matrixInvalid = false;
	    },

	    /**
	     * @ignore
	     */
	    _applyMatrix: function()
	    {
	        this._matrixInvalid = false;
	        // matrix decompose will trigger property updates, so disable this
	        this._changeListener.enabled = false;
	        this._rotationChangeListener.enabled = false;
	        this._matrix.decompose(this);
	        this._changeListener.enabled = true;
	        this._rotationChangeListener.enabled = true;
	        this._eulerInvalid = true;
	    },

		/**
		 * Creates a copy of the object.
	 	 */
		clone: function()
		{
			var clone = new Transform();
			clone.copyFrom(this);
			return clone;
		},

		/**
		 * @ignore
		 */
		copyFrom: function(src)
		{
			this.matrix = src.matrix;
		}
	};

	/**
	 * @classdec
	 * Matrix4x4 object represents a 4D matrix (generally an affine transformation or a projection). The elements are stored
	 * in column-major order. Vector multiplication is in column format (ie v' = M x v)
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 *
	 */
	function Matrix4x4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33)
	{
	    this.set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
	}

	/**
	 * Adds two matrices together
	 */
	Matrix4x4.add = function(m1, m2, target)
	{
	    target = target || new Matrix4x4();
	    target.copyFrom(m1);
	    return target.add(m2);
	};

	/**
	 * Multiplies two matrices. The order of the parameters are the order of the multiplication. M1 is appended to M2
	 */
	Matrix4x4.multiply = function(m1, m2, target)
	{
	    target = target || new Matrix4x4();
	    target.copyFrom(m1);
	    return target.prepend(m2);
	};

	Matrix4x4.prototype =
	{
	    /**
	     * Sets the values of the matrix directly.
	     */
	    set: function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33)
	    {
	        if (m00 !== undefined && isNaN(m00)) {
	            this._m = new Float32Array(m00);
	        }
	        else {
	            var m = this._m = new Float32Array(16);

	            m[0] = m00 === undefined ? 1 : 0;
	            m[1] = m10 || 0;
	            m[2] = m20 || 0;
	            m[3] = m30 || 0;
	            m[4] = m01 || 0;
	            m[5] = m11 === undefined ? 1 : 0;
	            m[6] = m21 || 0;
	            m[7] = m31 || 0;
	            m[8] = m02 || 0;
	            m[9] = m12 || 0;
	            m[10] = m22 === undefined ? 1 : 0;
	            m[11] = m32 || 0;
	            m[12] = m03 || 0;
	            m[13] = m13 || 0;
	            m[14] = m23 || 0;
	            m[15] = m33 === undefined ? 1 : 0;
	        }
	    },

	    /**
	     * Transforms a Float4 object (use for homogeneous general case of Float4, perspective or when "type" (w) of Float4 is unknown)
	     *
	     * @param v The Float4 object to transform.
	     * @param [target] An optional target. If not provided, a new object will be created and returned.
	     */
	    transform: function (v, target)
	    {
	        target = target || new Float4();
	        var x = v.x, y = v.y, z = v.z, w = v.w;
	        var m = this._m;

	        target.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	        target.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	        target.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	        target.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;

	        return target;
	    },

		/**
		 * Transforms a Float4 point (assuming its w component is 1) and divides by the resulting w
		 *
		 * @param v The Float4 object to transform.
		 * @param [target] An optional target. If not provided, a new object will be created and returned.
		 */
	    projectPoint: function(v, target)
	    {
			target = target || new Float4();
			var x = v.x, y = v.y, z = v.z;
			var m = this._m;

			var rcpW = 1.0 / (m[3] * x + m[7] * y + m[11] * z + m[15]);

			target.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * rcpW;
			target.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * rcpW;
			target.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * rcpW;
			target.w = 1.0;


			return target;
	    },

	    /**
	     * Transforms a Float4 object, treating it as a point. Slightly faster than transform for points.
	     *
	     * @param v The Float4 object to transform.
	     * @param [target] An optional target. If not provided, a new object will be created and returned.
	     */
	    transformPoint: function (v, target)
	    {
	        target = target || new Float4();
	        var x = v.x, y = v.y, z = v.z;
	        var m = this._m;

	        target.x = m[0] * x + m[4] * y + m[8] * z + m[12];
	        target.y = m[1] * x + m[5] * y + m[9] * z + m[13];
	        target.z = m[2] * x + m[6] * y + m[10] * z + m[14];
	        target.w = 1.0;

	        return target;
	    },

		/**
		 * Transforms a Float4 object, treating it as a normal vector.
		 *
		 * @param v The Float4 object to transform.
		 * @param [target] An optional target. If not provided, a new object will be created and returned.
		 */
		transformNormal: function (v, target)
		{
		    // calculate inverse
		    var m = this._m;
			var m0 = m[0], m1 = m[1], m2 = m[2];
			var m4 = m[4], m5 = m[5], m6 = m[6];
			var m8 = m[8], m9 = m[9], m10 = m[10];
			var determinant = m0 * (m5 * m10 - m9 * m6) - m4 * (m1 * m10 - m9 * m2) + m8 * (m1 * m6 - m5 * m2);
			var rcpDet = 1.0 / determinant;

			var n0 = (m5 * m10 - m9 * m6) * rcpDet;
			var n1 = (m9 * m2 - m1 * m10) * rcpDet;
			var n2 = (m1 * m6 - m5 * m2) * rcpDet;
			var n4 = (m8 * m6 - m4 * m10) * rcpDet;
			var n5 = (m0 * m10 - m8 * m2) * rcpDet;
			var n6 = (m4 * m2 - m0 * m6) * rcpDet;
			var n8 = (m4 * m9 - m8 * m5) * rcpDet;
			var n9 = (m8 * m1 - m0 * m9) * rcpDet;
			var n10 = (m0 * m5 - m4 * m1) * rcpDet;

			target = target || new Float4();
			var x = v.x, y = v.y, z = v.z;

			// multiply with transpose of that inverse
			target.x = n0 * x + n1 * y + n2 * z;
			target.y = n4 * x + n5 * y + n6 * z;
			target.z = n8 * x + n9 * y + n10 * z;
			target.w = 0.0;

			return target;
		},

		/**
		 * Transforms a Float4 object, treating it as a vector (ie: disregarding translation). Slightly faster than transform for vectors.
	     *
	     * @param v The Float4 object to transform.
	     * @param [target] An optional target. If not provided, a new object will be created and returned.
	     */
	    transformVector: function (v, target)
	    {
	        target = target || new Float4();
	        var x = v.x, y = v.y, z = v.z;

	        var m = this._m;
	        target.x = m[0] * x + m[4] * y + m[8] * z;
	        target.y = m[1] * x + m[5] * y + m[9] * z;
	        target.z = m[2] * x + m[6] * y + m[10] * z;
	        target.w = 0.0;

	        return target;
	    },

	    /**
	     * Transforms a Float4 object, treating it as a vector (ie: disregarding translation) containing a size (so always abs)! Slightly faster than transform for vectors.
	     *
	     * @param v The Float4 object to transform.
	     * @param [target] An optional target. If not provided, a new object will be created and returned.
	     */
	    transformExtent: function (v, target)
	    {
	        target = target || new Float4();
	        var x = v.x, y = v.y, z = v.z;

	        var m = this._m;
	        var m00 = m[0], m10 = m[1], m20 = m[2];
	        var m01 = m[4], m11 = m[5], m21 = m[6];
	        var m02 = m[8], m12 = m[9], m22 = m[10];

	        if (m00 < 0) m00 = -m00; if (m10 < 0) m10 = -m10; if (m20 < 0) m20 = -m20;
	        if (m01 < 0) m01 = -m01; if (m11 < 0) m11 = -m11; if (m21 < 0) m21 = -m21;
	        if (m02 < 0) m02 = -m02; if (m12 < 0) m12 = -m12; if (m22 < 0) m22 = -m22;

	        target.x = m00 * x + m01 * y + m02 * z;
	        target.y = m10 * x + m11 * y + m12 * z;
	        target.z = m20 * x + m21 * y + m22 * z;
	        target.w = 0.0;

	        return target;
	    },

	    /**
	     * Transforms a Quaternion.
	     * @param {Quaternion} q The quaternion to transform
	     * @param {Quaternion} [target] An optional target. If not provided, a new object will be created and returned.
	     */
	    transformQuaternion: function(q, target)
	    {
	        target = target || new Quaternion();
	        target.fromMatrix(this);
	        target.prepend(q);
	        return target;
	    },

	    /**
	     * Copies its elements from another matrix.
	     */
	    copyFrom: function(a)
	    {
	        var m = this._m;
	        var mm = a._m;
	        m[0] = mm[0];
	        m[1] = mm[1];
	        m[2] = mm[2];
	        m[3] = mm[3];
	        m[4] = mm[4];
	        m[5] = mm[5];
	        m[6] = mm[6];
	        m[7] = mm[7];
	        m[8] = mm[8];
	        m[9] = mm[9];
	        m[10] = mm[10];
	        m[11] = mm[11];
	        m[12] = mm[12];
	        m[13] = mm[13];
	        m[14] = mm[14];
	        m[15] = mm[15];

	        return this;
	    },

	    /**
	     * Initializes the matrix as a rotation matrix based on a quaternion.
	     */
	    fromQuaternion: function (q)
	    {
	        var x = q.x, y = q.y, z = q.z, w = q.w;

	        var m = this._m;
	        m[0] = 1 - 2 * (y * y + z * z);
	        m[1] = 2 * (x * y + w * z);
	        m[2] = 2 * (x * z - w * y);
	        m[3] = 0;
	        m[4] = 2 * (x * y - w * z);
	        m[5] = 1 - 2 * (x * x + z * z);
	        m[6] = 2 * (y * z + w * x);
	        m[7] = 0;
	        m[8] = 2 * (x * z + w * y);
	        m[9] = 2 * (y * z - w * x);
	        m[10] = 1 - 2 * (x * x + y * y);
	        m[11] = 0;
	        m[12] = 0;
	        m[13] = 0;
	        m[14] = 0;
	        m[15] = 1;
	        return this;
	    },

	    /**
	     * Multiplies two matrix objects and stores the result in this one
	     *
	     * @param a
	     * @param b
	     */
	    multiply: function (a, b)
	    {
	        var am = a._m, bm = b._m;
	        var a_m00 = am[0], a_m10 = am[1], a_m20 = am[2], a_m30 = am[3];
	        var a_m01 = am[4], a_m11 = am[5], a_m21 = am[6], a_m31 = am[7];
	        var a_m02 = am[8], a_m12 = am[9], a_m22 = am[10], a_m32 = am[11];
	        var a_m03 = am[12], a_m13 = am[13], a_m23 = am[14], a_m33 = am[15];
	        var b_m00 = bm[0], b_m10 = bm[1], b_m20 = bm[2], b_m30 = bm[3];
	        var b_m01 = bm[4], b_m11 = bm[5], b_m21 = bm[6], b_m31 = bm[7];
	        var b_m02 = bm[8], b_m12 = bm[9], b_m22 = bm[10], b_m32 = bm[11];
	        var b_m03 = bm[12], b_m13 = bm[13], b_m23 = bm[14], b_m33 = bm[15];

	        var m = this._m;
	        m[0] = a_m00 * b_m00 + a_m01 * b_m10 + a_m02 * b_m20 + a_m03 * b_m30;
	        m[1] = a_m10 * b_m00 + a_m11 * b_m10 + a_m12 * b_m20 + a_m13 * b_m30;
	        m[2] = a_m20 * b_m00 + a_m21 * b_m10 + a_m22 * b_m20 + a_m23 * b_m30;
	        m[3] = a_m30 * b_m00 + a_m31 * b_m10 + a_m32 * b_m20 + a_m33 * b_m30;
	        m[4] = a_m00 * b_m01 + a_m01 * b_m11 + a_m02 * b_m21 + a_m03 * b_m31;
	        m[5] = a_m10 * b_m01 + a_m11 * b_m11 + a_m12 * b_m21 + a_m13 * b_m31;
	        m[6] = a_m20 * b_m01 + a_m21 * b_m11 + a_m22 * b_m21 + a_m23 * b_m31;
	        m[7] = a_m30 * b_m01 + a_m31 * b_m11 + a_m32 * b_m21 + a_m33 * b_m31;
	        m[8] = a_m00 * b_m02 + a_m01 * b_m12 + a_m02 * b_m22 + a_m03 * b_m32;
	        m[9] = a_m10 * b_m02 + a_m11 * b_m12 + a_m12 * b_m22 + a_m13 * b_m32;
	        m[10] = a_m20 * b_m02 + a_m21 * b_m12 + a_m22 * b_m22 + a_m23 * b_m32;
	        m[11] = a_m30 * b_m02 + a_m31 * b_m12 + a_m32 * b_m22 + a_m33 * b_m32;
	        m[12] = a_m00 * b_m03 + a_m01 * b_m13 + a_m02 * b_m23 + a_m03 * b_m33;
	        m[13] = a_m10 * b_m03 + a_m11 * b_m13 + a_m12 * b_m23 + a_m13 * b_m33;
	        m[14] = a_m20 * b_m03 + a_m21 * b_m13 + a_m22 * b_m23 + a_m23 * b_m33;
	        m[15] = a_m30 * b_m03 + a_m31 * b_m13 + a_m32 * b_m23 + a_m33 * b_m33;
	        return this;
	    },

	    /**
	     * Multiplies two matrix objects, assuming they're affine transformations, and stores the result in this one
	     *
	     * @param a
	     * @param b
	     */
	    multiplyAffine: function (a, b)
	    {
	        var am = a._m, bm = b._m;
	        var a_m00 = am[0], a_m10 = am[1], a_m20 = am[2];
	        var a_m01 = am[4], a_m11 = am[5], a_m21 = am[6];
	        var a_m02 = am[8], a_m12 = am[9], a_m22 = am[10];
	        var a_m03 = am[12], a_m13 = am[13], a_m23 = am[14];
	        var b_m00 = bm[0], b_m10 = bm[1], b_m20 = bm[2];
	        var b_m01 = bm[4], b_m11 = bm[5], b_m21 = bm[6];
	        var b_m02 = bm[8], b_m12 = bm[9], b_m22 = bm[10];
	        var b_m03 = bm[12], b_m13 = bm[13], b_m23 = bm[14];

	        var m = this._m;
	        m[0] = a_m00 * b_m00 + a_m01 * b_m10 + a_m02 * b_m20;
	        m[1] = a_m10 * b_m00 + a_m11 * b_m10 + a_m12 * b_m20;
	        m[2] = a_m20 * b_m00 + a_m21 * b_m10 + a_m22 * b_m20;

	        m[4] = a_m00 * b_m01 + a_m01 * b_m11 + a_m02 * b_m21;
	        m[5] = a_m10 * b_m01 + a_m11 * b_m11 + a_m12 * b_m21;
	        m[6] = a_m20 * b_m01 + a_m21 * b_m11 + a_m22 * b_m21;

	        m[8] = a_m00 * b_m02 + a_m01 * b_m12 + a_m02 * b_m22;
	        m[9] = a_m10 * b_m02 + a_m11 * b_m12 + a_m12 * b_m22;
	        m[10] = a_m20 * b_m02 + a_m21 * b_m12 + a_m22 * b_m22;

	        m[12] = a_m00 * b_m03 + a_m01 * b_m13 + a_m02 * b_m23 + a_m03;
	        m[13] = a_m10 * b_m03 + a_m11 * b_m13 + a_m12 * b_m23 + a_m13;
	        m[14] = a_m20 * b_m03 + a_m21 * b_m13 + a_m22 * b_m23 + a_m23;
	        return this;

	    },

	    /**
	     * Initializes the matrix as a rotation matrix around a given axis
	     *
	     * @param axis The axis around which the rotation takes place.
	     * @param radians The angle of rotation
	     */
	    fromRotationAxisAngle: function (axis, radians)
	    {
	        var cos = Math.cos(radians);
	        var sin = Math.sin(radians);
	        var rcpLen = 1 / axis.length;


	        var x = axis.x * rcpLen, y = axis.y * rcpLen, z = axis.z * rcpLen;
	        var oneMinCos = 1 - cos;

	        var m = this._m;
	        m[0] = oneMinCos * x * x + cos;
	        m[1] = oneMinCos * x * y + sin * z;
	        m[2] = oneMinCos * x * z - sin * y;
	        m[3] = 0;
	        m[4] = oneMinCos * x * y - sin * z;
	        m[5] = oneMinCos * y * y + cos;
	        m[6] = oneMinCos * y * z + sin * x;
	        m[7] = 0;
	        m[8] = oneMinCos * x * z + sin * y;
	        m[9] = oneMinCos * y * z - sin * x;
	        m[10] = oneMinCos * z * z + cos;
	        m[11] = 0;
	        m[12] = 0;
	        m[13] = 0;
	        m[14] = 0;
	        m[15] = 1;
	        return this;
	    },


	    /**
	     * Initializes the matrix as a rotation matrix from 3 Euler angles
	     */
	    // this actually doesn't use a vector, because they're three unrelated quantities. A vector just doesn't make sense here, mathematically.
	    fromEuler: function (x, y, z)
	    {
	        var cosX = Math.cos(x);
	        var sinX = Math.sin(x);
	        var cosY = Math.cos(y);
	        var sinY = Math.sin(y);
	        var cosZ = Math.cos(z);
	        var sinZ = Math.sin(z);

	        var m = this._m;
	        m[0] = cosY * cosZ;
	        m[1] = cosX * sinZ + sinX * sinY * cosZ;
	        m[2] = sinX * sinZ - cosX * sinY * cosZ;
	        m[3] = 0;
	        m[4] = -cosY * sinZ;
	        m[5] = cosX * cosZ - sinX * sinY * sinZ;
	        m[6] = sinX * cosZ + cosX * sinY * sinZ;
	        m[7] = 0;
	        m[8] = sinY;
	        m[9] = -sinX * cosY;
	        m[10] = cosX * cosY;
	        m[11] = 0;
	        m[12] = 0;
	        m[13] = 0;
	        m[14] = 0;
	        m[15] = 1;
	        return this;
	    },

	    /**
	     * Initializes the matrix as a rotation matrix from Tait-Bryan angles (pitch, yaw, roll).
	     */
	    fromRotationPitchYawRoll: function (pitch, yaw, roll)
	    {
	        var cosP = Math.cos(-pitch);
	        var cosY = Math.cos(-yaw);
	        var cosR = Math.cos(roll);
	        var sinP = Math.sin(-pitch);
	        var sinY = Math.sin(-yaw);
	        var sinR = Math.sin(roll);

	        var yAxisX = -sinY * cosP;
	        var yAxisY = cosY * cosP;
	        var yAxisZ = -sinP;

	        var zAxisX = -cosY * sinR - sinY * sinP * cosR;
	        var zAxisY = -sinY * sinR + sinP * cosR * cosY;
	        var zAxisZ = cosP * cosR;

	        var xAxisX = yAxisY * zAxisZ - yAxisZ * zAxisY;
	        var xAxisY = yAxisZ * zAxisX - yAxisX * zAxisZ;
	        var xAxisZ = yAxisX * zAxisY - yAxisY * zAxisX;

	        var m = this._m;
	        m[0] = xAxisX;
	        m[1] = xAxisY;
	        m[2] = xAxisZ;
	        m[3] = 0;
	        m[4] = yAxisX;
	        m[5] = yAxisY;
	        m[6] = yAxisZ;
	        m[7] = 0;
	        m[8] = zAxisX;
	        m[9] = zAxisY;
	        m[10] = zAxisZ;
	        m[11] = 0;
	        m[12] = 0;
	        m[13] = 0;
	        m[14] = 0;
	        m[15] = 1;
	        return this;
	    },

	    /**
	     * Initializes as a translation matrix.
	     * @param xOrV A Float4 or a Number as x-coordinate
	     * @param y The y-translation. Omitted if xOrV is a Float4.
	     * @param z The z-translation. Omitted if xOrV is a Float4.
	     */
	    fromTranslation: function (xOrV, y, z)
	    {
	        if (y === undefined) {
	            xOrV = xOrV.x;
	            y = xOrV.y;
	            z = xOrV.z;
	        }
	        var m = this._m;
	        m[0] = 1;
	        m[1] = 0;
	        m[2] = 0;
	        m[3] = 0;
	        m[4] = 0;
	        m[5] = 1;
	        m[6] = 0;
	        m[7] = 0;
	        m[8] = 0;
	        m[9] = 0;
	        m[10] = 1;
	        m[11] = 0;
	        m[12] = xOrV;
	        m[13] = y;
	        m[14] = z;
	        m[15] = 1;
	        return this;
	    },

	    /**
	     * Initializes as a scale matrix.
	     * @param x
	     * @param y
	     * @param z
	     */
	    fromScale: function (x, y, z)
	    {
	        if (x instanceof Float4) {
	            y = x.y;
	            z = x.z;
	            x = x.x;
	        }
	        else if (y === undefined)
	            y = z = x;

	        var m = this._m;
	        m[0] = x;
	        m[1] = 0;
	        m[2] = 0;
	        m[3] = 0;
	        m[4] = 0;
	        m[5] = y;
	        m[6] = 0;
	        m[7] = 0;
	        m[8] = 0;
	        m[9] = 0;
	        m[10] = z;
	        m[11] = 0;
	        m[12] = 0;
	        m[13] = 0;
	        m[14] = 0;
	        m[15] = 1;
	        return this;
	    },

	    /**
	     * Initializes as a perspective projection matrix (from right-handed Y-up to left-handed NDC!).
	     * @param vFOV The vertical field of view in radians.
	     * @param aspectRatio The aspect ratio
	     * @param nearDistance The near plane distance
	     * @param farDistance The far plane distance
	     */
	    fromPerspectiveProjection: function (vFOV, aspectRatio, nearDistance, farDistance)
	    {
	        var vMax = 1.0 / Math.tan(vFOV * .5);
	        var hMax = vMax / aspectRatio;
	        var rcpFrustumDepth = 1.0 / (nearDistance - farDistance);

	        var m = this._m;
	        m[0] = hMax;
	        m[1] = 0;
	        m[2] = 0;
	        m[3] = 0;

	        m[4] = 0;
	        m[5] = 0;
	        m[6] = -(farDistance + nearDistance) * rcpFrustumDepth;
	        m[7] = 1;

	        m[8] = 0;
	        m[9] = vMax;
	        m[10] = 0;
	        m[11] = 0;

	        m[12] = 0;
	        m[13] = 0;
	        m[14] = 2 * nearDistance * farDistance * rcpFrustumDepth;
	        m[15] = 0;
	        return this;
	    },

	    /**
	     * Initializes as an off-center orthographic projection matrix.
	     * @param left The distance to the left plane
	     * @param right The distance to the right plane
	     * @param top The distance to the top plane
	     * @param bottom The distance to the bottom plane
	     * @param nearDistance The near plane distance
	     * @param farDistance The far plane distance
	     */
	    fromOrthographicOffCenterProjection: function (left, right, top, bottom, nearDistance, farDistance)
	    {
	        var rcpWidth = 1.0 / (right - left);
	        var rcpHeight = 1.0 / (top - bottom);
	        var rcpDepth = 1.0 / (nearDistance - farDistance);

	        var m = this._m;
	        m[0] = 2.0 * rcpWidth;
	        m[1] = 0;
	        m[2] = 0;
	        m[3] = 0;

	        m[4] = 0;
	        m[5] = 0;
	        m[6] = -2.0 * rcpDepth;
	        m[7] = 0;

	        m[8] = 0;
	        m[9] = 2.0 * rcpHeight;
	        m[10] = 0;
	        m[11] = 0;

	        m[12] = -(left + right) * rcpWidth;
	        m[13] = -(top + bottom) * rcpHeight;
	        m[14] = (farDistance + nearDistance) * rcpDepth;
	        m[15] = 1;
	        return this;
	    },

	    /**
	     * Initializes as a symmetrical orthographic projection matrix.
	     * @param width The width of the projection
	     * @param top The height of the projection
	     * @param nearDistance The near plane distance
	     * @param farDistance The far plane distance
	     */
	    fromOrthographicProjection: function (width, height, nearDistance, farDistance)
	    {
	        var rcpWidth = 1.0 / width;
	        var rcpHeight = 1.0 / height;
	        var rcpDepth = 1.0 / (nearDistance - farDistance);

	        var m = this._m;
	        m[0] = 2.0 * rcpWidth;
	        m[1] = 0;
	        m[2] = 0;
	        m[3] = 0;

	        m[4] = 0;
	        m[5] = 0;
	        m[6] = 2.0 * rcpDepth;
	        m[7] = 0;

	        m[8] = 0;
	        m[9] = 2.0 * rcpHeight;
	        m[10] = 0;
	        m[11] = 0;

	        m[12] = 0.0;
	        m[13] = 0.0;
	        m[14] = (farDistance + nearDistance) * rcpDepth;
	        m[15] = 1;
	        return this;
	    },

	    /**
	     * Returns a copy of this object.
	     */
	    clone: function ()
	    {
	        return new Matrix4x4(this._m);
	    },

	    /**
	     * Transposes the matrix.
	     */
	    transpose: function ()
	    {
	        var m = this._m;
	        var m1 = m[1];
	        var m2 = m[2];
	        var m3 = m[3];
	        var m6 = m[6];
	        var m7 = m[7];
	        var m11 = m[11];

	        m[1] = m[4];
	        m[2] = m[8];
	        m[3] = m[12];

	        m[4] = m1;
	        m[6] = m[9];
	        m[7] = m[13];

	        m[8] = m2;
	        m[9] = m6;
	        m[11] = m[14];

	        m[12] = m3;
	        m[13] = m7;
	        m[14] = m11;
	        return this;
	    },

	    /**
	     * The determinant of a 3x3 minor matrix (matrix created by removing a given row and column)
	     * @private
	     * @ignore
	     */
	    determinant3x3: function (row, col)
	    {
	        // columns are the indices * 4 (to form index for row 0)
	        var c1 = col === 0 ? 4 : 0;
	        var c2 = col < 2 ? 8 : 4;
	        var c3 = col === 3 ? 8 : 12;
	        var r1 = row === 0 ? 1 : 0;
	        var r2 = row < 2 ? 2 : 1;
	        var r3 = row === 3 ? 2 : 3;

	        var m = this._m;
	        var m21 = m[c1 | r2], m22 = m[r2 | c2], m23 = m[c3 | r2];
	        var m31 = m[c1 | r3], m32 = m[c2 | r3], m33 = m[r3 | c3];

	        return      m[c1 | r1] * (m22 * m33 - m23 * m32)
	            - m[c2 | r1] * (m21 * m33 - m23 * m31)
	            + m[c3 | r1] * (m21 * m32 - m22 * m31);
	    },

	    /**
	     * Calculates the cofactor for the given row and column
	     */
	    cofactor: function (row, col)
	    {
	        // should be able to xor sign bit instead
	        var sign = 1 - (((row + col) & 1) << 1);
	        return sign * this.determinant3x3(row, col);
	    },

	    /**
	     * Creates a matrix containing all the cofactors.
	     */
	    getCofactorMatrix: function (row, col, target)
	    {
	        target = target || new Matrix4x4();

	        var tm = target._m;
	        for (var i = 0; i < 16; ++i)
	            tm[i] = this.cofactor(i & 3, i >> 2);

	        return target;
	    },

	    /**
	     * Calculates teh adjugate matrix.
	     */
	    getAdjugate: function (row, col, target)
	    {
	        target = target || new Matrix4x4();

	        var tm = target._m;
	        for (var i = 0; i < 16; ++i)
	            tm[i] = this.cofactor(i >> 2, i & 3);    // transposed!

	        return target;
	    },

	    /**
	     * Calculates the determinant of the matrix.
	     */
	    determinant: function ()
	    {
	        var m = this._m;
	        return m[0] * this.determinant3x3(0, 0) - m[4] * this.determinant3x3(0, 1) + m[8] * this.determinant3x3(0, 2) - m[12] * this.determinant3x3(0, 3);
	    },

	    /**
	     * Initializes as the inverse of the given matrix. If the matrix is not invertible, the method returns null and the
	     * matrix remains unchanged. Otherwise, it returns itself.
	     */
	    inverseOf: function (matrix)
	    {
	        var determinant = matrix.determinant();
	        if (determinant === 0.0) return null;

	        // this can be much more efficient, but I'd like to keep it readable for now. The full inverse is not required often anyway.
	        var rcpDet = 1.0 / determinant;

	        // needs to be self-assignment-proof
	        var m0 = rcpDet * matrix.cofactor(0, 0);
	        var m1 = rcpDet * matrix.cofactor(0, 1);
	        var m2 = rcpDet * matrix.cofactor(0, 2);
	        var m3 = rcpDet * matrix.cofactor(0, 3);
	        var m4 = rcpDet * matrix.cofactor(1, 0);
	        var m5 = rcpDet * matrix.cofactor(1, 1);
	        var m6 = rcpDet * matrix.cofactor(1, 2);
	        var m7 = rcpDet * matrix.cofactor(1, 3);
	        var m8 = rcpDet * matrix.cofactor(2, 0);
	        var m9 = rcpDet * matrix.cofactor(2, 1);
	        var m10 = rcpDet * matrix.cofactor(2, 2);
	        var m11 = rcpDet * matrix.cofactor(2, 3);
	        var m12 = rcpDet * matrix.cofactor(3, 0);
	        var m13 = rcpDet * matrix.cofactor(3, 1);
	        var m14 = rcpDet * matrix.cofactor(3, 2);
	        var m15 = rcpDet * matrix.cofactor(3, 3);

	        var m = this._m;
	        m[0] = m0;
	        m[1] = m1;
	        m[2] = m2;
	        m[3] = m3;
	        m[4] = m4;
	        m[5] = m5;
	        m[6] = m6;
	        m[7] = m7;
	        m[8] = m8;
	        m[9] = m9;
	        m[10] = m10;
	        m[11] = m11;
	        m[12] = m12;
	        m[13] = m13;
	        m[14] = m14;
	        m[15] = m15;
	        return this;
	    },

	    /**
	     * Initializes as the inverse of the given matrix, assuming it is affine. It's faster than regular inverse.
	     * If the matrix is not invertible, the method returns null and the matrix remains unchanged.
	     */
	    inverseAffineOf: function (a)
	    {
	        var mm = a._m;
	        var m0 = mm[0], m1 = mm[1], m2 = mm[2];
	        var m4 = mm[4], m5 = mm[5], m6 = mm[6];
	        var m8 = mm[8], m9 = mm[9], m10 = mm[10];
	        var m12 = mm[12], m13 = mm[13], m14 = mm[14];
	        var determinant = m0 * (m5 * m10 - m9 * m6) - m4 * (m1 * m10 - m9 * m2) + m8 * (m1 * m6 - m5 * m2);

	        if (determinant === 0.0) return null;

	        var rcpDet = 1.0 / determinant;

	        var n0 = (m5 * m10 - m9 * m6) * rcpDet;
	        var n1 = (m9 * m2 - m1 * m10) * rcpDet;
	        var n2 = (m1 * m6 - m5 * m2) * rcpDet;
	        var n4 = (m8 * m6 - m4 * m10) * rcpDet;
	        var n5 = (m0 * m10 - m8 * m2) * rcpDet;
	        var n6 = (m4 * m2 - m0 * m6) * rcpDet;
	        var n8 = (m4 * m9 - m8 * m5) * rcpDet;
	        var n9 = (m8 * m1 - m0 * m9) * rcpDet;
	        var n10 = (m0 * m5 - m4 * m1) * rcpDet;

	        var m = this._m;
	        m[0] = n0;
	        m[1] = n1;
	        m[2] = n2;
	        m[3] = 0;
	        m[4] = n4;
	        m[5] = n5;
	        m[6] = n6;
	        m[7] = 0;
	        m[8] = n8;
	        m[9] = n9;
	        m[10] = n10;
	        m[11] = 0;
	        m[12] = -n0 * m12 - n4 * m13 - n8 * m14;
	        m[13] = -n1 * m12 - n5 * m13 - n9 * m14;
	        m[14] = -n2 * m12 - n6 * m13 - n10 * m14;
	        m[15] = 1;
	        return this;
	    },

	    /**
	     * Writes the inverse transpose into an array for upload (must support 9 elements)
	     */
	    writeNormalMatrix: function (array, index)
	    {
	        index = index || 0;
	        var m = this._m;
	        var m0 = m[0], m1 = m[1], m2 = m[2];
	        var m4 = m[4], m5 = m[5], m6 = m[6];
	        var m8 = m[8], m9 = m[9], m10 = m[10];

	        var determinant = m0 * (m5 * m10 - m9 * m6) - m4 * (m1 * m10 - m9 * m2) + m8 * (m1 * m6 - m5 * m2);
	        var rcpDet = 1.0 / determinant;

	        array[index] = (m5 * m10 - m9 * m6) * rcpDet;
	        array[index + 1] = (m8 * m6 - m4 * m10) * rcpDet;
	        array[index + 2] = (m4 * m9 - m8 * m5) * rcpDet;
	        array[index + 3] = (m9 * m2 - m1 * m10) * rcpDet;
	        array[index + 4] = (m0 * m10 - m8 * m2) * rcpDet;
	        array[index + 5] = (m8 * m1 - m0 * m9) * rcpDet;
	        array[index + 6] = (m1 * m6 - m5 * m2) * rcpDet;
	        array[index + 7] = (m4 * m2 - m0 * m6) * rcpDet;
	        array[index + 8] = (m0 * m5 - m4 * m1) * rcpDet;
	    },

	    /**
	     * Writes the matrix into an array for upload
	     */
	    writeData: function(array, index)
	    {
	        index = index || 0;
	        var m = this._m;
	        for (var i = 0; i < 16; ++i)
	            array[index + i] = m[i];
	    },

	    /**
	     * Writes the matrix into an array for upload, ignoring the bottom row (for affine matrices)
	     */
	    writeData4x3: function(array, index)
	    {
	        var m = this._m;
	        index = index || 0;
	        array[index] = m[0];
	        array[index + 1] = m[4];
	        array[index + 2] = m[8];
	        array[index + 3] = m[12];
	        array[index + 4] = m[1];
	        array[index + 5] = m[5];
	        array[index + 6] = m[9];
	        array[index + 7] = m[13];
	        array[index + 8] = m[2];
	        array[index + 9] = m[6];
	        array[index + 10] = m[10];
	        array[index + 11] = m[14];
	    },

	    /**
	     * Inverts the matrix. If the matrix is not invertible, the method returns null and the matrix remains unchanged.
	     * Otherwise, it returns itself.
	     */
	    invert: function ()
	    {
	        return this.inverseOf(this);
	    },

	    /**
	     * Inverts the matrix, assuming it's affine (faster than regular inverse). If the matrix is not invertible, the
	     * method returns null and the matrix remains unchanged. Otherwise, it returns itself.
	     */
	    invertAffine: function ()
	    {
	        return this.inverseAffineOf(this);
	    },

	    /**
	     * Post-multiplication (M x this)
	     */
	    append: function (m)
	    {
	        return this.multiply(m, this);
	    },

	    /**
	     * Pre-multiplication (this x M)
	     */
	    prepend: function (m)
	    {
	        return this.multiply(this, m);
	    },

	    /**
	     * Post-multiplication (M x this) assuming affine matrices
	     */
	    appendAffine: function (m)
	    {
	        return this.multiplyAffine(m, this);
	    },

	    /**
	     * Pre-multiplication (M x this) assuming affine matrices
	     */
	    prependAffine: function (m)
	    {
	        return this.multiplyAffine(this, m);
	    },

	    /**
	     * Adds the elements of another matrix to this one.
	     */
	    add: function (a)
	    {
	        var m = this._m;
	        var mm = a._m;
	        m[0] += mm[0];
	        m[1] += mm[1];
	        m[2] += mm[2];
	        m[3] += mm[3];
	        m[4] += mm[4];
	        m[5] += mm[5];
	        m[6] += mm[6];
	        m[7] += mm[7];
	        m[8] += mm[8];
	        m[9] += mm[9];
	        m[10] += mm[10];
	        m[11] += mm[11];
	        m[12] += mm[12];
	        m[13] += mm[13];
	        m[14] += mm[14];
	        m[15] += mm[15];
	        return this;
	    },

	    /**
	     * Adds the elements of another matrix to this one, assuming both are affine.
	     */
	    addAffine: function (a)
	    {
	        var m = this._m;
	        var mm = a._m;
	        m[0] += mm[0];
	        m[1] += mm[1];
	        m[2] += mm[2];
	        m[4] += mm[4];
	        m[5] += mm[5];
	        m[6] += mm[6];
	        m[8] += mm[8];
	        m[9] += mm[9];
	        m[10] += mm[10];
	        return this;
	    },

	    /**
	     * Subtracts the elements of another matrix from this one.
	     */
	    subtract: function (a)
	    {
	        var m = this._m;
	        var mm = a._m;
	        m[0] -= mm[0];
	        m[1] -= mm[1];
	        m[2] -= mm[2];
	        m[3] -= mm[3];
	        m[4] -= mm[4];
	        m[5] -= mm[5];
	        m[6] -= mm[6];
	        m[7] -= mm[7];
	        m[8] -= mm[8];
	        m[9] -= mm[9];
	        m[10] -= mm[10];
	        m[11] -= mm[11];
	        m[12] -= mm[12];
	        m[13] -= mm[13];
	        m[14] -= mm[14];
	        m[15] -= mm[15];
	        return this;
	    },

	    /**
	     * Subtracts the elements of another matrix from this one, assuming both are affine.
	     */
	    subtractAffine: function (a)
	    {
	        var m = this._m;
	        var mm = a._m;
	        m[0] -= mm[0];
	        m[1] -= mm[1];
	        m[2] -= mm[2];
	        m[4] -= mm[4];
	        m[5] -= mm[5];
	        m[6] -= mm[6];
	        m[8] -= mm[8];
	        m[9] -= mm[9];
	        m[10] -= mm[10];
	        return this;
	    },

	    /**
	     * Post-multiplies a scale
	     */
	    appendScale: function (x, y, z)
	    {
	        if (x instanceof Float4) {
	            y = x.y;
	            z = x.z;
	            x = x.x;
	        }
	        else if (y === undefined)
	            y = z = x;

	        var m = this._m;
	        m[0] *= x;
	        m[1] *= y;
	        m[2] *= z;
	        m[4] *= x;
	        m[5] *= y;
	        m[6] *= z;
	        m[8] *= x;
	        m[9] *= y;
	        m[10] *= z;
	        m[12] *= x;
	        m[13] *= y;
	        m[14] *= z;
	        return this;
	    },

	    /**
	     * Pre-multiplies a scale
	     */
	    prependScale: function (x, y, z)
	    {
	        if (x instanceof Float4) {
	            y = x.y;
	            z = x.z;
	            x = x.x;
	        }
	        else if (y === undefined)
	            y = z = x;

	        var m = this._m;
	        m[0] *= x;
	        m[1] *= x;
	        m[2] *= x;
	        m[3] *= x;
	        m[4] *= y;
	        m[5] *= y;
	        m[6] *= y;
	        m[7] *= y;
	        m[8] *= z;
	        m[9] *= z;
	        m[10] *= z;
	        m[11] *= z;
	        return this;
	    },

	    /**
	     * Post-multiplies a translation
	     */
	    appendTranslation: function (x, y, z)
	    {
	        if (y === undefined) { // the first is a Float4
	            y = x.y;
	            z = x.z;
	            x = x.x;
	        }

	        var m = this._m;
	        m[12] += x;
	        m[13] += y;
	        m[14] += z;
	        return this;
	    },

	    /**
	     * Pre-multiplies a translation
	     */
	    prependTranslation: function (x, y, z)
	    {
	        if (y === undefined) {
	            y = x.y;
	            z = x.z;
	            x = x.x;
	        }

	        var m = this._m;
	        m[12] += m[0] * x + m[4] * y + m[8] * z;
	        m[13] += m[1] * x + m[5] * y + m[9] * z;
	        m[14] += m[2] * x + m[6] * y + m[10] * z;
	        m[15] += m[3] * x + m[7] * y + m[11] * z;
	        return this;
	    },

	    /**
	     * Post-multiplies a quaternion rotation
	     */
	    appendQuaternion: function (q)
	    {
	        var m = this._m;
	        var x = q.x, y = q.y, z = q.z, w = q.w;
	        var a_m00 = 1 - 2 * (y * y + z * z), a_m10 = 2 * (x * y + w * z), a_m20 = 2 * (x * z - w * y);
	        var a_m01 = 2 * (x * y - w * z), a_m11 = 1 - 2 * (x * x + z * z), a_m21 = 2 * (y * z + w * x);
	        var a_m02 = 2 * (x * z + w * y), a_m12 = 2 * (y * z - w * x), a_m22 = 1 - 2 * (x * x + y * y);

	        var b_m00 = m[0], b_m10 = m[1], b_m20 = m[2];
	        var b_m01 = m[4], b_m11 = m[5], b_m21 = m[6];
	        var b_m02 = m[8], b_m12 = m[9], b_m22 = m[10];
	        var b_m03 = m[12], b_m13 = m[13], b_m23 = m[14];

	        m[0] = a_m00 * b_m00 + a_m01 * b_m10 + a_m02 * b_m20;
	        m[1] = a_m10 * b_m00 + a_m11 * b_m10 + a_m12 * b_m20;
	        m[2] = a_m20 * b_m00 + a_m21 * b_m10 + a_m22 * b_m20;

	        m[4] = a_m00 * b_m01 + a_m01 * b_m11 + a_m02 * b_m21;
	        m[5] = a_m10 * b_m01 + a_m11 * b_m11 + a_m12 * b_m21;
	        m[6] = a_m20 * b_m01 + a_m21 * b_m11 + a_m22 * b_m21;

	        m[8] = a_m00 * b_m02 + a_m01 * b_m12 + a_m02 * b_m22;
	        m[9] = a_m10 * b_m02 + a_m11 * b_m12 + a_m12 * b_m22;
	        m[10] = a_m20 * b_m02 + a_m21 * b_m12 + a_m22 * b_m22;

	        m[12] = a_m00 * b_m03 + a_m01 * b_m13 + a_m02 * b_m23;
	        m[13] = a_m10 * b_m03 + a_m11 * b_m13 + a_m12 * b_m23;
	        m[14] = a_m20 * b_m03 + a_m21 * b_m13 + a_m22 * b_m23;
	        return this;
	    },

	    /**
	     * Pre-multiplies a quaternion rotation
	     */
	    prependQuaternion: function (q)
	    {
	        var m = this._m;
	        var x = q.x, y = q.y, z = q.z, w = q.w;
	        var a_m00 = m[0], a_m10 = m[1], a_m20 = m[2];
	        var a_m01 = m[4], a_m11 = m[5], a_m21 = m[6];
	        var a_m02 = m[8], a_m12 = m[9], a_m22 = m[10];

	        var b_m00 = 1 - 2 * (y * y + z * z), b_m10 = 2 * (x * y + w * z), b_m20 = 2 * (x * z - w * y);
	        var b_m01 = 2 * (x * y - w * z), b_m11 = 1 - 2 * (x * x + z * z), b_m21 = 2 * (y * z + w * x);
	        var b_m02 = 2 * (x * z + w * y), b_m12 = 2 * (y * z - w * x), b_m22 = 1 - 2 * (x * x + y * y);

	        m[0] = a_m00 * b_m00 + a_m01 * b_m10 + a_m02 * b_m20;
	        m[1] = a_m10 * b_m00 + a_m11 * b_m10 + a_m12 * b_m20;
	        m[2] = a_m20 * b_m00 + a_m21 * b_m10 + a_m22 * b_m20;

	        m[4] = a_m00 * b_m01 + a_m01 * b_m11 + a_m02 * b_m21;
	        m[5] = a_m10 * b_m01 + a_m11 * b_m11 + a_m12 * b_m21;
	        m[6] = a_m20 * b_m01 + a_m21 * b_m11 + a_m22 * b_m21;

	        m[8] = a_m00 * b_m02 + a_m01 * b_m12 + a_m02 * b_m22;
	        m[9] = a_m10 * b_m02 + a_m11 * b_m12 + a_m12 * b_m22;
	        m[10] = a_m20 * b_m02 + a_m21 * b_m12 + a_m22 * b_m22;
	        return this;
	    },

	    /**
	     * Post-multiplies an axis/angle rotation
	     */
	    appendRotationAxisAngle: function (axis, radians)
	    {
	        var m = this._m;
	        var cos = Math.cos(radians);
	        var sin = Math.sin(radians);
	        var rcpLen = 1 / axis.length;

	        var x = axis.x * rcpLen, y = axis.y * rcpLen, z = axis.z * rcpLen;
	        var oneMinCos = 1 - cos;

	        var a_m00 = oneMinCos * x * x + cos, a_m10 = oneMinCos * x * y + sin * z, a_m20 = oneMinCos * x * z - sin * y;
	        var a_m01 = oneMinCos * x * y - sin * z, a_m11 = oneMinCos * y * y + cos, a_m21 = oneMinCos * y * z + sin * x;
	        var a_m02 = oneMinCos * x * z + sin * y, a_m12 = oneMinCos * y * z - sin * x, a_m22 = oneMinCos * z * z + cos;

	        var b_m00 = m[0], b_m10 = m[1], b_m20 = m[2];
	        var b_m01 = m[4], b_m11 = m[5], b_m21 = m[6];
	        var b_m02 = m[8], b_m12 = m[9], b_m22 = m[10];
	        var b_m03 = m[12], b_m13 = m[13], b_m23 = m[14];

	        m[0] = a_m00 * b_m00 + a_m01 * b_m10 + a_m02 * b_m20;
	        m[1] = a_m10 * b_m00 + a_m11 * b_m10 + a_m12 * b_m20;
	        m[2] = a_m20 * b_m00 + a_m21 * b_m10 + a_m22 * b_m20;

	        m[4] = a_m00 * b_m01 + a_m01 * b_m11 + a_m02 * b_m21;
	        m[5] = a_m10 * b_m01 + a_m11 * b_m11 + a_m12 * b_m21;
	        m[6] = a_m20 * b_m01 + a_m21 * b_m11 + a_m22 * b_m21;

	        m[8] = a_m00 * b_m02 + a_m01 * b_m12 + a_m02 * b_m22;
	        m[9] = a_m10 * b_m02 + a_m11 * b_m12 + a_m12 * b_m22;
	        m[10] = a_m20 * b_m02 + a_m21 * b_m12 + a_m22 * b_m22;

	        m[12] = a_m00 * b_m03 + a_m01 * b_m13 + a_m02 * b_m23;
	        m[13] = a_m10 * b_m03 + a_m11 * b_m13 + a_m12 * b_m23;
	        m[14] = a_m20 * b_m03 + a_m21 * b_m13 + a_m22 * b_m23;
	        return this;
	    },

	    /**
	     * Pre-multiplies an axis/angle rotation
	     */
	    prependRotationAxisAngle: function (axis, radians)
	    {
	        var m = this._m;
	        var cos = Math.cos(radians);
	        var sin = Math.sin(radians);
	        var rcpLen = 1 / axis.length;

	        var x = axis.x * rcpLen, y = axis.y * rcpLen, z = axis.z * rcpLen;
	        var oneMinCos = 1 - cos;

	        var a_m00 = m[0], a_m10 = m[1], a_m20 = m[2];
	        var a_m01 = m[4], a_m11 = m[5], a_m21 = m[6];
	        var a_m02 = m[8], a_m12 = m[9], a_m22 = m[10];

	        var b_m00 = oneMinCos * x * x + cos, b_m10 = oneMinCos * x * y + sin * z, b_m20 = oneMinCos * x * z - sin * y;
	        var b_m01 = oneMinCos * x * y - sin * z, b_m11 = oneMinCos * y * y + cos, b_m21 = oneMinCos * y * z + sin * x;
	        var b_m02 = oneMinCos * x * z + sin * y, b_m12 = oneMinCos * y * z - sin * x, b_m22 = oneMinCos * z * z + cos;

	        m[0] = a_m00 * b_m00 + a_m01 * b_m10 + a_m02 * b_m20;
	        m[1] = a_m10 * b_m00 + a_m11 * b_m10 + a_m12 * b_m20;
	        m[2] = a_m20 * b_m00 + a_m21 * b_m10 + a_m22 * b_m20;

	        m[4] = a_m00 * b_m01 + a_m01 * b_m11 + a_m02 * b_m21;
	        m[5] = a_m10 * b_m01 + a_m11 * b_m11 + a_m12 * b_m21;
	        m[6] = a_m20 * b_m01 + a_m21 * b_m11 + a_m22 * b_m21;

	        m[8] = a_m00 * b_m02 + a_m01 * b_m12 + a_m02 * b_m22;
	        m[9] = a_m10 * b_m02 + a_m11 * b_m12 + a_m12 * b_m22;
	        m[10] = a_m20 * b_m02 + a_m21 * b_m12 + a_m22 * b_m22;
	        return this;
	    },

	    /**
	     * Gets the given row from the matrix.
	     * @param {Number} index The index of the row
	     * @param {Float4} [target] An optional target. If omitted, a new object will be created.
	     */
	    getRow: function (index, target)
	    {
	        var m = this._m;
	        target = target || new Float4();
	        target.x = m[index];
	        target.y = m[index | 4];
	        target.z = m[index | 8];
	        target.w = m[index | 12];
	        return target;
	    },

	    /**
	     * Sets a row in the matrix.
	     * @param {Number} index The index of the row.
	     * @param {Float4} v The vector to assign to the row
	     */
	    setRow: function (index, v)
	    {
	        var m = this._m;
	        m[index] = v.x;
	        m[index | 4] = v.y;
	        m[index | 8] = v.z;
	        m[index | 12] = v.w;
	        return this;
	    },

	    /**
	     * Gets the value of a single element.
	     * @param row The row index
	     * @param col The column index
	     */
	    getElement: function(row, col)
	    {
	        return this._m[row | (col << 2)];
	    },

	    /**
	     * Sets the value of a single element.
	     * @param row The row index
	     * @param col The column index
	     * @param value The value to assign to the element
	     */
	    setElement: function(row, col, value)
	    {
	        this._m[row | (col << 2)] = value;
	        return this;
	    },

	    /**
	     * Gets the given column from the matrix.
	     * @param {Number} index The index of the column
	     * @param {Float4} [target] An optional target. If omitted, a new object will be created.
	     */
	    getColumn: function (index, target)
	    {
	        var m = this._m;
	        target = target || new Float4();
	        index <<= 2;
	        target.x = m[index];
	        target.y = m[index | 1];
	        target.z = m[index | 2];
	        target.w = m[index | 3];
	        return target;
	    },

	    /**
	     * Sets a column in the matrix.
	     * @param {Number} index The index of the column.
	     * @param {Float4} v The vector to assign to the column
	     */
	    setColumn: function (index, v)
	    {
	        var m = this._m;
	        index <<= 2;
	        m[index] = v.x;
	        m[index | 1] = v.y;
	        m[index | 2] = v.z;
	        m[index | 3] = v.w;
	        return this;
	    },

	    /**
	     * Copies a column from another matrix.
	     * @param {Number} index The index of the column.
	     * @param {Matrix4x4} m The matrix from which to copy.
	     */
	    copyColumn: function(index, m)
	    {
	        var m1 = this._m;
	        var m2 = m._m;
	        index <<= 2;
	        m1[index] = m2[index];
	        m1[index | 1] = m2[index | 1];
	        m1[index | 2] = m2[index | 2];
	        m1[index | 3] = m2[index | 3];
	        return this;
	    },

	    /**
	     * Initializes as a "lookAt" matrix at the given eye position oriented toward a target
	     * @param {Float4} target The target position to look at.
	     * @param {Float4} eye The target position the matrix should "be" at
	     * @param {Float4} up The world-up vector. Must be unit length (usually Float4.Z_AXIS)
	     */
	    lookAt: function (target, eye, up)
	    {
	        var xAxis = new Float4();
	        var yAxis = new Float4();
	        var zAxis = new Float4();

	        return function(target, eye, up)
	        {
	            up = up || Float4.Z_AXIS;
	            // Y axis is forward
	            Float4.subtract(target, eye, yAxis);
	            yAxis.normalize();

	            Float4.cross(yAxis, up, xAxis);

	            if (Math.abs(xAxis.lengthSqr) < .0001) {
	                var altUp = new Float4(up.x, up.z, up.y, 0.0);
	                Float4.cross(yAxis, altUp, xAxis);
	                if (Math.abs(xAxis.lengthSqr) <= .0001) {
	                    altUp.set(up.z, up.y, up.z, 0.0);
	                    Float4.cross(yAxis, altUp, xAxis);
	                }
	            }

				xAxis.normalize();

				Float4.cross(xAxis, yAxis, zAxis);

	            var m = this._m;
	            m[0] = xAxis.x;
	            m[1] = xAxis.y;
	            m[2] = xAxis.z;
	            m[3] = 0.0;
	            m[4] = yAxis.x;
	            m[5] = yAxis.y;
	            m[6] = yAxis.z;
	            m[7] = 0.0;
	            m[8] = zAxis.x;
	            m[9] = zAxis.y;
	            m[10] = zAxis.z;
	            m[11] = 0.0;
	            m[12] = eye.x;
	            m[13] = eye.y;
	            m[14] = eye.z;
	            m[15] = 1.0;

	            return this;
	        }
	    }(),

	    /**
	     * Initializes as an affine transformation based on a transform object
	     */
	    compose: function(transformOrPosition, rotation, scale)
	    {
	        // if rotation was provided, the first is a position
	        var position = rotation? transformOrPosition : transformOrPosition.position;
	        rotation = rotation || transformOrPosition.rotation;
	        scale = scale || transformOrPosition.scale;

	        if (scale)
	            this.fromScale(scale);
	        else
	            this.identity();

	        this.appendQuaternion(rotation);
	        this.appendTranslation(position);
	        return this;
	    },

	    /**
	     * Decomposes an affine transformation matrix into a Transform object, or a triplet position, quaternion, scale.
	     * @param targetOrPos An optional target object to store the values. If this is a Float4, quat and scale need to be provided. If omitted, a new Transform object will be created and returned.
	     * @param quat An optional quaternion to store rotation. Unused if targetOrPos is a Transform object.
	     * @param quat An optional Float4 to store scale. Unused if targetOrPos is a Transform object.
	     */
	    decompose: function (targetOrPos, quat, scale)
	    {
	        targetOrPos = targetOrPos || new Transform();

	        var pos;
	        if (quat === undefined) {
	            quat = targetOrPos.rotation;
	            scale = targetOrPos.scale;
	            pos = targetOrPos.position;
	        }
	        else pos = targetOrPos;

	        var m = this._m;
	        var m0 = m[0], m1 = m[1], m2 = m[2];
	        var m4 = m[4], m5 = m[5], m6 = m[6];
	        var m8 = m[8], m9 = m[9], m10 = m[10];

	        // check for negative scale by calculating cross X x Y (positive scale should yield the same Z)
	        var cx = m1*m6 - m2*m5;
	        var cy = m2*m4 - m0*m6;
	        var cz = m0*m5 - m1*m4;

	        // dot cross product X x Y with Z < 0? Lefthanded flip.
	        var flipSign = MathX.sign(cx * m8 + cy * m9 + cz * m10);

	        // we assign the flipSign to all three instead of just 1, so that if a uniform negative scale was used, this will
	        // be preserved
	        scale.x = flipSign * Math.sqrt(m0 * m0 + m1 * m1 + m2 * m2);
	        scale.y = flipSign * Math.sqrt(m4 * m4 + m5 * m5 + m6 * m6);
	        scale.z = flipSign * Math.sqrt(m8 * m8 + m9 * m9 + m10 * m10);

	        if (scale.x > 0.999 && scale.x < 1.001) scale.x = 1.0;
	        if (scale.y > 0.999 && scale.y < 1.001) scale.y = 1.0;
	        if (scale.z > 0.999 && scale.z < 1.001) scale.z = 1.0;

	        var clone = this.clone();

	        var rcpX = 1.0 / scale.x, rcpY = 1.0 / scale.y, rcpZ = 1.0 / scale.z;

	        var cm = clone._m;
	        cm[0] *= rcpX;
	        cm[1] *= rcpX;
	        cm[2] *= rcpX;
	        cm[4] *= rcpY;
	        cm[5] *= rcpY;
	        cm[6] *= rcpY;
	        cm[8] *= rcpZ;
	        cm[9] *= rcpZ;
	        cm[10] *= rcpZ;

	        quat.fromMatrix(clone);
	        this.getColumn(3, pos);

	        return targetOrPos;
	    },

	    /**
	     * Swaps two columns
	     */
	    swapColums: function(i, j)
	    {
	        var m = this._m;
	        if (i === j) return;
	        i <<= 2;
	        j <<= 2;
	        var x = m[i];
	        var y = m[i | 1];
	        var z = m[i | 2];
	        var w = m[i | 3];
	        m[i] = m[j];
	        m[i | 1] = m[j | 1];
	        m[i | 2] = m[j | 2];
	        m[i | 3] = m[j | 3];
	        m[j] = x;
	        m[j | 1] = y;
	        m[j | 2] = z;
	        m[j | 3] = w;
	        return this;
	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        var m = this._m;
	        var str = "";
	        for (var i = 0; i < 16; ++i) {
	            var mod = i & 0x3;
	            if (mod === 0)
	                str += "[";

	            str += m[i];

	            if (mod === 3)
	                str += "]\n";
	            else
	                str += "\t , \t";
	        }
	        return str;
	    }
	};

	/**
	 * Preset for the identity matrix
	 */
	Matrix4x4.IDENTITY = new Matrix4x4();

	/**
	 * Preset for the all-zero matrix
	 */
	Matrix4x4.ZERO = new Matrix4x4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

	/**
	 * @ignore
	 * @author derschmale <http://www.derschmale.com>
	 */
	var UniformSetter = {

	    getSettersPerInstance: function (shader)
	    {
	        if (UniformSetter._instanceTable === undefined)
	            UniformSetter._init();

	        return UniformSetter._findSetters(shader, UniformSetter._instanceTable);
	    },

	    getSettersPerPass: function (shader)
	    {
	        if (UniformSetter._passTable === undefined)
	            UniformSetter._init();

	        return UniformSetter._findSetters(shader, UniformSetter._passTable);
	    },

	    _findSetters: function (shader, table)
	    {
	        var setters = [];
	        for (var uniformName in table) {
	            var location = GL.gl.getUniformLocation(shader._program, uniformName);
	            if (!location) continue;
	            var setter = new table[uniformName]();
	            setters.push(setter);
	            setter.location = location;
	        }

	        return setters;
	    },

	    _init: function ()
	    {
	        UniformSetter._instanceTable = {};
	        UniformSetter._passTable = {};

	        UniformSetter._instanceTable.hx_worldMatrix = WorldMatrixSetter;
	        UniformSetter._instanceTable.hx_worldViewMatrix = WorldViewMatrixSetter;
	        UniformSetter._instanceTable.hx_wvpMatrix = WorldViewProjectionSetter;
	        UniformSetter._instanceTable.hx_inverseWVPMatrix = InverseWVPSetter;
	        UniformSetter._instanceTable.hx_normalWorldMatrix = NormalWorldMatrixSetter;
	        UniformSetter._instanceTable.hx_normalWorldViewMatrix = NormalWorldViewMatrixSetter;
	        UniformSetter._instanceTable["hx_skinningMatrices[0]"] = SkinningMatricesSetter;
	        UniformSetter._instanceTable["hx_morphWeights[0]"] = MorphWeightsSetter;

	        UniformSetter._passTable.hx_viewMatrix = ViewMatrixSetter;
	        UniformSetter._passTable.hx_projectionMatrix = ProjectionSetter;
	        UniformSetter._passTable.hx_inverseProjectionMatrix = InverseProjectionSetter;
	        UniformSetter._passTable.hx_viewProjectionMatrix = ViewProjectionSetter;
	        UniformSetter._passTable.hx_inverseViewProjectionMatrix = InverseViewProjectionSetter;
	        UniformSetter._passTable.hx_cameraWorldPosition = CameraWorldPosSetter;
	        UniformSetter._passTable.hx_cameraWorldMatrix = CameraWorldMatrixSetter;
	        UniformSetter._passTable.hx_cameraFrustumRange = CameraFrustumRangeSetter;
	        UniformSetter._passTable.hx_rcpCameraFrustumRange = RCPCameraFrustumRangeSetter;
	        UniformSetter._passTable.hx_cameraNearPlaneDistance = CameraNearPlaneDistanceSetter;
	        UniformSetter._passTable.hx_cameraFarPlaneDistance = CameraFarPlaneDistanceSetter;
	        UniformSetter._passTable.hx_renderTargetResolution = RenderTargetResolutionSetter;
	        UniformSetter._passTable.hx_rcpRenderTargetResolution = RCPRenderTargetResolutionSetter;
	        UniformSetter._passTable.hx_dither2DTextureScale = Dither2DTextureScaleSetter;
	        UniformSetter._passTable.hx_ambientColor = AmbientColorSetter;
	        UniformSetter._passTable["hx_poissonDisk[0]"] = PoissonDiskSetter;
	        UniformSetter._passTable["hx_poissonSphere[0]"] = PoissonSphereSetter;
	    }
	};


	function WorldMatrixSetter()
	{
	}

	WorldMatrixSetter.prototype.execute = function (camera, renderItem)
	{
	    GL.gl.uniformMatrix4fv(this.location, false, renderItem.worldMatrix._m);
	};


	function ViewProjectionSetter()
	{
	}

	ViewProjectionSetter.prototype.execute = function(camera)
	{
	    GL.gl.uniformMatrix4fv(this.location, false, camera.viewProjectionMatrix._m);
	};

	function InverseViewProjectionSetter()
	{
	}

	InverseViewProjectionSetter.prototype.execute = function(camera)
	{
	    GL.gl.uniformMatrix4fv(this.location, false, camera.inverseViewProjectionMatrix._m);
	};

	function InverseWVPSetter()
	{
	}

	InverseWVPSetter.prototype.execute = function(camera)
	{
	    GL.gl.uniformMatrix4fv(this.location, false, camera.inverseViewProjectionMatrix._m);
	};

	function ProjectionSetter()
	{
	}

	ProjectionSetter.prototype.execute = function(camera)
	{
	    GL.gl.uniformMatrix4fv(this.location, false, camera.projectionMatrix._m);
	};

	function InverseProjectionSetter()
	{
	}

	InverseProjectionSetter.prototype.execute = function(camera)
	{
	    GL.gl.uniformMatrix4fv(this.location, false, camera.inverseProjectionMatrix._m);
	};

	function WorldViewProjectionSetter()
	{
	}

	WorldViewProjectionSetter.prototype.execute = function()
	{
	    var matrix = new Matrix4x4();
	    var m = matrix._m;
	    return function(camera, renderItem)
	    {
	        matrix.multiply(camera.viewProjectionMatrix, renderItem.worldMatrix);
	        GL.gl.uniformMatrix4fv(this.location, false, m);
	    };
	}();

	function WorldViewMatrixSetter()
	{
	    this._matrix = new Matrix4x4();
	}
	WorldViewMatrixSetter.prototype.execute = function(){
	    var matrix = new Matrix4x4();
	    var m = matrix._m;
	    return function (camera, renderItem)
	    {
	        matrix.multiply(camera.viewMatrix, renderItem.worldMatrix);
	        GL.gl.uniformMatrix4fv(this.location, false, m);
	    }
	}();


	function NormalWorldMatrixSetter()
	{
	}

	NormalWorldMatrixSetter.prototype.execute = function() {
	    var data = new Float32Array(9);
	    return function (camera, renderItem)
	    {
	        renderItem.worldMatrix.writeNormalMatrix(data);
	        GL.gl.uniformMatrix3fv(this.location, false, data);    // transpose of inverse
	    }
	}();


	function NormalWorldViewMatrixSetter()
	{
	}

	NormalWorldViewMatrixSetter.prototype.execute = function() {
	    var data = new Float32Array(9);
	    //var matrix = new Matrix4x4();

	    return function (camera, renderItem)
	    {
	        // the following code is the same as the following two lines, but inlined and reducing the need for all field to be multiplied
	        //matrix.multiply(camera.viewMatrix, renderItem.worldMatrix);
	        //matrix.writeNormalMatrix(data);

	        var am = camera.viewMatrix._m;
	        var bm = renderItem.worldMatrix._m;

	        var a_m00 = am[0], a_m10 = am[1], a_m20 = am[2];
	        var a_m01 = am[4], a_m11 = am[5], a_m21 = am[6];
	        var a_m02 = am[8], a_m12 = am[9], a_m22 = am[10];
	        var a_m03 = am[12], a_m13 = am[13], a_m23 = am[14];
	        var b_m00 = bm[0], b_m10 = bm[1], b_m20 = bm[2], b_m30 = bm[3];
	        var b_m01 = bm[4], b_m11 = bm[5], b_m21 = bm[6], b_m31 = bm[7];
	        var b_m02 = bm[8], b_m12 = bm[9], b_m22 = bm[10], b_m32 = bm[11];

	        var m0 = a_m00 * b_m00 + a_m01 * b_m10 + a_m02 * b_m20 + a_m03 * b_m30;
	        var m1 = a_m10 * b_m00 + a_m11 * b_m10 + a_m12 * b_m20 + a_m13 * b_m30;
	        var m2 = a_m20 * b_m00 + a_m21 * b_m10 + a_m22 * b_m20 + a_m23 * b_m30;
	        var m4 = a_m00 * b_m01 + a_m01 * b_m11 + a_m02 * b_m21 + a_m03 * b_m31;
	        var m5 = a_m10 * b_m01 + a_m11 * b_m11 + a_m12 * b_m21 + a_m13 * b_m31;
	        var m6 = a_m20 * b_m01 + a_m21 * b_m11 + a_m22 * b_m21 + a_m23 * b_m31;
	        var m8 = a_m00 * b_m02 + a_m01 * b_m12 + a_m02 * b_m22 + a_m03 * b_m32;
	        var m9 = a_m10 * b_m02 + a_m11 * b_m12 + a_m12 * b_m22 + a_m13 * b_m32;
	        var m10 = a_m20 * b_m02 + a_m21 * b_m12 + a_m22 * b_m22 + a_m23 * b_m32;

	        var determinant = m0 * (m5 * m10 - m9 * m6) - m4 * (m1 * m10 - m9 * m2) + m8 * (m1 * m6 - m5 * m2);
	        var rcpDet = 1.0 / determinant;

	        data[0] = (m5 * m10 - m9 * m6) * rcpDet;
	        data[1] = (m8 * m6 - m4 * m10) * rcpDet;
	        data[2] = (m4 * m9 - m8 * m5) * rcpDet;
	        data[3] = (m9 * m2 - m1 * m10) * rcpDet;
	        data[4] = (m0 * m10 - m8 * m2) * rcpDet;
	        data[5] = (m8 * m1 - m0 * m9) * rcpDet;
	        data[6] = (m1 * m6 - m5 * m2) * rcpDet;
	        data[7] = (m4 * m2 - m0 * m6) * rcpDet;
	        data[8] = (m0 * m5 - m4 * m1) * rcpDet;

	        GL.gl.uniformMatrix3fv(this.location, false, data);    // transpose of inverse
	    }
	}();

	function CameraWorldPosSetter()
	{
	}

	CameraWorldPosSetter.prototype.execute = function (camera)
	{
	    var arr = camera.worldMatrix._m;
	    GL.gl.uniform3f(this.location, arr[12], arr[13], arr[14]);
	};

	function CameraWorldMatrixSetter()
	{
	}

	CameraWorldMatrixSetter.prototype.execute = function (camera)
	{
	    var matrix = camera.worldMatrix;
	    GL.gl.uniformMatrix4fv(this.location, false, matrix._m);
	};

	function CameraFrustumRangeSetter()
	{
	}

	CameraFrustumRangeSetter.prototype.execute = function (camera)
	{
	    GL.gl.uniform1f(this.location, camera._farDistance - camera._nearDistance);
	};

	function RCPCameraFrustumRangeSetter()
	{
	}

	RCPCameraFrustumRangeSetter.prototype.execute = function (camera)
	{
	    GL.gl.uniform1f(this.location, 1.0 / (camera._farDistance - camera._nearDistance));
	};

	function CameraNearPlaneDistanceSetter()
	{
	}

	CameraNearPlaneDistanceSetter.prototype.execute = function (camera)
	{
	    GL.gl.uniform1f(this.location, camera._nearDistance);
	};

	function CameraFarPlaneDistanceSetter()
	{
	}

	CameraFarPlaneDistanceSetter.prototype.execute = function (camera)
	{
	    GL.gl.uniform1f(this.location, camera._farDistance);
	};

	function ViewMatrixSetter()
	{
	}

	ViewMatrixSetter.prototype.execute = function (camera)
	{
	    GL.gl.uniformMatrix4fv(this.location, false, camera.viewMatrix._m);
	};

	function RenderTargetResolutionSetter()
	{
	}

	RenderTargetResolutionSetter.prototype.execute = function (camera)
	{
	    GL.gl.uniform2f(this.location, camera._renderTargetWidth, camera._renderTargetHeight);
	};

	function AmbientColorSetter()
	{
	}

	AmbientColorSetter.prototype.execute = function (camera, renderer)
	{
	    var color = renderer._ambientColor;
	    GL.gl.uniform3f(this.location, color.r, color.g, color.b);
	};

	function RCPRenderTargetResolutionSetter()
	{
	}

	RCPRenderTargetResolutionSetter.prototype.execute = function (camera)
	{
	    GL.gl.uniform2f(this.location, 1.0/camera._renderTargetWidth, 1.0/camera._renderTargetHeight);
	};

	function Dither2DTextureScaleSetter()
	{
	}

	Dither2DTextureScaleSetter.prototype.execute = function ()
	{
	    GL.gl.uniform2f(this.location, 1.0 / DEFAULTS.DEFAULT_2D_DITHER_TEXTURE.width, 1.0 / DEFAULTS.DEFAULT_2D_DITHER_TEXTURE.height);
	};

	function PoissonDiskSetter()
	{
	}

	PoissonDiskSetter.prototype.execute = function ()
	{
	    GL.gl.uniform2fv(this.location, PoissonDisk.DEFAULT_FLOAT32);
	};

	function PoissonSphereSetter()
	{
	}

	PoissonSphereSetter.prototype.execute = function ()
	{
	    GL.gl.uniform3fv(this.location, PoissonSphere.DEFAULT_FLOAT32);
	};

	function SkinningMatricesSetter()
	{
	    this._data = new Float32Array(META.OPTIONS.maxSkeletonJoints * 12);
	}

	SkinningMatricesSetter.prototype.execute = function (camera, renderItem)
	{
	    var skeleton = renderItem.skeleton;

	    if (skeleton) {
	        // TODO: Could we store the 4x3 format in renderItem.skeletonMatrices?
	        // no need to store actual matrices in this data
	        var matrices = renderItem.skeletonMatrices;
	        var numJoints = skeleton.numJoints;
	        var j = 0;

	        for (var i = 0; i < numJoints; ++i) {
	            matrices[i].writeData4x3(this._data, j);
	            j += 12;
	        }
	        GL.gl.uniform4fv(this.location, this._data);
	    }
	};

	function MorphWeightsSetter()
	{
	}

	MorphWeightsSetter.prototype.execute = function (camera, renderItem)
	{
	    GL.gl.uniform1fv(this.location, renderItem.meshInstance._morphWeights);
	};

	/**
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var Debug = {
	    printShaderCode: function(code)
	    {
	        var arr = code.split("\n");
	        var str = "";
	        for (var i = 0; i < arr.length; ++i) {
	            str += (i + 1) + ":\t" + arr[i] + "\n";
	        }
	        console.log(str);
	    },

	    printSkeletonHierarchy: function(skeleton)
	    {
	        var str = "Skeleton: \n";
	        for (var i = 0; i < skeleton.numJoints; ++i) {
	            var joint = skeleton.getJoint(i);
	            var name = joint.name;
	            while (joint.parentIndex !== -1) {
	                joint = skeleton.getJoint(joint.parentIndex);
	                str += "\t";
	            }
	            str += "\t" + name + "\n";
	        }
	        console.log(str);
	    },

	    assert: function(bool, message)
	    {
	        if (!bool) throw new Error(message);
	    }
	};

	/**
	 * @ignore
	 * @param vertexShaderCode
	 * @param fragmentShaderCode
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Shader(vertexShaderCode, fragmentShaderCode)
	{
	    this._ready = false;
	    this._vertexShader = null;
	    this._fragmentShader = null;
	    this._program = null;
	    this._uniformSettersInstance = null;
	    this._uniformSettersPass = null;

	    if (vertexShaderCode && fragmentShaderCode)
	        this.init(vertexShaderCode, fragmentShaderCode);
	}

	Shader.ID_COUNTER = 0;

	Shader.prototype = {
	    constructor: Shader,

	    isReady: function() { return this._ready; },

	    init: function(vertexShaderCode, fragmentShaderCode)
	    {
	        var gl = GL.gl;
	        vertexShaderCode = "#define HX_VERTEX_SHADER\n" + GLSLIncludes.GENERAL + vertexShaderCode;
	        fragmentShaderCode = "#define HX_FRAGMENT_SHADER\n" + GLSLIncludes.GENERAL + fragmentShaderCode;

	        vertexShaderCode = this._processShaderCode(vertexShaderCode);
	        fragmentShaderCode = this._processShaderCode(fragmentShaderCode);

	        this._vertexShader = gl.createShader(gl.VERTEX_SHADER);
	        if (!this._initShader(this._vertexShader, vertexShaderCode)) {
	            this.dispose();
	            if (META.OPTIONS.throwOnShaderError) {
	                throw new Error("Failed generating vertex shader: \n" + vertexShaderCode);
	            }
	            else {
	                console.warn("Failed generating vertex shader");
	            }

	            return;
	        }

	        this._fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	        if (!this._initShader(this._fragmentShader, fragmentShaderCode)) {
	            this.dispose();
	            if (META.OPTIONS.throwOnShaderError)
	                throw new Error("Failed generating fragment shader: \n" + fragmentShaderCode);
	            else
	                console.warn("Failed generating fragment shader:");
	            return;
	        }

	        this._program = gl.createProgram();

	        gl.attachShader(this._program, this._vertexShader);
	        gl.attachShader(this._program, this._fragmentShader);
	        gl.linkProgram(this._program);

	        if (META.OPTIONS.debug && !gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
	            var log = gl.getProgramInfoLog(this._program);
	            this.dispose();

	            console.log("**********");
	            Debug.printShaderCode(vertexShaderCode);
	            console.log("**********");
	            Debug.printShaderCode(fragmentShaderCode);

	            if (META.OPTIONS.throwOnShaderError)
	                throw new Error("Error in program linking:" + log);

	            console.warn("Error in program linking:" + log);

	            return;
	        }

	        this._ready = true;

	        // Profiler.stopTiming("Shader::init");

	        this._uniformSettersInstance = UniformSetter.getSettersPerInstance(this);
	        this._uniformSettersPass = UniformSetter.getSettersPerPass(this);
	    },

	    updatePassRenderState: function(camera, renderer)
	    {
	        GL.gl.useProgram(this._program);

	        var len = this._uniformSettersPass.length;
	        for (var i = 0; i < len; ++i)
	            this._uniformSettersPass[i].execute(camera, renderer);
	    },

	    updateInstanceRenderState: function(camera, renderItem)
	    {
	        var len = this._uniformSettersInstance.length;
	        for (var i = 0; i < len; ++i)
	            this._uniformSettersInstance[i].execute(camera, renderItem);
	    },

	    _initShader: function(shader, code)
	    {
	        var gl = GL.gl;
	        gl.shaderSource(shader, code);
	        gl.compileShader(shader);

	        // Check the compile status, return an error if failed
	        if (META.OPTIONS.debug && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	            console.warn(gl.getShaderInfoLog(shader));
	            Debug.printShaderCode(code);
	            return false;
	        }

	        return true;
	    },

	    dispose: function()
	    {
	        var gl = GL.gl;
	        gl.deleteShader(this._vertexShader);
	        gl.deleteShader(this._fragmentShader);
	        gl.deleteProgram(this._program);

	        this._ready = false;
	    },

	    getProgram: function() { return this._program; },

	    getUniformLocation: function(name)
	    {
	        return GL.gl.getUniformLocation(this._program, name);
	    },

	    getAttributeLocation: function(name)
	    {
	        return GL.gl.getAttribLocation(this._program, name);
	    },

	    _processShaderCode: function(code)
	    {
	        code = this._processExtensions(code, /^\s*#derivatives\s*$/gm, "GL_OES_standard_derivatives");
	        code = this._processExtensions(code, /^\s*#texturelod\s*$/gm, "GL_EXT_shader_texture_lod");
	        code = this._processExtensions(code, /^\s*#drawbuffers\s*$/gm, "GL_EXT_draw_buffers");
	        code = this._guard(code, /^\s*uniform\s+\w+\s+hx_\w+(\[\w+])?\s*;/gm);
	        code = this._guard(code, /^\s*attribute\s+\w+\s+hx_\w+\s*;/gm);
	        code = GLSLIncludes.VERSION + code;
	        return code;
	    },

	    _processExtensions: function(code, regEx, extension)
	    {

	        var index = code.search(regEx);
	        if (index < 0) return code;
	        code = "#extension " + extension + " : enable\n" + code.replace(regEx, "");
	        return code;
	    },

	    // this makes sure reserved uniforms are only used once, makes it easier to combine several snippets
	    // it's quite slow, tho
	    _guard: function(code, regEx)
	    {
	        var result = code.match(regEx) || [];
	        var covered = {};


	        for (var i = 0; i < result.length; ++i) {
	            var occ = result[i];
	            occ = occ.replace(/(\r|\n)/g, "");

	            if (occ.charCodeAt(0) === 10)
	                occ = occ.substring(1);

	            var start$$1 = occ.indexOf("hx_");
	            var end = occ.indexOf(";");

	            // in case of arrays
	            var sq = occ.indexOf("[");
	            if (sq >= 0 && sq < end) end = sq;

	            var name = occ.substring(start$$1, end);
	            name = name.trim();

	            if (covered[name]) continue;

	            covered[name] = true;

	            var defName = "HX_GUARD_" + name.toUpperCase();
	            var repl =  "\n#ifndef " + defName + "\n" +
	                        "#define " + defName + "\n" +
	                        occ + "\n" +
	                        "#endif\n";

	            occ = occ.replace(/\[/g, "\\[");
	            var replReg = new RegExp(occ, "g");
	            code = code.replace(replReg, repl);
	        }

	        return code;
	    }
	};

	/**
	 * @param fragmentShader
	 * @constructor
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function CustomCopyShader(fragmentShader)
	{
	    Shader.call(this);
	    this.init(ShaderLibrary.get("copy_vertex.glsl"), fragmentShader);

	    var gl = GL.gl;
	    var textureLocation = gl.getUniformLocation(this._program, "sampler");

	    this._positionAttributeLocation = gl.getAttribLocation(this._program, "hx_position");
	    this._texCoordAttributeLocation = gl.getAttribLocation(this._program, "hx_texCoord");

	    gl.useProgram(this._program);
	    gl.uniform1i(textureLocation, 0);
	}

	CustomCopyShader.prototype = Object.create(Shader.prototype);

	CustomCopyShader.prototype.execute = function(rect, texture)
	{
	    var gl = GL.gl;
	    GL.setDepthTest(Comparison.DISABLED);
	    GL.setCullMode(CullMode.NONE);

	    rect._vertexBuffers[0].bind();
	    rect._indexBuffer.bind();

	    this.updatePassRenderState();

	    texture.bind(0);

	    gl.vertexAttribPointer(this._positionAttributeLocation, 2, gl.FLOAT, false, 16, 0);
	    gl.vertexAttribPointer(this._texCoordAttributeLocation, 2, gl.FLOAT, false, 16, 8);

	    GL.enableAttributes(2);

	    GL.drawElements(ElementType.TRIANGLES, 6, 0);
	};



	/**
	 * Copies one texture's channels (in configurable ways) to another's.
	 * @param channel Can be either x, y, z, w or any 4-component swizzle. default is xyzw, meaning a simple copy
	 * @constructor
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function CopyChannelsShader(channel, copyAlpha)
	{
	    channel = channel || "xyzw";
	    copyAlpha = copyAlpha === undefined? true : copyAlpha;

	    var define = "#define extractChannels(src) ((src)." + channel + ")\n";

	    if (copyAlpha) define += "#define COPY_ALPHA\n";

	    CustomCopyShader.call(this, define + ShaderLibrary.get("copy_fragment.glsl"));
	}

	CopyChannelsShader.prototype = Object.create(CustomCopyShader.prototype);



	/**
	 * Copies one texture's channels while applying the same logic as gl.blendColor. This because it is broken for float textures.
	 * @constructor
	 * @ignore
	 * @author derschmale <http://www.derschmale.com>
	 */
	function BlendColorCopyShader()
	{
	    CustomCopyShader.call(this, ShaderLibrary.get("blend_color_copy_fragment.glsl"));
	    this._colorLocation = GL.gl.getUniformLocation(this._program, "blendColor");
	    this.setBlendColor(1, 1, 1, 1);
	}

	BlendColorCopyShader.prototype = Object.create(CustomCopyShader.prototype);

	BlendColorCopyShader.prototype.setBlendColor = function(r, g, b, a)
	{
	    var gl = GL.gl;
	    gl.useProgram(this._program);
	    gl.uniform4f(this._colorLocation, r, g, b, a);
	};


	/**
	 * @classdesc
	 * Copies the texture from linear space to gamma space.
	 *
	 * @ignore
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ApplyGammaShader()
	{
	    CustomCopyShader.call(this, ShaderLibrary.get("copy_to_gamma_fragment.glsl"));
	}

	ApplyGammaShader.prototype = Object.create(CustomCopyShader.prototype);

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function IndexBuffer()
	{
	    this._buffer = GL.gl.createBuffer();
	}

	IndexBuffer.prototype = {
	    /**
	     * Uploads data for the buffer.
	     * @param data The data to upload, must be a Int16Array object.
	     * @param usageHint An optional usage hint for the buffer.
	     */
	    uploadData: function(data, usageHint)
	    {
	        if (usageHint === undefined)
	            usageHint = BufferUsage.STATIC_DRAW;

	        this.bind();
	        GL.gl.bufferData(GL.gl.ELEMENT_ARRAY_BUFFER, data, usageHint);
	    },

	    /**
	     * @private
	     */
	    bind: function()
	    {
	        GL.gl.bindBuffer(GL.gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	    }
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function VertexBuffer()
	{
	    this._buffer = GL.gl.createBuffer();
	}

	VertexBuffer.prototype = {

	    /**
	     * Uploads data for the buffer.
	     * @param data The data to upload, must be a Float32Array object.
	     * @param usageHint An optional usage hint for the buffer.
	     */
	    uploadData: function(data, usageHint)
	    {
	        if (usageHint === undefined)
	            usageHint = GL.gl.STATIC_DRAW;

	        this.bind();
	        GL.gl.bufferData(GL.gl.ARRAY_BUFFER, data, usageHint);
	    },

	    /**
	     * @private
	     */
	    bind: function()
	    {
	        GL.gl.bindBuffer(GL.gl.ARRAY_BUFFER, this._buffer);
	    }
	};

	/**
	 * @classdesc
	 * BoundingVolume forms an abstract base class for axis-aligned bounding volumes, used in the scene hierarchy.
	 *
	 * @param type The type of bounding volume.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function BoundingVolume(type)
	{
	    this._type = type;

	    this._expanse = BoundingVolume.EXPANSE_EMPTY;
	    this._minimumX = 0.0;
	    this._minimumY = 0.0;
	    this._minimumZ = 0.0;
	    this._maximumX = 0.0;
	    this._maximumY = 0.0;
	    this._maximumZ = 0.0;
	    this._halfExtentX = 0.0;
	    this._halfExtentY = 0.0;
	    this._halfExtentZ = 0.0;
	    this._center = new Float4();
	}

	/**
	 * Indicates the bounds are empty
	 */
	BoundingVolume.EXPANSE_EMPTY = 0;

	/**
	 * Indicates the bounds are infinitely large
	 */
	BoundingVolume.EXPANSE_INFINITE = 1;

	/**
	 * Indicates the bounds have a real size and position
	 */
	BoundingVolume.EXPANSE_FINITE = 2;

	/**
	 * Indicates the parent's bounds are used in selecting.
	 */
	BoundingVolume.EXPANSE_INHERIT = 3;

	BoundingVolume._testAABBToSphere = function(aabb, sphere)
	{
	    // b = sphere var max = aabb._maximum;
	    var maxX = sphere._maximumX;
	    var maxY = sphere._maximumY;
	    var maxZ = sphere._maximumZ;
	    var minX = aabb._minimumX;
	    var minY = aabb._minimumY;
	    var minZ = aabb._minimumZ;
	    var radius = sphere._halfExtentX;
	    var centerX = sphere._center.x;
	    var centerY = sphere._center.y;
	    var centerZ = sphere._center.z;
	    var dot = 0, diff;

	    if (minX > centerX) {
	        diff = centerX - minX;
	        dot += diff * diff;
	    }
	    else if (maxX < centerX) {
	        diff = centerX - maxX;
	        dot += diff * diff;
	    }

	    if (minY > centerY) {
	        diff = centerY - minY;
	        dot += diff * diff;
	    }
	    else if (maxY < centerY) {
	        diff = centerY - maxY;
	        dot += diff * diff;
	    }

	    if (minZ > centerZ) {
	        diff = centerZ - minZ;
	        dot += diff * diff;
	    }
	    else if (maxZ < centerZ) {
	        diff = centerZ - maxZ;
	        dot += diff * diff;
	    }

	    return dot < radius * radius;
	};

	BoundingVolume.prototype =
	{
	    /**
	     * Describes the size of the bounding box. {@linkcode BoundingVolume#EXPANSE_EMPTY}, {@linkcode BoundingVolume#EXPANSE_FINITE}, or {@linkcode BoundingVolume#EXPANSE_INFINITE}
	     */
	    get expanse() { return this._expanse; },

	    /**
	     * @ignore
	     */
	    get type() { return this._type; },

	    growToIncludeMesh: function(mesh) { throw new Error("Abstract method!"); },
	    growToIncludeBound: function(bounds) { throw new Error("Abstract method!"); },
	    growToIncludeMinMax: function(min, max) { throw new Error("Abstract method!"); },

	    /**
	     * Clear the bounds.
	     * @param expanseState The state to reset to. Either {@linkcode BoundingVolume#EXPANSE_EMPTY} or {@linkcode BoundingVolume#EXPANSE_INFINITE}.
	     */
	    clear: function(expanseState)
	    {
	        this._minimumX = this._minimumY = this._minimumZ = 0;
	        this._maximumX = this._maximumY = this._maximumZ = 0;
	        this._center.set(0, 0, 0);
	        this._halfExtentX = this._halfExtentY = this._halfExtentZ = 0;
	        this._expanse = expanseState === undefined? BoundingVolume.EXPANSE_EMPTY : expanseState;
	    },

	    /**
	     * The minimum reach of the bounds, described as a box range.
	     */
	    get minimum() { return new Float4(this._minimumX, this._minimumY, this._minimumZ, 1.0); },

	    /**
	     * The maximum reach of the bounds, described as a box range.
	     */
	    get maximum() { return new Float4(this._maximumX, this._maximumY, this._maximumZ, 1.0); },

	    /**
	     * The center coordinate of the bounds
	     */
	    get center() { return this._center; },

	    /**
	     * The half extents of the bounds. These are the half-dimensions of the box encompassing the bounds from the center.
	     */
	    get halfExtent() { return new Float4(this._halfExtentX, this._halfExtentY, this._halfExtentZ, 0.0); },

	    /**
	     * The radius of the sphere encompassing the bounds. This is implementation-dependent, because the radius is less precise for a box than for a sphere
	     */
	    getRadius: function() { throw new Error("Abstract method!"); },

	    /**
	     * Transforms a bounding volume and stores it in this one.
	     * @param {BoundingVolume} sourceBound The bounds to transform.
	     * @param {Matrix4x4} matrix The matrix containing the transformation.
	     */
	    transformFrom: function(sourceBound, matrix) { throw new Error("Abstract method!"); },

	    /**
	     * Tests whether the bounds intersects a given convex solid. The convex solid is described as a list of planes pointing outward. Infinite solids are also allowed (Directional Light frusta without a near plane, for example)
	     * @param cullPlanes An Array of planes to be tested. Planes are simply Float4 objects.
	     * @param numPlanes The amount of planes to be tested against. This so we can test less planes than are in the cullPlanes array (Directional Light frusta, for example)
	     * @returns {boolean} Whether or not the bounds intersect the solid.
	     */
	    intersectsConvexSolid: function(cullPlanes, numPlanes) { throw new Error("Abstract method!"); },

	    /**
	     * Tests whether the bounds intersect another bounding volume
	     */
	    intersectsBound: function(bound) { throw new Error("Abstract method!"); },

	    /**
	     * Tests on which side of the plane the bounding box is (front, back or intersecting).
	     * @param plane The plane to test against.
	     * @return {PlaneSide} The side of the plane
	     */
	    classifyAgainstPlane: function(plane) { throw new Error("Abstract method!"); },

	    /**
	     * Tests whether or not this BoundingVolume intersects a ray.
	     */
	    intersectsRay: function(ray) { throw new Error("Abstract method!"); },

	    /**
	     * @ignore
	     */
	    createDebugModel: function() { throw new Error("Abstract method!"); },

	    /**
	     * @ignore
	     */
	    getDebugModel: function()
	    {
	        if (this._type._debugModel === undefined)
	            this._type._debugModel = this.createDebugModel();

	        return this._type._debugModel;
	    },

	    toString: function()
	    {
	        return "BoundingVolume: [ " +
	            this._minimumX + ", " +
	            this._minimumY + ", " +
	            this._minimumZ + " ] - [ " +
	            this._maximumX + ", " +
	            this._maximumY + ", " +
	            this._maximumZ + " ], expanse: " +
	            this._expanse;
	    },

	    clone: function()
	    {
	        throw new Error("Abstract method called!");
	    }
	};

	/**
	 * Values for classifying a point or object to a plane
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var PlaneSide = {
	    /**
	     * Entirely on the front side of the plane
	     */
	    FRONT: 1,

	    /**
	     * Entirely on the back side of the plane
	     */
	    BACK: -1,

	    /**
	     * Intersecting the plane.
	     */
	    INTERSECTING: 0
	};

	/**
	 * @classdesc
	 * BoundingAABB represents a bounding sphere.
	 *
	 * @constructor
	 *
	 * @extends BoundingVolume
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function BoundingSphere()
	{
	    BoundingVolume.call(this, BoundingSphere);
	}

	BoundingSphere.prototype = Object.create(BoundingVolume.prototype);

	/**
	 * Sets the center and radius explicitly.
	 */
	BoundingSphere.prototype.setExplicit = function(center, radius)
	{
	    this._center.copyFrom(center);
	    this._halfExtentX = this._halfExtentY = this._halfExtentZ = radius;
	    this._expanse = BoundingVolume.EXPANSE_FINITE;
	    this._updateMinAndMax();
	};

	/**
	 * @inheritDoc
	 */
	BoundingSphere.prototype.growToIncludeMesh = function(mesh)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE) return;

	    var attribute = mesh.getVertexAttributeByName("hx_position");
	    var index = attribute.offset;
	    var stride = mesh.getVertexStride(attribute.streamIndex);
	    var vertices = mesh.getVertexData(attribute.streamIndex);
	    var len = vertices.length;
	    var minX, minY, minZ;
	    var maxX, maxY, maxZ;

	    if (this._expanse === BoundingVolume.EXPANSE_EMPTY) {
	        maxX = minX = vertices[index];
	        maxY = minY = vertices[index + 1];
	        maxZ = minZ = vertices[index + 2];
	        index += stride;
	    }
	    else {
	        minX = this._minimumX; minY = this._minimumY; minZ = this._minimumZ;
	        maxX = this._maximumX; maxY = this._maximumY; maxZ = this._maximumZ;
	    }

	    for (; index < len; index += stride) {
	        var x = vertices[index];
	        var y = vertices[index + 1];
	        var z = vertices[index + 2];

	        if (x > maxX) maxX = x;
	        else if (x < minX) minX = x;
	        if (y > maxY) maxY = y;
	        else if (y < minY) minY = y;
	        if (z > maxZ) maxZ = z;
	        else if (z < minZ) minZ = z;
	    }
	    var centerX = (maxX + minX) * .5;
	    var centerY = (maxY + minY) * .5;
	    var centerZ = (maxZ + minZ) * .5;
	    var maxSqrRadius = 0.0;

	    index = attribute.offset;
	    for (; index < len; index += stride) {
	        var dx = centerX - vertices[index];
	        var dy = centerY - vertices[index + 1];
	        var dz = centerZ - vertices[index + 2];
	        var sqrRadius = dx*dx + dy*dy + dz*dz;
	        if (sqrRadius > maxSqrRadius) maxSqrRadius = sqrRadius;
	    }

	    this._center.x = centerX;
	    this._center.y = centerY;
	    this._center.z = centerZ;

	    var radius = Math.sqrt(maxSqrRadius);
	    this._halfExtentX = radius;
	    this._halfExtentY = radius;
	    this._halfExtentZ = radius;

	    this._expanse = BoundingVolume.EXPANSE_FINITE;

	    this._updateMinAndMax();
	};

	/**
	 * @inheritDoc
	 */
	BoundingSphere.prototype.growToIncludeBound = function(bounds)
	{
	    if (bounds._expanse === BoundingVolume.EXPANSE_EMPTY ||
	        bounds._expanse === BoundingVolume.EXPANSE_INHERIT ||
	        this._expanse === BoundingVolume.EXPANSE_INFINITE) return;

	    if (bounds._expanse === BoundingVolume.EXPANSE_INFINITE)
	        this._expanse = BoundingVolume.EXPANSE_INFINITE;

	    else if (this._expanse === BoundingVolume.EXPANSE_EMPTY) {
	        this._center.x = bounds._center.x;
	        this._center.y = bounds._center.y;
	        this._center.z = bounds._center.z;
	        if (bounds._type === this._type) {
	            this._halfExtentX = bounds._halfExtentX;
	            this._halfExtentY = bounds._halfExtentY;
	            this._halfExtentZ = bounds._halfExtentZ;
	        }
	        else {
	            this._halfExtentX = this._halfExtentY = this._halfExtentZ = bounds.getRadius();
	        }
	        this._expanse = BoundingVolume.EXPANSE_FINITE;
	    }

	    else {
	        var minX = this._minimumX; var minY = this._minimumY; var minZ = this._minimumZ;
	        var maxX = this._maximumX; var maxY = this._maximumY; var maxZ = this._maximumZ;

	        if (bounds._maximumX > maxX)
	            maxX = bounds._maximumX;
	        if (bounds._maximumY > maxY)
	            maxY = bounds._maximumY;
	        if (bounds._maximumZ > maxZ)
	            maxZ = bounds._maximumZ;
	        if (bounds._minimumX < minX)
	            minX = bounds._minimumX;
	        if (bounds._minimumY < minY)
	            minY = bounds._minimumY;
	        if (bounds._minimumZ < minZ)
	            minZ = bounds._minimumZ;

	        this._center.x = (minX + maxX) * .5;
	        this._center.y = (minY + maxY) * .5;
	        this._center.z = (minZ + maxZ) * .5;

	        var dx = maxX - this._center.x;
	        var dy = maxY - this._center.y;
	        var dz = maxZ - this._center.z;
	        var radius = Math.sqrt(dx*dx + dy*dy + dz*dz);
	        this._halfExtentX = this._halfExtentY = this._halfExtentZ = radius;
	    }

	    this._updateMinAndMax();
	};

	/**
	 * @inheritDoc
	 */
	BoundingSphere.prototype.growToIncludeMinMax = function(min, max)
	{
	    // temp solution, not run-time perf critical
	    var aabb = new BoundingAABB();
	    aabb.growToIncludeMinMax(min, max);
	    this.growToIncludeBound(aabb);
	};

	/**
	 * @inheritDoc
	 */
	BoundingSphere.prototype.getRadius = function()
	{
	    return this._halfExtentX;
	};

	/**
	 * Generates a new BoundingSphere with the transformation matrix applied.
	 */
	BoundingSphere.prototype.transform = function(matrix)
	{
	    var clone = new BoundingSphere();
	    clone.transformFrom(this, matrix);
	    return clone;
	};

	/**
	 * @inheritDoc
	 */
	BoundingSphere.prototype.transformFrom = function(sourceBound, matrix)
	{
	    if (sourceBound._expanse === BoundingVolume.EXPANSE_INFINITE || sourceBound._expanse === BoundingVolume.EXPANSE_EMPTY)
	        this.clear(sourceBound._expanse);
	    else {
	        var arr = matrix._m;
	        var m00 = arr[0], m10 = arr[1], m20 = arr[2];
	        var m01 = arr[4], m11 = arr[5], m21 = arr[6];
	        var m02 = arr[8], m12 = arr[9], m22 = arr[10];

	        var x = sourceBound._center.x;
	        var y = sourceBound._center.y;
	        var z = sourceBound._center.z;

	        this._center.x = m00 * x + m01 * y + m02 * z + arr[12];
	        this._center.y = m10 * x + m11 * y + m12 * z + arr[13];
	        this._center.z = m20 * x + m21 * y + m22 * z + arr[14];


	        if (m00 < 0) m00 = -m00; if (m10 < 0) m10 = -m10; if (m20 < 0) m20 = -m20;
	        if (m01 < 0) m01 = -m01; if (m11 < 0) m11 = -m11; if (m21 < 0) m21 = -m21;
	        if (m02 < 0) m02 = -m02; if (m12 < 0) m12 = -m12; if (m22 < 0) m22 = -m22;
	        x = sourceBound._halfExtentX;
	        y = sourceBound._halfExtentY;
	        z = sourceBound._halfExtentZ;

	        var hx = m00 * x + m01 * y + m02 * z;
	        var hy = m10 * x + m11 * y + m12 * z;
	        var hz = m20 * x + m21 * y + m22 * z;

	        var radius = Math.sqrt(hx * hx + hy * hy + hz * hz);
	        this._halfExtentX = this._halfExtentY = this._halfExtentZ = radius;

	        this._minimumX = this._center.x - this._halfExtentX;
	        this._minimumY = this._center.y - this._halfExtentY;
	        this._minimumZ = this._center.z - this._halfExtentZ;
	        this._maximumX = this._center.x + this._halfExtentX;
	        this._maximumY = this._center.y + this._halfExtentY;
	        this._maximumZ = this._center.z + this._halfExtentZ;

	        this._expanse = BoundingVolume.EXPANSE_FINITE;
	    }
	};

	/**
	 * @inheritDoc
	 */
	BoundingSphere.prototype.intersectsConvexSolid = function(cullPlanes, numPlanes)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE || this._expanse === BoundingVolume.EXPANSE_INHERIT)
	        return true;
	    else if (this._expanse === BoundingVolume.EXPANSE_EMPTY)
	        return false;

	    var centerX = this._center.x, centerY = this._center.y, centerZ = this._center.z;
	    var radius = this._halfExtentX;

	    for (var i = 0; i < numPlanes; ++i) {
	        var plane = cullPlanes[i];
	        var signedDist = plane.x * centerX + plane.y * centerY + plane.z * centerZ + plane.w;

	        if (signedDist > radius)
	            return false;
	    }

	    return true;
	};

	/**
	 * @inheritDoc
	 */
	BoundingSphere.prototype.intersectsBound = function(bounds)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_EMPTY || bounds._expanse === BoundingVolume.EXPANSE_EMPTY)
	        return false;

	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE || bounds._expanse === BoundingVolume.EXPANSE_INFINITE || this._expanse === BoundingVolume.EXPANSE_INHERIT || bounds._expanse === BoundingVolume.EXPANSE_INHERIT)
	        return true;

	    // both Spheres
	    if (bounds._type === this._type) {
	        var dx = this._center.x - bounds._center.x;
	        var dy = this._center.y - bounds._center.y;
	        var dz = this._center.z - bounds._center.z;
	        var touchDistance = this._halfExtentX + bounds._halfExtentX;
	        return dx*dx + dy*dy + dz*dz < touchDistance*touchDistance;
	    }
	    else
	        return BoundingVolume._testAABBToSphere(bounds, this);
	};

	/**
	 * @inheritDoc
	 */
	BoundingSphere.prototype.classifyAgainstPlane = function(plane)
	{
	    var dist = plane.x * this._center.x + plane.y * this._center.y + plane.z * this._center.z + plane.w;
	    var radius = this._halfExtentX;
	    if (dist > radius) return PlaneSide.FRONT;
	    else if (dist < -radius) return PlaneSide.BACK;
	    else return PlaneSide.INTERSECTING;
	};

	/**
	 * @ignore
	 * @private
	 */
	BoundingSphere.prototype._updateMinAndMax = function()
	{
	    var centerX = this._center.x, centerY = this._center.y, centerZ = this._center.z;
	    var radius = this._halfExtentX;
	    this._minimumX = centerX - radius;
	    this._minimumY = centerY - radius;
	    this._minimumZ = centerZ - radius;
	    this._maximumX = centerX + radius;
	    this._maximumY = centerY + radius;
	    this._maximumZ = centerZ + radius;
	};

	/**
	 * @ignore
	 */
	BoundingSphere.prototype.intersectsRay = function(ray)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE) return true;
	    if (this._expanse === BoundingVolume.EXPANSE_EMPTY || this._expanse === BoundingVolume.EXPANSE_INHERIT) return false;

	    var centerX = this._center.x, centerY = this._center.y, centerZ = this._center.z;
	    var radius = this._halfExtentX;
	    var o = ray.origin;
	    var d = ray.direction;
	    var oX = o.x, oY = o.y, oZ = o.z;
	    var dirX = d.x, dirY = d.y, dirZ = d.z;
	    var diffX = centerX - oX;
	    var diffY = centerY - oY;
	    var diffZ = centerZ - oZ;

	    // project center onto ray
	    var dot = diffX * dirX + diffY * dirY + diffZ * dirZ;
	    var sqrDist;
	    if (dot > 0.0) {
	        // projection of c on the line
	        var cx = oX + dot * dirX;
	        var cy = oY + dot * dirY;
	        var cz = oZ + dot * dirZ;
	        // vector from projection to center is perpendicular length
	        cx = centerX - cx;
	        cy = centerY - cy;
	        cz = centerZ - cz;
	        sqrDist = cx * cx + cy * cy + cz * cz;
	    }
	    else
	        sqrDist = diffX * diffX + diffY * diffY + diffZ * diffZ;

	    // larger than the radius, so cannot intersect
	    return sqrDist <= radius * radius;
	};

	BoundingSphere.prototype.clone = function()
	{
	    var aabb = new BoundingSphere();
	    aabb.growToIncludeBound(this);
	    return aabb;
	};

	/**
	 * @classdesc
	 * BoundingAABB represents an axis-aligned bounding box.
	 *
	 * @constructor
	 *
	 * @extends BoundingVolume
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function BoundingAABB()
	{
	    BoundingVolume.call(this, BoundingAABB);
	}

	BoundingAABB.prototype = Object.create(BoundingVolume.prototype);

	/**
	 * @inheritDoc
	 */
	BoundingAABB.prototype.growToIncludeMesh = function(mesh)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE) return;

	    var attribute = mesh.getVertexAttributeByName("hx_position");
	    var index = attribute.offset;
	    var stride = mesh.getVertexStride(attribute.streamIndex);
	    var vertices = mesh.getVertexData(attribute.streamIndex);
	    var len = vertices.length;
	    var minX, minY, minZ;
	    var maxX, maxY, maxZ;

	    if (this._expanse === BoundingVolume.EXPANSE_EMPTY) {
	        maxX = minX = vertices[index];
	        maxY = minY = vertices[index + 1];
	        maxZ = minZ = vertices[index + 2];
	        index += stride;
	    }
	    else {
	        minX = this._minimumX; minY = this._minimumY; minZ = this._minimumZ;
	        maxX = this._maximumX; maxY = this._maximumY; maxZ = this._maximumZ;
	    }

	    for (; index < len; index += stride) {
	        var x = vertices[index];
	        var y = vertices[index + 1];
	        var z = vertices[index + 2];

	        if (x > maxX) maxX = x;
	        else if (x < minX) minX = x;
	        if (y > maxY) maxY = y;
	        else if (y < minY) minY = y;
	        if (z > maxZ) maxZ = z;
	        else if (z < minZ) minZ = z;
	    }

	    this._minimumX = minX; this._minimumY = minY; this._minimumZ = minZ;
	    this._maximumX = maxX; this._maximumY = maxY; this._maximumZ = maxZ;
	    this._expanse = BoundingVolume.EXPANSE_FINITE;

	    this._updateCenterAndExtent();
	};

	/**
	 * @inheritDoc
	 */
	BoundingAABB.prototype.growToIncludeBound = function(bounds)
	{
	    if (bounds._expanse === BoundingVolume.EXPANSE_EMPTY ||
	        bounds._expanse === BoundingVolume.EXPANSE_INHERIT ||
	        this._expanse === BoundingVolume.EXPANSE_INFINITE) return;

	    if (bounds._expanse === BoundingVolume.EXPANSE_INFINITE)
	        this._expanse = BoundingVolume.EXPANSE_INFINITE;

	    else if (this._expanse === BoundingVolume.EXPANSE_EMPTY) {
	        this._minimumX = bounds._minimumX;
	        this._minimumY = bounds._minimumY;
	        this._minimumZ = bounds._minimumZ;
	        this._maximumX = bounds._maximumX;
	        this._maximumY = bounds._maximumY;
	        this._maximumZ = bounds._maximumZ;
	        this._expanse = BoundingVolume.EXPANSE_FINITE;
	    }
	    else {
	        if (bounds._minimumX < this._minimumX)
	            this._minimumX = bounds._minimumX;
	        if (bounds._minimumY < this._minimumY)
	            this._minimumY = bounds._minimumY;
	        if (bounds._minimumZ < this._minimumZ)
	            this._minimumZ = bounds._minimumZ;
	        if (bounds._maximumX > this._maximumX)
	            this._maximumX = bounds._maximumX;
	        if (bounds._maximumY > this._maximumY)
	            this._maximumY = bounds._maximumY;
	        if (bounds._maximumZ > this._maximumZ)
	            this._maximumZ = bounds._maximumZ;
	    }

	    this._updateCenterAndExtent();
	};

	/**
	 * @inheritDoc
	 */
	BoundingAABB.prototype.growToIncludeMinMax = function(min, max)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE) return;

	    if (this._expanse === BoundingVolume.EXPANSE_EMPTY) {
	        this._minimumX = min.x;
	        this._minimumY = min.y;
	        this._minimumZ = min.z;
	        this._maximumX = max.x;
	        this._maximumY = max.y;
	        this._maximumZ = max.z;
	        this._expanse = BoundingVolume.EXPANSE_FINITE;
	    }
	    else {
	        if (min.x < this._minimumX)
	            this._minimumX = min.x;
	        if (min.y < this._minimumY)
	            this._minimumY = min.y;
	        if (min.z < this._minimumZ)
	            this._minimumZ = min.z;
	        if (max.x > this._maximumX)
	            this._maximumX = max.x;
	        if (max.y > this._maximumY)
	            this._maximumY = max.y;
	        if (max.z > this._maximumZ)
	            this._maximumZ = max.z;
	    }

	    this._updateCenterAndExtent();
	};

	/**
	 * Generates a new BoundingSphere with the transformation matrix applied.
	 */
	BoundingAABB.prototype.transform = function(matrix)
	{
	    var clone = new BoundingAABB();
	    clone.transformFrom(this, matrix);
	    return clone;
	};

	/**
	 * @inheritDoc
	 */
	BoundingAABB.prototype.transformFrom = function(sourceBound, matrix)
	{
	    if (sourceBound._expanse === BoundingVolume.EXPANSE_FINITE) {
	        var arr = matrix._m;
	        var m00 = arr[0], m10 = arr[1], m20 = arr[2];
	        var m01 = arr[4], m11 = arr[5], m21 = arr[6];
	        var m02 = arr[8], m12 = arr[9], m22 = arr[10];

	        var x = sourceBound._center.x;
	        var y = sourceBound._center.y;
	        var z = sourceBound._center.z;

	        var cx = this._center.x = m00 * x + m01 * y + m02 * z + arr[12];
	        var cy = this._center.y = m10 * x + m11 * y + m12 * z + arr[13];
	        var cz = this._center.z = m20 * x + m21 * y + m22 * z + arr[14];

	        if (m00 < 0) m00 = -m00; if (m10 < 0) m10 = -m10; if (m20 < 0) m20 = -m20;
	        if (m01 < 0) m01 = -m01; if (m11 < 0) m11 = -m11; if (m21 < 0) m21 = -m21;
	        if (m02 < 0) m02 = -m02; if (m12 < 0) m12 = -m12; if (m22 < 0) m22 = -m22;
	        x = sourceBound._halfExtentX;
	        y = sourceBound._halfExtentY;
	        z = sourceBound._halfExtentZ;

	        var hx = this._halfExtentX = m00 * x + m01 * y + m02 * z;
	        var hy = this._halfExtentY = m10 * x + m11 * y + m12 * z;
	        var hz = this._halfExtentZ = m20 * x + m21 * y + m22 * z;

	        this._minimumX = cx - hx;
	        this._minimumY = cy - hy;
	        this._minimumZ = cz - hz;
	        this._maximumX = cx + hx;
	        this._maximumY = cy + hy;
	        this._maximumZ = cz + hz;
	        this._expanse = sourceBound._expanse;
	    }
	    else {
	        this.clear(sourceBound._expanse);
	    }
	};


	/**
	 * @inheritDoc
	 */
	BoundingAABB.prototype.intersectsConvexSolid = function(cullPlanes, numPlanes)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE || this._expanse === BoundingVolume.EXPANSE_INHERIT)
	        return true;
	    else if (this._expanse === BoundingVolume.EXPANSE_EMPTY)
	        return false;

	    var minX = this._minimumX, minY = this._minimumY, minZ = this._minimumZ;
	    var maxX = this._maximumX, maxY = this._maximumY, maxZ = this._maximumZ;

	    for (var i = 0; i < numPlanes; ++i) {
	        // find the point that will always have the smallest signed distance
	        var plane = cullPlanes[i];
	        var planeX = plane.x, planeY = plane.y, planeZ = plane.z, planeW = plane.w;
	        var closestX = planeX > 0? minX : maxX;
	        var closestY = planeY > 0? minY : maxY;
	        var closestZ = planeZ > 0? minZ : maxZ;

	        // classify the closest point
	        var signedDist = planeX * closestX + planeY * closestY + planeZ * closestZ + planeW;
	        if (signedDist > 0.0)
	            return false;
	    }

	    return true;
	};

	/**
	 * @inheritDoc
	 */
	BoundingAABB.prototype.intersectsBound = function(bound)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_EMPTY || bound._expanse === BoundingVolume.EXPANSE_EMPTY)
	        return false;

	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE || bound._expanse === BoundingVolume.EXPANSE_INFINITE ||
	        this._expanse === BoundingVolume.EXPANSE_INHERIT || bound._expanse === BoundingVolume.EXPANSE_INHERIT)
	        return true;

	    // both AABB
	    if (bound._type === this._type) {
	        return 	this._maximumX > bound._minimumX &&
	            this._minimumX < bound._maximumX &&
	            this._maximumY > bound._minimumY &&
	            this._minimumY < bound._maximumY &&
	            this._maximumZ > bound._minimumZ &&
	            this._minimumZ < bound._maximumZ;
	    }
	    else {
	        return BoundingVolume._testAABBToSphere(this, bound);
	    }
	};

	/**
	 * @inheritDoc
	 */
	BoundingAABB.prototype.classifyAgainstPlane = function(plane)
	{
	    var planeX = plane.x, planeY = plane.y, planeZ = plane.z, planeW = plane.w;

	    var centerDist = planeX * this._center.x + planeY * this._center.y + planeZ * this._center.z + planeW;

	    if (planeX < 0) planeX = -planeX;
	    if (planeY < 0) planeY = -planeY;
	    if (planeZ < 0) planeZ = -planeZ;

	    var intersectionDist = planeX * this._halfExtentX + planeY * this._halfExtentY + planeZ * this._halfExtentZ;
	    // intersectionDist is the distance to the far point
	    // -intersectionDist is the distance to the closest point

	    if (centerDist > intersectionDist)
	        return PlaneSide.FRONT;
	    if (centerDist < -intersectionDist)
	        return PlaneSide.BACK;
	    else
	        return PlaneSide.INTERSECTING;
	};

	/**
	 * @ignore
	 */
	BoundingAABB.prototype.intersectsRay = function(ray)
	{
	    if (this._expanse === BoundingVolume.EXPANSE_INFINITE) return true;
	    if (this._expanse === BoundingVolume.EXPANSE_EMPTY || this._expanse === BoundingVolume.EXPANSE_INHERIT) return false;
	    // slab method
	    var o = ray.origin;
	    var d = ray.direction;
	    var oX = o.x, oY = o.y, oZ = o.z;
	    var dirX = d.x, dirY = d.y, dirZ = d.z;
	    var rcpDirX = 1.0 / dirX, rcpDirY = 1.0 / dirY, rcpDirZ = 1.0 / dirZ;

	    var nearT = -Infinity;
	    var farT = Infinity;

	    var t1, t2;

	    // t = (minX - oX) / dirX

	    if (dirX !== 0.0) {
	        t1 = (this._minimumX - oX) * rcpDirX;
	        t2 = (this._maximumX - oX) * rcpDirX;
	        // near is the closest intersection factor to the ray, far the furthest
	        // so [nearT - farT] is the line segment cut off by the planes
	        nearT = Math.min(t1, t2);
	        farT = Math.max(t1, t2);
	    }

	    if (dirY !== 0.0) {
	        t1 = (this._minimumY - oY) * rcpDirY;
	        t2 = (this._maximumY - oY) * rcpDirY;

	        // slice of more from the line segment [nearT - farT]
	        nearT = Math.max(nearT, Math.min(t1, t2));
	        farT = Math.min(farT, Math.max(t1, t2));
	    }

	    if (dirZ !== 0.0) {
	        t1 = (this._minimumZ - oZ) * rcpDirZ;
	        t2 = (this._maximumZ - oZ) * rcpDirZ;

	        nearT = Math.max(nearT, Math.min(t1, t2));
	        farT = Math.min(farT, Math.max(t1, t2));
	    }

	    return farT > 0 && farT >= nearT;
	};

	/**
	 * Sets the minimum and maximum explicitly using {@linkcode Float4}
	 */
	BoundingAABB.prototype.setExplicit = function(min, max)
	{
	    this._minimumX = min.x;
	    this._minimumY = min.y;
	    this._minimumZ = min.z;
	    this._maximumX = max.x;
	    this._maximumY = max.y;
	    this._maximumZ = max.z;
	    this._expanse = BoundingVolume.EXPANSE_FINITE;
	    this._updateCenterAndExtent();
	};

	/**
	 * @ignore
	 * @private
	 */
	BoundingAABB.prototype._updateCenterAndExtent = function()
	{
	    var minX = this._minimumX, minY = this._minimumY, minZ = this._minimumZ;
	    var maxX = this._maximumX, maxY = this._maximumY, maxZ = this._maximumZ;
	    this._center.x = (minX + maxX) * .5;
	    this._center.y = (minY + maxY) * .5;
	    this._center.z = (minZ + maxZ) * .5;
	    this._halfExtentX = (maxX - minX) * .5;
	    this._halfExtentY = (maxY - minY) * .5;
	    this._halfExtentZ = (maxZ - minZ) * .5;
	};

	/**
	 * @inheritDoc
	 */
	BoundingAABB.prototype.getRadius = function()
	{
	    return Math.sqrt(this._halfExtentX * this._halfExtentX + this._halfExtentY * this._halfExtentY + this._halfExtentZ * this._halfExtentZ);
	};

	BoundingAABB.prototype.getHalfExtents = function()
	{
	    return new Float4(this._halfExtentX, this._halfExtentY, this._halfExtentZ, 0.0);
	};

	BoundingAABB.prototype.clone = function()
	{
	    var aabb = new BoundingAABB();
	    aabb.growToIncludeBound(this);
	    return aabb;
	};

	/**
	 * @classdesc
	 * MorphTarget defines the displacements per vertex that can be used to displace a Mesh. This can be used to animate
	 * vertices between different poses. Several MorphTargets can be used in a {@linkcode MorphPose} or through a component
	 * such as {@linkcode MorphAnimation}
	 * A MorphTarget describes the offsets for a whole {@linkcode Model}, so several sets might be present (one for each {@linkcode Mesh}).
	 *
	 * @constructor
	 *
	 * @see {@linkcode MorphAnimation}
	 * @see {@linkcode MorphPose}
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function MorphTarget()
	{
	    this.name = null;
	    this._positionBuffer = null;
	    this._normalBuffer = null;
	    this._numVertices = 0;
	}

	MorphTarget.prototype =
	{
	    /**
	     * Indicates whether or not vertex normals are provided in the morph target initialisation.
	     * @returns {boolean|*}
	     */
	    get hasNormals()
	    {
	        return !!this._normalBuffer;
	    },

	    /**
	     * @ignore
	     */
	    get numVertices()
	    {
	        return this._numVertices;
	    },

	    /**
	     * @ignore
	     */
	    get positionBuffer()
	    {
	        return this._positionBuffer;
	    },

	    /**
	     * @ignore
	     */
	    get normalBuffer()
	    {
	        return this._normalBuffer;
	    },

	    /**
	     * Initializes the current MorphTarget object.
	     * @param {Array} positions An Array of 3 floats per vertex (x, y, z), containing the displacement vectors. The size must match the vertex count of the target Mesh.
	     * @param {Array} normals An Array of 3 floats per vertex (x, y, z), containing the normal offset vectors. The size must match the vertex count of the target Mesh.
	     *
	     */
	    init: function(positions, normals)
	    {
	        this._numVertices = positions.length / 3;

	        this._positionBuffer = new VertexBuffer();
	        this._positionBuffer.uploadData(new Float32Array(positions));

	        if (normals) {
	            this._normalBuffer = new VertexBuffer();
	            this._normalBuffer.uploadData(new Float32Array(normals));
	        }
	    }
	};

	/**
	 * @ignore
	 */
	var MESH_ID_COUNTER = 0;

	/**
	 * @classdesc
	 *
	 * <p>Mesh contains the geometry of a renderable object. A {@linkcode MeshInstance} component is used to combine a Mesh
	 * with a Material for rendering.
	 *
	 * <p>A Mesh can have vertex attributes spread out over several "streams". Every stream means a separate vertex buffer will be used.</p>
	 *
	 * <p>A Mesh should have its layout defined using addVertexAttribute, and initial data supplied using setVertexData,
	 * before passing it on to a Model. These values will be used to calculate its local bounding box.
	 * After this, setVertexData can be called to change data, but it will not change the model</p>
	 *
	 * @param {BufferUsage} vertexUsage A usage hint for the vertex buffer.
	 * @param {BufferUsage} indexUsage A usage hint for the index buffer.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Mesh()
	{
	    this.onBoundsChanged = new Signal();
	    this.onLayoutChanged = new Signal();
	    this.onMorphDataCreated = new Signal();
		this.onSkeletonChange = new Signal();
		this._name = "hx_mesh_" + MESH_ID_COUNTER;
		this._bounds = new BoundingAABB();
		this._boundsInvalid = true;
		this._dynamicBounds = true;
	    this._vertexBuffers = [];
	    this._vertexStrides = [];
	    this._vertexData = [];
	    this._indexData = undefined;
	    this._vertexUsage = BufferUsage.STATIC_DRAW;
	    this._indexUsage = BufferUsage.STATIC_DRAW;
	    this._numStreams = 0;
	    this._numVertices = 0;

	    this._vertexAttributes = [];
	    this._vertexAttributesLookUp = {};
	    this._indexBuffer = new IndexBuffer();

	    this._morphTargets = {};
		this._hasMorphNormals = false;
		this._defaultMorphTarget = null;

		this._skeleton = null;

	    this._renderOrderHint = ++MESH_ID_COUNTER;
	}

	/**
	 * The vertex stride for meshes created with {@linkcode Mesh#createDefaultEmpty}
	 */
	Mesh.DEFAULT_VERTEX_SIZE = 12;

	/**
	 * @ignore
	 */
	Mesh.ID_COUNTER = 0;

	// other possible indices:
	// hx_instanceID (used by MeshBatch)
	// hx_jointIndices (4)
	// hx_jointWeights (4)
	/**
	 * Creates an empty Mesh with a default layout.
	 */
	Mesh.createDefaultEmpty = function(target)
	{
		target = target || new Mesh();
		target.addVertexAttribute("hx_position", 3);
		target.addVertexAttribute("hx_normal", 3);
		target.addVertexAttribute("hx_tangent", 4);
		target.addVertexAttribute("hx_texCoord", 2);
	    return target;
	};


	Mesh.prototype = {
		/**
		 * The object-space bounding volume. Setting this value only changes the type of volume.
		 */
		get bounds()
		{
			if (this._boundsInvalid) this._updateBounds();
			return this._bounds;
		},

		set bounds(value)
		{
			this._bounds = value;
			this._invalidateBounds();
		},

		/**
		 * The object-space bounding volume. Setting this value only changes the type of volume.
		 */
		get dynamicBounds()
		{
			return this._dynamicBounds;
		},

		set dynamicBounds(value)
		{
			if (value === this._dynamicBounds)
				return;

			this._dynamicBounds = value;

			if (value)
				this._invalidateBounds();
			else
				this._boundsInvalid = false;
		},

		/**
		 * The {@linkcode Skeleton} used for skinning animations.
		 */
		get skeleton()
		{
			return this._skeleton;
		},

		set skeleton(value)
		{
			this._skeleton = value;
			this.onSkeletonChange.dispatch();
		},

	    /**
	     * Whether or not this Mesh supports morph target animations. This is the case if {@linkcode Mesh#generateMorphData}
	     * was called.
	     */
	    get hasMorphData()
	    {
	        return !!this._defaultMorphTarget;
	    },

	    get hasMorphNormals()
	    {
	        return this._hasMorphNormals;
	    },

	    /**
	     * Returns whether or not vertex data was uploaded to the given stream index.
	     */
	    hasVertexData: function (streamIndex)
	    {
	        return !!this._vertexData[streamIndex];
	    },

	    /**
	     * Gets the vertex data for a given stream.
	     */
	    getVertexData: function (streamIndex)
	    {
	        return this._vertexData[streamIndex];
	    },

	    /**
	     * Uploads vertex data from an Array or a Float32Array. This method must be called after the layout for the stream
	     * has been finalized using setVertexAttribute calls. The data in the stream should be an interleaved array of
	     * floats, with each attribute data in the order specified with the setVertexAttribute calls.
	     */
	    setVertexData: function (data, streamIndex, usageHint)
	    {
	        streamIndex = streamIndex || 0;

	        this._vertexUsage = usageHint || BufferUsage.STATIC_DRAW;

	        this._vertexData[streamIndex] = data instanceof Float32Array? data : new Float32Array(data);
	        this._vertexBuffers[streamIndex] = this._vertexBuffers[streamIndex] || new VertexBuffer();
	        this._vertexBuffers[streamIndex].uploadData(this._vertexData[streamIndex], this._vertexUsage);

	        if (streamIndex === 0)
	            this._numVertices = data.length / this._vertexStrides[0];

			this._invalidateBounds();
	    },

	    /**
	     * Returns the index data uploaded to the index buffer.
	     */
	    getIndexData: function()
	    {
	        return this._indexData;
	    },

	    /**
	     * Uploads index data from an Array or a Uint16Array
	     */
	    setIndexData: function (data, usageHint)
	    {
	        this._indexUsage = usageHint || BufferUsage.STATIC_DRAW;

	        if (data instanceof Uint16Array) {
	            this._indexData = data;
	            this._indexType = DataType.UNSIGNED_SHORT;
	        }
	        else if (data instanceof Uint32Array) {
	            this._indexData = data;
	            this._indexType = DataType.UNSIGNED_INT;
	        }
	        else {
	            this._indexData = new Uint16Array(data);
	            this._indexType = DataType.UNSIGNED_SHORT;
	        }
	        this._numIndices = this._indexData.length;
	        this._indexBuffer.uploadData(this._indexData, this._indexUsage);
	    },

	    /**
	     * Adds a named vertex attribute. All properties are given manually to make it easier to support multiple streams in the future.
	     * @param name The name of the attribute, matching the attribute name used in the vertex shaders.
	     * @param numComponents The amount of components used by the attribute value.
	     * @param streamIndex [Optional] The stream index indicating which vertex buffer is used, defaults to 0
	     */
	    addVertexAttribute: function (name, numComponents, streamIndex)
	    {
	        streamIndex = streamIndex || 0;
	        this._numStreams = Math.max(this._numStreams, streamIndex + 1);
	        var offset = this._vertexStrides[streamIndex] || 0;
	        var attrib = {
	            name: name,
	            offset: offset,
	            numComponents: numComponents,
	            streamIndex: streamIndex
	        };
	        this._vertexAttributes.push(attrib);
	        this._vertexAttributesLookUp[name] = attrib;

	        this._vertexStrides[streamIndex] = offset + numComponents;

	        this.onLayoutChanged.dispatch();
	    },

	    /**
	     * The amount of streams (vertex buffers) used for this Mesh/
	     */
	    get numStreams()
	    {
	        return this._numStreams;
	    },

	    /**
	     * Extracts the vertex attribute data for the given attribute name as a flat Array.
	     */
	    extractAttributeData: function(name)
	    {
	        var attrib = this.getVertexAttributeByName(name);
	        var stride = this.getVertexStride(attrib);
	        var data = this.getVertexData(attrib.streamIndex);
	        var numComps = attrib.numComponents;
	        var vertData = [];
	        var t = 0;
	        for (var i = attrib.offset; i < data.length; i += stride) {
	            for (var j = 0; j < numComps; ++j) {
	                vertData[t++] = data[i + j];
	            }
	        }
	        return vertData;
	    },

	    /**
	     * Generates the required data to support morph target animations.
	     */
	    generateMorphData: function(supportNormals)
	    {
	        var count;

	        if (supportNormals) {
	            this._hasMorphNormals = true;
	            count = 4;
	        }
	        else {
	            count = 8;
	        }

	        for (i = 0; i < count; ++i) {
	            // these will never have data assigned to them!
	            // append these each as a different stream
	            this.addVertexAttribute("hx_morphPosition" + i, 3, this._numStreams);

	            if (supportNormals)
	                this.addVertexAttribute("hx_morphNormal" + i, 3, this._numStreams);
	        }

	        var data = [];

	        for (var i = 0; i < this._numVertices; ++i) {
	            data.push(0, 0, 0);
	        }

	        // this is used for both positions and normals (if needed)
	        this._defaultMorphTarget = new VertexBuffer();
	        this._defaultMorphTarget.uploadData(new Float32Array(data), BufferUsage.STATIC_DRAW);

			this.onMorphDataCreated.dispatch();
			this.onLayoutChanged.dispatch();
	    },

	    /**
	     * The amount of vertices contained in the Mesh.
	     */
	    get numVertices()
	    {
	        return this._numVertices;
	    },

	    /**
	     * The amount of face indices contained in the Mesh.
	     */
	    get numIndices()
	    {
	        return this._numIndices;
	    },

	    /**
	     * The amount of vertex attributes contained in the Mesh.
	     */
	    get numVertexAttributes()
	    {
	        return this._vertexAttributes.length;
	    },

	    /**
	     * Gets the vertex stride (number of components used per stream per vertex) for a given stream
	     */
	    getVertexStride: function(streamIndex)
	    {
	        return this._vertexStrides[streamIndex];
	    },

	    /**
	     * Gets the vertex attribute data according to the attribute name.
	     */
	    getVertexAttributeByName: function (name)
	    {
	        return this._vertexAttributesLookUp[name];
	    },

	    /**
	     * Gets the vertex attribute data according to the index.
	     */
	    getVertexAttributeByIndex: function (index)
	    {
	        return this._vertexAttributes[index];
	    },

		/**
		 * Adds a MorphTarget object for animators to work with.
		 */
	    addMorphTarget: function(morphTarget)
		{
			this._morphTargets[morphTarget.name] = morphTarget;

			if (!this._defaultMorphTarget)
			    this.generateMorphData();
		},

		/**
		 * Adds a MorphTarget object for animators to work with.
		 */
	    removeMorphTarget: function(morphTarget)
		{
			delete this._morphTargets[morphTarget.name];
		},

		/**
		 * Gets the morph target by name.
		 * @param {name} index The name of the {@linkcode MorphTarget}
		 * @returns {MorphTarget}
		 */
		getMorphTarget: function(name)
		{
			return this._morphTargets[name];
		},

	    /**
	     * Returns a duplicate of this Mesh.
	     */
	    clone: function()
	    {
	        var mesh = new Mesh();
	        var numAttribs = this._vertexAttributes.length;

	        for (var i = 0; i < numAttribs; ++i) {
	            var attrib = this._vertexAttributes[i];
	            mesh.addVertexAttribute(attrib.name, attrib.numComponents, attrib.streamIndex);
	        }

	        for (i = 0; i < this._numStreams; ++i) {
	            if (this._vertexData[i])
	                mesh.setVertexData(this._vertexData[i], i, this._vertexUsage);
	        }

	        if (this._indexData)
	            mesh.setIndexData(this._indexData, this._indexUsage);

	        return mesh;
	    },

	    translate: function(x, y, z)
	    {
	        if (x instanceof Float4) {
	            y = x.y;
	            z = x.z;
	            x = x.x;
	        }

	        var attrib = this.getVertexAttributeByName("hx_position");
	        if (!attrib) return;

	        var stride = this.getVertexStride(attrib);
	        var data = this.getVertexData(attrib.streamIndex);
	        for (var i = attrib.offset; i < data.length; i += stride) {
	            data[i] += x;
	            data[i + 1] += x;
	            data[i + 2] += x;
	        }

	        this._vertexBuffers[attrib.streamIndex].uploadData(this._vertexData[attrib.streamIndex], this._vertexUsage);
	    },

		/**
		 * @ignore
		 * @private
		 */
		_updateBounds: function()
		{
			this._bounds.clear();
			this._bounds.growToIncludeMesh(this);
			this._boundsInvalid = false;
		},

		/**
	     * @ignore
		 * @private
		 */
		_invalidateBounds: function()
	    {
	    	if (this._dynamicBounds) {
				this._boundsInvalid = true;
				this.onBoundsChanged.dispatch();
			}
	    }
	};

	/**
	 * RectMesh is a util that allows creating Mesh objects for rendering 2D quads. Generally, use RectMesh.DEFAULT for
	 * full-screen quads.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var RectMesh = {
	    create: function()
	    {
	        var mesh = new Mesh();
	        mesh.addVertexAttribute("hx_position", 2);
	        mesh.addVertexAttribute("hx_texCoord", 2);
	        mesh.setVertexData([-1, 1, 0, 1,
	            1, 1, 1, 1,
	            1, -1, 1, 0,
	            -1, -1, 0, 0], 0);
	        mesh.setIndexData([0, 1, 2, 0, 2, 3]);
	        return mesh;
	    },

	    _initDefault: function()
	    {
	        RectMesh.DEFAULT = RectMesh.create();
	    }
	};

	/**
	 * @ignore
	 * @author derschmale <http://www.derschmale.com>
	 */
	var TextureUtils =
	{
	    /**
	     * Resizes a texture (empty) if its size doesn't match. Returns true if the size has changed.
	     * @param width The target width
	     * @param height The target height
	     * @param texture The texture to be resized if necessary
	     * @param fbo (optional) Any fbos to be reinitialized if necessary
	     * @returns {boolean} Returns true if the texture has been resized, false otherwise.
	     */
	    assureSize: function(width, height, texture, fbo, format, dataType)
	    {
	        if (width === texture.width && height === texture.height)
	            return false;

	        texture.initEmpty(width, height, format, dataType);
	        if (fbo) fbo.init();
	        return true;
	    },

	    /**
	     * Copies a texture into a Framebuffer.
	     * @param sourceTexture The source texture to be copied.
	     * @param destFBO The target FBO to copy into.
	     */
	    copy: function(sourceTexture, destFBO)
	    {
	        GL.setRenderTarget(destFBO);
	        GL.clear();
	        DEFAULTS.COPY_SHADER.execute(RectMesh.DEFAULT, sourceTexture);
	        GL.setRenderTarget(null);
	    },

	    // ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript
	    encodeHalfFloat: function(val) {

	        var floatView = new Float32Array(1);
	        var int32View = new Int32Array(floatView.buffer);

	        /* This method is faster than the OpenEXR implementation (very often
	         * used, eg. in Ogre), with the additional benefit of rounding, inspired
	         * by James Tursa?s half-precision code. */
	        return function toHalf(val) {

	            floatView[0] = val;
	            var x = int32View[0];

	            var bits = (x >> 16) & 0x8000; /* Get the sign */
	            var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
	            var e = (x >> 23) & 0xff; /* Using int is faster here */

	            /* If zero, or denormal, or exponent underflows too much for a denormal
	             * half, return signed zero. */
	            if (e < 103) {
	                return bits;
	            }

	            /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
	            if (e > 142) {
	                bits |= 0x7c00;
	                /* If exponent was 0xff and one mantissa bit was set, it means NaN,
	                 * not Inf, so make sure we set one mantissa bit too. */
	                bits |= ((e === 255) ? 0 : 1) && (x & 0x007fffff);
	                return bits;
	            }

	            /* If exponent underflows but not too much, return a denormal */
	            if (e < 113) {
	                m |= 0x0800;
	                /* Extra rounding may overflow and set mantissa to 0 and exponent
	                 * to 1, which is OK. */
	                bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
	                return bits;
	            }

	            bits |= ((e - 112) << 10) | (m >> 1);
	            /* Extra rounding. An overflow will set mantissa to 0 and increment
	             * the exponent, which is OK. */
	            bits += m & 1;
	            return bits;
	        };
	    }(),

	    encodeToFloat16Array: function(float32Array)
	    {
	        var encFun = TextureUtils.encodeHalfFloat;
	        var arr = [];
	        for (var i = 0; i < float32Array.length; ++i) {
	            arr[i] = encFun(float32Array[i]);
	        }
	        return new Uint16Array(arr);
	    }
	};

	var nameCounter = 0;

	/**
	 * @classdesc
	 * Texture2D represents a 2D texture.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Texture2D()
	{
	    this._name = "hx_texture2d_" + (nameCounter++);
	    this._default = Texture2D.DEFAULT;
	    this._texture = GL.gl.createTexture();
	    this._width = 0;
	    this._height = 0;
	    this._format = null;
	    this._dataType = null;

	    this.bind();

	    // set defaults
	    this.maxAnisotropy = capabilities.DEFAULT_TEXTURE_MAX_ANISOTROPY;
	    this.filter = TextureFilter.DEFAULT;
	    this.wrapMode = TextureWrapMode.DEFAULT;

	    this._isReady = false;

	    GL.gl.bindTexture(GL.gl.TEXTURE_2D, null);
	}

	/**
	 * @ignore
	 */
	Texture2D._initDefault = function()
	{
	    var data = new Uint8Array([0xff, 0x00, 0xff, 0xff]);
	    Texture2D.DEFAULT = new Texture2D();
	    Texture2D.DEFAULT.uploadData(data, 1, 1, true);
	    Texture2D.DEFAULT.filter = TextureFilter.NEAREST_NOMIP;
	};

	Texture2D.prototype =
	{
	    /**
	     * The name of the texture.
	     */
	    get name()
	    {
	        return this._name;
	    },

	    set name(value)
	    {
	        this._name = value;
	    },

	    /**
	     * Generates a mip map chain.
	     */
	    generateMipmap: function()
	    {
	        var gl = GL.gl;

	        this.bind();

	        gl.generateMipmap(gl.TEXTURE_2D);
	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    /**
	     * A {@linkcode TextureFilter} object defining how the texture should be filtered during sampling.
	     */
	    get filter()
	    {
	        return this._filter;
	    },

	    set filter(filter)
	    {
	        var gl = GL.gl;
	        this._filter = filter;
	        this.bind();
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter.min);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter.mag);
	        gl.bindTexture(gl.TEXTURE_2D, null);

	        if (filter === TextureFilter.NEAREST_NOMIP || filter === TextureFilter.NEAREST) {
	            this.maxAnisotropy = 1;
	        }
	    },

	    /**
	     * A {@linkcode TextureWrapMode} object defining how out-of-bounds sampling should be handled.
	     */
	    get wrapMode()
	    {
	        return this._wrapMode;
	    },

	    set wrapMode(mode)
	    {
	        var gl = GL.gl;
	        this._wrapMode = mode;
	        this.bind();
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, mode.s);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, mode.t);
	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    /**
	     * The maximum anisotropy used when sampling. Limited to {@linkcode capabilities#DEFAULT_TEXTURE_MAX_ANISOTROPY}
	     */
	    get maxAnisotropy()
	    {
	        return this._maxAnisotropy;
	    },

	    set maxAnisotropy(value)
	    {
	        var gl = GL.gl;

	        if (value > capabilities.DEFAULT_TEXTURE_MAX_ANISOTROPY)
	            value = capabilities.DEFAULT_TEXTURE_MAX_ANISOTROPY;

	        this._maxAnisotropy = value;

	        this.bind();
	        if (capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC)
	            GL.gl.texParameteri(gl.TEXTURE_2D, capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC.TEXTURE_MAX_ANISOTROPY_EXT, value);
	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    /**
	     * The texture's width
	     */
	    get width() { return this._width; },

	    /**
	     * The texture's height
	     */
	    get height() { return this._height; },

	    /**
	     * The texture's format
	     *
	     * @see {@linkcode TextureFormat}
	     */
	    get format() { return this._format; },

	    /**
	     * The texture's data type
	     *
	     * @see {@linkcode DataType}
	     */
	    get dataType() { return this._dataType; },

	    /**
	     * Inits an empty texture.
	     * @param width The width of the texture.
	     * @param height The height of the texture.
	     * @param {TextureFormat} format The texture's format.
	     * @param {DataType} dataType The texture's data format.
	     */
	    initEmpty: function(width, height, format, dataType)
	    {
	        var gl = GL.gl;
	        this._format = format = format || TextureFormat.RGBA;
	        this._dataType = dataType = dataType || DataType.UNSIGNED_BYTE;

	        this.bind();
	        this._width = width;
	        this._height = height;

			var internalFormat = TextureFormat.getDefaultInternalFormat(format, dataType);
	        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, dataType, null);

	        this._isReady = true;

	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    /**
	     * Initializes the texture with the given data.
	     * @param {*} data An typed array containing the initial data.
	     * @param {number} width The width of the texture.
	     * @param {number} height The height of the texture.
	     * @param {boolean} generateMips Whether or not a mip chain should be generated.
	     * @param {TextureFormat} format The texture's format.
	     * @param {DataType} dataType The texture's data format.
	     */
	    uploadData: function(data, width, height, generateMips, format, dataType)
	    {
	        var gl = GL.gl;

	        if (capabilities.EXT_HALF_FLOAT_TEXTURES && dataType === DataType.HALF_FLOAT)
	            data = TextureUtils.encodeToFloat16Array(data);

	        this._width = width;
	        this._height = height;

	        this._format = format = format || TextureFormat.RGBA;
	        this._dataType = dataType = dataType || DataType.UNSIGNED_BYTE;
	        generateMips = generateMips === undefined? false: generateMips;

	        this.bind();

	        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);

	        var internalFormat = TextureFormat.getDefaultInternalFormat(format, dataType);
	        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, dataType, data);

	        if (generateMips)
	            gl.generateMipmap(gl.TEXTURE_2D);

	        this._isReady = true;

	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    /**
	     * Initializes the texture with a given Image.
	     * @param image The Image to upload to the texture
	     * @param width The width of the texture.
	     * @param height The height of the texture.
	     * @param generateMips Whether or not a mip chain should be generated.
	     * @param {TextureFormat} format The texture's format.
	     * @param {DataType} dataType The texture's data format.
	     *
	     * TODO: Just use image.naturalWidth / image.naturalHeight ?
	     */
	    uploadImage: function(image, width, height, generateMips, format, dataType)
	    {
	        var gl = GL.gl;

	        this._width = width;
	        this._height = height;

	        this._format = format = format || TextureFormat.RGBA;
	        this._dataType = dataType = dataType || DataType.UNSIGNED_BYTE;
	        generateMips = generateMips === undefined? true: generateMips;

	        this.bind();

	        if (image)
	            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);

			var internalFormat = TextureFormat.getDefaultInternalFormat(format, dataType);
	        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, format, dataType, image);

	        if (generateMips)
	            gl.generateMipmap(gl.TEXTURE_2D);

	        this._isReady = true;

	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    /**
	     * Defines whether data has been uploaded to the texture or not.
	     */
	    isReady: function() { return this._isReady; },

	    /**
	     * Binds a texture to a given texture unit.
	     * @ignore
	     */
	    bind: function(unitIndex)
	    {
	        var gl = GL.gl;

	        if (unitIndex !== undefined) {
	            gl.activeTexture(gl.TEXTURE0 + unitIndex);
	        }

	        gl.bindTexture(gl.TEXTURE_2D, this._texture);
	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        return "[Texture2D(name=" + this._name + ")]";
	    }
	};

	var nameCounter$1 = 0;

	//       +-----+
	//       |  +Z |
	// +-----+-----+-----+-----+
	// |  -X |  +Y |  +X |  -Y |
	// +-----+-----+-----+-----+
	//       |  -Z |
	//       +-----+

	/**
	 * @classdesc
	 * TextureCube represents a cube map texture. The order of the textures in a cross map is as such:
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function TextureCube()
	{
		this._name = "hx_texturecube_" + (nameCounter$1++);
	    this._default = TextureCube.DEFAULT;
	    this._texture = GL.gl.createTexture();
	    this._size = 0;
	    this._format = null;
	    this._dataType = null;

	    this.bind();
	    this.filter = TextureFilter.DEFAULT;
	    this.maxAnisotropy = capabilities.DEFAULT_TEXTURE_MAX_ANISOTROPY;

	    this._isReady = false;
	}

	/**
	 * @ignore
	 */
	TextureCube._initDefault = function()
	{
	    var gl = GL.gl;
	    var data = new Uint8Array([0xff, 0x00, 0xff, 0xff]);
	    TextureCube.DEFAULT = new TextureCube();
	    TextureCube.DEFAULT.uploadData([data, data, data, data, data, data], 1, true);
	    TextureCube.DEFAULT.filter = TextureFilter.NEAREST_NOMIP;
	    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	};

	TextureCube.prototype =
	{
	    /**
	     * The name of the texture.
	     */
	    get name()
	    {
	        return this._name;
	    },

	    set name(value)
	    {
	        this._name = value;
	    },

	    /**
	     * Generates a mip map chain.
	     */
	    generateMipmap: function()
	    {
	        this.bind();
	        var gl = GL.gl;
	        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	    },

	    /**
	     * A {@linkcode TextureFilter} object defining how the texture should be filtered during sampling.
	     */
	    get filter()
	    {
	        return this._filter;
	    },

	    set filter(filter)
	    {
	        this._filter = filter;
	        this.bind();
	        var gl = GL.gl;
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filter.min);
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filter.mag);
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	    },

	    /**
	     * The maximum anisotropy used when sampling. Limited to {@linkcode capabilities#DEFAULT_TEXTURE_MAX_ANISOTROPY}
	     */
	    get maxAnisotropy()
	    {
	        return this._maxAnisotropy;
	    },

	    set maxAnisotropy(value)
	    {
	        if (value > capabilities.DEFAULT_TEXTURE_MAX_ANISOTROPY)
	            value = capabilities.DEFAULT_TEXTURE_MAX_ANISOTROPY;

	        this._maxAnisotropy = value;

	        this.bind();

	        var gl = GL.gl;
	        if (capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC)
	            gl.texParameteri(gl.TEXTURE_CUBE_MAP, capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC.TEXTURE_MAX_ANISOTROPY_EXT, value);
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	    },

	    /**
	     * The cube texture's size
	     */
	    get size() { return this._size; },

	    /**
	     * The texture's format
	     *
	     * @see {@linkcode TextureFormat}
	     */
	    get format() { return this._format; },

	    /**
	     * The texture's data type
	     *
	     * @see {@linkcode DataType}
	     */
	    get dataType() { return this._dataType; },

	    /**
	     * Inits an empty texture.
	     * @param size The size of the texture.
	     * @param {TextureFormat} format The texture's format.
	     * @param {DataType} dataType The texture's data format.
	     */
	    initEmpty: function(size, format, dataType)
	    {
	        this._format = format = format || TextureFormat.RGBA;
	        this._dataType = dataType = dataType || DataType.UNSIGNED_BYTE;

	        this._size = size;

	        this.bind();

	        var gl = GL.gl;
			var internalFormat = TextureFormat.getDefaultInternalFormat(format, dataType);
			gl.texImage2D(CubeFace.POSITIVE_X, 0, internalFormat, size, size, 0, format, dataType, null);
	        gl.texImage2D(CubeFace.NEGATIVE_X, 0, internalFormat, size, size, 0, format, dataType, null);
	        gl.texImage2D(CubeFace.POSITIVE_Y, 0, internalFormat, size, size, 0, format, dataType, null);
	        gl.texImage2D(CubeFace.NEGATIVE_Y, 0, internalFormat, size, size, 0, format, dataType, null);
	        gl.texImage2D(CubeFace.POSITIVE_Z, 0, internalFormat, size, size, 0, format, dataType, null);
	        gl.texImage2D(CubeFace.NEGATIVE_Z, 0, internalFormat, size, size, 0, format, dataType, null);

	        this._isReady = true;

	        gl.bindTexture(gl.TEXTURE_2D, null);
	    },

	    /**
	     * Initializes the texture with the given data.
	     * @param data A array of typed arrays (per {@linkcode CubeFace}) containing the initial data.
	     * @param size The size of the texture.
	     * @param generateMips Whether or not a mip chain should be generated.
	     * @param {TextureFormat} format The texture's format.
	     * @param {DataType} dataType The texture's data format.
	     */
	    uploadData: function(data, size, generateMips, format, dataType)
	    {
	        this._size = size;

	        this._format = format = format || TextureFormat.RGBA;
	        this._dataType = dataType = dataType || DataType.UNSIGNED_BYTE;
	        generateMips = generateMips === undefined? true: generateMips;

	        this.bind();

	        var gl = GL.gl;
	        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);

			var internalFormat = TextureFormat.getDefaultInternalFormat(format, dataType);
	        gl.texImage2D(CubeFace.POSITIVE_X, 0, internalFormat, size, size, 0, format, dataType, data[0]);
	        gl.texImage2D(CubeFace.NEGATIVE_X, 0, internalFormat, size, size, 0, format, dataType, data[1]);
	        gl.texImage2D(CubeFace.POSITIVE_Y, 0, internalFormat, size, size, 0, format, dataType, data[2]);
	        gl.texImage2D(CubeFace.NEGATIVE_Y, 0, internalFormat, size, size, 0, format, dataType, data[3]);
	        gl.texImage2D(CubeFace.POSITIVE_Z, 0, internalFormat, size, size, 0, format, dataType, data[4]);
	        gl.texImage2D(CubeFace.NEGATIVE_Z, 0, internalFormat, size, size, 0, format, dataType, data[5]);

	        if (generateMips)
	            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

	        this._isReady = true;

	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	    },

	    /**
	     * Initializes the texture with the given Images.
	     * @param data A array of typed arrays (per {@linkcode CubeFace}) containing the initial data.
	     * @param generateMips Whether or not a mip chain should be generated.
	     * @param {TextureFormat} format The texture's format.
	     * @param {DataType} dataType The texture's data format.
	     */
	    uploadImages: function(images, generateMips, format, dataType)
	    {
	        generateMips = generateMips === undefined? true: generateMips;

	        this._format = format;
	        this._dataType = dataType;

	        this.uploadImagesToMipLevel(images, 0, format, dataType);

	        var gl = GL.gl;
	        if (generateMips) {
	            this.bind();
	            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
	        }

	        this._isReady = true;

	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	    },

	    /**
	     * Initializes a miplevel with the given Images.
	     * @param data A array of typed arrays (per {@linkcode CubeFace}) containing the initial data.
	     * @param mipLevel The mip-level to initialize.
	     * @param {TextureFormat} format The texture's format.
	     * @param {DataType} dataType The texture's data format.
	     */
	    uploadImagesToMipLevel: function(images, mipLevel, format, dataType)
	    {
	        var gl = GL.gl;
	        this._format = format = format || TextureFormat.RGBA;
	        this._dataType = dataType = dataType || DataType.UNSIGNED_BYTE;

	        if (mipLevel === 0)
	            this._size = images[0].naturalWidth;

	        this.bind();

	        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);

			var internalFormat = TextureFormat.getDefaultInternalFormat(format, dataType);
	        gl.texImage2D(CubeFace.POSITIVE_X, mipLevel, internalFormat, format, dataType, images[0]);
	        gl.texImage2D(CubeFace.NEGATIVE_X, mipLevel, internalFormat, format, dataType, images[1]);
	        gl.texImage2D(CubeFace.POSITIVE_Y, mipLevel, internalFormat, format, dataType, images[2]);
	        gl.texImage2D(CubeFace.NEGATIVE_Y, mipLevel, internalFormat, format, dataType, images[3]);
	        gl.texImage2D(CubeFace.POSITIVE_Z, mipLevel, internalFormat, format, dataType, images[4]);
	        gl.texImage2D(CubeFace.NEGATIVE_Z, mipLevel, internalFormat, format, dataType, images[5]);

	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	    },

	    /**
	     * Defines whether data has been uploaded to the texture or not.
	     */
	    isReady: function() { return this._isReady; },

	    /**
	     * Binds a texture to a given texture unit.
	     * @ignore
	     */
	    bind: function(unitIndex)
	    {
	        var gl = GL.gl;

	        if (unitIndex !== undefined)
	            gl.activeTexture(gl.TEXTURE0 + unitIndex);

	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._texture);
	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        return "[TextureCube(name=" + this._name + ")]";
	    }
	};

	/**
	 * @classdesc
	 * BlendState defines the blend mode the renderer should use. Default presets include BlendState.ALPHA, BlendState.ADD
	 * and BlendState.MULTIPLY.
	 *
	 * @param srcFactor The source blend factor.
	 * @param dstFactor The destination blend factor.
	 * @param operator The blend operator.
	 * @param color The blend color.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function BlendState(srcFactor, dstFactor, operator, color)
	{
	    /**
	     * Defines whether blending is enabled.
	     */
	    this.enabled = true;

	    /**
	     * The source blend factor.
	     * @see {@linkcode BlendFactor}
	     */
	    this.srcFactor = srcFactor || BlendFactor.ONE;

	    /**
	     * The destination blend factor.
	     * @see {@linkcode BlendFactor}
	     */
	    this.dstFactor = dstFactor || BlendFactor.ZERO;

	    /**
	     * The blend operator.
	     * @see {@linkcode BlendOperation}
	     */
	    this.operator = operator || BlendOperation.ADD;

	    /**
	     * The source blend factor for the alpha.
	     * @see {@linkcode BlendFactor}
	     */
	    this.alphaSrcFactor = null;

	    /**
	     * The source blend factor for the alpha.
	     * @see {@linkcode BlendFactor}
	     */
	    this.alphaDstFactor = null;

	    /**
	     * The blend operator for the alpha.
	     * @see {@linkcode BlendOperation}
	     */
	    this.alphaOperator = null;

	    /**
	     * The blend color.
	     * @see {@linkcode Color}
	     */
	    this.color = color || null;
	}

	BlendState.prototype = {
	    /**
	     * Creates a copy of this BlendState.
	     */
	    clone: function() {
	        return new BlendState(this.srcFactor, this.dstFactor, this.operator, this.color);
	    }
	};

	BlendState._initDefaults = function()
	{
	    BlendState.ADD = new BlendState(BlendFactor.SOURCE_ALPHA, BlendFactor.ONE);
	    BlendState.ADD_NO_ALPHA = new BlendState(BlendFactor.ONE, BlendFactor.ONE);
	    BlendState.MULTIPLY = new BlendState(BlendFactor.DESTINATION_COLOR, BlendFactor.ZERO);
	    BlendState.ALPHA = new BlendState(BlendFactor.SOURCE_ALPHA, BlendFactor.ONE_MINUS_SOURCE_ALPHA);
	    BlendState.ALPHA.alphaSrcFactor = BlendFactor.ONE;
	    BlendState.ALPHA.alphaDstFactor = BlendFactor.ONE_MINUS_SOURCE_ALPHA;
	    BlendState.INV_ALPHA = new BlendState(BlendFactor.ONE_MINUS_SOURCE_ALPHA, BlendFactor.SOURCE_ALPHA);
	};

	/**
	 * @classdesc
	 * FrameBuffer provides a render target associated with a given texture/textures.
	 *
	 * @param colorTextures Either a single texture, or an Array of textures (only if {@linkcode capabilities#EXT_DRAW_BUFFERS} is supported).
	 * @param depthBuffer An optional depth buffer. This can be a {@linkcode WriteOnlyDepthBuffer} or, if readback is required, a {@linkcode Texture2D} (only available if {@linkcode capabilities#EXT_DEPTH_TEXTURE} is supported).
	 * @param cubeFace If colorTextures is a {@linkcode TextureCube}, cubeFace should contain the relevant {@linkcode CubeFace}.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function FrameBuffer(colorTextures, depthBuffer, cubeFace)
	{
	    if (colorTextures && colorTextures[0] === undefined) colorTextures = [ colorTextures ];

	    this._cubeFace = cubeFace;
	    this._colorTextures = colorTextures;
	    this._numColorTextures = this._colorTextures? this._colorTextures.length : 0;
	    this._depthBuffer = depthBuffer;

	    if (this._colorTextures && this._numColorTextures > 1) {

	        this._drawBuffers = new Array(this._numColorTextures);
	        for (var i = 0; i < this._numColorTextures; ++i) {
	            this._drawBuffers[i] = capabilities.EXT_DRAW_BUFFERS.COLOR_ATTACHMENT0_WEBGL + i;
	        }
	    }
	    else {
	        this._drawBuffers = null;
	    }

	    this._fbo = GL.gl.createFramebuffer();
	}

	FrameBuffer.prototype = {
	    get width() { return this._width; },
	    get height() { return this._height; },

	    /**
	     * Initializes the framebuffer object. This needs to be called whenever the Texture2D's are resized using initEmpty.
	     * @param silent Whether or not warnings should be printed.
	     */
	    init: function(silent)
	    {
	        var gl = GL.gl;
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);

	        if (this._colorTextures) {
	            if (this._cubeFace === undefined) {
	                this._width = this._colorTextures[0]._width;
	                this._height = this._colorTextures[0]._height;
	            }
	            else {
	                this._height = this._width = this._colorTextures[0].size;
	            }
	        }
	        else  {
	            this._width = this._depthBuffer._width;
	            this._height = this._depthBuffer._height;
	        }

	        var target = this._cubeFace === undefined? gl.TEXTURE_2D : this._cubeFace;

	        if (this._numColorTextures === 1) {
	            var texture = this._colorTextures[0];
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, texture._texture, 0);
	        }
	        else if (capabilities.EXT_DRAW_BUFFERS) {
	            for (var i = 0; i < this._numColorTextures; ++i) {
	                texture = this._colorTextures[i];
	                gl.framebufferTexture2D(gl.FRAMEBUFFER, capabilities.EXT_DRAW_BUFFERS.COLOR_ATTACHMENT0_WEBGL + i, target, texture._texture, 0);
	            }
	        }
	        else
	            throw new Error("Trying to bind multiple render targets without EXT_DRAW_BUFFERS support!");


	        if (this._depthBuffer) {
	            var attachment = this._depthBuffer.format === gl.DEPTH_STENCIL? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

	            if (this._depthBuffer instanceof Texture2D)
	                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, this._depthBuffer._texture, 0);
	            else
	                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, this._depthBuffer._renderBuffer);
	        }

	        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

	        switch (status && !silent) {
	            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
	                console.warn("Failed to initialize FBO: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
	                break;
	            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
	                console.warn("Failed to initialize FBO: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
	                break;
	            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
	                console.warn("Failed to initialize FBO: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
	                break;
	            case gl.FRAMEBUFFER_UNSUPPORTED:
	                console.warn("Failed to initialize FBO: FRAMEBUFFER_UNSUPPORTED");
	                break;
	            default:
	                // nothing
	        }

	        return status === gl.FRAMEBUFFER_COMPLETE;
	    },

		/**
	     * Retrieves pixel data from this FBO. Not recommended, as it can be slow.
		 */
		readPixels: function()
	    {
			var gl = GL.gl;
			var texture = this._colorTextures[0];
			gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);

			var numComponents;
			var pixels;
			switch(texture.format) {
	            case TextureFormat.RGB:
					numComponents = 3;
					break;
	            case TextureFormat.RGBA:
					numComponents = 4;
					break;
			}

			var len = this.width * this.height * numComponents;
			switch(texture.dataType) {
	            case DataType.FLOAT:
	            case DataType.HALF_FLOAT:
					pixels = new Float32Array(len);
	                break;
	            case DataType.UNSIGNED_BYTE:
					pixels = new Uint8Array(len);
					break;
	        }
			gl.readPixels(0, 0, this.width, this.height, texture.format, texture.dataType, pixels);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	        return pixels;
	    }

	};

	/**
	 * @ignore
	 * @author derschmale <http://www.derschmale.com>
	 */
	var TextureSetter = {
	    getSettersPerPass: function (materialPass)
	    {
	        if (TextureSetter._passTable === undefined)
	            TextureSetter._init();

	        return TextureSetter._findSetters(materialPass, TextureSetter._passTable);
	    },

	    getSettersPerInstance: function (materialPass)
	    {
	        if (TextureSetter._instanceTable === undefined)
	            TextureSetter._init();

	        return TextureSetter._findSetters(materialPass, TextureSetter._instanceTable);
	    },

	    _findSetters: function (materialPass, table)
	    {
	        var setters = [];
	        for (var slotName in table) {
	            if (!table.hasOwnProperty(slotName)) continue;
	            var slot = materialPass.getTextureSlot(slotName);
	            if (!slot) continue;
	            var setter = new table[slotName]();
	            setters.push(setter);
	            setter.slot = slot;
	            setter.pass = materialPass;
	        }

	        return setters;
	    },

	    _init: function()
	    {
	        TextureSetter._passTable = {};
	        TextureSetter._instanceTable = {};

	        TextureSetter._passTable.hx_normalDepthBuffer = NormalDepthBufferSetter;
	        TextureSetter._passTable.hx_backbuffer = BackbufferSetter;
	        TextureSetter._passTable.hx_frontbuffer = FrontbufferSetter;
	        TextureSetter._passTable.hx_lightAccumulation = LightAccumulationSetter;
	        TextureSetter._passTable.hx_ssao = SSAOSetter;
	        TextureSetter._passTable.hx_shadowMap = ShadowMapSetter;
	        TextureSetter._passTable["hx_diffuseProbes[0]"] = DiffuseProbesSetter;
	        TextureSetter._passTable["hx_specularProbes[0]"] = SpecularProbesSetter;

	        TextureSetter._instanceTable.hx_skinningTexture = SkinningTextureSetter;
	    },

	    setArray: function(pass, firstSlot, textures)
	    {
	        var len = textures.length;
	        var location = firstSlot.location;

	        for (var i = 0; i < len; ++i) {
	            var slot = pass._textureSlots[firstSlot.index + i];
	            // make sure we're not overshooting the array and writing to another element (larger arrays are allowed analogous to uniform arrays)
	            if (!slot || slot.location !== location) return;
	            slot.texture = textures[i];
	        }
	    }
	};


	// Texture setters can be either per pass or per instance. The execute method gets passed eithter the renderer or the
	// render item, respectively.

	function NormalDepthBufferSetter()
	{
	}

	NormalDepthBufferSetter.prototype.execute = function (renderer)
	{
	    this.slot.texture = renderer._normalDepthBuffer;
	};


	function FrontbufferSetter()
	{
	}

	FrontbufferSetter.prototype.execute = function (renderer)
	{
	    if (renderer._hdrFront)
	        this.slot.texture = renderer._hdrFront.texture;
	};

	function BackbufferSetter()
	{
	}

	BackbufferSetter.prototype.execute = function (renderer)
	{
	    if (renderer._hdrBack)
	        this.slot.texture = renderer._hdrBack.texture;
	};

	function LightAccumulationSetter()
	{
	}

	LightAccumulationSetter.prototype.execute = function (renderer)
	{
	    if (renderer._hdrBack)
	        this.slot.texture = renderer._hdrBack.texture;
	};


	function SSAOSetter()
	{
	}

	SSAOSetter.prototype.execute = function (renderer)
	{
	    this.slot.texture = renderer._ssaoTexture;
	};

	function ShadowMapSetter()
	{
	}

	ShadowMapSetter.prototype.execute = function (renderer)
	{
	    this.slot.texture = renderer._shadowAtlas.texture;
	};

	function DiffuseProbesSetter()
	{
	}

	DiffuseProbesSetter.prototype.execute = function (renderer)
	{
	    TextureSetter.setArray(this.pass, this.slot, renderer._diffuseProbeArray);
	};

	function SpecularProbesSetter()
	{
	}

	SpecularProbesSetter.prototype.execute = function (renderer)
	{
	    TextureSetter.setArray(this.pass, this.slot, renderer._specularProbeArray);
	};

	function SkinningTextureSetter()
	{
	}

	SkinningTextureSetter.prototype.execute = function (renderItem)
	{
	    this.slot.texture = renderItem.skeletonMatrices;
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function TextureSlot() {
	    this.location = -1;
	    this.texture = null;
	    this.name = null;   // for debugging
	    this.index = -1;
	}

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function UniformBufferSlot() {
	    this.blockIndex = -1;
	    this.bindingPoint = -1;
	    this.buffer = null;
	    this.name = null;   // for debugging
	}

	/**
	 * @ignore
	 * @author derschmale <http://www.derschmale.com>
	 */
	var UniformBufferSetter = {
	    getSettersPerPass: function (materialPass)
	    {
	        if (UniformBufferSetter._passTable === undefined)
	            UniformBufferSetter._init();

	        return UniformBufferSetter._findSetters(materialPass, UniformBufferSetter._passTable);
	    },

	    getSettersPerInstance: function (materialPass)
	    {
	        if (UniformBufferSetter._instanceTable === undefined)
	            UniformBufferSetter._init();

	        return UniformBufferSetter._findSetters(materialPass, UniformBufferSetter._instanceTable);
	    },

	    _findSetters: function (materialPass, table)
	    {
	        var setters = [];
	        for (var slotName in table) {
	            if (!table.hasOwnProperty(slotName)) continue;
	            var slot = materialPass.getUniformBufferSlot(slotName);
	            if (!slot) continue;
	            var setter = new table[slotName]();
	            setters.push(setter);
	            setter.slot = slot;
	        }

	        return setters;
	    },

	    _init: function()
	    {
	        UniformBufferSetter._passTable = {};
	        UniformBufferSetter._instanceTable = {};

	        UniformBufferSetter._passTable.hx_lights = LightsSetter;
			UniformBufferSetter._passTable.hx_lightingCells = LightingCellsSetter;
	    }
	};

	function LightsSetter()
	{
	}

	LightsSetter.prototype.execute = function (renderer)
	{
	    this.slot.buffer = renderer._lightingUniformBuffer;
	};

	function LightingCellsSetter()
	{
	}

	LightingCellsSetter.prototype.execute = function (renderer)
	{
		this.slot.buffer = renderer._lightingCellsUniformBuffer;
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function UniformBuffer(size)
	{
	    this._buffer = GL.gl.createBuffer();
	    // contains { offset, type, size }
	    this._uniforms = [];
	    this._size = size;
	}

	UniformBuffer.prototype = {
	    /**
	     * The size of the uniform buffer in bytes
	     */
	    get size() { return this._size; },

	    /**
	     * Uploads raw data for the buffer.
	     * @param data The data to upload, must be a Float32Array object.
	     * @param usageHint An optional usage hint for the buffer.
	     */
	    uploadData: function(data, usageHint)
	    {
	        var gl = GL.gl;

	        if (usageHint === undefined)
	            usageHint = gl.DYNAMIC_DRAW;

	        this.bind();
	        gl.bufferData(gl.UNIFORM_BUFFER, data, usageHint);
	    },

	    registerUniform: function(name, offset, size, type)
	    {
	        this._uniforms[name] = {offset: offset, size: size, type: type};
	    },

	    getUniformOffset: function(name)
	    {
	        var uniform = this._uniforms[name];
	        return uniform? uniform.offset : -1;
	    },
	    
	    setUniform: function(name, data)
	    {
	        var gl = GL.gl;
	        var uniform = this._uniforms[name];
	        this.bind();

	        switch(uniform.type) {
	            case gl.FLOAT:
	                var arr = new Float32Array(1);
	                arr[0] = data;
	                data = arr;
	                break;
	            case gl.FLOAT_VEC2:
	                arr = new Float32Array(2);
	                arr[0] = value.x || value[0] || 0;
	                arr[1] = value.y || value[1] || 0;
	                data = arr;
	                break;
	            case gl.FLOAT_VEC3:
	                arr = new Float32Array(3);
	                arr[0] = value.x || value[0] || 0;
	                arr[1] = value.y || value[1] || 0;
	                arr[2] = value.z || value[2] || 0;
	                data = arr;
	                break;
	            case gl.FLOAT_VEC4:
	                arr = new Float32Array(4);
	                arr[0] = value.x || value[0] || 0;
	                arr[1] = value.y || value[1] || 0;
	                arr[2] = value.z || value[2] || 0;
	                arr[3] = value.w || value[3] || 0;
	                data = arr;
	                break;
	            case gl.INT:
	            case gl.BOOL:
	                arr = new Int32Array(1);
	                arr[0] = value;
	                data = arr;
	                break;
	            case gl.INT_VEC2:
	            case gl.BOOL_VEC2:
	                arr = new Int32Array(2);
	                arr[0] = value.x || value[0] || 0;
	                arr[1] = value.y || value[1] || 0;
	                data = arr;
	                break;
	            case gl.INT_VEC3:
	            case gl.BOOL_VEC3:
	                arr = new Int32Array(3);
	                arr[0] = value.x || value[0] || 0;
	                arr[1] = value.y || value[1] || 0;
	                arr[2] = value.z || value[2] || 0;
	                data = arr;
	                break;
	            case gl.INT_VEC4:
	            case gl.BOOL_VEC4:
	                arr = new Int32Array(4);
	                arr[0] = value.x || value[0] || 0;
	                arr[1] = value.y || value[1] || 0;
	                arr[2] = value.z || value[2] || 0;
	                arr[3] = value.w || value[3] || 0;
	                data = arr;
	                break;
	            case gl.FLOAT_MAT4:
	                data = value;
	                break;
	            default:
	                // expect data to be correct
	        }

	        // TODO: Allow setting different types
	        gl.bufferSubData(gl.UNIFORM_BUFFER, uniform.offset, uniform.size, data);
	    },

	    // TODO: Allow setting member uniforms by name. However, getting this requires a shader to get the definition from
	    // Could we create a dummy material and then just grab it from there?
	    // We would need to provide a sort of MaterialPass.createUniformBuffer

	    /**
	     * @private
	     */
	    bind: function(bindingPoint)
	    {
	        var gl = GL.gl;

	        if (bindingPoint === undefined) {
	            gl.bindBuffer(gl.UNIFORM_BUFFER, this._buffer);
	        }
	        else {
	            gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPoint, this._buffer);
	        }
	    }
	};

	/**
	 * @ignore
	 * @param shader
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function MaterialPass(shader)
	{
	    this._shader = shader;
	    this._textureSlots = [];
	    this._uniformBufferSlots = [];
	    this._uniforms = {};
	    this._elementType = ElementType.TRIANGLES;
	    this._cullMode = CullMode.BACK;
	    this._writeColor = true;
	    this._depthTest = Comparison.LESS_EQUAL;
	    this._writeDepth = true;
	    this._blendState = null;

	    this._storeUniforms();
	    this._textureSettersPass = TextureSetter.getSettersPerPass(this);
	    this._textureSettersInstance = TextureSetter.getSettersPerInstance(this);

	    if (capabilities.WEBGL_2) {
	        this._uniformBufferSettersPass = UniformBufferSetter.getSettersPerPass(this);
	        this._uniformBufferSettersInstance = UniformBufferSetter.getSettersPerInstance(this);
	    }

	    this.setTexture("hx_dither2D", DEFAULTS.DEFAULT_2D_DITHER_TEXTURE);
	}

	// these will be set upon initialization
	// if a shader supports multiple lights per pass, they will take up 3 type slots (fe: 3 point lights: POINT_LIGHT_PASS, POINT_LIGHT_PASS + 1, POINT_LIGHT_PASS + 2)
	MaterialPass.BASE_PASS = 0;  // used for unlit, for predefined lights, or for WebGL 2 dynamic  passes

	MaterialPass.NORMAL_DEPTH_PASS = 1;

	// shadow map generation
	MaterialPass.DIR_LIGHT_SHADOW_MAP_PASS = 2;
	MaterialPass.POINT_LIGHT_SHADOW_MAP_PASS = 3;

	// dynamic lighting passes
	MaterialPass.DIR_LIGHT_PASS = 4;
	MaterialPass.POINT_LIGHT_PASS = 5;
	MaterialPass.SPOT_LIGHT_PASS = 6;
	MaterialPass.LIGHT_PROBE_PASS = 7;

	MaterialPass.NUM_PASS_TYPES = 8;

	MaterialPass.prototype =
	    {
	        constructor: MaterialPass,

	        getShader: function ()
	        {
	            return this._shader;
	        },

	        get elementType()
	        {
	            return this._elementType;
	        },

	        set elementType(value)
	        {
	            this._elementType = value;
	        },

	        get depthTest()
	        {
	            return this._depthTest;
	        },

	        set depthTest(value)
	        {
	            this._depthTest = value;
	        },

	        get writeColor()
	        {
	            return this._writeColor;
	        },

	        set writeColor(value)
	        {
	            this._writeColor = value;
	        },
	        get writeDepth()
	        {
	            return this._writeDepth;
	        },

	        set writeDepth(value)
	        {
	            this._writeDepth = value;
	        },

	        get cullMode()
	        {
	            return this._cullMode;
	        },

	        // use null for disabled
	        set cullMode(value)
	        {
	            this._cullMode = value;
	        },

	        get blendState()
	        {
	            return this._blendState;
	        },

	        set blendState(value)
	        {
	            this._blendState = value;
	        },

	        /**
	         * Called per render item.
	         */
	        updateInstanceRenderState: function(camera, renderItem)
	        {
	            var len = this._textureSettersInstance.length;

	            for (var i = 0; i < len; ++i) {
	                this._textureSettersInstance[i].execute(renderItem);
	            }

	            if (this._uniformBufferSettersInstance) {
	                len = this._uniformBufferSettersInstance.length;

	                for (i = 0; i < len; ++i) {
	                    this._uniformBufferSettersInstance[i].execute(renderItem);
	                }
	            }

	            this._shader.updateInstanceRenderState(camera, renderItem);
	        },

	        /**
	         * Only called upon activation, not per render item.
	         */
	        updatePassRenderState: function (camera, renderer, data)
	        {
	            var len = this._textureSettersPass.length;
	            var i;
	            for (i = 0; i < len; ++i) {
	                this._textureSettersPass[i].execute(renderer);
	            }

	            if (this._uniformBufferSettersPass) {
	                len = this._uniformBufferSettersPass.length;
	                for (i = 0; i < len; ++i) {
	                    this._uniformBufferSettersPass[i].execute(renderer);
	                }
	            }

	            len = this._textureSlots.length;

	            for (i = 0; i < len; ++i) {
	                var slot = this._textureSlots[i];
	                var texture = slot.texture;

	                if (!texture) {
	                    Texture2D.DEFAULT.bind(i);
	                    continue;
	                }

	                if (texture.isReady())
	                    texture.bind(i);
	                else
	                    texture._default.bind(i);
	            }

	            len = this._uniformBufferSlots.length;

	            for (i = 0; i < len; ++i) {
	                slot = this._uniformBufferSlots[i];
	                var buffer = slot.buffer;
	                buffer.bind(i);
	            }

	            GL.setMaterialPassState(this._cullMode, this._depthTest, this._writeDepth, this._writeColor, this._blendState);

	            this._shader.updatePassRenderState(camera, renderer);
	        },

	        _storeUniforms: function()
	        {
	            var gl = GL.gl;

	            var len = gl.getProgramParameter(this._shader._program, gl.ACTIVE_UNIFORMS);

	            for (var i = 0; i < len; ++i) {
	                var uniform = gl.getActiveUniform(this._shader._program, i);
	                var name = uniform.name;
	                var location = gl.getUniformLocation(this._shader._program, name);
	                this._uniforms[name] = {type: uniform.type, location: location, size: uniform.size};
	            }
	        },

	        createUniformBufferFromShader: function(name)
	        {
	            var gl = GL.gl;
	            var slot = this.getUniformBufferSlot(name);
	            var program = this._shader._program;
	            var indices = gl.getActiveUniformBlockParameter(program, slot.blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES);
	            var totalSize = gl.getActiveUniformBlockParameter(program, slot.blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE);
	            var uniformBuffer = new UniformBuffer(totalSize);

	            var offsets = gl.getActiveUniforms(program, indices, gl.UNIFORM_OFFSET);

	            for (var i = 0; i < indices.length; ++i) {
	                var uniform = gl.getActiveUniform(this._shader._program, indices[i]);
	                uniformBuffer.registerUniform(uniform.name, offsets[i], uniform.size, uniform.type);
	            }

	            uniformBuffer.uploadData(new Float32Array(totalSize / 4));

	            return uniformBuffer;
	        },

	        getTextureSlot: function(slotName)
	        {
	            if (!this._uniforms.hasOwnProperty(slotName)) return null;

	            var gl = GL.gl;
	            gl.useProgram(this._shader._program);

	            var uniform = this._uniforms[slotName];

	            if (!uniform) return;

	            var location = uniform.location;

	            var slot = null;

	            // reuse if location is already used
	            var len = this._textureSlots.length;
	            for (var i = 0; i < len; ++i) {
	                if (this._textureSlots[i].location === location) {
	                    slot = this._textureSlots[i];
	                    break;
	                }
	            }

	            if (!slot) {
	                var indices = new Int32Array(uniform.size);
	                for (var s = 0; s < uniform.size; ++s) {
	                    slot = new TextureSlot();
	                    slot.index = i;
	                    slot.name = slotName;
	                    this._textureSlots.push(slot);
	                    slot.location = location;
	                    indices[s] = i + s;
	                }

	                if (uniform.size === 1) {
	                    gl.uniform1i(location, i);
	                }
	                else {
	                    gl.uniform1iv(location, indices);
	                }
	            }

	            return slot;
	        },

	        getUniformBufferSlot: function(slotName)
	        {
	            var gl = GL.gl;
	            gl.useProgram(this._shader._program);

	            var blockIndex = GL.gl.getUniformBlockIndex(this._shader._program, slotName);
	            // seems it's returning -1 as *unsigned*
	            if (blockIndex > 1000) return;

	            var slot = null;

	            // reuse if blockIndex is already used
	            var len = this._uniformBufferSlots.length;
	            for (var i = 0; i < len; ++i) {
	                if (this._uniformBufferSlots[i].blockIndex === blockIndex) {
	                    slot = this._uniformBufferSlots[i];
	                    break;
	                }
	            }

	            if (!slot) {
	                slot = new UniformBufferSlot();
	                // grab the next available binding point
	                slot.bindingPoint = i;
	                slot.name = slotName;
	                this._uniformBufferSlots.push(slot);
	                slot.blockIndex = blockIndex;
	                gl.uniformBlockBinding(this._shader._program, slot.blockIndex, slot.bindingPoint);
	            }

	            return slot;
	        },

	        setTexture: function(slotName, texture)
	        {
	            var slot = this.getTextureSlot(slotName);
	            if (slot)
	                slot.texture = texture;
	        },

	        setUniformBuffer: function(slotName, buffer)
	        {
	            var slot = this.getUniformBufferSlot(slotName);
	            if (slot)
	                slot.buffer = buffer;
	        },

	        setTextureArray: function(slotName, textures)
	        {
	            var firstSlot = this.getTextureSlot(slotName + "[0]");
	            var location = firstSlot.location;
	            if (firstSlot) {
	                var len = textures.length;
	                for (var i = 0; i < len; ++i) {
	                    var slot = this._textureSlots[firstSlot.index + i];
	                    // make sure we're not overshooting the array and writing to another element (larger arrays are allowed analogous to uniform arrays)
	                    if (!slot || slot.location !== location) return;
	                    slot.texture = textures[i];
	                }
	            }
	        },

	        getUniformLocation: function(name)
	        {
	            if (this._uniforms.hasOwnProperty(name))
	                return this._uniforms[name].location;
	        },

	        getAttributeLocation: function(name)
	        {
	            return this._shader.getAttributeLocation(name);
	        },

	        // slow :(
	        setUniformStructArray: function(name, value)
	        {
	            var len = value.length;
	            for (var i = 0; i < len; ++i) {
	                var elm = value[i];
	                for (var key in elm) {
	                    if (elm.hasOwnProperty("key"))
	                        this.setUniform(name + "[" + i + "]." + key, value);
	                }
	            }
	        },

	        setUniformArray: function(name, value)
	        {
	            name += "[0]";

	            if (!this._uniforms.hasOwnProperty(name))
	                return;

	            var uniform = this._uniforms[name];
	            var gl = GL.gl;
	            gl.useProgram(this._shader._program);

	            switch(uniform.type) {
	                case gl.FLOAT:
	                    gl.uniform1fv(uniform.location, value);
	                    break;
	                case gl.FLOAT_VEC2:
	                    gl.uniform2fv(uniform.location, value);
	                    break;
	                case gl.FLOAT_VEC3:
	                    gl.uniform3fv(uniform.location, value);
	                    break;
	                case gl.FLOAT_VEC4:
	                    gl.uniform4fv(uniform.location, value);
	                    break;
	                case gl.FLOAT_MAT4:
	                    gl.uniformMatrix4fv(uniform.location, false, value);
	                    break;
	                case gl.INT:
	                    gl.uniform1iv(uniform.location, value);
	                    break;
	                case gl.INT_VEC2:
	                    gl.uniform2iv(uniform.location, value);
	                    break;
	                case gl.INT_VEC3:
	                    gl.uniform3iv(uniform.location, value);
	                    break;
	                case gl.INT_VEC4:
	                    gl.uniform1iv(uniform.location, value);
	                    break;
	                case gl.BOOL:
	                    gl.uniform1bv(uniform.location, value);
	                    break;
	                case gl.BOOL_VEC2:
	                    gl.uniform2bv(uniform.location, value);
	                    break;
	                case gl.BOOL_VEC3:
	                    gl.uniform3bv(uniform.location, value);
	                    break;
	                case gl.BOOL_VEC4:
	                    gl.uniform4bv(uniform.location, value);
	                    break;
	                default:
	                    throw new Error("Unsupported uniform format for setting (" + uniform.type + ") for uniform '" + name + "'. May be a todo.");

	            }
	        },

	        setUniform: function(name, value)
	        {
	            if (!this._uniforms.hasOwnProperty(name))
	                return;

	            var uniform = this._uniforms[name];

	            var gl = GL.gl;
	            gl.useProgram(this._shader._program);

	            switch(uniform.type) {
	                case gl.FLOAT:
	                    gl.uniform1f(uniform.location, value);
	                    break;
	                case gl.FLOAT_VEC2:
	                    gl.uniform2f(uniform.location, value.x || value[0] || 0, value.y || value[1] || 0);
	                    break;
	                case gl.FLOAT_VEC3:
	                    gl.uniform3f(uniform.location, value.x || value.r || value[0] || 0, value.y || value.g || value[1] || 0, value.z || value.b || value[2] || 0 );
	                    break;
	                case gl.FLOAT_VEC4:
	                    gl.uniform4f(uniform.location, value.x || value.r || value[0] || 0, value.y || value.g || value[1] || 0, value.z || value.b || value[2] || 0, value.w || value.a || value[3] || 0);
	                    break;
	                case gl.INT:
	                    gl.uniform1i(uniform.location, value);
	                    break;
	                case gl.INT_VEC2:
	                    gl.uniform2i(uniform.location, value.x || value[0], value.y || value[1]);
	                    break;
	                case gl.INT_VEC3:
	                    gl.uniform3i(uniform.location, value.x || value[0], value.y || value[1], value.z || value[2]);
	                    break;
	                case gl.INT_VEC4:
	                    gl.uniform4i(uniform.location, value.x || value[0], value.y || value[1], value.z || value[2], value.w || value[3]);
	                    break;
	                case gl.BOOL:
	                    gl.uniform1i(uniform.location, value);
	                    break;
	                case gl.BOOL_VEC2:
	                    gl.uniform2i(uniform.location, value.x || value[0], value.y || value[1]);
	                    break;
	                case gl.BOOL_VEC3:
	                    gl.uniform3i(uniform.location, value.x || value[0], value.y || value[1], value.z || value[2]);
	                    break;
	                case gl.BOOL_VEC4:
	                    gl.uniform4i(uniform.location, value.x || value[0], value.y || value[1], value.z || value[2], value.w || value[3]);
	                    break;
	                case gl.FLOAT_MAT4:
	                    gl.uniformMatrix4fv(uniform.location, false, value._m);
	                    break;
	                default:
	                    throw new Error("Unsupported uniform format for setting. May be a todo.");

	            }
	        }
	    };

	/**
	 * Implementation details: every button or axis has an integer index from an enum.
	 *
	 * @ignore
	 */
	function InputPlugin()
	{
		this._mapping = [];
		this._input = null;
	    this._values = {};
	}

	InputPlugin.prototype =
	{
		/**
		 * @ignore
		 */
		onEnabled: function()
		{
			throw new Error("Abstract method called!");
		},

		/**
		 * @ignore
		 */
		onDisabled: function()
		{
			throw new Error("Abstract method called!");
		},

		/**
		 * Maps a button or axis to an action. The value for this action name can be listened to or queried from {@linkcode Input}.
		 *
		 * @param buttonOrAxis The button or axis to map to an action. The value of this is one of the subclasses' enum properties.
		 * @param actionName The name of the action on the {@Input} that will be targeted by the button/axis.
		 */
		map: function(buttonOrAxis, actionName)
		{
			this._mapping[buttonOrAxis] = actionName;
		},

		/**
		 * Removes the mapping of a button or axis.
		 */
		unmap: function(buttonOrAxis)
		{
			this._mapping[buttonOrAxis] = undefined;
		},

		/**
		 * Returns whether or not the button or axis is mapped.
		 */
		isMapped: function(buttonOrAxis)
		{
			return !!this._mapping[buttonOrAxis];
		},

		/**
		 * Called by concrete subclasses
		 * @ignore
		 */
		setValue: function(buttonOrAxis, value)
		{
			if (!this._input) return;

	        // every plugin needs to check against their own values, or it could constantly overwrite other input plugins:
			var oldValue = this._values[buttonOrAxis];
			if (oldValue === value) return;
			this._values[buttonOrAxis] = value;

			var action = this._mapping[buttonOrAxis];
			if (action)
				this._input.setActionValue(action, value);
		},

		/**
		 * @ignore
		 * @private
		 */
		_setInput: function(value)
		{
			console.assert(!!this._input !== !!value, "Cannot enable or disable inputs twice!");
			this._input = value;

			if (value)
				this.onEnabled();
			else
				this.onDisabled();
		}
	};

	/**
	 * @classdesc
	 *
	 * The Gamepad class enables gamepad input in {@linkcode Input}. The Javascript Gamepad API is currently still
	 * experimental, hence this input type should be handled with care. Gamepad objects should not be created manually
	 * unless you're querying the native gamepad API directly. Otherwise, get them from {@linkcode getGamepads} or {@linkcode
	 * onGamepadConnected}.
	 *
	 * The button names for mapping are simply their integer indexes. Similar to axes, but they start from 0x100. For
	 * convenience, you can use the <code>Gamepad.A</code>, <code>Gamepad.DPAD_UP</code>, ... enum. The naming of these is
	 * based on the default Windows (XBox) and similar controllers. This will only apply if the mapping property is "standard".
	 * If the gamepad supports it, button "touches" rather than presses can also be mapped.
	 * If the buttons are analog, the communicated values will be between 0 and 1. Alternatively, you can also map "pressed"
	 * and "touched" states by providing <code>(buttonName | Gamepad.PRESS)</code> or <code>(buttonName | Gamepad.TOUCH)</code>
	 *
	 * @property displayId The id of the VR display this gamepad is associated with, if any.
	 * @property id The gamepad's id.
	 * @property index The gamepad's index. This matches the index in the array returned by {@linkcode getGamepads}
	 * @property mapping The mapping the user agent applies to the buttons. If not "standard", the input may not behave as
	 * expected. If this is a specific type of gamepad or controller, you may want to provide custom mapping based on its id.
	 * @property axisDeadzone The range for the axes to be considered "0". This assumes a default controller scheme where
	 * @property hand Either {@linkcode Gamepad#HAND_LEFT} or {@linkcode Gamepad#HAND_RIGHT}. Used for VR controllers.
	 *
	 * @see {@link https://w3c.github.io/gamepad/#remapping}
	 *
	 * @constructor
	 */
	function Gamepad(device)
	{
	    InputPlugin.call(this);

	    this.axisDeadzone = 0.251;

	    this._device = device;
	    this._hasPosition = false;
	    this._hasRotation = false;
	    this._position = new Float4();
	    this._rotation = new Quaternion();
	    this._linearVelocity = new Float4(0, 0, 0, 0);
	    this._angularVelocity = new Float4(0, 0, 0, 0);
	    this._linearAcceleration = new Float4(0, 0, 0, 0);
	    this._angularAcceleration = new Float4(0, 0, 0, 0);
	}

	/**
	 * The bottom button in the right cluster. On PS: Cross.
	 */
	Gamepad.A = 0;

	/**
	 * The right button in the right cluster. On PS: Circle.
	 */
	Gamepad.B = 0x01;

	/**
	 * The left button in the right cluster. On PS: Square.
	 */
	Gamepad.X = 0x02;

	/**
	 * The top button in the right cluster. On PS: Triangle.
	 */
	Gamepad.Y = 0x03;

	/**
	 * The top left trigger/bumper. On PS: L1.
	 */
	Gamepad.LB = 0x04;

	/**
	 * The top right trigger/bumper. On PS: R1.
	 */
	Gamepad.RB = 0x05;

	/**
	 * The bottom left trigger. On PS: L2.
	 */
	Gamepad.LT = 0x06;

	/**
	 * The bottom right trigger. On PS: R2.
	 */
	Gamepad.RT = 0x07;

	/**
	 * The back/select button.
	 */
	Gamepad.BACK = 0x08;

	/**
	 * The start button.
	 */
	Gamepad.START = 0x09;

	/**
	 * The left analog stick pressed down.
	 */
	Gamepad.L3 = 0x10;

	/**
	 * The right analog stick pressed down.
	 */
	Gamepad.R3 = 0x11;

	/**
	 * The up button on the directional pad.
	 */
	Gamepad.DPAD_UP = 0x12;

	/**
	 * The down button on the directional pad.
	 */
	Gamepad.DPAD_DOWN = 0x13;

	/**
	 * The left button on the directional pad.
	 */
	Gamepad.DPAD_LEFT = 0x14;

	/**
	 * The right button on the directional pad.
	 */
	Gamepad.DPAD_RIGHT = 0x15;

	/**
	 * The horizontal axis of the left analog stick.
	 */
	Gamepad.STICK_LX = 0x100;

	/**
	 * The vertical axis of the left analog stick.
	 */
	Gamepad.STICK_LY = 0x101;

	/**
	 * The horizontal axis of the right analog stick.
	 */
	Gamepad.STICK_RX = 0x102;

	/**
	 * The vertical axis of the right analog stick.
	 */
	Gamepad.STICK_RY = 0x103;

	/**
	 * Combine with a button name to indicate that the action is only interested in the pressed state, not the analog value:
	 * <code>gamepad.map(name | Gamepad.PRESSED, "action")</code>
	 */
	Gamepad.PRESS = 0x1000;

	/**
	 * Combine with a button name to indicate that the action is interested in the touched state, if the gamepad supports this.
	 * <code>gamepad.map(name | Gamepad.TOUCHED, "action")</code>
	 */
	Gamepad.TOUCH = 0x2000;

	Gamepad.HAND_LEFT = "left";
	Gamepad.HAND_RIGHT = "right";

	Gamepad.prototype = Object.create(InputPlugin.prototype, {
	    hasPosition: {
	        get: function()
	        {
	            return this._hasPosition;
	        }
	    },

	    hasRotation: {
	        get: function()
	        {
	            return this._hasRotation;
	        }
	    },

	    linearVelocity: {
	        get: function() {
	            return this._linearVelocity;
	        }
	    },

	    angularVelocity: {
	        get: function() {
	            return this._angularVelocity;
	        }
	    },

	    linearAcceleration: {
	        get: function() {
	            return this._linearAcceleration;
	        }
	    },

	    angularAcceleration: {
	        get: function() {
	            return this._angularAcceleration;
	        }
	    },

	    position: {
	        get: function() {
	            return this._position;
	        }
	    },

	    rotation: {
	        get: function() {
	            return this._rotation;
	        }
	    },

	    displayId: {
	        get: function()
	        {
	            return this._device.displayId;
	        }
	    },

	    id: {
	        get: function()
	        {
	            return this._device.id;
	        }
	    },

	    index: {
	        get: function()
	        {
	            return this._device.index;
	        }
	    },

	    mapping: {
	        get: function()
	        {
	            return this._device.mapping;
	        }
	    },

	    hand: {
	        get: function()
	        {
	            return this._device.hand;
	        }
	    }
	});

	/**
	 * @ignore
	 */
	Gamepad.prototype.onEnabled = function()
	{
	    increaseUsedGamepads();
	    onPreFrame.bind(this._onPreFrame, this);
	};

	/**
	 * @ignore
	 */
	Gamepad.prototype.onDisabled = function()
	{
	    decreaseUsedGamepads();
	    onPreFrame.unbind(this._onPreFrame);
	};

	/**
	 * @ignore
	 * @private
	 */
	Gamepad.prototype._onPreFrame = function()
	{
	    var device = this._device;
	    if (!device.connected) return;

	    var buttons = device.buttons;
	    var axes = device.axes;

	    for (var i = 0, len = buttons.length; i < len; ++i) {
	        var button = buttons[i];
	        this.setValue(i, button.value);
	        this.setValue(i | Gamepad.PRESS, button.pressed? 1 : 0);

	        if (button.touched !== undefined)
	            this.setValue(i | Gamepad.TOUCH, button.touched? 1 : 0);

	    }

	    var deadzone = this.axisDeadzone;

	    var i, len;

	    if (deadzone > 0) {
	        var deadzoneSqr = deadzone * deadzone;
	        var rcpDeadZone = 1.0 / (1.0 - deadzone); // this remaps it to 0 - 1 after applying deadzone

	        // this assumes a default controller
	        for (i = 0, len = axes.length; i < len; i += 2) {
	            var x = axes[i];
	            var y = axes[i | 1];
	            var magSqr = x * x + y * y;
	            if (magSqr > deadzoneSqr) {
	                var mag = Math.sqrt(magSqr);
	                var newMag = (mag - deadzone) * rcpDeadZone;
	                var sc = newMag / mag;  // this scales to the new magnitude
	                this.setValue(i | 0x100, x * sc);
	                this.setValue(i | 0x101, y * sc);
	            }
	            else {
	                this.setValue(i | 0x100, 0);
	                this.setValue(i | 0x101, 0);
	            }
	        }
	    }
	    else {
	        for (i = 0, len = axes.length; i < len; ++i) {
	            var v = axes[i];
	            this.setValue(i | 0x100, v);
	        }
	    }

	    var pose = this._device.pose;

	    if (pose) {
	        var pos = pose.position;
	        var quat = pose.orientation;
	        var lv = pose.linearVelocity;
	        var av = pose.angularVelocity;
	        var la = pose.linearAcceleration;
	        var aa = pose.angularAcceleration;

	        // may have to swap orientation again... (see VRCamera)
	        if (pos) {
	            this._position.set(pos[0], -pos[2], pos[1]);
	            this._hasPosition = true;
	        }
	        else
	            this._hasPosition = false;

	        if (quat) {
	            this._rotation.set(quat[0], -quat[2], quat[1], quat[3]);
	            this._hasRotation = true;
	        }
	        else {
	            this._hasRotation = false;
	        }
	        if (lv) this._linearVelocity.set(lv[0], -lv[2], lv[1]);
	        if (la) this._linearAcceleration.set(la[0], -la[2], la[1]);
	        if (av) this._angularVelocity.set(av[0], -av[2], av[1]);
	        if (aa) this._angularAcceleration.set(aa[0], -aa[2], aa[1]);
	    }
	};

	var gamepads = [];
	var usedGamepadCount = 0;

	/**
	 * Dispatched when a gamepad is connected.
	 */
	var onGamepadConnected = new Signal();

	/**
	 * Dispatched when a gamepad is disconnected.
	 */
	var onGamepadDisconnected = new Signal();

	/**
	 * Returns the connected gamepads as Gamepad objects that can be enabled in an {@linkcode Input} object. Entries
	 * in the array may be undefined or null, depending on whether it was disconnected or not. If a gamepad is plugged in,
	 * it's not necessarily available due to user agent security policies. You may have to interact with the pad. It will
	 * then become available through the {@linkcode onGamepadConnected} signal.
	 *
	 * @see Gamepad
	 * @see Input
	 */
	function getGamepads()
	{
	    return gamepads;
	}

	/**
	 * Returns the gamepad with a given index.
	 *
	 * @see Gamepad
	 * @see Input
	 */
	function getGamepad(index)
	{
	    return gamepads[index];
	}

	/**
	 * @ignore
	 */
	function _onGamepadConnected(event)
	{
	    console.log("gamepad connected ", event.gamepad.id, event.gamepad.displayId);

	    var gamepad = new Gamepad(event.gamepad);
	    gamepads[event.gamepad.index] = gamepad;
	    onGamepadConnected.dispatch(gamepad);
	}

	/**
	 * @ignore
	 */
	function _onGamepadDisconnected(event)
	{
	    console.log("gamepad disconnected " + event.gamepad.id);

	    var index = event.gamepad.index;
	    var gamepad = gamepads[index];
	    // keep it sparse
	    delete gamepads[index];
	    onGamepadDisconnected.dispatch(gamepad);
	}

	/**
	 * @ignore
	 */
	function initGamepads()
	{
	    // no support for gamepads
	    if (!navigator.getGamepads)
	        return;

	    var devices = navigator.getGamepads();
	    if (!devices) return;

	    for (var i = 0, l = devices.length; i < l; ++i) {

	        // keep the list sparse to match the devices list
	        if (devices[i])
	            gamepads[i] = new Gamepad(devices[i]);
	    }

	    window.addEventListener("gamepadconnected", _onGamepadConnected);
	    window.addEventListener("gamepaddisconnected", _onGamepadDisconnected);
	}

	// this is required for Chrome to update its gamepad state correctly!
	function updateGamepads()
	{
	    var vrDisplay = META.VR_DISPLAY;
	    // don't update if we're not actually using any
	    // we do need to update with VR to ensure handedness gets updated
	    if (!vrDisplay && (!usedGamepadCount || !navigator.getGamepads))
	        return;

	    var devices = navigator.getGamepads();

	    if (!devices) return;

	    for (var i = 0, l = gamepads.length; i < l; ++i) {
	        var gamepad = gamepads[i];
	        var device = devices[i];

	        if (gamepad && device) {
	            var vrDisplayToNotify;

	            // this is a hack for Chrome when it does not provide hand information straight-away
	            if (device.displayId === vrDisplay.displayId && gamepad._device.hand !== device.hand) {
	                vrDisplayToNotify = true;
	                vrDisplay._onGamepadDisconnected(gamepad);
	            }

	            gamepad._device = device;

	            if (vrDisplayToNotify)
	                vrDisplay._onGamepadConnected(gamepad);
	        }
	    }
	}

	function increaseUsedGamepads()
	{
	    ++usedGamepadCount;
	}

	function decreaseUsedGamepads()
	{
	    --usedGamepadCount;
	}

	/**
	 * @classdesc
	 *
	 * VRDisplay represents a VR display. It's a wrapper for the native VRDisplay class, and provides some convienence
	 * methods to retrieve the controllers.
	 *
	 * @property {Signal} onGamepadConnected A signal that is dispatched when a Gamepad associated with this VR display is
	 * connected. This only applies if controllers have hand information (otherwise, use the standard gamepad queries).
	 * @property {Signal} onGamepadDisconnected A signal that is dispatched when a Gamepad associated with this VR display
	 * has disconnected. This only applies if controllers have hand information (otherwise, use the standard gamepad queries).
	 *
	 * @constructor
	 */
	function VRDisplay(display)
	{
	    this._display = display;
	    this.onGamepadConnected = new Signal();
	    this.onGamepadDisconnected = new Signal();

	    this.requestAnimationFrame = display.requestAnimationFrame.bind(display);
	    this.cancelAnimationFrame = display.cancelAnimationFrame.bind(display);
	    this.getEyeParameters = display.getEyeParameters.bind(display);
	    this.getFrameData = display.getFrameData.bind(display);
	    this.capabilities = display.capabilities;

	    this._gamepadLeft = null;
	    this._gamepadRight = null;

	    this.sittingToStandingTransform = null;
	    this.roomSize = undefined;

	    if (display.stageParameters) {
	        // this is actually an inverse matrix
	        if (display.stageParameters.sittingToStandingTransform) {
	            this.sittingToStandingTransform = new Matrix4x4(display.stageParameters.sittingToStandingTransform);
	            var t = new Transform();
	            this.sittingToStandingTransform.decompose(t);
	            var temp = t.position.y;
	            t.position.y = -t.position.z;
	            t.position.z = temp;
	            temp = t.rotation.y;
	            t.rotation.y = -t.rotation.z;
	            t.rotation.z = temp;
	            this.sittingToStandingTransform.compose(t);
	        }

	        if (display.stageParameters.sizeX) {
	            this.roomSize = new Float2(display.stageParameters.sizeX, display.stageParameters.sizeY);
	        }
	    }

	    // provide default
	    if (!this.sittingToStandingTransform) {
	        this.sittingToStandingTransform = new Matrix4x4();
	        this.sittingToStandingTransform.fromTranslation(0, 0, META.OPTIONS.vrUserHeight);
	    }
	}

	VRDisplay.prototype = {
	    /**
	     * The display name of the VR device.
	     */
	    get displayName()
	    {
	        return this._display.displayName;
	    },

	    /**
	     * The display id of the VR device.
	     */
	    get displayId()
	    {
	        return this._display.displayId;
	    },

	    get gamepads()
	    {
	        return this._gamepads;
	    },

	    /**
	     * The left handed Gamepad device associated with this display, if present.
	     */
	    get gamepadLeft()
	    {
	        return this._gamepadLeft;
	    },

	    /**
	     * The right handed Gamepad device associated with this display, if present.
	     */
	    get gamepadRight()
	    {
	        return this._gamepadRight;
	    },

	    /**
	     * Indicates whether or not the display is currently presenting
	     */
	    get isPresenting()
	    {
	        return this._display.isPresenting;
	    },

	    /**
	     * Stops presenting.
	     */
	    exitPresent: function()
	    {
	        this._display.exitPresent();
	    },

	    /**
	     * called by vr.js
	     * @ignore
	     */
	    onEnabled: function ()
	    {
	        onGamepadConnected.bind(this._onGamepadConnected, this);
	        onGamepadDisconnected.bind(this._onGamepadDisconnected, this);

	        getGamepads().forEach(this._onGamepadConnected.bind(this));
	    },

	    /**
	     * called by vr.js
	     * @ignore
	     */
	    onDisabled: function ()
	    {
	        onGamepadConnected.unbind(this._onGamepadConnected, this);
	        onGamepadDisconnected.unbind(this._onGamepadDisconnected, this);
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _onGamepadConnected: function (gamepad)
	    {
	        // sometimes, Chrome will notify a connected gamepad without giving the correct hand information
	        if (gamepad.displayId === this.displayId) {
	            // if controller is already set, it's probably a case where the gamepad query comes after the connect event
	            // (although connect doesn't seem to trigger with VR controllers, can't be safe enough)
	            if (gamepad.hand === Gamepad.HAND_LEFT && !this._gamepadLeft) {
	                console.log("Left VR controller connected");
	                this._gamepadLeft = gamepad;
	                this.onGamepadConnected.dispatch(gamepad);
	            }
	            else if (gamepad.hand === Gamepad.HAND_RIGHT && !this._gamepadRight) {
	                console.log("Right VR controller connected");
	                this._gamepadRight = gamepad;
	                this.onGamepadConnected.dispatch(gamepad);
	            }
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _onGamepadDisconnected: function (gamepad)
	    {
	        if (gamepad.displayId === this.displayId) {
	            if (gamepad.hand === Gamepad.HAND_LEFT) {
	                this._gamepadLeft = null;
	                this.onGamepadDisconnected.dispatch(gamepad);
	            }
	            else if (gamepad.hand === Gamepad.HAND_RIGHT) {
	                this._gamepadRight = null;
	                this.onGamepadDisconnected.dispatch(gamepad);
	            }
	        }
	    }
	};

	var _isVRPresenting = false;

	function isVRPresenting()
	{
	    return _isVRPresenting;
	}

	/**
	 * Turns on a VR display
	 */
	function enableVR(display, onFail)
	{
	    if (META.VR_DISPLAY)
	        throw new Error("VR already enabled!");

	    META.VR_DISPLAY = display;
	    display.onEnabled();

	    capabilities.VR_CAN_PRESENT = display.capabilities.canPresent;

	    if (capabilities.VR_CAN_PRESENT) {
	        META.VR_LEFT_EYE_PARAMS = display.getEyeParameters("left");
	        META.VR_RIGHT_EYE_PARAMS = display.getEyeParameters("right");

	        META.VR_DISPLAY._display.requestPresent([{
	            source: META.TARGET_CANVAS
	        }]).then(function() {
	            _isVRPresenting = true;
	        }, onFail);

	        META.TARGET_CANVAS.width = Math.max(META.VR_LEFT_EYE_PARAMS.renderWidth, META.VR_RIGHT_EYE_PARAMS.renderWidth);
	        META.TARGET_CANVAS.height = Math.max(META.VR_LEFT_EYE_PARAMS.renderHeight, META.VR_RIGHT_EYE_PARAMS.renderHeight);
	    }

	    console.log("Starting VR on " + display.displayName);
	}

	function disableVR()
	{
	    if (!META.VR_DISPLAY) return;

	    META.VR_DISPLAY.onDisabled();
	    _isVRPresenting = false;

	    if (META.VR_DISPLAY.isPresenting)
	        META.VR_DISPLAY.exitPresent();

	    capabilities.VR_CAN_PRESENT = false;
	    META.VR_DISPLAY = null;
	    META.VR_LEFT_EYE_PARAMS = null;
	    META.VR_RIGHT_EYE_PARAMS = null;
	}

	/**
	 * Asynchronously retrieves the available VR displays and passes them into a callback function.
	 */
	function getVRDisplays(callback)
	{
	    if (!navigator.getVRDisplays) {
	        callback([]);
	        return;
	    }

	    navigator.getVRDisplays().then(function (displays) {
	        var mappedDisplays = [];

	        displays.forEach(function(display) {
	            mappedDisplays.push(new VRDisplay(display));
	        });

	        callback(mappedDisplays);
	    });
	}

	/**
	 * META contains some data about the Helix engine, such as the options it was initialized with.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var META =
	    {
	        /**
	         * Whether or not Helix has been initialized.
	         */
	        INITIALIZED: false,

	        /**
	         * The options passed to Helix when initializing. These are possibly updated to reflect the device's capabilties,
	         * so it can be used to verify settings.
	         */
	        OPTIONS: null,

	        /**
	         * The canvas used to contain the to-screen renders.
	         */
	        TARGET_CANVAS: null,

	        /**
	         * The WebVR display (if enabled) used for rendering
	         */
	        VR_DISPLAY: null,

			/**
	         * The WebVR left eye parameters (if enabled)
			 */
			VR_LEFT_EYE_PARAMS: null,

	        /**
	         * The WebVR right eye parameters (if enabled)
			 */
			VR_RIGHT_EYE_PARAMS: null,

			/**
	         * The Audio Context used for audio playback
			 */
			AUDIO_CONTEXT: null
		};

	/**
	 * The {@linkcode Signal} that dispatched before a frame renders.
	 */
	var onPreFrame = new Signal();

	/**
	 * The {@linkcode Signal} that triggers rendering. Listen to this to call {@linkcode Renderer#render}
	 */
	var onFrame = new Signal();

	/**
	 * The duration to update and render a frame.
	 */
	var frameTime = 0;

	/**
	 * @ignore
	 * @type {FrameTicker}
	 */
	var frameTicker = new FrameTicker();

	frameTicker.onTick.bind(_onFrameTick);

	/**
	 * @ignore
	 * @author derschmale <http://www.derschmale.com>
	 */
	var DEFAULTS =
	    {
	        COPY_SHADER: null,
	        DEFAULT_2D_DITHER_TEXTURE: null,
	        DEFAULT_SKINNING_TEXTURE: null
	    };

	/**
	 * capabilities contains the device-specific properties and supported extensions.
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var capabilities =
	    {
	        WEBGL_2: false,

	        // extensions:
	        EXT_DRAW_BUFFERS: null,
	        EXT_FLOAT_TEXTURES: null,
	        EXT_HALF_FLOAT_TEXTURES: null,
	        EXT_FLOAT_TEXTURES_LINEAR: null,
	        EXT_HALF_FLOAT_TEXTURES_LINEAR: null,
	        EXT_DEPTH_TEXTURE: null,
	        EXT_STANDARD_DERIVATIVES: null,
	        EXT_SHADER_TEXTURE_LOD: null,
	        EXT_TEXTURE_FILTER_ANISOTROPIC: null,
	        EXT_ELEMENT_INDEX_UINT: null,
	        EXT_COLOR_BUFFER_FLOAT: null,
	        EXT_COLOR_BUFFER_HALF_FLOAT: null,

	        DEFAULT_TEXTURE_MAX_ANISOTROPY: 0,
	        HDR_FORMAT: 0,

	        VR_CAN_PRESENT: false
	    };

	/**
	 * TextureFilter contains texture filtering presets.
	 *
	 * @namespace
	 *
	 * @property NEAREST Performs nearest neighbour filter with nearest mip level selection
	 * @property NEAREST_NOMIP Performs nearest neighbour filter with mipmapping disabled
	 * @property BILINEAR Performs bilinear filtering with nearest mip level selection
	 * @property BILINEAR_NOMIP Performs bilinear filtering with mipmapping disabled
	 * @property TRILINEAR Performs trilinear filtering (bilinear + linear mipmap interpolation)
	 * @property TRILINEAR_ANISOTROPIC Performs anisotropic trilinear filtering. Only available if capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC is available.
	 */
	var TextureFilter = {};

	/**
	 * TextureWrapMode defines how a texture should be samples when the coordinate is outside the [0, 1] range.
	 *
	 * @namespace
	 *
	 * @property DEFAULT The default texture wrap mode (REPEAT).
	 * @property REPEAT The fractional part of the coordinate will be used as the coordinate, causing the texture to repeat.
	 * @property CLAMP The coordinates will be clamped to 0 and 1.
	 */
	var TextureWrapMode = {};

	/**
	 * CullMode defines the type of face culling used when rendering.
	 *
	 * @namespace
	 *
	 * @property NONE Doesn't perform any culling (both sides are rendered).
	 * @property BACK Culls the faces pointing away from the screen
	 * @property FRONT = Culls the faces pointing toward the screen
	 * @property ALL = Culls both faces (nothing is rendered)
	 */
	var CullMode = {
	    NONE: null,
	    BACK: 0x0405,
	    FRONT: 0x0404,
	    ALL: 0x0408
	};

	/**
	 * StencilOp defines how the stencil buffer gets updated.
	 *
	 * @namespace
	 *
	 * @property KEEP Keeps the existing stencil value.
	 * @property ZERO Sets the stencil value to 0.
	 * @property REPLACE Replaces the stencil value with the reference value.
	 * @property INCREMENT Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
	 * @property INCREMENT_WRAP Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.
	 * @property DECREMENT Decrements the current stencil buffer value. Clamps to 0.
	 * @property DECREMENT_WRAP Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.
	 * @property INVERT Bitwise inverts the current stencil buffer value.
	 *
	 * @see {@linkcode StencilState}
	 */
	var StencilOp = {};

	/**
	 * Comparison represents comparison modes used in depth tests, stencil tests, etc
	 *
	 * @namespace
	 *
	 * @property DISABLED The given test is disabled.
	 * @property ALWAYS The given test always succeeds.
	 * @property NEVER The given test never succeeds.
	 * @property LESS Less than
	 * @property EQUAL Equal
	 * @property LESS_EQUAL Less than or equal
	 * @property GREATER Greater than.
	 * @property GREATER_EQUAL Greater than or equal.
	 * @property NOT_EQUAL Not equal.
	 */
	var Comparison = {};

	/**
	 * ElementType described the type of geometry is described by the index buffer.
	 *
	 * @namespace
	 *
	 * @property POINTS Every index represents a point.
	 * @property LINES Every two indices represent a line.
	 * @property LINE_STRIP The indices represent a set of connected lines.
	 * @property LINE_LOOP The indices represent a set of connected lines. The last index is also connected to the first.
	 * @property TRIANGLES Every three indices represent a line.
	 * @property TRIANGLE_STRIP The indices represent a set of connected triangles, in such a way that any consecutive 3 indices form a triangle.
	 * @property TRIANGLE_FAN The indices represent a set of connected triangles, fanning out with the first index shared.
	 */
	var ElementType = {};

	/**
	 * BlendFactor define the factors used by {@linkcode BlendState} to multiply with the source and destination colors.
	 *
	 * @namespace
	 *
	 * @property ZERO Multiplies by 0.
	 * @property ONE Multiplies by 1.
	 * @property SOURCE_COLOR Multiplies by the source color.
	 * @property ONE_MINUS_SOURCE_COLOR Multiplies by one minus the source color.
	 * @property DESTINATION_COLOR Multiplies by the destination color.
	 * @property ONE_MINUS_DESTINATION_COLOR Multiplies by one minus the destination color.
	 * @property SOURCE_ALPHA Multiplies by the source alpha.
	 * @property ONE_MINUS_SOURCE_ALPHA Multiplies by one minus the source alpha.
	 * @property DESTINATION_ALPHA Multiplies by the destination alpha.
	 * @property ONE_MINUS_DESTINATION_ALPHA Multiplies by one minus the destination alpha.
	 * @property SOURCE_ALPHA_SATURATE Multiplies by the minimum of the source and (1 – destination) alphas
	 * @property CONSTANT_ALPHA Multiplies by the constant alpha value
	 * @property ONE_MINUS_CONSTANT_ALPHA Multiplies by one minus the constant alpha value
	 *
	 * @see {@linkcode BlendState}
	 */
	var BlendFactor = {};

	/**
	 * BlendOperation defines the operation used to combine the multiplied source and destination colors.
	 * @namespace
	 *
	 * @property ADD Adds the two values.
	 * @property SUBTRACT Subtracts the two values.
	 * @property REVERSE_SUBTRACT Subtracts the two values in the reverse order.
	 *
	 * @see {@linkcode BlendState}
	 */
	var BlendOperation = {};

	/**
	 * ClearMask defines which data needs to be cleared when calling {@linkcode GL#clear}
	 *
	 * @namespace
	 *
	 * @property COLOR Only clear the color buffer.
	 * @property STENCIL Only clear the stencil buffer.
	 * @property DEPTH Only clear the depth buffer.
	 * @property COMPLETE Clear all buffers.
	 *
	 * @see {@linkcode GL#clear}
	 */
	var ClearMask = {};

	/**
	 * TextureFormat defines which texture channels are used by a texture.
	 *
	 * @namespace
	 *
	 * @property RGBA A 4-channel color texture
	 * @property RGB A 3-channel color texture (no alpha)
	 */
	var TextureFormat = {
		/**
	     * This is mainly for WebGL 2 compatibility and floating point textures.
	     * @ignore
		 */
		getDefaultInternalFormat: function(format, dataType)
	    {
	        if (!capabilities.WEBGL_2)
	            return format;

	        if (dataType === DataType.FLOAT) {
	            if (format === TextureFormat.RGBA)
	                return GL.gl.RGBA32F;
	            if (format === TextureFormat.RGB)
	                return GL.gl.RGB32F;
	            if (format === TextureFormat.RG)
	                return GL.gl.RG32F;
	        }

	        if (dataType === DataType.HALF_FLOAT) {
	            if (format === TextureFormat.RGBA)
	                return GL.gl.RGBA16F;
	            if (format === TextureFormat.RGB)
	                return GL.gl.RGB16F;
				if (format === TextureFormat.RG)
					return GL.gl.RG16F;
	        }

	        return format;
	    }

	};

	/**
	 * DataType represents the data type used by a gpu buffer (vertex buffer, index buffer, textures)
	 *
	 * @namespace
	 *
	 * @property UNSIGNED_BYTE Unsigned byte (8 bit integer)
	 * @property UNSIGNED_SHORT Unsigned short (16 bit integer)
	 * @property UNSIGNED_INT Unsigned short (32 bit integer)
	 * @property FLOAT Floating point (32 bit float)
	 */
	var DataType = {};

	/**
	 * BufferUsage describes the type of cpu <-> gpu interaction a vertex or index buffer requires.
	 *
	 * @namespace
	 *
	 * @property STATIC_DRAW The buffer is meant to be uploaded once (or rarely)
	 * @property DYNAMIC_DRAW The buffer is meant to be updated often.
	 *
	 * @see {@linkcode Mesh#vertexUsage}
	 * @see {@linkcode Mesh#indexUsage}
	 */
	var BufferUsage = {};

	/**
	 * CubeFace represents the sides of a cube, for example the faces of a cube texture.
	 *
	 * @namespace
	 *
	 * @property POSITIVE_X The positive X side.
	 * @property NEGATIVE_X The negative X side.
	 * @property POSITIVE_Y The positive Y side.
	 * @property NEGATIVE_Y The negative Y side.
	 * @property POSITIVE_Z The positive Z side.
	 * @property NEGATIVE_Z The negative Z side.
	 */
	var CubeFace = {};

	/**
	 * @classdesc
	 * Provides a set of options to configure Helix at init. Once passed, the options get assigned to {@linkcode META#OPTIONS}
	 * but the values may have changed to reflect the capabilities of the device. For example: hdr may be set to false if
	 * floating point render targets aren't supported. It's important to check options like these through META.OPTIONS to
	 * handle them correctly. (lack of hdr may require a different lighting setup).
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function InitOptions()
	{
	    /**
	     * Whether or not the drawing buffer is cleared or not between frames. Set this to true for VR mirroring.
	     */
	    this.preserveDrawingBuffer = false;

	    /**
	     * Use WebGL 2 if available.
	     */
	    this.webgl2 = false;

	    /**
	     * The maximum supported number of joints for skinning animations.
	     */
	    this.maxSkeletonJoints = 64;

	    /**
	     * Maximum number of directional lights inside a dynamic WebGL 2.0 shader.
	     */
	    this.maxDirLights = 3;

	    /**
	     * Maximum number of point / spot lights inside a dynamic WebGL 2.0 shader.
	     */
	    this.maxPointSpotLights = 20;

		/**
	     * Number of cells for clustered rendering in WebGL 2.0
		 */
		this.numLightingCellsX = 16;

		/**
		 * Number of cells for clustered rendering in WebGL 2.0
		 */
		this.numLightingCellsY = 9;

	    /**
	     * Maximum number of light probes inside a dynamic WebGL 2.0 shader.
	     */
	    this.maxLightProbes = 1;

	    /**
	     * Allows applying ambient occlusion ({@linkcode SSAO} or {@linkcode HBAO}) to the scene.
	     */
	    this.ambientOcclusion = null;

	    /**
	     * Whether or not to use a texture to store skinning data. May be forced to "false" if floating point textures are not supported.
	     */
	    this.useSkinningTexture = true;

	    /**
	     * Use high dynamic range for rendering. May be forced to "false" if floating point render targets are not supported.
	     */
	    this.hdr = false;

	    /**
	     * Apply gamma correction. This allows lighting to happen in linear space, as it should.
	     */
	    this.useGammaCorrection = true;

	    /**
	     * If true, uses a gamma of 2.2 instead of 2. The latter is faster and generally "good enough".
	     */
	    this.usePreciseGammaCorrection = false;

	    /**
	     * The default {@codelink LightingModel} to use.
	     */
	    this.defaultLightingModel = LightingModel.Unlit;

	    /**
	     * The amount of shadow cascades to use. Cascades split up the view frustum into areas with their own shadow maps,
	     * increasing quality at the cost of performance.
	     */
	    this.numShadowCascades = 1;

	    // debug stuff
	    /**
	     * This enables some error-checking (such as on shader compilation). This has a big performance impact on shader
	     * initialisation.
	     */
	    this.debug = false;

	    /**
	     * Throws errors when shaders fail to compile.
	     */
	    this.throwOnShaderError = false;

	    /**
	     * The shadow filter to use when rendering directional light shadows.
	     */
	    this.shadowFilter = new HardShadowFilter();

	    /**
	     * Indicates whether the back buffer should support transparency.
	     */
	    this.transparentBackground = false;

	    /**
	     * The default eye height for room-scale positions - in case the VR device does not support room-scale VR
	     */
	    this.vrUserHeight = 1.65;
	}

	/**
	 * Initializes Helix and creates a WebGL context for a given canvas
	 *
	 * @param canvas The canvas to create the gl context from.
	 * @param [options] An optional {@linkcode InitOptions} object.
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function init(canvas, options)
	{
	    if (META.INITIALIZED) throw new Error("Can only initialize Helix once!");

	    META.TARGET_CANVAS = canvas;
	    META.TARGET_CANVAS.requestPointerLock = META.TARGET_CANVAS.requestPointerLock || META.TARGET_CANVAS.mozRequestPointerLock;
	    META.AUDIO_CONTEXT = window.hx_audioContext;

	    _updateCanvasSize();
	    initGamepads();

	    META.OPTIONS = options = options || new InitOptions();

	    var webglFlags = {
	        antialias: false,   // we're rendering to texture by default, so native AA has no effect
	        alpha: META.OPTIONS.transparentBackground,
	        // we render offscreen, so no depth/stencil needed in backbuffer
	        depth: false,
	        stencil: false,
	        premultipliedAlpha: false,
	        preserveDrawingBuffer: META.OPTIONS.preserveDrawingBuffer
	    };

	    var defines = "";
	    var gl;

	    if (options.webgl2)
	        gl = canvas.getContext('webgl2', webglFlags);

	    if (gl) {
	        capabilities.WEBGL_2 = true;
	        console.log("WebGL 2 supported!");
	        GLSLIncludes.VERSION = "#version 300 es\n";
	        defines += "#define HX_GLSL_300_ES\n";

	        // throw away all the dynamic passes
	        MaterialPass.NUM_PASS_TYPES = 4;
	    }
	    else {
	        gl = canvas.getContext('webgl', webglFlags) || canvas.getContext('experimental-webgl', webglFlags);
	    }

	    if (!gl) throw new Error("WebGL not supported");
	    GL._setGL(gl);

	    META.INITIALIZED = true;

	    var glExtensions = gl.getSupportedExtensions();

	    function _getExtension(name)
	    {

	        var ext = glExtensions.indexOf(name) >= 0 ? gl.getExtension(name) : null;
	        if (!ext) console.warn(name + ' extension not supported!');
	        return ext;
	    }

	    // shortcuts
	    _initGLProperties();

	    if (options.useGammaCorrection !== false)
	        defines += META.OPTIONS.usePreciseGammaCorrection ? "#define HX_GAMMA_CORRECTION_PRECISE\n" : "#define HX_GAMMA_CORRECTION_FAST\n";

	    defines += "#define HX_NUM_SHADOW_CASCADES " + META.OPTIONS.numShadowCascades + "\n";
	    defines += "#define HX_MAX_SKELETON_JOINTS " + META.OPTIONS.maxSkeletonJoints + "\n";

	    capabilities.EXT_DRAW_BUFFERS = capabilities.WEBGL_2? true : _getExtension('WEBGL_draw_buffers');
	    // can assume this exists
	    capabilities.EXT_FLOAT_TEXTURES = capabilities.WEBGL_2? true : _getExtension('OES_texture_float');
	    capabilities.EXT_FLOAT_TEXTURES_LINEAR = _getExtension('OES_texture_float_linear');
	    capabilities.EXT_HALF_FLOAT_TEXTURES = capabilities.WEBGL_2? true : _getExtension('OES_texture_half_float');
	    capabilities.EXT_HALF_FLOAT_TEXTURES_LINEAR = _getExtension('OES_texture_half_float_linear');

	    // try webgl 2 extension first (will return null if no webgl 2 context is present anyway)
	    capabilities.EXT_COLOR_BUFFER_FLOAT = _getExtension("EXT_color_buffer_float") || _getExtension('WEBGL_color_buffer_float');
	    capabilities.EXT_COLOR_BUFFER_HALF_FLOAT = _getExtension('EXT_color_buffer_float') || _getExtension('EXT_color_buffer_half_float');
	    capabilities.EXT_DEPTH_TEXTURE = _getExtension('WEBGL_depth_texture');
	    capabilities.EXT_STANDARD_DERIVATIVES = _getExtension('OES_standard_derivatives');
	    capabilities.EXT_SHADER_TEXTURE_LOD = _getExtension('EXT_shader_texture_lod');
	    capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC = _getExtension('EXT_texture_filter_anisotropic');
	    capabilities.EXT_ELEMENT_INDEX_UINT = _getExtension('OES_element_index_uint');
	    capabilities.DEFAULT_TEXTURE_MAX_ANISOTROPY = capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC ? gl.getParameter(capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;

	    if (capabilities.EXT_FLOAT_TEXTURES)
	        defines += "#define HX_FLOAT_TEXTURES\n";
	    else
	        options.useSkinningTexture = false;

	    if (capabilities.EXT_FLOAT_TEXTURES_LINEAR)
	        defines += "#define HX_FLOAT_TEXTURES_LINEAR\n";

	    if (capabilities.EXT_HALF_FLOAT_TEXTURES) {
	        defines += "#define HX_HALF_FLOAT_TEXTURES\n";
	        DataType.HALF_FLOAT = capabilities.WEBGL_2? gl.HALF_FLOAT : capabilities.EXT_HALF_FLOAT_TEXTURES.HALF_FLOAT_OES;
	    }

	    if (capabilities.WEBGL_2 || capabilities.EXT_HALF_FLOAT_TEXTURES_LINEAR)
	        defines += "#define HX_HALF_FLOAT_TEXTURES_LINEAR\n";
	    else
	        options.hdr = false;

	    // Common WebGL 1 bug, where EXT_COLOR_BUFFER_FLOAT is false, but float render targets are in fact supported
	    if (!capabilities.EXT_COLOR_BUFFER_FLOAT) {
	        capabilities.EXT_COLOR_BUFFER_FLOAT = _tryFBO(DataType.FLOAT);
	        if (!capabilities.EXT_COLOR_BUFFER_FLOAT)
	            console.warn("Float FBOs not supported");
	    }

	    if (!capabilities.EXT_COLOR_BUFFER_HALF_FLOAT) {
	        capabilities.EXT_COLOR_BUFFER_HALF_FLOAT = _tryFBO(DataType.HALF_FLOAT);
	        if (!capabilities.EXT_COLOR_BUFFER_HALF_FLOAT)
	            console.warn("HalfFloat FBOs not supported");
	    }

	    if (!capabilities.EXT_DEPTH_TEXTURE)
	        defines += "#define HX_NO_DEPTH_TEXTURES\n";

	    if (capabilities.EXT_SHADER_TEXTURE_LOD)
	        defines += "#define HX_TEXTURE_LOD\n";

	    //EXT_SRGB = _getExtension('EXT_sRGB');
	    //if (!EXT_SRGB) console.warn('EXT_sRGB extension not supported!');

	    capabilities.HDR_FORMAT = options.hdr ? DataType.HALF_FLOAT : gl.UNSIGNED_BYTE;

	    if (options.useSkinningTexture) {
	        defines += "#define HX_USE_SKINNING_TEXTURE\n";

	        _initDefaultSkinningTexture();
	    }

	    Texture2D._initDefault();
	    TextureCube._initDefault();
	    BlendState._initDefaults();
	    RectMesh._initDefault();
	    PoissonDisk._initDefault();
	    PoissonSphere._initDefault();

	    _init2DDitherTexture(32, 32);

	    if (options.ambientOcclusion) {
	        defines += "#define HX_SSAO\n";
	        options.ambientOcclusion.init();
	    }

	    GLSLIncludes.GENERAL = defines + GLSLIncludes.GENERAL;

	    // default copy shader
	    // TODO: Provide a default copy mechanic, can be replaced with blit in WebGL 2.0
	    DEFAULTS.COPY_SHADER = new CopyChannelsShader();

	    GL.setClearColor(Color.BLACK);

	    start();
	}

	function _onFrameTick(dt)
	{
	    var startTime = (performance || Date).now();

	    updateGamepads();
	    _clearGLStats();
	    onPreFrame.dispatch(dt);

	    // VR stopped presenting (present change event doesn't seem reliable)
	    if (isVRPresenting() && !META.VR_DISPLAY.isPresenting) {
	        console.log("VR device stopped presenting, disabling VR");
			disableVR();
		}

	    if (!META.VR_DISPLAY)
			_updateCanvasSize();

	    onFrame.dispatch(dt);

	    if (META.VR_DISPLAY && META.VR_DISPLAY.isPresenting)
	        META.VR_DISPLAY._display.submitFrame();

	    frameTime = (performance || Date).now() - startTime;
	}

	function _updateCanvasSize()
	{
	    // helix does NOT adapt the size automatically, so you can have complete control over the resolution
	    var dpr = window.devicePixelRatio || 1;

	    var canvas = META.TARGET_CANVAS;

	    var w = Math.round(canvas.clientWidth * dpr);
	    var h = Math.round(canvas.clientHeight * dpr);

	    if (canvas.width !== w || canvas.height !== h) {
	        canvas.width = w;
	        canvas.height = h;
		}
	}

	/**
	 * This destroys Helix. Any resources created will become invalid.
	 */
	function destroy()
	{
	    stop();
	    META.INITIALIZED = false;
	    onFrame.unbindAll();
	    onPreFrame.unbindAll();
	    GL._setGL(null);
	}

	/**
	 * Starts the Helix loop (happens automatically).
	 */
	function start()
	{
	    frameTicker.start();
	}

	/**
	 * Stops the Helix loop.
	 */
	function stop()
	{
	    frameTicker.stop();
	}

	function _initDefaultSkinningTexture()
	{
	    DEFAULTS.DEFAULT_SKINNING_TEXTURE = new Texture2D();

	    var data = [];
	    for (var i = 0; i < META.OPTIONS.maxSkeletonJoints; ++i)
	        data.push(1, 0, 0, 0);

	    for (i = 0; i < META.OPTIONS.maxSkeletonJoints; ++i)
	        data.push(0, 1, 0, 0);

	    for (i = 0; i < META.OPTIONS.maxSkeletonJoints; ++i)
	        data.push(0, 0, 1, 0);

	    DEFAULTS.DEFAULT_SKINNING_TEXTURE.uploadData(new Float32Array(data), META.OPTIONS.maxSkeletonJoints, 3, false, TextureFormat.RGBA, DataType.FLOAT);
	    DEFAULTS.DEFAULT_SKINNING_TEXTURE.filter = TextureFilter.NEAREST_NOMIP;
	    DEFAULTS.DEFAULT_SKINNING_TEXTURE.wrapMode = TextureWrapMode.CLAMP;
	}

	function _init2DDitherTexture(width, height)
	{
	    var len = width * height;
	    var minValue = 1.0 / len;
	    var data = [];
	    var k = 0;
	    var values = [];
	    var i;

	    for (i = 0; i < len; ++i) {
	        values.push(i / len);
	    }

	    ArrayUtils.shuffle(values);

	    for (i = 0; i < len; ++i) {
	        var angle = values[i] * Math.PI * 2.0;
	        var cos = Math.cos(angle);
	        var sin = Math.sin(angle);
	        // store rotation matrix
	        // RGBA:
	        data[k++] = cos;
	        data[k++] = sin;
	        data[k++] = minValue + values[i];
	        data[k++] = 1.0;
	    }

	    DEFAULTS.DEFAULT_2D_DITHER_TEXTURE = new Texture2D();
	    DEFAULTS.DEFAULT_2D_DITHER_TEXTURE.filter = TextureFilter.NEAREST_NOMIP;
	    DEFAULTS.DEFAULT_2D_DITHER_TEXTURE.wrapMode = TextureWrapMode.REPEAT;

	    if (capabilities.EXT_FLOAT_TEXTURES)
	        DEFAULTS.DEFAULT_2D_DITHER_TEXTURE.uploadData(new Float32Array(data), width, height, false, TextureFormat.RGBA, DataType.FLOAT);
	    else {
	        len = data.length;

	        for (i = 0; i < len; ++i)
	            data[i] = Math.round((data[i] * .5 + .5) * 0xff);

	        DEFAULTS.DEFAULT_2D_DITHER_TEXTURE.uploadData(new Uint8Array(data), width, height, false, TextureFormat.RGBA, DataType.UNSIGNED_BYTE);
	    }

	    // this one is used when dynamic light probes passes need to disable a map
	    DEFAULTS.DARK_CUBE_TEXTURE = new TextureCube();
	    data = new Uint8Array([0x00, 0x00, 0x00, 0x00]);
	    data = [ data, data, data, data, data, data ];
	    DEFAULTS.DARK_CUBE_TEXTURE.uploadData(data, 1, true);
	}


	function _initGLProperties()
	{
	    var gl = GL.gl;
	    TextureFilter.NEAREST = {min: gl.NEAREST_MIPMAP_NEAREST, mag: gl.NEAREST};
	    TextureFilter.BILINEAR = {min: gl.LINEAR_MIPMAP_NEAREST, mag: gl.LINEAR};
	    TextureFilter.TRILINEAR = {min: gl.LINEAR_MIPMAP_LINEAR, mag: gl.LINEAR};

	    if (capabilities.EXT_TEXTURE_FILTER_ANISOTROPIC)
	        TextureFilter.TRILINEAR_ANISOTROPIC = {min: gl.LINEAR_MIPMAP_LINEAR, mag: gl.LINEAR};


	    TextureFilter.NEAREST_NOMIP = {min: gl.NEAREST, mag: gl.NEAREST};
	    TextureFilter.BILINEAR_NOMIP = {min: gl.LINEAR, mag: gl.LINEAR};

	    TextureWrapMode.REPEAT = {s: gl.REPEAT, t: gl.REPEAT};
	    TextureWrapMode.CLAMP = {s: gl.CLAMP_TO_EDGE, t: gl.CLAMP_TO_EDGE};

	    // default settings:
	    TextureWrapMode.DEFAULT = TextureWrapMode.REPEAT;
	    TextureFilter.DEFAULT = TextureFilter.TRILINEAR;

	    StencilOp.KEEP = gl.KEEP;
	    StencilOp.ZERO = gl.ZERO;
	    StencilOp.REPLACE = gl.REPLACE;
	    StencilOp.INCREMENT = gl.INCR;
	    StencilOp.INCREMENT_WRAP = gl.INCR_WRAP;
	    StencilOp.DECREMENT = gl.DECR;
	    StencilOp.DECREMENT_WRAP = gl.DECR_WRAP;
	    StencilOp.INVERT = gl.INVERT;

	    Comparison.DISABLED = null;
	    Comparison.ALWAYS = gl.ALWAYS;
	    Comparison.NEVER = gl.NEVER;
	    Comparison.LESS = gl.LESS;
	    Comparison.EQUAL = gl.EQUAL;
	    Comparison.LESS_EQUAL = gl.LEQUAL;
	    Comparison.GREATER = gl.GREATER;
	    Comparison.NOT_EQUAL = gl.NOTEQUAL;
	    Comparison.GREATER_EQUAL = gl.GEQUAL;

	    ElementType.POINTS = gl.POINTS;
	    ElementType.LINES = gl.LINES;
	    ElementType.LINE_STRIP = gl.LINE_STRIP;
	    ElementType.LINE_LOOP = gl.LINE_LOOP;
	    ElementType.TRIANGLES = gl.TRIANGLES;
	    ElementType.TRIANGLE_STRIP = gl.TRIANGLE_STRIP;
	    ElementType.TRIANGLE_FAN = gl.TRIANGLE_FAN;

	    BlendFactor.ZERO = gl.ZERO;
	    BlendFactor.ONE = gl.ONE;
	    BlendFactor.SOURCE_COLOR = gl.SRC_COLOR;
	    BlendFactor.ONE_MINUS_SOURCE_COLOR = gl.ONE_MINUS_SRC_COLOR;
	    BlendFactor.DESTINATION_COLOR = gl.DST_COLOR;
	    BlendFactor.ONE_MINUS_DESTINATION_COLOR = gl.ONE_MINUS_DST_COLOR;
	    BlendFactor.SOURCE_ALPHA = gl.SRC_ALPHA;
	    BlendFactor.ONE_MINUS_SOURCE_ALPHA = gl.ONE_MINUS_SRC_ALPHA;
	    BlendFactor.DESTINATION_ALPHA = gl.DST_ALPHA;
	    BlendFactor.ONE_MINUS_DESTINATION_ALPHA = gl.ONE_MINUS_DST_ALPHA;
	    BlendFactor.SOURCE_ALPHA_SATURATE = gl.SRC_ALPHA_SATURATE;
	    BlendFactor.CONSTANT_ALPHA = gl.CONSTANT_ALPHA;
	    BlendFactor.ONE_MINUS_CONSTANT_ALPHA = gl.ONE_MINUS_CONSTANT_ALPHA;

	    BlendOperation.ADD = gl.FUNC_ADD;
	    BlendOperation.SUBTRACT = gl.FUNC_SUBTRACT;
	    BlendOperation.REVERSE_SUBTRACT = gl.FUNC_REVERSE_SUBTRACT;

	    ClearMask.COLOR = gl.COLOR_BUFFER_BIT;
	    ClearMask.STENCIL = gl.STENCIL_BUFFER_BIT;
	    ClearMask.DEPTH = gl.DEPTH_BUFFER_BIT;
	    ClearMask.COMPLETE = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT;

	    TextureFormat.RGBA = gl.RGBA;
	    TextureFormat.RGB = gl.RGB;
	    TextureFormat.RG = gl.RG;   // only assigned if available (WebGL 2)

	    DataType.UNSIGNED_BYTE = gl.UNSIGNED_BYTE;
	    DataType.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
	    DataType.UNSIGNED_INT = gl.UNSIGNED_INT;
	    DataType.FLOAT = gl.FLOAT;
	    DataType.HALF_FLOAT = gl.HALF_FLOAT;    // possibly set later, if supported

	    BufferUsage.STATIC_DRAW = gl.STATIC_DRAW;
	    BufferUsage.DYNAMIC_DRAW = gl.DYNAMIC_DRAW;

	    // notice that cube face has Y and Z flipped to match with Helix' RH Z-up coordinate system
	    CubeFace.POSITIVE_X = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
	    CubeFace.NEGATIVE_X = gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
	    CubeFace.POSITIVE_Y = gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
	    CubeFace.NEGATIVE_Y = gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
	    CubeFace.POSITIVE_Z = gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
	    CubeFace.NEGATIVE_Z = gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
	}

	function _tryFBO(dataType)
	{
	    var tex = new Texture2D();
	    tex.initEmpty(8, 8, null, dataType);
	    var fbo = new FrameBuffer(tex);
	    return fbo.init(true);
	}

	/**
	 * @classdesc
	 * CenteredGaussianCurve is a class that can be used to generate values from a gaussian curve symmetrical to the Y-axis.
	 *
	 * @constructor
	 * @param variance The variance of the distribution.
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function CenteredGaussianCurve(variance)
	{
	    this._amplitude = 1.0 / Math.sqrt(2.0 * variance * Math.PI);
	    this._expScale = -1.0 / (2.0 * variance);
	}

	CenteredGaussianCurve.prototype =
	{
	    /**
	     * Gets the y-value of the curve at the given x-coordinate.
	     */
	    getValueAt: function(x)
	    {
	        return this._amplitude * Math.pow(Math.E, x*x*this._expScale);
	    }
	};

	/**
	 * Creates a CenteredGaussianCurve with a given "radius" of influence.
	 * @param radius The "radius" of the curve.
	 * @param epsilon The minimum value to still be considered within the radius.
	 * @returns {CenteredGaussianCurve} The curve with the given radius.
	 */
	CenteredGaussianCurve.fromRadius = function(radius, epsilon)
	{
	    epsilon = epsilon || .01;
	    var standardDeviation = radius / Math.sqrt(-2.0 * Math.log(epsilon));
	    return new CenteredGaussianCurve(standardDeviation*standardDeviation);
	};

	/**
	 * @classdesc
	 * Ray class bundles an origin point and a direction vector for ray-intersection tests.
	 *
	 * @constructor
	 */
	function Ray()
	{
	    /**
	     * The origin point of the ray.
	     */
	    this.origin = new Float4(0, 0, 0, 1);

	    /**
	     * The direction vector of the ray.
	     */
	    this.direction = new Float4(0, 0, 0, 0);
	}

	Ray.prototype =
	{
	    /**
	     * Transforms a given ray and stores it in this one.
	     * @param ray The ray to transform.
	     * @param matrix The matrix containing the transformation.
	     */
	    transformFrom: function(ray, matrix)
	    {
	        matrix.transformPoint(ray.origin, this.origin);
	        matrix.transformVector(ray.direction, this.direction);
	        this.direction.normalize();
	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        return "Ray(\n" +
	                "origin: " + this.origin.toString() + "\n" +
	                "direction: " + this.direction.toString() + "\n" +
	                ")";
	    }
	};

	/**
	 * @classdesc
	 * NormalTangentGenerator generates normal and/or tangent vectors for a {@codelink Mesh}.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function NormalTangentGenerator()
	{
	    this._flip = false;
	    this._mesh = null;
	    this._mode = 0;
	    this._faceNormals = null;
	    this._faceTangents = null;
	    this._faceBitangents = null;
	}

	/**
	 * A bit flag to generate normal vectors
	 */
	NormalTangentGenerator.MODE_NORMALS = 1;

	/**
	 * A bit flag to generate tangent vectors
	 */
	NormalTangentGenerator.MODE_TANGENTS = 2;

	NormalTangentGenerator.prototype =
	{
	    /**
	     * Generates normal and/or tangent vectors for a {@codelink Mesh}.
	     * @param mesh The target {@codelink Mesh}
	     * @param mode Defines which vectors to use. Use {@linkcode NormalTangentGenerator#MODE_NORMALS} | {@linkcode NormalTangentGenerator#MODE_TANGENTS}
	     * @param [useFaceWeights] Defines whether or not the face sizes should play a role in how much weight their contribute to the vertex normal.
	     * @param [flip] Defines whether or not the face normals should be flipped. Could be required for some mirrored scaling.
	     */
	    generate: function(mesh, mode, useFaceWeights, flip)
	    {
	        if (useFaceWeights === undefined) useFaceWeights = true;
	        this._mode = mode === undefined? NormalTangentGenerator.MODE_NORMALS | NormalTangentGenerator.MODE_TANGENTS : mode;

	        this._flip = flip || false;

	        this._mesh = mesh;

	        this._positionAttrib = mesh.getVertexAttributeByName("hx_position");
	        this._normalAttrib = mesh.getVertexAttributeByName("hx_normal");
	        this._tangentAttrib = mesh.getVertexAttributeByName("hx_tangent");
	        this._uvAttrib = mesh.getVertexAttributeByName("hx_texCoord");
	        this._positionStride = mesh.getVertexStride(this._positionAttrib.streamIndex);
	        this._normalStride = mesh.getVertexStride(this._normalAttrib.streamIndex);
	        this._tangentStride = mesh.getVertexStride(this._tangentAttrib.streamIndex);
	        this._uvStride = mesh.getVertexStride(this._uvAttrib.streamIndex);

	        this._calculateFaceVectors(useFaceWeights);
	        this._calculateVertexVectors();
	    },

	    _calculateFaceVectors: function(useFaceWeights)
	    {
	        var numIndices = this._mesh._indexData.length;

	        if ((this._mode & NormalTangentGenerator.MODE_NORMALS) !== 0) this._faceNormals = new Array(numIndices);
	        if ((this._mode & NormalTangentGenerator.MODE_TANGENTS) !== 0) {
	            this._faceTangents = new Array(numIndices);
	            this._faceBitangents = new Array(numIndices);
	        }

	        var temp = new Float4();
	        var temp1 = new Float4();
	        var temp2 = new Float4();
	        var v0 = new Float4();
	        var v1 = new Float4();
	        var v2 = new Float4();
	        var uv0 = new Float2();
	        var uv1 = new Float2();
	        var uv2 = new Float2();
	        var st1 = new Float2();
	        var st2 = new Float2();

	        var posOffset = this._positionAttrib.offset;
	        var uvOffset = this._uvAttrib.offset;
	        var posData = this._mesh.getVertexData(this._positionAttrib.streamIndex);
	        var uvData = this._mesh.getVertexData(this._uvAttrib.streamIndex);

	        for (var i = 0; i < numIndices; i += 3) {
	            this._getFloat3At(i, posOffset, this._positionStride, v0, posData);
	            this._getFloat3At(i + 1, posOffset, this._positionStride, v1, posData);
	            this._getFloat3At(i + 2, posOffset, this._positionStride, v2, posData);
	            this._getFloat2At(i, uvOffset, this._uvStride, uv0, uvData);
	            this._getFloat2At(i + 1, uvOffset, this._uvStride, uv1, uvData);
	            this._getFloat2At(i + 2, uvOffset, this._uvStride, uv2, uvData);

	            v1.subtract(v0);
	            v2.subtract(v0);

	            if (this._faceNormals) {
	                if (this._flip)
	                    Float4.cross(v2, v1, temp);
	                else
	                    Float4.cross(v1, v2, temp);

	                if (!useFaceWeights) temp.normalize();

	                this._faceNormals[i] = temp.x;
	                this._faceNormals[i + 1] = temp.y;
	                this._faceNormals[i + 2] = temp.z;
	            }

	            if (this._faceTangents) {
	                //var div = ((uv1.x - uv0.x)*(uv2.y - uv0.y) - (uv1.y - uv0.y)*(uv2.x - uv0.x));
	                Float2.subtract(uv1, uv0, st1);
	                Float2.subtract(uv2, uv0, st2);

	                Float4.scale(v1, st2.y, temp1);
	                Float4.scale(v2, st1.y, temp2);
	                Float4.subtract(temp1, temp2, temp);

	                if (temp.lengthSqr > .001)
	                    temp.normalize();

	                this._faceTangents[i] = temp.x;
	                this._faceTangents[i + 1] = temp.y;
	                this._faceTangents[i + 2] = temp.z;

	                Float4.scale(v1, st2.x, temp1);
	                Float4.scale(v2, st1.x, temp1);
	                Float4.subtract(temp2, temp1, temp);
	                // no need to normalize bitangent, just need it for orientation

	                this._faceBitangents[i] = temp.x;
	                this._faceBitangents[i + 1] = temp.y;
	                this._faceBitangents[i + 2] = temp.z;
	            }
	        }
	    },

	    _calculateVertexVectors: function()
	    {
	        this._zeroVectors();

	        var bitangents = this._faceTangents ? [] : null;
	        var indexData = this._mesh._indexData;
	        var normalOffset = this._normalAttrib.offset;
	        var tangentOffset = this._tangentAttrib.offset;
	        var normalData = this._mesh.getVertexData(this._normalAttrib.streamIndex);
	        var tangentData = this._mesh.getVertexData(this._tangentAttrib.streamIndex);
	        var numIndices = indexData.length;

	        for (var i = 0; i < numIndices; ++i) {
	            var index = indexData[i];
	            var normalIndex = normalOffset + index * this._normalStride;
	            var tangentIndex = tangentOffset + index * this._tangentStride;
	            var bitangentIndex = index * 3;
	            var faceIndex = Math.floor(i / 3) * 3;

	            if (this._faceNormals) {
	                normalData[normalIndex] += this._faceNormals[faceIndex];
	                normalData[normalIndex + 1] += this._faceNormals[faceIndex + 1];
	                normalData[normalIndex + 2] += this._faceNormals[faceIndex + 2];
	            }

	            if (this._faceTangents) {
	                tangentData[tangentIndex] += this._faceTangents[faceIndex];
	                tangentData[tangentIndex + 1] += this._faceTangents[faceIndex + 1];
	                tangentData[tangentIndex + 2] += this._faceTangents[faceIndex + 2];

	                bitangents[bitangentIndex] += this._faceBitangents[faceIndex];
	                bitangents[bitangentIndex + 1] += this._faceBitangents[faceIndex + 1];
	                bitangents[bitangentIndex + 2] += this._faceBitangents[faceIndex + 2];
	            }
	        }

	        this._normalize(bitangents);
	    },

	    _zeroVectors: function()
	    {
	        var normalData = this._mesh.getVertexData(this._normalAttrib.streamIndex);
	        var tangentData = this._mesh.getVertexData(this._tangentAttrib.streamIndex);
	        var normalStride = this._mesh.getVertexStride(this._normalAttrib.streamIndex);
	        var tangentStride = this._mesh.getVertexStride(this._tangentAttrib.streamIndex);
	        var numVertices = normalData.length / normalStride;
	        var normalIndex = this._normalAttrib.offset;
	        var tangentIndex = this._tangentAttrib.offset;

	        for (var i = 0; i < numVertices; ++i) {
	            if (this._mode & NormalTangentGenerator.MODE_NORMALS) {
	                normalData[normalIndex] = 0.0;
	                normalData[normalIndex + 1] = 0.0;
	                normalData[normalIndex + 2] = 0.0;
	            }
	            if (this._mode & NormalTangentGenerator.MODE_TANGENTS) {
	                tangentData[tangentIndex] = 0.0;
	                tangentData[tangentIndex + 1] = 0.0;
	                tangentData[tangentIndex + 2] = 0.0;
	            }
	            normalIndex += normalStride;
	            tangentIndex += tangentStride;
	        }
	    },

	    _normalize: function(bitangents)
	    {
	        var normalData = this._mesh.getVertexData(this._normalAttrib.streamIndex);
	        var tangentData = this._mesh.getVertexData(this._tangentAttrib.streamIndex);
	        var numVertices = normalData.length / this._normalStride;
	        var normalIndex = this._normalAttrib.offset;
	        var tangentIndex = this._tangentAttrib.offset;
	        var bitangentIndex = 0;
	        var normal = new Float4();
	        var tangent = new Float4();
	        var bitangent = new Float4();
	        var cross = new Float4();

	        for (var i = 0; i < numVertices; ++i) {
	            normal.x = normalData[normalIndex];
	            normal.y = normalData[normalIndex + 1];
	            normal.z = normalData[normalIndex + 2];

	            if (this._mode & NormalTangentGenerator.MODE_NORMALS) {
	                normal.normalize();
	                normalData[normalIndex] = normal.x;
	                normalData[normalIndex + 1] = normal.y;
	                normalData[normalIndex + 2] = normal.z;
	            }
	            if (this._mode & NormalTangentGenerator.MODE_TANGENTS) {
	                tangent.x = tangentData[tangentIndex];
	                tangent.y = tangentData[tangentIndex + 1];
	                tangent.z = tangentData[tangentIndex + 2];

	                // can happen in singularities
	                if (tangent.lengthSqr < 0.0001)
	                    tangent.set(1.0, 1.0, 1.0, 1.0);
	                else
	                    tangent.normalize();

	                bitangent.x = bitangents[bitangentIndex];
	                bitangent.y = bitangents[bitangentIndex + 1];
	                bitangent.z = bitangents[bitangentIndex + 2];
	                Float4.cross(normal, tangent, cross);

	                tangentData[tangentIndex] = tangent.x;
	                tangentData[tangentIndex + 1] = tangent.y;
	                tangentData[tangentIndex + 2] = tangent.z;
	                tangentData[tangentIndex + 3] = bitangent.dot3(cross) > 0.0? -1.0 : 1.0;
	            }

	            normalIndex += this._normalStride;
	            tangentIndex += this._tangentStride;
	        }

	        this._mesh.setVertexData(normalData, this._normalAttrib.streamIndex);
	        if (this._normalAttrib.streamIndex !== this._tangentAttrib.streamIndex)
	            this._mesh.setVertexData(tangentData, this._tangentAttrib.streamIndex);
	    },

	    _getFloat3At: function(i, offset, stride, target, data)
	    {
	        var indices = this._mesh._indexData;
	        var posIndex = offset + indices[i] * stride;
	        target.x = data[posIndex];
	        target.y = data[posIndex + 1];
	        target.z = data[posIndex + 2];
	    },

	    _getFloat2At: function(i, offset, stride, target, data)
	    {
	        var indices = this._mesh._indexData;
	        var posIndex = offset + indices[i] * stride;
	        target.x = data[posIndex];
	        target.y = data[posIndex + 1];
	    }
	};

	/**
	 * @ignore
	 * @param definition
	 * @constructor
	 *
	 * @extends Mesh
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Primitive(definition)
	{
		Mesh.call(this);

		definition = definition || {};
		this._createMesh(definition);

	    this.bounds = this._getBounds();
	}

	Primitive._ATTRIBS = function()
	{
	    this.positions = [];
	    this.uvs = null;
	    this.normals = null;
	    this.vertexColors = null;
	    this.indices = [];
	};

	Primitive.prototype = Object.create(Mesh.prototype);

	Primitive.prototype._generate = function(target, definition)
	{
	    throw new Error("Abstract method called!");
	};

	Primitive.prototype._createMesh = function(definition)
	{
	    var attribs = new Primitive._ATTRIBS();
	    var uvs = definition.uvs === undefined? true : definition.uvs;
	    var normals = definition.normals === undefined? true : definition.normals;
	    var tangents = definition.tangents === undefined? true : definition.tangents;
	    // depends on the primitive type

	    this.addVertexAttribute('hx_position', 3);

	    if (normals) {
			this.addVertexAttribute('hx_normal', 3);
	        attribs.normals = [];
	    }

	    if (tangents)
			this.addVertexAttribute('hx_tangent', 4);

	    if (uvs) {
			this.addVertexAttribute('hx_texCoord', 2);
	        attribs.uvs = [];
	    }

	    this._generate(attribs, definition);

	    var vertexColors = attribs.vertexColors;
	    if (vertexColors) {
			this.addVertexAttribute('hx_vertexColor', 3);
	    }

	    var scaleU = definition.scaleU || 1;
	    var scaleV = definition.scaleV || 1;

	    var len = attribs.positions.length / 3;
	    var v = 0, v2 = 0, v3 = 0;
	    var vertices = [];

	    for (var i = 0; i < len; ++i) {
	        vertices[v++] = attribs.positions[v3];
	        vertices[v++] = attribs.positions[v3 + 1];
	        vertices[v++] = attribs.positions[v3 + 2];

	        if (normals) {
	            vertices[v++] = attribs.normals[v3];
	            vertices[v++] = attribs.normals[v3 + 1];
	            vertices[v++] = attribs.normals[v3 + 2];
	        }

	        if (tangents)
	            v += 4;

	        if (uvs) {
	            vertices[v++] = attribs.uvs[v2++] * scaleU;
	            vertices[v++] = attribs.uvs[v2++] * scaleV;
	        }

	        if (vertexColors) {
	            vertices[v++] = attribs.vertexColors[v3];
	            vertices[v++] = attribs.vertexColors[v3 + 1];
	            vertices[v++] = attribs.vertexColors[v3 + 2];
	        }

	        v3 += 3;
	    }

		this.setVertexData(vertices, 0);
		this.setIndexData(attribs.indices);

	    var mode = 0;

	    // if data isn't provided, generate it manually
	    if (normals && attribs.normals.length === 0)
	        mode |= NormalTangentGenerator.MODE_NORMALS;

	    if (tangents)
	        mode |= NormalTangentGenerator.MODE_TANGENTS;

	    if (mode) {
	        var generator = new NormalTangentGenerator();
	        generator.generate(this, mode);
	    }
	};

	Primitive.prototype._getBounds = function()
	{
	    return new BoundingAABB();
	};

	/**
	 * @classdesc
	 * CylinderPrimitive provides a primitive cylinder {@linkcode Model}.
	 *
	 * @constructor
	 * @param definition An object containing the following (optional) parameters:
	 * <ul>
	 *     <li>numSegmentsW: The amount of horizontal segments</li>
	 *     <li>numSegmentsH: The amount of vertical segments </li>
	 *     <li>radius: The radius of the cylinder</li>
	 *     <li>height: The height of the cylinder</li>
	 *     <li>doubleSided: Whether or not the faces should point both ways</li>
	 *     <li>alignment: The axis along which to orient the cylinder. One of {@linkcode CylinderPrimitive#ALIGN_X}, {@linkcode CylinderPrimitive#ALIGN_Y}, {@linkcode CylinderPrimitive#ALIGN_Z}</li>
	 * </ul>
	 *
	 * @extends Primitive
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function CylinderPrimitive(definition)
	{
	    Primitive.call(this, definition);
	}

	CylinderPrimitive.prototype = Object.create(Primitive.prototype);

	/**
	 * The alignment dictates which access should be parallel to the sides of the cylinder
	 * @type {number}
	 */
	CylinderPrimitive.ALIGN_X = 1;
	CylinderPrimitive.ALIGN_Y = 2;
	CylinderPrimitive.ALIGN_Z = 3;

	/**
	 * @ignore
	 */
	CylinderPrimitive.prototype._generate = function(target, definition)
	{
	    definition = definition || {};
	    var alignment = definition.alignment || CylinderPrimitive.ALIGN_Z;
	    var numSegmentsH = definition.numSegmentsH || 1;
	    var numSegmentsW = definition.numSegmentsW || 16;
	    var radius = definition.radius || .5;
	    var height = definition.height || 1;
	    var doubleSided = definition.doubleSided === undefined? false : definition.doubleSided;

	    var positions = target.positions;
	    var uvs = target.uvs;
	    var normals = target.normals;
	    var indices = target.indices;

	    var rcpNumSegmentsW = 1/numSegmentsW;
	    var rcpNumSegmentsH = 1/numSegmentsH;
	    var hi, ci;
	    var cx, cy;
	    var angle;

	    // sides
	    for (hi = 0; hi <= numSegmentsH; ++hi) {
	        var h = (hi*rcpNumSegmentsH - .5)*height;
	        for (ci = 0; ci <= numSegmentsW; ++ci) {
	            angle = ci * rcpNumSegmentsW * Math.PI * 2;
	            var nx = Math.sin(angle);
	            var ny = Math.cos(angle);
	            cx = nx * radius;
	            cy = ny * radius;

	            switch (alignment) {
	                case CylinderPrimitive.ALIGN_X:
	                    positions.push(-h, cx, cy);
	                    if (normals) normals.push(0, nx, ny);
	                    break;
	                case CylinderPrimitive.ALIGN_Z:
	                    positions.push(cx, cy, -h);
	                    if (normals) normals.push(nx, ny, 0);
	                    break;
	                default:
	                    positions.push(cx, h, cy);
	                    if (normals) normals.push(nx, 0, ny);
	                    break;
	            }

	            if (uvs) uvs.push(1.0 - ci*rcpNumSegmentsW, hi*rcpNumSegmentsH);
	        }
	    }

	    for (hi = 0; hi < numSegmentsH; ++hi) {
	        for (ci = 0; ci < numSegmentsW; ++ci) {
	            var w = numSegmentsW + 1;
	            var base = ci + hi*w;

	            indices.push(base, base + w + 1, base + w);
	            indices.push(base, base + 1, base + w + 1);

	            if (doubleSided) {
	                indices.push(base, base + w, base + w + 1);
	                indices.push(base, base + w + 1, base + 1);
	            }
	        }
	    }


	    // top & bottom
	    var indexOffset = positions.length / 3;
	    var halfH = height * .5;
	    for (ci = 0; ci < numSegmentsW; ++ci) {
	        angle = ci * rcpNumSegmentsW * Math.PI * 2;
	        var u = Math.sin(angle);
	        var v = Math.cos(angle);
	        cx = u * radius;
	        cy = v * radius;

	        u = -u * .5 + .5;
	        v = v * .5 + .5;

	        switch (alignment) {
	            case CylinderPrimitive.ALIGN_X:
	                positions.push(halfH, cx, cy);
	                positions.push(-halfH, cx, cy);

	                if (normals) {
	                    normals.push(1, 0, 0);
	                    normals.push(-1, 0, 0);
	                }

	                if (uvs) {
	                    uvs.push(v, 1.0 - u);
	                    uvs.push(1.0 - v,  1.0 - u);
	                }
	                break;

	            case CylinderPrimitive.ALIGN_Z:
	                positions.push(cx, cy, halfH);
	                positions.push(cx, cy, -halfH);

	                if (normals) {
	                    normals.push(0, 0, 1);
	                    normals.push(0, 0, -1);
	                }

	                if (uvs) {
	                    uvs.push(u, v);
	                    uvs.push(1.0 - u, v);
	                }
	                break;
	            default:
	                positions.push(cx, -halfH, cy);
	                positions.push(cx, halfH, cy);

	                if (normals) {
	                    normals.push(0, -1, 0);
	                    normals.push(0, 1, 0);
	                }

	                if (uvs) {
	                    uvs.push(u, v);
	                    uvs.push(u, 1.0 - v);
	                }
	                break;
	        }
	    }

	    for (ci = 1; ci < numSegmentsW - 1; ++ci) {
	        var offset = ci << 1;
	        indices.push(indexOffset, indexOffset + offset + 2, indexOffset + offset);
	        indices.push(indexOffset + 1, indexOffset + offset + 1, indexOffset + offset + 3);
	    }
	};

	/**
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function UnlitPass(geometryVertex, geometryFragment)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment));
	}

	UnlitPass.prototype = Object.create(MaterialPass.prototype);

	UnlitPass.prototype._generateShader = function(geometryVertex, geometryFragment)
	{
	    var defines =
	        "#define HX_SKIP_NORMALS\n" +
	        "#define HX_SKIP_SPECULAR\n";
	    var fragmentShader = defines + ShaderLibrary.get("snippets_geometry.glsl") + "\n" + geometryFragment + "\n" + ShaderLibrary.get("material_unlit_fragment.glsl");
	    var vertexShader = defines + geometryVertex + "\n" + ShaderLibrary.get("material_unlit_vertex.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function DirectionalShadowPass(geometryVertex, geometryFragment)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment));
	}

	DirectionalShadowPass.prototype = Object.create(MaterialPass.prototype);

	DirectionalShadowPass.prototype._generateShader = function(geometryVertex, geometryFragment)
	{
	    var defines =
	        "#define HX_SKIP_NORMALS\n" +
	        "#define HX_SKIP_SPECULAR\n";
	    var fragmentShader = defines + ShaderLibrary.get("snippets_geometry.glsl") + "\n" + META.OPTIONS.shadowFilter.getGLSL() + "\n" + geometryFragment + "\n" + ShaderLibrary.get("material_dir_shadow_fragment.glsl");
	    var vertexShader = defines + geometryVertex + "\n" + ShaderLibrary.get("material_unlit_vertex.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @param lightingModel
	 * @param shadows
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function DirectionalLightingPass(geometryVertex, geometryFragment, lightingModel)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment, lightingModel));

	    this._colorLocation = this.getUniformLocation("hx_directionalLight.color");
	    this._dirLocation = this.getUniformLocation("hx_directionalLight.direction");

	    this._castShadowsLocation = this.getUniformLocation("hx_directionalLight.castShadows");
	    this._shadowMatricesLocation = this.getUniformLocation("hx_directionalLight.shadowMapMatrices[0]");
	    this._shadowSplitsLocation = this.getUniformLocation("hx_directionalLight.splitDistances");
	    this._depthBiasLocation = this.getUniformLocation("hx_directionalLight.depthBias");
	    this._maxShadowDistanceLocation = this.getUniformLocation("hx_directionalLight.maxShadowDistance");
	}

	DirectionalLightingPass.prototype = Object.create(MaterialPass.prototype);

	// the light is passed in as data
	DirectionalLightingPass.prototype.updatePassRenderState = function(camera, renderer, light)
	{
	    var dir = new Float4();
	    var matrix = new Matrix4x4();
	    var matrixData = new Float32Array(64);

	    return function(camera, renderer, light) {
	        var gl = GL.gl;
	        var col = light._scaledIrradiance;

	        gl.useProgram(this._shader._program);

	        camera.viewMatrix.transformVector(light.direction, dir);
	        gl.uniform3f(this._colorLocation, col.r, col.g, col.b);
	        gl.uniform3f(this._dirLocation, dir.x, dir.y, dir.z);
	        gl.uniform1i(this._castShadowsLocation, light.castShadows? 1 : 0);

	        if (light.castShadows) {
	            var numCascades = META.OPTIONS.numShadowCascades;
	            var splits = light._cascadeSplitDistances;
	            var k = 0;

	            for (var j = 0; j < numCascades; ++j) {
	                matrix.multiply(light.getShadowMatrix(j), camera.worldMatrix);
	                var m = matrix._m;
	                for (var l = 0; l < 16; ++l) {
	                    matrixData[k++] = m[l];
	                }
	            }

	            gl.uniformMatrix4fv(this._shadowMatricesLocation, false, matrixData);
	            gl.uniform4f(this._shadowSplitsLocation, splits[0], splits[1], splits[2], splits[3]);
	            gl.uniform1f(this._depthBiasLocation, light.depthBias);
	            gl.uniform1f(this._maxShadowDistanceLocation, splits[numCascades - 1]);
	        }

	        MaterialPass.prototype.updatePassRenderState.call(this, camera, renderer);
	    }
	}();

	DirectionalLightingPass.prototype._generateShader = function(geometryVertex, geometryFragment, lightingModel, shadows)
	{
	    var defines = {};
	    var vertexShader = geometryVertex + "\n" + ShaderLibrary.get("material_fwd_dir_vertex.glsl", defines);

	    var fragmentShader =
	        ShaderLibrary.get("snippets_geometry.glsl", defines) + "\n" +
	        lightingModel + "\n\n\n" +
	        META.OPTIONS.shadowFilter.getGLSL() + "\n" +
	        ShaderLibrary.get("directional_light.glsl") + "\n" +
	        geometryFragment + "\n" +
	        ShaderLibrary.get("material_fwd_dir_fragment.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * @classdesc
	 * This material pass renders all lighting in one fragment shader.
	 *
	 * @ignore
	 *
	 * @param geometryVertex
	 * @param geometryFragment
	 * @param lightingModel
	 * @param lights
	 * @constructor
	 */
	function ClusteredLitPass(geometryVertex, geometryFragment, lightingModel)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment, lightingModel));
	}

	ClusteredLitPass.prototype = Object.create(MaterialPass.prototype);

	ClusteredLitPass.prototype._generateShader = function (geometryVertex, geometryFragment, lightingModel)
	{
	    var extensions = "#derivatives\n";
	    var defines = {
	        HX_NUM_DIR_LIGHTS: META.OPTIONS.maxDirLights,
			HX_NUM_POINT_SPOT_LIGHTS: META.OPTIONS.maxPointSpotLights,
	        HX_NUM_LIGHT_PROBES: META.OPTIONS.maxLightProbes,
	        HX_CELL_STRIDE: META.OPTIONS.maxPointSpotLights + 1,
	        HX_NUM_CELLS_X: META.OPTIONS.numLightingCellsX,
	        HX_NUM_CELLS_Y: META.OPTIONS.numLightingCellsY,
			HX_CELL_ARRAY_LEN: Math.ceil(META.OPTIONS.numLightingCellsX * META.OPTIONS.numLightingCellsY * (META.OPTIONS.maxPointSpotLights + 1) / 4)
	    };

	    if (capabilities.EXT_SHADER_TEXTURE_LOD) {
	        extensions += "#texturelod\n";
	    }

	    var vertexShader = geometryVertex + "\n" + ShaderLibrary.get("material_fwd_clustered_vertex.glsl", defines);

	    var fragmentShader =
	        extensions +
	        ShaderLibrary.get("snippets_geometry.glsl") + "\n" +
	        lightingModel + "\n\n\n" +
	        META.OPTIONS.shadowFilter.getGLSL() + "\n" +
	        ShaderLibrary.get("directional_light.glsl", defines) + "\n" +
	        ShaderLibrary.get("point_light.glsl") + "\n" +
	        ShaderLibrary.get("spot_light.glsl") + "\n" +
	        ShaderLibrary.get("light_probe.glsl") + "\n" +
	        geometryFragment + "\n" +
	        ShaderLibrary.get("material_fwd_clustered_fragment.glsl");

	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * The base pass for dynamic lighting
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function DynamicLitBasePass(geometryVertex, geometryFragment)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment));
	}

	DynamicLitBasePass.prototype = Object.create(MaterialPass.prototype);

	DynamicLitBasePass.prototype._generateShader = function(geometryVertex, geometryFragment)
	{
	    // no normals or specular are needed
	    var defines =   "#define HX_SKIP_NORMALS\n" +
	                    "#define HX_SKIP_SPECULAR\n";
	    var fragmentShader = defines + ShaderLibrary.get("snippets_geometry.glsl") + "\n" + geometryFragment + "\n" + ShaderLibrary.get("material_fwd_base_fragment.glsl");
	    var vertexShader = defines + geometryVertex + "\n" + ShaderLibrary.get("material_fwd_base_vertex.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	// basic version is non-hierarchical, for use with lights etc


	var nameCounter$2 = 0;

	/**
	 * @classdesc
	 * <p>SceneNode is an empty hierarchical container for the scene graph. It can be attached to other SceneNode objects and
	 * have SceneNode objects attached to itself.</p>
	 *
	 * <p>SceneNode also functions as the base class for other scene graph objects, such as {@linkcode Entity}</p>
	 *
	 * @property {string} name The name of the scene node.
	 * @property {SceneNode} parent The parent of this node in the scene hierarchy.
	 * @property {number} numChildren The amount of children attached to this node.
	 * @property {boolean} isOnRoot Indicates whether this node is added directly to the scene root.
	 * @property {boolean} visible Defines whether or not this and any children attached to this node should be rendered or not.
	 * @property {boolean} raycast Defines whether or not this and any children attached to this node should be tested when raycasting.
	 * @property {Matrix4x4} worldMatrix The matrix transforming from the node's local space to world space.
	 *
	 * @see {@linkcode Scene}
	 *
	 * @constructor
	 *
	 * @extends Transform
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SceneNode()
	{
	    Transform.call(this);
	    this.meta = {};
	    this._name = "hx_scenenode_" + (nameCounter$2++);
	    this._matrixInvalid = true;
		this._worldMatrix = new Matrix4x4();
	    this._worldMatrixInvalid = true;
	    this._parent = null;
	    this._scene = null;
	    this._visible = true;
	    this._ancestorsVisible = true;
	    this._raycast = true;
	    this._children = [];
	    this._isOnRoot = false;

	    // used to determine sorting index for the render loop
	    // models can use this to store distance to camera for more efficient rendering, lights use this to sort based on
	    // intersection with near plane, etc
	    this._renderOrderHint = 0.0;
	}

	SceneNode.prototype = Object.create(Transform.prototype, {
	    name: {
	        get: function()
	        {
	            return this._name;
	        },
	        set: function(value)
	        {
	            this._name = value;
	        }
	    },

	    parent: {
	        get: function()
	        {
	            return this._parent;
	        }
	    },

	    isOnRoot: {
	        get: function()
	        {
	            return this._isOnRoot;
	        }
	    },

	    numChildren: {
	        get: function() { return this._children.length; }
	    },

	    visible: {
	        get: function()
	        {
	            return this._visible;
	        },
	        set: function(value)
	        {
	            this._visible = value;

	            for (var i = 0, len = this._children.length; i < len; ++i) {
	                this._children[i]._updateAncestorsVisible(value && this._ancestorsVisible);
	            }
	        }
	    },

	    hierarchyVisible: {
	        get: function()
	        {
	            return this._visible && this._ancestorsVisible
	        }
	    },

	    raycast: {
	        get: function()
	        {
	            return this._raycast;
	        },
	        set: function(value)
	        {
	            this._raycast = value;
	        }
	    },

	    worldMatrix: {
	        get: function()
	        {
	            if (this._worldMatrixInvalid)
	                this._updateWorldMatrix();

	            return this._worldMatrix;
	        }
	    }
	});

	/**
	 * Attaches a child SceneNode to this node.
	 */
	SceneNode.prototype.attach = function(child)
	{
	    if (child instanceof Array) {
	        var len = child.length;
	        for (var i = 0; i < len; ++i) {
	            this.attach(child[i]);
	        }
	        return;
	    }

	    if (child._parent) {
	        // remove child from existing parent
	        child._parent.detach(child);
		}

	    child._parent = this;
	    // this has a scene but does NOT have a parent, it means this is the root
	    // this also means the child has no world transform (useful for some performance considerations)
	    child._isOnRoot = this._scene && !!this._parent;
	    child._setScene(this._scene);
	    child._updateAncestorsVisible(this._visible && this._ancestorsVisible);

	    this._children.push(child);
	};

	/**
	 * Attaches a child SceneNode to this node.
	 *
	 * @param {SceneNode} child The child to be attached.
	 * @param {SceneNode} refChild The scene node after which to add the new child.
	 */
	SceneNode.prototype.attachAfter = function(child, refChild)
	{
	    if (refChild._parent !== this)
	        throw new Error("Reference child not a child of the scene node");

		if (child._parent) {
			// remove child from existing parent
			child._parent.detach(child);
		}

		child._parent = this;
	    child._isOnRoot = this._scene && !!this._parent;
		child._setScene(this._scene);

		var index = this._children.indexOf(refChild);
		this._children.splice(index + 1, 0, child);
	};

	/**
	 * Returns whether or not this scene node is contained by a parent. This works recursively.
	 */
	SceneNode.prototype.isContainedIn = function(parent)
	{
	    var p = this._parent;

	    while (p) {
			if (p === parent) return true;
			p = p._parent;
	    }

	    return false;
	};

	/**
	 * Returns whether or not a child is contained in a parent. This works recursively!
	 */
	SceneNode.prototype.contains = function(child)
	{
	    var index = this._children.indexOf(child);
	    if (index >= 0) return true;

	    var len = this._children.length;
	    for (var i = 0; i < len; ++i) {
	        if (this._children[i].contains(child))
	            return true;
	    }

	    return false;
	};


	/**
	 * Removes a child SceneNode from this node.
	 */
	SceneNode.prototype.detach = function(child)
	{
	    var index = this._children.indexOf(child);

	    if (index < 0)
	        throw new Error("Trying to remove a scene object that is not a child");

	    child._parent = null;
	    child._isOnRoot = false;
	    child._updateAncestorsVisible(true);
	    child._setScene(null);

	    this._children.splice(index, 1);
	};

	/**
	 * Retrieves a child SceneNode with the given index.
	 */
	SceneNode.prototype.getChild = function(index) { return this._children[index]; };

	/**
	 * Returns the index of a child SceneNode.
	 * @param child
	 * @returns {*}
	 */
	SceneNode.prototype.getChildIndex = function(child) { return this._children.indexOf(child); };

	/**
	 * Removes the scene node from the scene and destroys it and all of its children.
	 */
	SceneNode.prototype.destroy = function()
	{
	    if (this._parent)
		    this._parent.detach(this);

	    while(this._children.length)
			this._children[0].destroy();
	};


	/**
	 * @ignore
	 * @private
	 */
	SceneNode.prototype._applyMatrix = function()
	{
	    Transform.prototype._applyMatrix.call(this);
	    this._invalidateWorldMatrix();
	};

	/**
	 * Finds a scene node with the given name somewhere in this node's children.
	 */
	SceneNode.prototype.findNodeByName = function(name)
	{
	    if (this._name === name) return this;

	    var len = this._children.length;
	    for (var i = 0; i < len; ++i) {
	        var node = this._children[i].findNodeByName(name);
	        if (node) return node;
	    }
	};


	/**
	 * Queries the scene graph for a material with the given name
	 * @param name The name of the Material
	 */
	SceneNode.prototype.findMaterialByName = function(name)
	{
		for (var i = 0, len = this._children.length; i < len; ++i) {
			var material = this._children[i].findMaterialByName(name);
			if (material) return material;
		}
	};

	/**
	 * @ignore
	 */
	SceneNode.prototype._setScene = function(scene)
	{
	    this._scene = scene;

	    var len = this._children.length;

	    for (var i = 0; i < len; ++i)
	        this._children[i]._setScene(scene);
	};

	/**
	 * @ignore
	 */
	SceneNode.prototype._invalidateMatrix = function ()
	{
	    Transform.prototype._invalidateMatrix.call(this);
	    this._invalidateWorldMatrix();
	};

	/**
	 * @ignore
	 */
	SceneNode.prototype._invalidateWorldMatrix = function ()
	{
	    this._worldMatrixInvalid = true;

	    var len = this._children.length;
	    for (var i = 0; i < len; ++i)
	        this._children[i]._invalidateWorldMatrix();
	};

	/**
	 * @ignore
	 */
	SceneNode.prototype._updateWorldMatrix = function()
	{
	    if (this._parent)
	        this._worldMatrix.multiply(this._parent.worldMatrix, this.matrix);
	    else
	        this._worldMatrix.copyFrom(this.matrix);

	    this._worldMatrixInvalid = false;
	};

	/**
	 * @ignore
	 */
	SceneNode.prototype.toString = function()
	{
	    return "[SceneNode(name=" + this._name + ")]";
	};

	/**
	 * Applies a function recursively to all child nodes.
	 * @param func The function to call (using the traversed node as argument)
	 * @param [thisRef] Optional reference to "this" in the calling function, to keep the scope of "this" in the called method.
	 */
	SceneNode.prototype.applyFunction = function(func, thisRef)
	{
	    if (thisRef)
	        func.call(thisRef, this);
	    else
	    // Heehee, this line amuses me:
	        func(this);

	    var len = this._children.length;
	    for (var i = 0; i < len; ++i)
	        this._children[i].applyFunction(func, thisRef);
	};

	/**
	 * Applies a function recursively to all child nodes while the passed function returns true
	 * @param func The function to call (using the traversed node as argument)
	 * @param [thisRef] Optional reference to "this" in the calling function, to keep the scope of "this" in the called method.
	 */
	SceneNode.prototype.applyFunctionConditional = function(func, thisRef)
	{
	    var result;
	    if (thisRef)
			result = func.call(thisRef, this);
	    else
	    // Heehee, this line amuses me:
			result = func(this);

	    if (!result) return;

	    var len = this._children.length;
	    for (var i = 0; i < len; ++i)
	        this._children[i].applyFunction(func, thisRef);
	};

	/**
	 * @private
	 * @ignore
	 */
	SceneNode.prototype._updateAncestorsVisible = function(value)
	{
	    this._ancestorsVisible = value;

	    for (var i = 0, len = this._children.length; i < len; ++i) {
			this._children[i]._updateAncestorsVisible(value);
	    }
	};

	/**
	 * @ignore
	 */
	SceneNode.prototype.copyFrom = function(src)
	{
	    Transform.prototype.copyFrom.call(this, src);

		this.name = src.name;
		this.visible = src.visible;
		this.raycast = src.raycast;

		for (var i = 0, len = src._children.length; i < len; ++i) {
			this.attach(src._children[i].clone());
		}
	};

	/**
	 * @inheritDoc
	 */
	SceneNode.prototype.clone = function()
	{
	    var clone = new SceneNode();
		clone.copyFrom(this);
	    return clone;
	};

	/**
	 * Bitfield is a bitfield that allows more than 32 bits.
	 *
	 * @ignore
	 * @constructor
	 */


	function Bitfield()
	{
	    this._hash = [];
	}

	Bitfield.prototype = {
	    isBitSet: function(index) {
	        var i = index >> 5; // divide by 32 gives the array index for each overshoot of 32 bits
	        index &= ~(i << 5); // clear the bits used to find the array index

	        return this._hash[i] & (1 << index);
	    },

	    setBit: function(index) {
	        var hash = this._hash;
	        var i = index >> 5;
	        index &= ~(i << 5);
	        hash[i] = (hash[i] || 0) | (1 << index);
	    },

	    clearBit: function(index) {
	        var hash = this._hash;
	        var i = index >> 5;
	        index &= ~(i << 5);
	        hash[i] = (hash[i] || 0) & ~(1 << index);
	    },

	    zero: function() {
	        var hash = this._hash;
	        var l = hash.length;
	        for (var i = 0; i < l; ++i)
	            hash[i] = 0;
	    },

	    OR: function(b) {
	        var hash = this._hash;
	        b = b._hash;

	        var l = Math.max(hash.length, b.length);

	        for (var i = 0; i < l; ++i)
	            hash[i] = (hash[i] || 0) | (b[i] || 0);
	    },

	    AND: function(b) {
	        var hash = this._hash;
	        b = b._hash;

	        var l = Math.max(hash.length, b.length);

	        for (var i = 0; i < l; ++i)
	            hash[i] = (hash[i] || 0) & (b[i] || 0);
	    },

	    NOT: function() {
	        var hash = this._hash;
	        var l = hash.length;
	        for (var i = 0; i < l; ++i)
	            hash[i] = ~(hash[i] || 0);
	    },

	    /**
	     * Checks if all bits of b are also set in this
	     */
	    contains: function(b) {
	        var hash = this._hash;
	        var bHash = b._hash;

	        for (var i = 0, l = bHash.length; i < l; ++i) {
	            var bi = bHash[i];
	            if ((hash[i] & bi) !== bi)
	                return false;
	        }

	        return true;
	    },

	    clone: function()
	    {
	        var b = new Bitfield();
	        var l = this._hash.length;

	        for (var i = 0; i < l; ++i)
	            b._hash[i] = this._hash[i];

	        return b;
	    },

	    toString: function() {
	        var str = "";

	        var hash = this._hash;
	        var l = hash.length;

	        if (l === 0) return "0b0";

	        for (var i = 0; i < l; ++i) {
	            var s = (hash[i] || 0).toString(2);
	            while (s.length < 32)
	                s = "0" + s;
	            str = s + str;
	        }

	        return "0b" + str;
	    }
	};

	/**
	 * @classdesc
	 * VertexLayout links the mesh's vertex attributes to a shader's attributes
	 *
	 * @param mesh
	 * @param pass
	 * @constructor
	 *
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function VertexLayout(mesh, pass)
	{
	    var shader = pass.getShader();
	    this.attributes = [];
	    this.morphPositionAttributes = [];
	    this.morphNormalAttributes = [];

	    this._numAttributes = -1;

	    for (var i = 0; i < mesh.numVertexAttributes; ++i) {
	        var attribute = mesh.getVertexAttributeByIndex(i);
	        var index = shader.getAttributeLocation(attribute.name);

	        if (!(index >= 0)) continue;

	        var stride = mesh.getVertexStride(attribute.streamIndex);
	        var attrib = {
	            index: index,
	            offset: attribute.offset * 4,
	            external: false,
	            numComponents: attribute.numComponents,
	            stride: stride * 4,
	            streamIndex: attribute.streamIndex
	        };

	        // morph attributes are handled differently because their associated vertex buffers change dynamically
	        if (attribute.name.indexOf("hx_morphPosition") === 0) {
	            this.morphPositionAttributes.push(attrib);
	            attrib.external = true;
	        }

	        if (attribute.name.indexOf("hx_morphNormal") === 0) {
	            this.morphNormalAttributes.push(attrib);
	            attrib.external = true;
	        }

	        // so in some cases, it occurs that - when attributes are optimized out by the driver - the indices don't change,
	        // but those unused become -1, leaving gaps. This keeps the gaps so we can take care of them
	        this.attributes[index] = attrib;

	        this._numAttributes = Math.max(this._numAttributes, index + 1);
	    }
	}

	/**
	 * @abstract
	 *
	 * @constructor
	 *
	 * @classdesc
	 * <p>A Component is an object that can be added to an {@linkcode Entity} to add behavior to it in a modular fashion.
	 * This can be useful to create small pieces of functionality that can be reused often and without extra boilerplate code.</p>
	 * <p>If it implements an onUpdate(dt) function, the update method will be called every frame.</p>
	 * <p>A single Component instance is unique to an Entity and cannot be shared!</p>
	 *
	 * Instead of using Object.create, Component subclasses need to be extended using
	 *
	 * <pre><code>
	 * Component.create(SubComponentClass, props);
	 * </pre></code>
	 *
	 * @see {@linkcode Entity}
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Component()
	{
		// this allows notifying entities about bound changes (useful for sized components)
		this._entity = null;
		this._enabled = true;
		this._bounds = null;
		this._boundsInvalid = true;
	}

	Component.COMPONENT_ID = 0;

	Component.create = (function (constructor, props, baseClass)
	{
		var COUNTER = 0;

		return function (constructor, props, baseClass)
		{
			baseClass = baseClass || Component;
			constructor.prototype = Object.create(baseClass.prototype, props);
			constructor.COMPONENT_ID = ++COUNTER;
			constructor.prototype.COMPONENT_ID = constructor.COMPONENT_ID;
		};
	}());

	Component.prototype =
		{
			/**
			 * If a Component has a scene presence, it can have bounds
			 */
			get bounds()
			{
				if (this._boundsInvalid) {
					if (this._bounds) this._updateBounds();
					this._boundsInvalid = false;
				}
				return this._bounds;
			},

			/**
			 * Called when this component is added to an Entity.
			 */
			onAdded: function ()
			{
			},

			/**
			 * Called when this component is removed from an Entity.
			 */
			onRemoved: function ()
			{
			},

			/**
			 * If provided, this method will be called every frame, allowing updating the entity.
			 * @param [Number] dt The amount of milliseconds passed since last frame.
			 */
			onUpdate: null,

			/**
			 * The target entity.
			 */
			get entity()
			{
				return this._entity;
			},

			/**
			 * Defines whether or not this component should be enabled.
			 */
			get enabled()
			{
				return this._enabled;
			},

			set enabled(value)
			{
				if (this._entity) {
					if (value)
						this.onAdded();
					else
						this.onRemoved();
				}
				this._enabled = value;
			},

			/**
			 * If provided, this method will be called by the scene partition traverser, allowing collection by the renderer.
			 */
			acceptVisitor: null,

			_updateBounds: function ()
			{
			},

			_invalidateBounds: function ()
			{
				this._boundsInvalid = true;

				if (this._entity)
					this._entity._invalidateBounds();
			},

			/**
			 * Creates a duplicate of this Component.
			 */
			clone: function()
			{
				throw new Error("Abstract method called!");
			},

	        /**
			 * Broadcasts a message dispatched by the owning Entity's onMessage Signal.
	         */
	        broadcast: function(name, args)
			{
	            if (this._entity) {
	            	var messenger = this._entity.messenger;
	            	messenger.broadcast.apply(messenger, arguments);
	            }
			},

	        /**
			 * Tests whether the given signal is being listened to.
	         */
	        hasListeners: function(name)
			{
	            if (this._entity) {
					return this._entity.messenger.hasListeners(name);
	            }
	            return false;
			},

	        /**
			 * Listens to the entity's messenger for a given message type.
	         */
	        bindListener: function(name, func, thisRef)
			{
	            this._entity.messenger.bind(name, func, thisRef);
			},

	        /**
	         * Listens to the entity's messenger for a given message type.
	         */
	        unbindListener: function(name, func, thisRef)
	        {
	            this._entity.messenger.unbind(name, func);
	        }
		};

	var nameCounter$3 = 0;

	/**
	 * @classdesc
	 * MeshInstance allows bundling a {@linkcode Mesh} with a {@linkcode Material} for rendering, allowing both the geometry
	 * and materials to be shared regardless of the combination of both.
	 *
	 * @property {boolean} castShadows Defines whether or not this MeshInstance should cast shadows.
	 * @property mesh The {@linkcode Mesh} providing the geometry for this instance.
	 * @property material The {@linkcode Material} to use to render the given Mesh.
	 *
	 * @param mesh The {@linkcode Mesh} providing the geometry for this instance.
	 * @param material The {@linkcode Material} to use to render the given Mesh.
	 * @constructor
	 */
	function MeshInstance(mesh, material)
	{
		Component.call(this);

		this._name = "hx_meshinstance_" + (nameCounter$3++);
		this._bounds = new BoundingAABB();
		this._morphPositions = null;
		this._morphNormals = null;
		this._morphWeights = null;
		this._meshMaterialLinkInvalid = true;
		this._vertexLayouts = null;
		this._castShadows = true;
		this._skeletonPose = null;
		this._morphPose = null;
		this.mesh = mesh;
		this.material = material;

	}

	Component.create(MeshInstance, {
		castShadows: {
			get: function()
			{
				return this._castShadows;
			},

			set: function(value)
			{
				this._castShadows = value;
			}
		},

		skeleton: {
			get: function()
			{
				return this._mesh.skeleton;
			}
		},

		/**
		 * The global matrices defining the skeleton pose. This could be a Float32Array with flat matrix data, or a texture
		 * containing the data (depending on the capabilities). This is usually set by {@linkcode SkeletonAnimation}, and
		 * should not be handled manually.
		 *
		 * @ignore
		 */
		skeletonMatrices: {
			get: function()
			{
				return this._skeletonPose? this._skeletonPose.getBindMatrices(this._mesh._skeleton) : null;
			}
		},

		skeletonPose: {
			get: function()
			{
				return this._skeletonPose;
			},

			set: function(value)
			{
				this._skeletonPose = value;
			}

		},

		morphPose: {
			get: function() {
				return this._morphPose;
			},

			set: function(value) {
				if (this._morphPose)
					this._morphPose.onChange.unbind(this._onMorphChanged);

				this._morphPose = value;

				if (this._morphPose) {
					this._morphPose.onChange.bind(this._onMorphChanged, this);
					this._onMorphChanged();
				}
				else
					this._clearMorph();
			}
		},

		mesh: {
			get: function()
			{
				return this._mesh;
			},

			set: function(mesh)
			{
				if (this._mesh === mesh) return;

				if (this._mesh) {
					this._mesh.onLayoutChanged.unbind(this._onMaterialOrMeshChange);
					this._mesh.onBoundsChanged.unbind(this._invalidateBounds);
					this._mesh.onMorphDataCreated.unbind(this._initMorphData);
					this._mesh.onSkeletonChange.unbind(this._onSkeletonChange);
				}

				this._mesh = mesh;

				mesh.onLayoutChanged.bind(this._onMaterialOrMeshChange, this);
				mesh.onBoundsChanged.bind(this._invalidateBounds, this);
				mesh.onMorphDataCreated.bind(this._initMorphData, this);
				mesh.onSkeletonChange.bind(this._onSkeletonChange, this);

				this._initMorphData();

				this._meshMaterialLinkInvalid = true;

				this._invalidateBounds();
			}
		},

		/**
		 * The {@linkcode Material} used to render the Mesh.
		 */
		material: {
			get: function()
			{
				return this._material;
			},

			set: function(value)
			{
				if (this._material)
					this._material.onChange.unbind(this._onMaterialOrMeshChange);

				this._material = value;

				if (this._material) {
					this._material.onChange.bind(this._onMaterialOrMeshChange, this);

					// TODO: Should this be set explicitly on the material by the user?
					this._material._setUseSkinning(!!this._mesh.skeleton);
					this._material._setUseMorphing(
						this._mesh.hasMorphData,
						this._mesh.hasMorphNormals
					);
				}

				this._meshMaterialLinkInvalid = true;
			}
		}
	});

	/**
	 * Sets state for this mesh/material combination.
	 * @param passType
	 * @ignore
	 */
	MeshInstance.prototype.updateRenderState = function(passType)
	{
		if (this._meshMaterialLinkInvalid)
			this._linkMeshWithMaterial();

		var vertexBuffers = this._mesh._vertexBuffers;
		this._mesh._indexBuffer.bind();

		var layout = this._vertexLayouts[passType];
		var morphPosAttributes = layout.morphPositionAttributes;
		var morphNormalAttributes = layout.morphNormalAttributes;
		var attribute;
		var gl = GL.gl;

		var len = morphPosAttributes.length;

		for (var i = 0; i < len; ++i) {
			attribute = morphPosAttributes[i];
			var buffer = this._morphPositions[i] || this._mesh._defaultMorphTarget;
			buffer.bind();

			gl.vertexAttribPointer(attribute.index, attribute.numComponents, gl.FLOAT, false, attribute.stride, attribute.offset);
		}

		if (this._morphNormals) {
			len = morphNormalAttributes.length;
			for (i = 0; i < len; ++i) {
				attribute = morphNormalAttributes[i];
				buffer = this._morphNormals[i] || this._mesh._defaultMorphTarget;
				buffer.bind();

				gl.vertexAttribPointer(attribute.index, attribute.numComponents, gl.FLOAT, false, attribute.stride, attribute.offset);
			}
		}

		var attributes = layout.attributes;
		len = layout._numAttributes;

		GL.enableAttributes(layout._numAttributes);

		for (i = 0; i < len; ++i) {
			attribute = attributes[i];

			if (attribute) {
				// external = in case of morph targets etc
				if (!attribute.external) {
					vertexBuffers[attribute.streamIndex].bind();
					gl.vertexAttribPointer(i, attribute.numComponents, gl.FLOAT, false, attribute.stride, attribute.offset);
				}
			}
			else {
				GL.gl.disableVertexAttribArray(i);
				// there seem to be some bugs in ANGLE with disabling vertex attribute arrays, so bind a dummy instead
				// vertexBuffers[0].bind();
				// gl.vertexAttribPointer(i, 1, gl.FLOAT, false, 4, 0);
			}
		}
	};

	/**
	 * @ignore
	 * @private
	 */
	MeshInstance.prototype._initVertexLayouts = function()
	{
		this._vertexLayouts = new Array(MaterialPass.NUM_PASS_TYPES);
		for (var type = 0; type < MaterialPass.NUM_PASS_TYPES; ++type) {
			var pass = this._material.getPass(type);
			if (pass)
				this._vertexLayouts[type] = new VertexLayout(this._mesh, pass);
		}
	};

	/**
	 * @ignore
	 * @private
	 */
	MeshInstance.prototype._linkMeshWithMaterial = function()
	{
		this._initVertexLayouts();

		this._meshMaterialLinkInvalid = false;
	};

	/**
	 * @ignore
	 * @private
	 */
	MeshInstance.prototype._onMaterialOrMeshChange = function()
	{
		this._meshMaterialLinkInvalid = true;
	};


	/**
	 * @ignore
	 */
	MeshInstance.prototype.toString = function()
	{
		return "[MeshInstance(mesh=" + this._mesh.name + ")]";
	};

	/**
	 * @ignore
	 */
	MeshInstance.prototype.acceptVisitor = function(visitor)
	{
		visitor.visitMeshInstance(this, this._entity);
	};

	/**
	 * @ignore
	 * @private
	 */
	MeshInstance.prototype._onMorphChanged = function()
	{
		for (var t = 0; t < 8; ++t) {
			var name = this._morphPose.getMorphTargetName(t);
			var target = null;

			if (name)
				target = this._mesh.getMorphTarget(name);

			if (target) {
				var weight = this._morphPose.getWeight(name);

				var pos = target.positionBuffer;
				var normal = target.hasNormals? target.normalBuffer : null;

				this._setMorphTarget(t, pos, normal, weight);
			}
			else {
				this._setMorphTarget(t, null, null, 0.0);
			}
		}
	};

	/**
	 * @ignore
	 * @private
	 */
	MeshInstance.prototype._clearMorph = function()
	{
		for (var t = 0; t < 8; ++t) {
			this._setMorphTarget(t, null, null, 0);
		}
	};

	/**
	 * @ignore
	 */
	MeshInstance.prototype._setMorphTarget = function(targetIndex, positionBuffer, normalBuffer, weight)
	{
		if (targetIndex >= this._morphWeights.length) return;

		this._morphPositions[targetIndex] = positionBuffer;
		if (normalBuffer && this._morphNormals)
			this._morphNormals[targetIndex] = normalBuffer;

		this._morphWeights[targetIndex] = positionBuffer? weight : 0.0;
	};

	MeshInstance.prototype._onSkeletonChange = function()
	{
		this._material._setUseSkinning(!!this._mesh.skeleton);
	};

	MeshInstance.prototype._updateBounds = function()
	{
		this._bounds = this._mesh.bounds;
	};

	MeshInstance.prototype._initMorphData = function()
	{
		this._morphPositions = null;
		this._morphNormals = null;
		this._morphWeights = null;

		if (!this._mesh.hasMorphData) return;

		this._morphPositions = [];

		var numMorphs = 8;

		if (this._mesh.hasMorphNormals) {
			this._morphNormals = [];
			numMorphs = 4;
		}

		this._morphWeights = new Float32Array(numMorphs);

		for (var i = 0; i < numMorphs; ++i) {
			this._morphWeights[i] = 0;
		}

		if (this._material) {
			this._material._setUseMorphing(
				this._mesh.hasMorphData,
				this._mesh.hasMorphNormals
			);
		}
	};

	MeshInstance.prototype.clone = function()
	{
		var clone = new MeshInstance(this._mesh, this._material);
		clone.castShadows = this.castShadows;
		if (this._skeletonPose)
			clone.skeletonPose = this._skeletonPose.clone();
		return clone;
	};

	/**
	 * @classdesc
	 * Messenger is a system that allows subscribing to named Signals.
	 *
	 * @constructor
	 */
	function Messenger()
	{
	    this._signals = {};
	}

	Messenger.prototype =
	{
	    /**
	     * Dispatches the message with the given name.
	     */
	    broadcast: function(name, args)
	    {
	        var signal = this._signals[name];

	        // if it doesn't exist, there are no listeners
	        if (signal) {
	            signal.dispatch.apply(signal, arguments);
	        }
	    },

	    /**
	     * Binds a function to the message with the given name. The callback's first argument will be the name string of the message.
	     */
	    bind: function(name, callback, thisRef)
	    {
	        var signal = this._signals[name];

	        if (!signal) {
	            signal = new Signal();
	            this._signals[name] = signal;
	        }

	        signal.bind(callback, thisRef);
	    },

	    /**
	     * Removes a bound callback function.
	     */
	    unbind: function(name, callback)
	    {
	        var signal = this._signals[name];
	        signal.unbind(callback);
	        if (!signal.hasListeners)
	            delete this._signals[name];
	    },

	    /**
	     * Returns whether or not anyone is listening to the given message.
	     */
	    hasListeners: function(name)
	    {
	        return !!this._signals[name];
	    }
	};

	/**
	 * @classdesc
	 * Entity represents a node in the Scene graph that can have {@linkcode Component} objects added to it, which can
	 * define its behavior in a modular way.
	 *
	 * @property {BoundingVolume} worldBounds The bounding volume for this node in world coordinates. This does not include
	 * children
	 *
	 * @property {Messenger} messenger The Messenger to which elements can listen for certain names Signals related to this Entity.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Entity(components)
	{
		SceneNode.call(this);

		this.messenger = new Messenger();

		// components
		this._componentHash = new Bitfield();
		this._components = [];
		this._requiresUpdates = false;
		this._onComponentsChange = new Signal();

		this._boundsInvalid = true;
		this._worldBoundsInvalid = true;
		this._worldBounds = this._createBoundingVolume();
		this._bounds = this._createBoundingVolume();

		if (components instanceof Array) {
			for (var i = 0; i < components.length; ++i) {
				this.addComponent(components[i]);
			}
		}
		else if (components) {
			this.addComponent(components);
		}
	}

	Entity.prototype = Object.create(SceneNode.prototype, {
		worldBounds: {
			get: function()
			{
				if (this._worldBoundsInvalid) {
					this._updateWorldBounds();
					this._worldBoundsInvalid = false;
				}

				return this._worldBounds;
			}
		},
		bounds: {
			get: function()
			{
				if (this._boundsInvalid) {
					this._updateBounds();
					this._boundsInvalid = false;
				}

				return this._bounds;
			}
		}
	});

	Entity.prototype.findMaterialByName = function(name)
	{
		for (var i = 0, len = this._components.length; i < len; ++i) {
			var component = this._components[i];
			if (component instanceof MeshInstance && component.material.name === name)
				return component.material;
		}

		return SceneNode.prototype.findMaterialByName.call(this, name);
	};

	/**
	 * Adds a single {@linkcode Component} object to the Entity.
	 */
	Entity.prototype.addComponent = function(component)
	{
		if (component._entity)
			throw new Error("Component already added to an entity!");

		var oldHash = this._componentHash;
		this._componentHash = this._componentHash.clone();

		this._components.push(component);
		this._componentHash.setBit(component.COMPONENT_ID);

		this._requiresUpdates = this._requiresUpdates || (!!component.onUpdate);

		component._entity = this;
		if (component.enabled)
			component.onAdded();

		if (component.bounds)
			this._invalidateBounds();

		this._onComponentsChange.dispatch(this, oldHash);
	};

	/**
	 * @ignore
	 */
	Entity.prototype._invalidateWorldMatrix = function()
	{
		SceneNode.prototype._invalidateWorldMatrix.call(this);
		this._invalidateWorldBounds();
	};

	/**
	 * @ignore
	 */
	Entity.prototype._invalidateBounds = function ()
	{
		this._boundsInvalid = true;
		this._invalidateWorldBounds();
	};

	/**
	 * @ignore
	 */
	Entity.prototype._invalidateWorldBounds = function ()
	{
		this._worldBoundsInvalid = true;
	};

	/**
	 * @ignore
	 */
	Entity.prototype._updateWorldBounds = function ()
	{
		this._worldBounds.transformFrom(this.bounds, this.worldMatrix);
	};

	/**
	 * @ignore
	 */
	Entity.prototype._updateBounds = function ()
	{
		var components = this._components;

		this._bounds.clear();

		for (var i = 0, len = components.length; i < len; ++i) {
			var bounds = components[i].bounds;

			if (bounds)
				this._bounds.growToIncludeBound(bounds);
		}
	};


	/**
	 * Removes a single Component from the Entity.
	 */
	Entity.prototype.removeComponent = function(component)
	{
		var requiresUpdates = false;
		var j = 0;
		var newComps = [];

		var oldHash = this._componentHash;
		this._componentHash = new Bitfield();

		// not splicing since we need to regenerate _requiresUpdates anyway by looping
		for (var i = 0, len = this._components.length; i < len; ++i) {
			var c = this._components[i];
			if (c !== component) {
				newComps[j++] = c;
				requiresUpdates = requiresUpdates || !!component.onUpdate;
				this._componentHash.setBit(c.COMPONENT_ID);
			}
		}

		this._requiresUpdates = requiresUpdates;

		this._onComponentsChange.dispatch(this, oldHash);

		this._components = newComps;
		component._entity = null;

		if (component.enabled)
			component.onRemoved();

		if (component.bounds)
			this._invalidateBounds();
	};

	/**
	 * Adds multiple {@linkcode Component} objects to the Entity.
	 * @param {Array} components An array of components to add.
	 */
	Entity.prototype.addComponents = function(components)
	{
		for (var i = 0; i < components.length; ++i)
			this.addComponent(components[i]);
	};

	/**
	 * Removes multiple {@linkcode Component} objects from the Entity.
	 * @param {Array} components A list of components to remove.
	 */
	Entity.prototype.removeComponents = function(components)
	{
		for (var i = 0; i < components.length; ++i) {
			this.removeComponent(components[i]);
		}
	};

	/**
	 * @inheritDoc
	 */
	Entity.prototype.destroy = function()
	{
		SceneNode.prototype.destroy.call(this);
		if (this._components)
			this.removeComponents(this._components);
	};


	/**
	 * Returns whether or not the Entity has a component of a given type assigned to it.
	 */
	Entity.prototype.hasComponentType = function(type)
	{
		return this._componentHash.contains(type.COMPONENT_ID);
	};

	/**
	 * Returns the first Component of a given type
	 */
	Entity.prototype.getFirstComponentByType = function(type)
	{
		for (var i = 0, len = this._components.length; i < len; ++i) {
			var comp = this._components[i];
			if (comp instanceof type)
				return comp;
		}
		return null;
	};

	/**
	 * Returns an array of all Components with a given type.
	 */
	Entity.prototype.getComponentsByType = function(type)
	{
		var collection = [];
		for (var i = 0, len = this._components.length; i < len; ++i) {
			var comp = this._components[i];
			if (comp instanceof type) collection.push(comp);
		}
		return collection;
	};

	/**
	 * Return the Component with a given name.
	 */
	Entity.prototype.getComponentByName = function(name)
	{
		for (var i = 0, len = this._components.length; i < len; ++i) {
			var comp = this._components[i];
			if (comp.name === name) return comp;
		}
		return null;
	};

	/**
	 * @ignore
	 */
	Entity.prototype.update = function(dt)
	{
		var components = this._components;
		for (var i = 0, len = components.length; i < len; ++i) {
			var component = components[i];
			if (component.enabled && component.onUpdate) {
				component.onUpdate(dt);
			}
		}
	};

	/**
	 * @ignore
	 */
	Entity.prototype._setScene = function(scene)
	{
		if (this._scene) {
			this._scene.entityEngine.unregisterEntity(this);
			this._scene.partitioning.unregisterEntity(this);
		}

		if (scene) {
			scene.entityEngine.registerEntity(this);
			scene.partitioning.registerEntity(this);
		}

		SceneNode.prototype._setScene.call(this, scene);
	};

	/**
	 * @ignore
	 */
	Entity.prototype._createBoundingVolume = function()
	{
		return new BoundingAABB();
	};

	/**
	 * @ignore
	 */
	Entity.prototype.acceptVisitor = function(visitor)
	{
		var components = this._components;
		for (var i = 0, len = components.length; i < len; ++i) {
			var component = components[i];
			if (component.acceptVisitor && component.enabled) {
				component.acceptVisitor(visitor);
			}
		}
	};


	/**
	 * @ignore
	 */

	Entity.prototype._invalidateWorldMatrix = function()
	{
		SceneNode.prototype._invalidateWorldMatrix.call(this);

		this._invalidateWorldBounds();

		if (this._scene)
			this._scene._partitioning.markEntityForUpdate(this);
	};

	/**
	 * @ignore
	 */
	Entity.prototype.copyFrom = function(src)
	{
		SceneNode.prototype.copyFrom.call(this, src);

		for (var i = 0, len = src._components.length; i < len; ++i) {
			this.addComponent(src._components[i].clone());
		}
	};

	/**
	 * @inheritDoc
	 */
	Entity.prototype.clone = function()
	{
		var clone = new Entity();
		clone.copyFrom(this);
		return clone;
	};

	/**
	 * @classdesc
	 * Light is a base class for light objects.
	 *
	 * @property {Color} color The color of the ambient light.
	 * @property {number} intensity The intensity of the ambient light.
	 *
	 * @abstract
	 * @constructor
	 *
	 * @extends Entity
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Light()
	{
		// TODO: Refactor, all the light code is generally the same as for HX.Light and HX.AmbientLight
		// AMBIENT LIGHT IS NOT ACTUALLY A REAL LIGHT OBJECT
		Component.call(this);
		this._scaledIrradiance = new Color();
		this._intensity = .2;
		this._color = new Color(1, 1, 1);

		this._colorChangeListener = new PropertyListener();
		this._colorChangeListener.add(this._color, "r");
		this._colorChangeListener.add(this._color, "g");
		this._colorChangeListener.add(this._color, "b");
		this._colorChangeListener.onChange.bind(this._updateScaledIrradiance, this);

		this._scaledIrradiance = new Color();
		this._updateScaledIrradiance();
	}

	Light.prototype = Object.create(Component.prototype, {
		color: {
			get: function() { return this._color; },
			set: function(value)
			{
				this._colorChangeListener.enabled = false;
				if (isNaN(value))
					this._color.copyFrom(value);
				else
					this._color.set(value);
				this._colorChangeListener.enabled = true;
				this._updateScaledIrradiance();
			}
		},

		intensity: {
			get: function() { return this._intensity; },
			set: function(value)
			{
				this._intensity = value;
				this._updateScaledIrradiance();
			},
		}
	});

	/**
	 * Calculates the luminance of the light (color * intensity).
	 */
	Light.prototype.luminance = function ()
	{
		return this._color.luminance() * this._intensity;
	};

	/**
	 * @ignore
	 */
	Light.prototype._updateScaledIrradiance = function()
	{
		// do not scale by 1/PI. It feels weird to control for general lights.
		if (META.OPTIONS.useGammaCorrection)
			this._color.gammaToLinear(this._scaledIrradiance);
		else
			this._scaledIrradiance.copyFrom(this._color);

		this._scaledIrradiance.r *= this._intensity;
		this._scaledIrradiance.g *= this._intensity;
		this._scaledIrradiance.b *= this._intensity;
	};

	/**
	 * @ignore
	 */
	Light.prototype.copyFrom = function(src)
	{
		this.color = src.color;
		this.intensity = src.intensity;
	};

	/**
	 * @classdesc
	 * DirectLight forms a base class for direct lights.
	 *
	 * @property {boolean} castShadows Defines whether or not this light casts shadows.
	 * @property {number} shadowQualityBias Shifts the priority of the shadow quality. Higher values will mean lower quality.
	 *
	 * @abstract
	 *
	 * @constructor
	 *
	 * @extends Entity
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function DirectLight()
	{
	    Light.call(this);
	    this.intensity = 3.1415;
		this.depthBias = .0;
	    this._castShadows = false;
	    this.shadowQualityBias = 0;
	}

	DirectLight.prototype = Object.create(Light.prototype);

	DirectLight.prototype.acceptVisitor = function (visitor)
	{
	    visitor.visitLight(this);
	};

	DirectLight.prototype._updateScaledIrradiance = function ()
	{
	    Light.prototype._updateScaledIrradiance.call(this);

	    // 1/PI radiance->irradiance factor
	    var scale = 1 / Math.PI;

	    this._scaledIrradiance.r *= scale;
	    this._scaledIrradiance.g *= scale;
	    this._scaledIrradiance.b *= scale;
	};



	/**
	 * @ignore
	 */
	DirectLight.prototype.copyFrom = function(src)
	{
		Light.prototype.copyFrom.call(this, src);
		this.shadowQualityBias = src.shadowQualityBias;
		this.castShadows = src.castShadows;
		this.depthBias = src.depthBias;
	};

	/**
	 * @classdesc
	 * DirectionalLight represents a light source that is "infinitely far away", used as an approximation for sun light where
	 * locally all sun rays appear to be parallel. The direction of the DirectionalLight is defined by the Entity's Y-axis.
	 * You can do a lookAt to easily control this.
	 *
	 * @property {number} shadowMapSize The shadow map size used by this light.
	 * @property {Float4} direction The direction in *world space* of the light rays. This cannot be set per component but
	 * needs to be assigned as a whole Float4.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function DirectionalLight()
	{
		DirectLight.call(this);

	    this._direction = new Float4();
	    this._cascadeSplitRatios = [];
	    this._cascadeSplitDistances = [];
	    this._initCascadeSplitProperties();

		this._bounds = new BoundingAABB();
	}

	Component.create(DirectionalLight,
	    {
	        numAtlasPlanes: {
	            get: function() { return META.OPTIONS.numShadowCascades; }
	        },

	        castShadows: {
	            get: function()
	            {
	                return this._castShadows;
	            },

	            set: function(value)
	            {
	                if (this._castShadows === value) return;

	                this._castShadows = value;
	                if (value) {
	                    this._shadowMatrices = value? [ new Matrix4x4(), new Matrix4x4(), new Matrix4x4(), new Matrix4x4() ] : null;
	                }
	                else {
	                    this._shadowMatrices = null;
	                }
	            }
	        },

	        direction: {
	            get: function()
	            {
	                var dir = this._direction;
	                if (this._entity)
	                    this._entity.worldMatrix.getColumn(1, dir);
	                return dir;
	            }
	        },

	        cascadeSplitDistances: {
	            get: function ()
	            {
	                return this._cascadeSplitDistances;
	            }
	        }
	    },
		DirectLight
	);

	/**
	 * The ratios that define every cascade's split distance. 1 is at the far plane, 0 is at the near plane.
	 * @param r1
	 * @param r2
	 * @param r3
	 * @param r4
	 */
	DirectionalLight.prototype.setCascadeRatios = function(r1, r2, r3, r4)
	{
	    this._cascadeSplitRatios[0] = r1;
	    this._cascadeSplitRatios[1] = r2;
	    this._cascadeSplitRatios[2] = r3;
	    this._cascadeSplitRatios[3] = r4;
	};

	/**
	 * @private
	 * @ignore
	 */
	DirectionalLight.prototype._initCascadeSplitProperties = function()
	{
	    var ratio = 1.0;

	    for (var i = META.OPTIONS.numShadowCascades - 1; i >= 0; --i)
	    {
	        this._cascadeSplitRatios[i] = ratio;
	        this._cascadeSplitDistances[i] = 0;
	        ratio *= .5;
	    }
	};

	/**
	 * @private
	 * @ignore
	 */
	DirectionalLight.prototype.getShadowMatrix = function(cascade)
	{
	    return this._shadowMatrices[cascade];
	};

	/**
	 * @ignore
	 */
	DirectionalLight.prototype._updateBounds = function()
	{
		this._bounds.clear(BoundingVolume.EXPANSE_INFINITE);
	};

	/**
	 * @ignore
	 */
	DirectionalLight.prototype.toString = function()
	{
		return "[DirectionalLight(name=" + this._name + ")]";
	};

	DirectionalLight.prototype.clone = function()
	{
		var clone = new DirectionalLight();
		clone.copyFrom(this);
		return clone;
	};

	/**
	 * @classdesc
	 * PointLight represents an omnidirectional light source with a single point as origin. The light strength falls off
	 * according to the inverse square rule.
	 *
	 * @property {number} radius The maximum reach of the light. While this is physically incorrect, it's necessary to limit the lights to a given area for performance.
	 * @property {boolean} castShadows Defines whether or not this light casts shadows.
	 *
	 * @constructor
	 *
	 * @extends DirectLight
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PointLight()
	{
		DirectLight.call(this);

	    this._radius = 100.0;
	    this.intensity = 3.1415;
	    this.shadowQualityBias = 2;
	    this._shadowTiles = null;
	    this._bounds = new BoundingSphere();
	}

	Component.create(PointLight,
	    {
	        numAtlasPlanes: {
	            get: function() { return 6; }
	        },

	        castShadows: {
	            get: function()
	            {
	                return this._castShadows;
	            },

	            set: function(value)
	            {
	                this._castShadows = value;

	                if (value) {
	                    this._shadowTiles = [];
	                    for (var i = 0; i < 6; ++i)
	                        this._shadowTiles[i] = new Float4();
	                }
	                else {
	                    this._shadowTiles = null;
	                }
	            }
	        },

	        radius: {
	            get: function() {
	                return this._radius;
	            },

	            set: function(value) {
	                this._radius = value;
	                this._invalidateBounds();
	            }
	        }
	    },
		DirectLight
	);

	/**
	 * @ignore
	 * @private
	 */
	PointLight.prototype._updateBounds = function()
	{
		this._bounds.setExplicit(Float4.ORIGIN_POINT, this._radius);
	};

	/**
	 * @ignore
	 */
	PointLight.prototype.toString = function()
	{
		return "[PointLight(name=" + this._name + ")]";
	};

	/**
	 * @ignore
	 */
	PointLight.prototype.copyFrom = function(src)
	{
		DirectLight.prototype.copyFrom.call(this, src);
		this.radius = src.radius;
	};

	/**
	 * @inheritDoc
	 */
	PointLight.prototype.clone = function()
	{
		var clone = new PointLight();
		clone.copyFrom(this);
		return clone;
	};

	/**
	 * @classdesc
	 * LightProbe provides functionality to store global illumination information and apply it to the scene lighting.
	 * Only providing a simple specularTexture will behave like environment mapping, but diffuse convolution can be applied
	 * for global diffuse illumination.
	 *
	 * @property {TextureCube} diffuseTexture A cube map texture containing diffuse global illumination information
	 * @property {TextureCube} specularTexture A cube map texture containing specular global illumination information
	 * @property {number} size Defines the virtual size of the environment map box. Useful for local reflections. Leave undefined for a traditional environment map "at infinity"
	 *
	 * @see {@linkcode https://www.knaldtech.com/lys/} for an example tool to generate the required images.
	 *
	 * @constructor
	 * @param {TextureCube} diffuseTexture A cube map texture containing diffuse global illumination information
	 * @param {TextureCube} specularTexture A cube map texture containing specular global illumination information
	 *
	 * @extends Entity
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function LightProbe(diffuseTexture, specularTexture)
	{
	    Component.call(this);
	    this._specularTexture = specularTexture;
	    this._diffuseTexture = diffuseTexture;
	    this._size = undefined;
	    this._bounds = new BoundingAABB();
		this._bounds.clear(BoundingVolume.EXPANSE_INFINITE);
	}

	// conversion range for spec power to mip. Lys style.
	LightProbe.powerRange0 = .00098;
	LightProbe.powerRange1 = .9921;

	Component.create(LightProbe,
	    {
	        specularTexture: {
	            get: function() { return this._specularTexture; }
	        },
	        diffuseTexture: {
	            get: function() { return this._diffuseTexture; }
	        },
	        size: {
	            get: function()
	            {
	                return this._size;
	            },
	            set: function(value)
	            {
	                if (this._size === value) return;

	                this._size = value;

					if (value)
						this._bounds.setExplicit(Float4.ORIGIN_POINT, value);
					else
						this._bounds.clear(BoundingVolume.EXPANSE_INFINITE);
				},
	        }
	    });


	/**
	 * ignore
	 */
	LightProbe.prototype.acceptVisitor = function (visitor)
	{
	    visitor.visitLight(this);
	};

	LightProbe.prototype.clone = function()
	{
		var clone = new LightProbe(this._diffuseTexture, this._specularTexture);
		clone.size = this.size;
		return clone;
	};

	/**
	 * @classdesc
	 * SpotLight represents an light source with a single point as origin and a conical range. The light strength falls off
	 * according to the inverse square rule.
	 *
	 * @property {number} radius The maximum reach of the light. While this is physically incorrect, it's necessary to limit the lights to a given area for performance.
	 * @property {number} innerAngle The angle of the spot light where it starts attenuating outwards. In radians!
	 * @property {number} outerAngle The maximum angle of the spot light's reach. In radians!
	 * @property {boolean} castShadows Defines whether or not this light casts shadows.
	 *
	 * @constructor
	 *
	 * @extends DirectLight
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SpotLight()
	{
		DirectLight.call(this);

	    this._radius = 50.0;
	    this._innerAngle = 1.2;
	    this._outerAngle = 1.3;
	    this._cosInner = Math.cos(this._innerAngle * .5);
	    this._cosOuter = Math.cos(this._outerAngle * .5);
	    this.intensity = 3.1415;

	    this.shadowQualityBias = 1;
	    this._shadowMatrix = null;
	    this._shadowTile = null;    // xy = scale, zw = offset

	    this._bounds = new BoundingSphere();
	}

	Component.create(SpotLight,
	    {
	        numAtlasPlanes: {
	            get: function() { return 1; }
	        },

	        castShadows: {
	            get: function()
	            {
	                return this._castShadows;
	            },

	            set: function(value)
	            {
	                if (this._castShadows === value) return;

	                this._castShadows = value;

	                if (value) {
	                    this._shadowMatrix = new Matrix4x4();
	                    this._shadowTile = new Float4();
	                }
	                else {
	                    this._shadowMatrix = null;
	                    this._shadowTile = null;
	                }
	            }
	        },

	        shadowMatrix: {
	            get: function()
	            {
	                return this._shadowMatrix;
	            }
	        },

	        shadowTile: {
	            get: function()
	            {
	                return this._shadowTile;
	            }
	        },

	        radius: {
	            get: function() {
	                return this._radius;
	            },

	            set: function(value) {
	                this._radius = value;
					this._invalidateBounds();
	            }
	        },

	        innerAngle: {
	            get: function() {
	                return this._innerAngle;
	            },

	            set: function(value) {
	                this._innerAngle = MathX.clamp(value, 0, Math.PI);
	                this._outerAngle = MathX.clamp(this._outerAngle, this._innerAngle, Math.PI);
	                this._cosInner = Math.cos(this._innerAngle * .5);
	                this._cosOuter = Math.cos(this._outerAngle * .5);
					this._invalidateBounds();
	            }
	        },

	        outerAngle: {
	            get: function() {
	                return this._outerAngle;
	            },

	            set: function(value) {
	                this._outerAngle = MathX.clamp(value, 0, Math.PI);
	                this._innerAngle = MathX.clamp(this._innerAngle, 0, this._outerAngle);
	                this._cosInner = Math.cos(this._innerAngle * .5);
	                this._cosOuter = Math.cos(this._outerAngle * .5);
					this._invalidateBounds();
	            }
	        }
	    },
		DirectLight
	);

	/**
	 * @ignore
	 */
	SpotLight.prototype._updateBounds = function()
	{
	    var p = new Float4();
	    return function() {
	        // find the center of the sphere that contains both the origin as well as the outer points
			var x = this._radius / (2.0 * this._cosOuter);
			p.set(0, x, 0);
			this._bounds.setExplicit(p, x);
		};
	}();

	/**
	 * @ignore
	 */
	SpotLight.prototype.toString = function()
	{
		return "[SpotLight(name=" + this._name + ")]";
	};

	/**
	 * @ignore
	 */
	SpotLight.prototype.copyFrom = function(src)
	{
	    DirectLight.prototype.copyFrom.call(this, src);
		this.radius = src.radius;
		this.innerAngle = src.innerAngle;
		this.outerAngle = src.outerAngle;
	};

	/**
	 * @inheritDoc
	 */
	SpotLight.prototype.clone = function()
	{
		var clone = new SpotLight();
		clone.copyFrom(this);
		return clone;
	};

	/**
	 * @classdesc
	 * This material pass renders all lighting in one fragment shader.
	 *
	 * @ignore
	 *
	 * @param geometryVertex
	 * @param geometryFragment
	 * @param lightingModel
	 * @param lights
	 * @constructor
	 */
	function FixedLitPass(geometryVertex, geometryFragment, lightingModel, lights)
	{
	    this._dirLights = null;
	    this._pointLights = null;
	    this._spotLights = null;
	    this._diffuseLightProbes = null;
	    this._specularLightProbes = null;

	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment, lightingModel, lights));

	    this._getUniformLocations();

	    this._assignLightProbes();
	}

	FixedLitPass.prototype = Object.create(MaterialPass.prototype);

	FixedLitPass.prototype.updatePassRenderState = function (camera, renderer)
	{
	    GL.gl.useProgram(this._shader._program);
	    this._assignDirLights(camera);
	    this._assignPointLights(camera);
	    this._assignSpotLights(camera);
	    this._assignLightProbes(camera);

	    MaterialPass.prototype.updatePassRenderState.call(this, camera, renderer);
	};

	FixedLitPass.prototype._generateShader = function (geometryVertex, geometryFragment, lightingModel, lights)
	{
	    this._dirLights = [];
	    this._pointLights = [];
	    this._spotLights = [];
	    this._diffuseLightProbes = [];
	    this._specularLightProbes = [];

	    for (var i = 0; i < lights.length; ++i) {
	        var light = lights[i];

	        // I don't like typechecking, but do we have a choice? :(
	        if (light instanceof DirectionalLight) {
	            this._dirLights.push(light);
	        }
	        else if (light instanceof PointLight) {
	            this._pointLights.push(light);
	        }
	        else if (light instanceof SpotLight) {
	            this._spotLights.push(light);
	        }
	        else if (light instanceof LightProbe) {
	            if (light.diffuseTexture)
	                this._diffuseLightProbes.push(light);

	            if (light.specularTexture)
	                this._specularLightProbes.push(light);
	        }
	    }

	    var extensions = [];

	    var defines = {
	        HX_NUM_DIR_LIGHTS: this._dirLights.length,
	        HX_NUM_POINT_LIGHTS: this._pointLights.length,
	        HX_NUM_SPOT_LIGHTS: this._spotLights.length,
	        HX_NUM_DIFFUSE_PROBES: this._diffuseLightProbes.length,
	        HX_NUM_SPECULAR_PROBES: this._specularLightProbes.length
	    };

	    if (capabilities.EXT_SHADER_TEXTURE_LOD) {
	        extensions += "#texturelod\n";
	    }

	    var vertexShader = geometryVertex + "\n" + ShaderLibrary.get("material_fwd_fixed_vertex.glsl", defines);

	    var fragmentShader =
	        extensions +
	        ShaderLibrary.get("snippets_geometry.glsl") + "\n" +
	        lightingModel + "\n\n\n" +
	        META.OPTIONS.shadowFilter.getGLSL() + "\n" +
	        ShaderLibrary.get("directional_light.glsl", defines) + "\n" +
	        ShaderLibrary.get("point_light.glsl") + "\n" +
	        ShaderLibrary.get("spot_light.glsl") + "\n" +
	        ShaderLibrary.get("light_probe.glsl") + "\n" +
	        geometryFragment + "\n" +
	        ShaderLibrary.get("material_fwd_fixed_fragment.glsl");

	    return new Shader(vertexShader, fragmentShader);
	};

	FixedLitPass.prototype._assignDirLights = function (camera)
	{
	    var dir = new Float4();
	    var matrix = new Matrix4x4();
	    var matrixData = new Float32Array(64);

	    return function(camera) {
	        var lights = this._dirLights;
	        if (!lights) return;

	        var len = lights.length;
	        var gl = GL.gl;

	        for (var i = 0; i < len; ++i) {
	            var light = lights[i];
	            var locs = this._dirLocations[i];
	            camera.viewMatrix.transformVector(light.direction, dir);

	            var col = light._scaledIrradiance;
	            gl.uniform3f(locs.color, col.r, col.g, col.b);
	            gl.uniform3f(locs.direction, dir.x, dir.y, dir.z);
	            gl.uniform1i(locs.castShadows, light.castShadows? 1 : 0);

	            if (light.castShadows) {
	                var numCascades = META.OPTIONS.numShadowCascades;
	                var splits = light._cascadeSplitDistances;
	                var k = 0;
	                for (var j = 0; j < numCascades; ++j) {
	                    matrix.multiply(light.getShadowMatrix(j), camera.worldMatrix);
	                    var m = matrix._m;

	                    for (var l = 0; l < 16; ++l) {
	                        matrixData[k++] = m[l];
	                    }
	                }

	                gl.uniformMatrix4fv(locs.matrices, false, matrixData);
	                gl.uniform4f(locs.splits, splits[0], splits[1], splits[2], splits[3]);
	                gl.uniform1f(locs.depthBias, light.depthBias);
	                gl.uniform1f(locs.maxShadowDistance, splits[numCascades - 1]);
	            }
	        }
	    }
	}();


	FixedLitPass.prototype._assignPointLights = function (camera) {
	    var pos = new Float4();
	    var tiles = new Float32Array(24);

	    return function (camera)
	    {
	        var lights = this._pointLights;
	        if (!lights) return;

	        var gl = GL.gl;

	        var len = lights.length;

	        for (var i = 0; i < len; ++i) {
	            var locs = this._pointLocations[i];
	            var light = lights[i];
	            light.entity.worldMatrix.getColumn(3, pos);
	            camera.viewMatrix.transformPoint(pos, pos);

	            var col = light._scaledIrradiance;
	            gl.uniform3f(locs.color, col.r, col.g, col.b);
	            gl.uniform3f(locs.position, pos.x, pos.y, pos.z);
	            gl.uniform1f(locs.radius, light._radius);
	            gl.uniform1f(locs.rcpRadius, 1.0 / light._radius);

	            gl.uniform1i(locs.castShadows, light.castShadows? 1 : 0);

	            if (light.castShadows) {
	                gl.uniformMatrix4fv(locs.matrix, false, camera.worldMatrix._m);
	                gl.uniform1f(locs.depthBias, light.depthBias);

	                var j = 0;
	                for (i = 0; i < 6; ++i) {
	                    var t = light._shadowTiles[i];
	                    tiles[j++] = t.x;
	                    tiles[j++] = t.y;
	                    tiles[j++] = t.z;
	                    tiles[j++] = t.w;
	                }
	                gl.uniform4fv(locs.tiles, tiles);


	            }
	        }
	    }
	}();


	FixedLitPass.prototype._assignSpotLights = function (camera)
	{
	    var pos = new Float4();
	    var matrix = new Matrix4x4();

	    return function (camera)
	    {
	        var lights = this._spotLights;
	        if (!lights) return;

	        var gl = GL.gl;

	        var len = lights.length;

	        for (var i = 0; i < len; ++i) {
	            var locs = this._spotLocations[i];
	            var light = lights[i];
	            var worldMatrix = light.worldMatrix;
	            var viewMatrix = camera.viewMatrix;
	            worldMatrix.getColumn(3, pos);
	            viewMatrix.transformPoint(pos, pos);

	            var col = light._scaledIrradiance;
	            gl.uniform3f(locs.color, col.r, col.g, col.b);
	            gl.uniform3f(locs.position, pos.x, pos.y, pos.z);
	            gl.uniform1f(locs.radius, light._radius);
	            gl.uniform1f(locs.rcpRadius, 1.0 / light._radius);
	            gl.uniform2f(locs.angleData, light._cosOuter, 1.0 / Math.max((light._cosInner - light._cosOuter), .00001));

	            worldMatrix.getColumn(1, pos);
	            viewMatrix.transformVector(pos, pos);
	            gl.uniform3f(locs.direction, pos.x, pos.y, pos.z);

	            gl.uniform1i(locs.castShadows, light.castShadows? 1 : 0);

	            if (light.castShadows) {
	                matrix.multiply(light.shadowMatrix, camera.worldMatrix);

	                gl.uniformMatrix4fv(locs.matrix, false, matrix._m);
	                gl.uniform1f(locs.depthBias, light.depthBias);
	                var tile = light._shadowTile;
	                gl.uniform4f(locs.tile, tile.x, tile.y, tile.z, tile.w);
	            }
	        }
	    }
	}();


	FixedLitPass.prototype._assignLightProbes = function () {
	    var diffuseMaps = [];
	    var specularMaps = [];

	    var probes = this._diffuseLightProbes;
	    var len = probes.length;
	    for (var i = 0; i < len; ++i)
	        diffuseMaps[i] = probes[i].diffuseTexture;

	    probes = this._specularLightProbes;
	    len = probes.length;
	    var mips = [];
	    for (i = 0; i < len; ++i) {
	        specularMaps[i] = probes[i].specularTexture;
	        mips[i] = Math.floor(MathX.log2(specularMaps[i].size));
	    }

	    if (diffuseMaps.length > 0) this.setTextureArray("hx_diffuseProbeMaps", diffuseMaps);
	    if (specularMaps.length > 0) {
	        this.setTextureArray("hx_specularProbeMaps", specularMaps);
	        this.setUniformArray("hx_specularProbeNumMips", new Float32Array(mips));
	    }
	};

	FixedLitPass.prototype._getUniformLocations = function ()
	{
	    this._dirLocations = [];
	    this._pointLocations = [];
	    this._spotLocations = [];

	    for (var i = 0; i < this._dirLights.length; ++i) {
	        this._dirLocations.push({
	            color: this.getUniformLocation("hx_directionalLights[" + i + "].color"),
	            direction: this.getUniformLocation("hx_directionalLights[" + i + "].direction"),
	            matrices: this.getUniformLocation("hx_directionalLights[" + i + "].shadowMapMatrices[0]"),
	            splits: this.getUniformLocation("hx_directionalLights[" + i + "].splitDistances"),
	            depthBias: this.getUniformLocation("hx_directionalLights[" + i + "].depthBias"),
	            maxShadowDistance: this.getUniformLocation("hx_directionalLights[" + i + "].maxShadowDistance"),
	            castShadows: this.getUniformLocation("hx_directionalLights[" + i + "].castShadows")
	        });
	    }

	    for (i = 0; i < this._pointLights.length; ++i) {
	        this._pointLocations.push({
	            color: this.getUniformLocation("hx_pointLights[" + i + "].color"),
	            position: this.getUniformLocation("hx_pointLights[" + i + "].position"),
	            radius: this.getUniformLocation("hx_pointLights[" + i + "].radius"),
	            rcpRadius: this.getUniformLocation("hx_pointLights[" + i + "].rcpRadius"),
	            castShadows: this.getUniformLocation("hx_pointLights[" + i + "].castShadows"),
	            depthBias: this.getUniformLocation("hx_pointLights[" + i + "].depthBias"),
	            matrix: this.getUniformLocation("hx_pointLights[" + i + "].shadowMapMatrix"),
	            tiles: this.getUniformLocation("hx_pointLights[" + i + "].shadowTiles[0]")
	        });
	    }

	    for (i = 0; i < this._spotLights.length; ++i) {
	        this._spotLocations.push({
	            color: this.getUniformLocation("hx_spotLights[" + i + "].color"),
	            position: this.getUniformLocation("hx_spotLights[" + i + "].position"),
	            direction: this.getUniformLocation("hx_spotLights[" + i + "].direction"),
	            radius: this.getUniformLocation("hx_spotLights[" + i + "].radius"),
	            rcpRadius: this.getUniformLocation("hx_spotLights[" + i + "].rcpRadius"),
	            angleData: this.getUniformLocation("hx_spotLights[" + i + "].angleData"),
	            castShadows: this.getUniformLocation("hx_spotLights[" + i + "].castShadows"),
	            matrix: this.getUniformLocation("hx_spotLights[" + i + "].shadowMapMatrix"),
	            tile: this.getUniformLocation("hx_spotLights[" + i + "].shadowTile"),
	            depthBias: this.getUniformLocation("hx_spotLights[" + i + "].depthBias")
	        });
	    }
	};

	/**
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @param lightingModel
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PointLightingPass(geometryVertex, geometryFragment, lightingModel)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment, lightingModel));

	    this._colorLocation = this.getUniformLocation("hx_pointLight.color");
	    this._posLocation = this.getUniformLocation("hx_pointLight.position");
	    this._radiusLocation = this.getUniformLocation("hx_pointLight.radius");
	    this._rcpRadiusLocation = this.getUniformLocation("hx_pointLight.rcpRadius");
	    this._castShadowsLocation = this.getUniformLocation("hx_pointLight.castShadows");
	    this._depthBiasLocation = this.getUniformLocation("hx_pointLight.depthBias");
	    this._shadowMatrixLocation = this.getUniformLocation("hx_pointLight.shadowMapMatrix");
	    this._shadowTilesLocation = this.getUniformLocation("hx_pointLight.shadowTiles[0]");
	}

	PointLightingPass.prototype = Object.create(MaterialPass.prototype);

	// the light is passed in as data
	PointLightingPass.prototype.updatePassRenderState = function(camera, renderer, light)
	{
	    var pos = new Float4();
	    var tiles = new Float32Array(24);

	    return function(camera, renderer, light) {
	        var gl = GL.gl;
	        var col = light._scaledIrradiance;

	        gl.useProgram(this._shader._program);

	        light.entity.worldMatrix.getColumn(3, pos);
	        camera.viewMatrix.transformPoint(pos, pos);
	        gl.uniform3f(this._colorLocation, col.r, col.g, col.b);
	        gl.uniform3f(this._posLocation, pos.x, pos.y, pos.z);
	        gl.uniform1f(this._radiusLocation, light._radius);
	        gl.uniform1f(this._rcpRadiusLocation, 1.0 / light._radius);
	        gl.uniform1i(this._castShadowsLocation, light.castShadows? 1 : 0);

	        if (light.castShadows) {
	            var j = 0;
	            for (var i = 0; i < 6; ++i) {
	                var t = light._shadowTiles[i];
	                tiles[j++] = t.x;
	                tiles[j++] = t.y;
	                tiles[j++] = t.z;
	                tiles[j++] = t.w;
	            }
	            gl.uniform4fv(this._shadowTilesLocation, tiles);
	            gl.uniform1f(this._depthBiasLocation, light.depthBias);
	            gl.uniformMatrix4fv(this._shadowMatrixLocation, false, camera.worldMatrix._m);
	        }

	        MaterialPass.prototype.updatePassRenderState.call(this, camera, renderer);
	    }
	}();

	PointLightingPass.prototype._generateShader = function(geometryVertex, geometryFragment, lightingModel)
	{
	    var defines = {};

	    var vertexShader = geometryVertex + "\n" + ShaderLibrary.get("material_fwd_point_vertex.glsl", defines);

	    var fragmentShader =
	        ShaderLibrary.get("snippets_geometry.glsl", defines) + "\n" +
	        lightingModel + "\n\n\n" +
	        META.OPTIONS.shadowFilter.getGLSL() + "\n" +
	        ShaderLibrary.get("point_light.glsl") + "\n" +
	        geometryFragment + "\n" +
	        ShaderLibrary.get("material_fwd_point_fragment.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @param lightingModel
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ProbeLightingPass(geometryVertex, geometryFragment, lightingModel)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment, lightingModel));
	    this._diffuseSlot = this.getTextureSlot("hx_diffuseProbeMap");
	    this._specularSlot = this.getTextureSlot("hx_specularProbeMap");
	    this._numMipsLocation = this.getUniformLocation("hx_specularProbeNumMips");
	    this._localLocation = this.getUniformLocation("hx_probeLocal");
	    this._sizeLocation = this.getUniformLocation("hx_probeSize");
	    this._positionLocation = this.getUniformLocation("hx_probePosition");
	}

	ProbeLightingPass.prototype = Object.create(MaterialPass.prototype);

	// the light is passed in as data
	ProbeLightingPass.prototype.updatePassRenderState = function(camera, renderer, probe)
	{
	    var gl = GL.gl;
	    gl.useProgram(this._shader._program);

	    // TODO: allow setting locality of probes
	    this._diffuseSlot.texture = probe.diffuseTexture || DEFAULTS.DARK_CUBE_TEXTURE;
	    var specularTex = probe.specularTexture || DEFAULTS.DARK_CUBE_TEXTURE;

	    this._specularSlot.texture = specularTex;
	    gl.uniform1f(this._numMipsLocation, Math.floor(MathX.log2(specularTex.size)));
	    gl.uniform1f(this._localLocation, probe._size? 1.0 : 0.0);
	    gl.uniform1f(this._sizeLocation, probe._size || 0.0);
	    var m = probe.entity.worldMatrix._m;
	    gl.uniform3f(this._positionLocation, m[12], m[13], m[14]);
	    MaterialPass.prototype.updatePassRenderState.call(this, camera, renderer);
	};

	ProbeLightingPass.prototype._generateShader = function(geometryVertex, geometryFragment, lightingModel)
	{
	    var extensions = "";
	    if (capabilities.EXT_SHADER_TEXTURE_LOD) {
	        extensions += "#texturelod\n";
	    }

	    var vertexShader = geometryVertex + "\n" + ShaderLibrary.get("material_fwd_probe_vertex.glsl");

	    var fragmentShader =
	        extensions +
	        ShaderLibrary.get("snippets_geometry.glsl") + "\n" +
	        lightingModel + "\n\n\n" +
	        ShaderLibrary.get("light_probe.glsl") + "\n" +
	        geometryFragment + "\n" +
	        ShaderLibrary.get("material_fwd_probe_fragment.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @param lightingModel
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SpotLightingPass(geometryVertex, geometryFragment, lightingModel)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment, lightingModel));

	    this._colorLocation = this.getUniformLocation("hx_spotLight.color");
	    this._posLocation = this.getUniformLocation("hx_spotLight.position");
	    this._radiusLocation = this.getUniformLocation("hx_spotLight.radius");
	    this._anglesLocation = this.getUniformLocation("hx_spotLight.angleData");
	    this._dirLocation = this.getUniformLocation("hx_spotLight.direction");
	    this._rcpRadiusLocation = this.getUniformLocation("hx_spotLight.rcpRadius");
	    this._castShadowsLocation = this.getUniformLocation("hx_spotLight.castShadows");
	    this._depthBiasLocation = this.getUniformLocation("hx_spotLight.depthBias");
	    this._shadowMatrixLocation = this.getUniformLocation("hx_spotLight.shadowMapMatrix");
	    this._shadowTileLocation = this.getUniformLocation("hx_spotLight.shadowTile");
	}

	SpotLightingPass.prototype = Object.create(MaterialPass.prototype);

	// the light is passed in as data
	SpotLightingPass.prototype.updatePassRenderState = function(camera, renderer, light)
	{
	    var pos = new Float4();
	    var matrix = new Matrix4x4();

	    return function(camera, renderer, light) {
	        var gl = GL.gl;
	        var col = light._scaledIrradiance;

	        gl.useProgram(this._shader._program);

	        var worldMatrix = light.entity.worldMatrix;
	        var viewMatrix = camera.viewMatrix;
	        worldMatrix.getColumn(3, pos);
	        viewMatrix.transformPoint(pos, pos);
	        gl.uniform3f(this._colorLocation, col.r, col.g, col.b);
	        gl.uniform3f(this._posLocation, pos.x, pos.y, pos.z);

	        worldMatrix.getColumn(1, pos);
	        viewMatrix.transformVector(pos, pos);
	        gl.uniform3f(this._dirLocation, pos.x, pos.y, pos.z);

	        gl.uniform1f(this._radiusLocation, light._radius);
	        gl.uniform1f(this._rcpRadiusLocation, 1.0 / light._radius);
	        gl.uniform2f(this._anglesLocation, light._cosOuter, 1.0 / Math.max((light._cosInner - light._cosOuter), .00001));
	        gl.uniform1i(this._castShadowsLocation, light.castShadows? 1 : 0);

	        if (light.castShadows) {
	            var tile = light._shadowTile;
	            gl.uniform1f(this._depthBiasLocation, light.depthBias);
	            gl.uniform4f(this._shadowTileLocation, tile.x, tile.y, tile.z, tile.w);
	            matrix.multiply(light._shadowMatrix, camera.worldMatrix);
	            gl.uniformMatrix4fv(this._shadowMatrixLocation, false, matrix._m);
	        }

	        MaterialPass.prototype.updatePassRenderState.call(this, camera, renderer);
	    }
	}();

	SpotLightingPass.prototype._generateShader = function(geometryVertex, geometryFragment, lightingModel)
	{
	    var defines = {};

	    var vertexShader = geometryVertex + "\n" + ShaderLibrary.get("material_fwd_spot_vertex.glsl", defines);

	    var fragmentShader =
	        ShaderLibrary.get("snippets_geometry.glsl", defines) + "\n" +
	        lightingModel + "\n\n\n" +
	        META.OPTIONS.shadowFilter.getGLSL() + "\n" +
	        ShaderLibrary.get("spot_light.glsl") + "\n" +
	        geometryFragment + "\n" +
	        ShaderLibrary.get("material_fwd_spot_fragment.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function NormalDepthPass(geometryVertex, geometryFragment)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment));
	}

	NormalDepthPass.prototype = Object.create(MaterialPass.prototype);

	NormalDepthPass.prototype._generateShader = function(geometryVertex, geometryFragment)
	{
	    var defines = "#define HX_SKIP_SPECULAR\n";
	    var fragmentShader = defines + ShaderLibrary.get("snippets_geometry.glsl") + "\n" + geometryFragment + "\n" + ShaderLibrary.get("material_normal_depth_fragment.glsl");
	    var vertexShader = defines + geometryVertex + "\n" + ShaderLibrary.get("material_normal_depth_vertex.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * @ignore
	 */
	var RenderPath = {
	    // forward with dynamic light picking
	    FORWARD_DYNAMIC: 0,
	    // forward with fixed assigned set of lights
	    FORWARD_FIXED: 1,

	    // WebGL 2 could use a separate render path supporting dynamic loops

	    NUM_PATHS: 2
	};

	/**
	 * @ignore
	 * @param geometryVertex
	 * @param geometryFragment
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PointShadowPass(geometryVertex, geometryFragment)
	{
	    MaterialPass.call(this, this._generateShader(geometryVertex, geometryFragment));
	    this._rcpRadiusLocation = this.getUniformLocation("hx_rcpRadius");
	}

	PointShadowPass.prototype = Object.create(MaterialPass.prototype);

	PointShadowPass.prototype.updatePassRenderState = function(geometryVertex, geometryFragment, light)
	{
	    MaterialPass.prototype.updatePassRenderState.call(this, geometryVertex, geometryFragment);
	    GL.gl.uniform1f(this._rcpRadiusLocation, 1.0 / light._radius);
	};

	PointShadowPass.prototype._generateShader = function(geometryVertex, geometryFragment)
	{
	    var defines =
	        "#define HX_SKIP_NORMALS\n" +
	        "#define HX_SKIP_SPECULAR\n";
	    var fragmentShader = defines + ShaderLibrary.get("snippets_geometry.glsl") + "\n" + META.OPTIONS.shadowFilter.getGLSL() + "\n" + geometryFragment + "\n" + ShaderLibrary.get("material_point_shadow_fragment.glsl");
	    var vertexShader = defines + geometryVertex + "\n" + ShaderLibrary.get("material_point_shadow_vertex.glsl");
	    return new Shader(vertexShader, fragmentShader);
	};

	/**
	 * @ignore
	 */
	var MATERIAL_ID_COUNTER = 0;

	/**
	 * @classdesc
	 * Material is a base class for materials. It splits up into two components: the geometry stage, and the lighting model.
	 *
	 * @constructor
	 *
	 * @param geometryVertexShader The vertex code for the geometry stage.
	 * @param geometryFragmentShader The fragment code for the geometry stage.
	 * @param [lightingModel] The {@linkcode LightingModel} to use. Defaults to what was passed in (if anything) with {@linkcode InitOptions#defaultLightingModel}.
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Material(geometryVertexShader, geometryFragmentShader, lightingModel)
	{
	    // dispatched when the material's code changed and a link with a mesh may have become invalid
	    this.onChange = new Signal();

		this._name = "hx_material_" + MATERIAL_ID_COUNTER;
	    this._elementType = ElementType.TRIANGLES;
	    this._cullMode = CullMode.BACK;
	    this._writeDepth = true;
	    this._writeColor = true;
	    this._passes = new Array(Material.NUM_PASS_TYPES);
	    // automatic render order by engine
	    this._renderOrderHint = ++MATERIAL_ID_COUNTER;
	    // forced render order by user:
	    this._renderOrder = 0;
	    this._renderPath = null;
	    this._textures = {};
	    this._uniforms = {};
	    this._fixedLights = null;
	    this._useMorphing = false;
	    this._useNormalMorphing = false;
	    this._useSkinning = false;

	    this._geometryVertexShader = geometryVertexShader;
	    this._geometryFragmentShader = geometryFragmentShader;
	    this._lightingModel = lightingModel || META.OPTIONS.defaultLightingModel;

	    this._initialized = false;
	    this._blendState = null;
	    this._additiveBlendState = BlendState.ADD;    // additive blend state is used for dynamic lighting
	    this._needsNormalDepth = false;
	    this._needsBackbuffer = false;
	}

	Material.ID_COUNTER = 0;

	Material.prototype =
	{
	    /**
	     * @ignore
	     */
	    init: function()
	    {
	        if (this._initialized || !this._geometryVertexShader || !this._geometryFragmentShader)
	            return;

	        this._needsNormalDepth = false;
	        this._needsBackbuffer = false;

	        var vertex = this._geometryVertexShader;
	        var fragment = this._geometryFragmentShader;

	        if (this._useSkinning)
	            vertex = "#define HX_USE_SKINNING\n" + vertex;

	        if (this._useMorphing) {
	            vertex = "#define HX_USE_MORPHING\n" + vertex;

	            if (this._useNormalMorphing)
	                vertex = "#define HX_USE_NORMAL_MORPHING\n" + vertex;
	        }

	        if (!this._lightingModel) {
	            this._renderPath = RenderPath.FORWARD_FIXED;
	            this.setPass(MaterialPass.BASE_PASS, new UnlitPass(vertex, fragment));
	        }
	        else if (this._fixedLights) {
	            this._renderPath = RenderPath.FORWARD_FIXED;
	            this.setPass(MaterialPass.BASE_PASS, new FixedLitPass(vertex, fragment, this._lightingModel, this._fixedLights));
	        }
	        else if (capabilities.WEBGL_2) {
	            this._renderPath = RenderPath.FORWARD_DYNAMIC;

	            this.setPass(MaterialPass.BASE_PASS, new ClusteredLitPass(vertex, fragment, this._lightingModel, null));
	        }
	        else {
	            this._renderPath = RenderPath.FORWARD_DYNAMIC;

	            this.setPass(MaterialPass.BASE_PASS, new DynamicLitBasePass(vertex, fragment));

	            this.setPass(MaterialPass.DIR_LIGHT_PASS, new DirectionalLightingPass(vertex, fragment, this._lightingModel));
	            this.setPass(MaterialPass.POINT_LIGHT_PASS, new PointLightingPass(vertex, fragment, this._lightingModel));
	            this.setPass(MaterialPass.SPOT_LIGHT_PASS, new SpotLightingPass(vertex, fragment, this._lightingModel));
	            this.setPass(MaterialPass.LIGHT_PROBE_PASS, new ProbeLightingPass(vertex, fragment, this._lightingModel));
	        }

	        this.setPass(MaterialPass.DIR_LIGHT_SHADOW_MAP_PASS, new DirectionalShadowPass(vertex, fragment));
	        this.setPass(MaterialPass.POINT_LIGHT_SHADOW_MAP_PASS, new PointShadowPass(vertex, fragment));

	        this.setPass(MaterialPass.NORMAL_DEPTH_PASS, new NormalDepthPass(vertex, fragment));

	        this._initialized = true;
	    },

	    /**
	     * Whether or not the Material was initialized and ready to use.
	     * @ignore
	     */
	    get initialized() { return this._initialized; },

	    /**
	     * The blend state used for this material.
	     *
	     * @see {@linkcode BlendState}
	     */
	    get blendState()
	    {
	        return this._blendState;
	    },

	    set blendState(value)
	    {
	        this._blendState = value;
	        if (value) {
	            this._additiveBlendState = value.clone();
	            this._additiveBlendState.dstFactor = BlendFactor.ONE;
	        }
	        else {
	            this._additiveBlendState = BlendState.ADD;
	        }

	        // blend state can require different render path, so shaders need to adapt
	        this._invalidate();
	    },

	    /**
	     * Allows setting a specific set of lights to this material, avoiding having to figure out lighting dynamically.
	     * This will cause all lighting to happen in a single pass, which is generally *much* faster than any other option.
	     */
	    get fixedLights()
	    {
	        return this._fixedLights;
	    },

	    set fixedLights(value)
	    {
	        this._fixedLights = value;
	        this._invalidate();
	    },

	    /**
	     * The name of the material.
	     */
	    get name()
	    {
	        return this._name;
	    },

	    set name(value)
	    {
	        this._name = value;
	    },

	    /**
	     * The {@options LightingModel} used to light this material.
	     */
	    get lightingModel()
	    {
	        return this._lightingModel;
	    },

	    set lightingModel(value)
	    {
	        this._lightingModel = value;
	        this._invalidate();
	    },

	    /**
	     * A Number that can force the order in which the material is rendered. Higher values will be rendered later!
	     */
	    get renderOrder()
	    {
	        return this._renderOrder;
	    },

	    set renderOrder(value)
	    {
	        this._renderOrder = value;
	    },

	    /**
	     * An {@linkcode ElementType} to describe the type of elements to render.
	     */
	    get elementType()
	    {
	        return this._elementType;
	    },

	    set elementType(value)
	    {
	        this._elementType = value;
	        for (var i = 0; i < MaterialPass.NUM_PASS_TYPES; ++i) {
	            if (this._passes[i])
	                this._passes[i].elementType = value;
	        }
	    },

	    /**
	     * Defines whether or not this material should write depth information.
	     */
	    get writeDepth()
	    {
	        return this._writeDepth;
	    },

	    set writeDepth(value)
	    {
	        this._writeDepth = value;

	        if (!value && this._passes[MaterialPass.NORMAL_DEPTH_PASS]) {
	            this._passes[MaterialPass.NORMAL_DEPTH_PASS] = null;
	        }
	        else if (value && !this._passes[MaterialPass.NORMAL_DEPTH_PASS])
	            this._invalidate();

	        for (var i = 0; i < MaterialPass.NUM_PASS_TYPES; ++i) {
	            if (this._passes[i])
	                this._passes[i].writeDepth = value;
	        }
	    },

	    /**
	     * Defines whether or not this material should write color information. This should only be used for some special
	     * cases.
	     */
	    get writeColor()
	    {
	        return this._writeColor;
	    },

	    set writeColor(value)
	    {
	        this._writeColor = value;

	        for (var i = 0; i < MaterialPass.NUM_PASS_TYPES; ++i) {
	            if (this._passes[i])
	                this._passes[i].writeColor = value;
	        }
	    },

	    /**
	     * Defines how back-face culling is applied. One of {@linkcode CullMode}.
	     */
	    get cullMode()
	    {
	        return this._cullMode;
	    },

	    set cullMode(value)
	    {
	        this._cullMode = value;
	        for (var i = 0; i < MaterialPass.NUM_PASS_TYPES; ++i) {
	            if (i !== MaterialPass.DIR_LIGHT_SHADOW_MAP_PASS  &&
	                i !== MaterialPass.POINT_LIGHT_SHADOW_MAP_PASS &&
	                this._passes[i])
	                this._passes[i].cullMode = value;
	        }
	    },

	    /**
	     * @ignore
	     */
	    get renderPath()
	    {
	        // make sure that if we request the path, it's figured out
	        if (!this._initialized) this.init();
	        return this._renderPath;
	    },

	    /**
	     * @ignore
	     */
	    getPass: function (type)
	    {
	        if (!this._initialized) this.init();
	        return this._passes[type];
	    },

	    /**
	     * @ignore
	     */
	    setPass: function (type, pass)
	    {
	        this._passes[type] = pass;

	        if (pass) {

	            if(type === MaterialPass.DIR_LIGHT_SHADOW_MAP_PASS || type === MaterialPass.POINT_LIGHT_SHADOW_MAP_PASS)
	                pass.cullMode = META.OPTIONS.shadowFilter.cullMode;
	            else
	                pass.cullMode = this._cullMode;

	            pass.elementType = this._elementType;
	            pass.writeDepth = this._writeDepth;
	            pass.writeColor = this._writeColor;

	            // one of the lit ones
	            if (type >= MaterialPass.DIR_LIGHT_PASS  && type <= MaterialPass.LIGHT_PROBE_PASS)
	                pass.blendState = this._additiveBlendState;

	            if (type === MaterialPass.BASE_PASS)
	                pass.blendState = this._blendState;

	            if (pass.getTextureSlot("hx_normalDepthBuffer"))
	                this._needsNormalDepth = true;

	            if (pass.getTextureSlot("hx_backbuffer"))
	                this._needsBackbuffer = true;

	            for (var slotName in this._textures) {
	                if (this._textures.hasOwnProperty(slotName)) {
	                    var texture = this._textures[slotName];
	                    if (texture instanceof Array)
	                        pass.setTextureArray(slotName, texture);
	                    else
	                        pass.setTexture(slotName, texture);
	                }
	            }

	            for (var uniformName in this._uniforms) {
	                if (this._uniforms.hasOwnProperty(uniformName)) {
	                    if (uniformName.charAt(uniformName.length - 1) === ']')
	                        pass.setUniformArray(uniformName.substr(0, uniformName.length - 3), this._uniforms[uniformName]);
	                    else
	                        pass.setUniform(uniformName, this._uniforms[uniformName]);
	                }
	            }
	        }

	        this.onChange.dispatch();
	    },

	    /**
	     * @ignore
	     */
	    hasPass: function (type)
	    {
	        if (!this._initialized) this.init();
	        return !!this._passes[type];
	    },

	    /**
	     * Assigns a texture to the shaders with a given name.
	     * @param {string} slotName The name of the texture as it appears in the shader code.
	     * @param {Texture2D} texture The texture to assign
	     */
	    setTexture: function(slotName, texture)
	    {
	        if (texture)
	            this._textures[slotName] = texture;
	        else
	            delete this._textures[slotName];

	        for (var i = 0; i < MaterialPass.NUM_PASS_TYPES; ++i)
	            if (this._passes[i]) this._passes[i].setTexture(slotName, texture);
	    },

	    /**
	     * Assigns a texture array to the shaders with a given name.
	     * @param {string} slotName The name of the texture array as it appears in the shader code.
	     * @param {Array} texture An Array of {@linkcode Texture2D} objects
	     */
	    setTextureArray: function(slotName, textures)
	    {
	        if (textures)
	            this._textures[slotName] = textures;
	        else
	            delete this._textures[slotName];

	        for (var i = 0; i < MaterialPass.NUM_PASS_TYPES; ++i)
	            if (this._passes[i]) this._passes[i].setTextureArray(slotName, textures);
	    },

	    /**
	     * Sets a uniform value to the shaders.
	     * @param name The uniform name as it appears in the shader code.
	     * @param value The uniform value. For vectors, this can be a {@linkcode Float2}, {@linkcode Float4}, or an Array
	     * @param [overwrite] If the value was already set, ignore the new value. Defaults to true.
	     */
	    setUniform: function(name, value, overwrite)
	    {
	        if (overwrite === undefined) overwrite = true;

	        if (!overwrite && this._uniforms.hasOwnProperty(name))
	            return;

	        this._uniforms[name] = value;

	        for (var i = 0; i < MaterialPass.NUM_PASS_TYPES; ++i) {
	            if (this._passes[i])
	                this._passes[i].setUniform(name, value);
	        }
	    },

	    /**
	     * Sets the value for a uniform array to the shaders.
	     * @param name The uniform array name as it appears in the shader code.
	     * @param value An array of values.
	     * @param overwrite (Optional) If the value was already set, ignore the new value.
	     */
	    setUniformArray: function(name, value, overwrite)
	    {
	        if (overwrite === undefined) overwrite = true;

	        if (!overwrite && this._uniforms.hasOwnProperty(name + '[0]'))
	            return;

	        this._uniforms[name + '[0]'] = value;

	        for (var i = 0; i < MaterialPass.NUM_PASS_TYPES; ++i) {
	            if (this._passes[i])
	                this._passes[i].setUniformArray(name, value);
	        }
	    },

	    /**
	     * @ignore
	     */
	    _setUseSkinning: function(value)
	    {
	        if (this._useSkinning !== value)
	            this._invalidate();

	        this._useSkinning = value;
	    },

	    /**
	     * @ignore
	     */
	    _setUseMorphing: function(positions, normals)
	    {
	        if (this._useSkinning !== positions || this._useNormalMorphing !== normals)
	            this._invalidate();

	        this._useMorphing = positions;
	        this._useNormalMorphing = normals;
	    },

	    /**
	     * Called by subclasses when their shaders are invalidated
	     * @ignore
	     */
	    _invalidate: function()
	    {
	        this._initialized = false;
	        this._passes = new Array(Material.NUM_PASS_TYPES);
	        this.onChange.dispatch();
	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        return "[Material(name=" + this._name + ")]";
	    }
	};

	/**
	 * @classdesc
	 * BasicMaterial is the default physically plausible rendering material.
	 *
	 * @property {boolean} doubleSided Defines whether the material is double sided (no back-face culling) or not. An easier-to-read alternative to {@linkcode Material#cullMode}
	 * @property {number} alpha The overall transparency of the object. Has no effect without a matching blendState value.
	 * @property {boolean} useVertexColors Defines whether the material should use the hx_vertexColor attribute. Only available for meshes that have this attribute.
	 * @property {Color} color The base color of the material. Multiplied with the colorMap if provided.
	 * @property {Color} emissiveColor The emission color of the material. Multiplied with the emissionMap if provided.
	 * @property {Texture2D} colorMap A {@linkcode Texture2D} object containing color data.
	 * @property {Texture2D} normalMap A {@linkcode Texture2D} object containing surface normals.
	 * @property {Texture2D} occlusionMap A {@linkcode Texture2D} object containing baked ambient occlusion.
	 * @property {Texture2D} emissionMap A {@linkcode Texture2D} object containing color emission.
	 * @property {Texture2D} specularMap A texture containing specular reflection data. The contents of the map depend on {@linkcode BasicMaterial#specularMapMode}. The roughness in the specular map is encoded as shininess; ie: lower values result in higher roughness to reflect the apparent brighness of the reflection. This is visually more intuitive.
	 * @property {Texture2D} maskMap A {@linkcode Texture2D} object containing transparency data. Requires a matching blendState.
	 * @property {number} specularMapMode Defines the contents of the specular map. One of the following:
	 * <ul>
	 *     <li>{@linkcode BasicMaterial#SPECULAR_MAP_ROUGHNESS_ONLY}</li>
	 *     <li>{@linkcode BasicMaterial#SPECULAR_MAP_ALL}</li>
	 *     <li>{@linkcode BasicMaterial#SPECULAR_MAP_SHARE_NORMAL_MAP}</li>
	 *     <li>{@linkcode BasicMaterial#SPECULAR_MAP_METALLIC_ROUGHNESS}</li>
	 * </ul>
	 * @property {number} metallicness A value describing the overall "metallicness" of an object. Normally 0 or 1, but it can be used for some hybrid materials.
	 * @property {number} normalSpecularReflectance The amount of light reflecting off a surface at 90 degrees (ie: the minimum reflectance in the Fresnel equation according to Schlick's approximation). This is generally 0.027 for most materials.
	 * @property {number} roughness The microfacet roughness of the material. Higher values will result in dimmer but larger highlights.
	 * @property {number} roughnessRange Represents the range at which the roughness map operates. When using a roughness texture, roughness represents the middle roughness, range the deviation from there. So textured roughness ranges from [roughness - roughnessRange, roughness + roughnessRange]
	 * @property {number} alphaThreshold The alpha threshold that prevents pixels with opacity below this from being rendered. This is not recommended on certain mobile platforms due to depth buffer hierarchy performance.
	 *
	 * @constructor
	 *
	 * @param options An object with key/value pairs describing the initial values of the material.
	 *
	 * <ul>
	 * <li>color: {@linkcode Color} or hexcode Number</li>
	 * <li>colorMap: {@linkcode Texture2D}</li>
	 * <li>doubleSided: Boolean</li>
	 * <li>normalMap: {@linkcode Texture2D}</li>
	 * <li>specularMap: {@linkcode Texture2D}</li>
	 * <li>maskMap: {@linkcode Texture2D}</li>
	 * <li>specularMapMode: {@linkcode BasicMaterial#SPECULAR_MAP_ROUGHNESS_ONLY}</li>
	 * <li>metallicness: Number</li>
	 * <li>alpha: Number</li>
	 * <li>roughness: Number</li>
	 * <li>roughnessRange: Number</li>
	 * <li>normalSpecularReflectance: Number</li>
	 * <li>alphaThreshold: Number</li>
	 * <li>useVertexColors: Boolean</li>
	 * <li>lightingModel: {@linkcode LightingModel}</li>
	 * </ul>
	 *
	 * @extends Material
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function BasicMaterial(options)
	{
	    Material.call(this);

	    options = options || {};

	    this._color = options.color || new Color(1, 1, 1, 1);
	    this._emissiveColor = options.emissiveColor || new Color(0, 0, 0, 1);
	    this._colorMap = options.colorMap || null;
	    this._doubleSided = !!options.doubleSided;
	    this._normalMap = options.normalMap || null;
	    this._specularMap = options.specularMap || null;
	    this._maskMap = options.maskMap || null;
	    this._specularMapMode = options.specularMapMode || BasicMaterial.SPECULAR_MAP_ROUGHNESS_ONLY;
	    this._metallicness = options.metallicness === undefined? 0.0 : options.metallicness;
	    this._alpha = options.alpha === undefined? 1.0 : options.alpha;
	    this._roughness = options.roughness === undefined ? 0.5 : options.roughness;
	    this._roughnessRange = options.roughnessRange === undefined? .5 : options.roughnessRange;
	    this._normalSpecularReflectance = options.normalSpecularReflectance === undefined? 0.027 : options.normalSpecularReflectance;
	    this._alphaThreshold = options.alphaThreshold === undefined? 1.0 : options.alphaThreshold;
	    this._useVertexColors = !!options.useVertexColors;

	    // trigger assignments
	    this.color = this._color;
	    this.emissiveColor = this._emissiveColor;
	    this.alpha = this._alpha;
	    this.metallicness = this._metallicness;
	    this.roughness = this._roughness;
	    this.normalSpecularReflectance = this._normalSpecularReflectance;

	    if (options.lightingModel !== undefined)
	        this.lightingModel = options.lightingModel;
	}

	/**
	 * Converts to roughness from a "shininess" or "gloss" property, traditionally used in Phong lighting.
	 * @param specularPower The specular power used as the gloss parameter.
	 */
	BasicMaterial.roughnessFromShininess = function(specularPower)
	{
	    return Math.sqrt(2.0/(specularPower + 2.0));
	};

	/**
	 * Used for specularMapMode to specify the specular map only uses roughness data
	 */
	BasicMaterial.SPECULAR_MAP_ROUGHNESS_ONLY = 1;
	/**
	 * Used for specularMapMode to specify the specular map has rgb channels containing roughness, normal reflectance and metallicness, respectively
	 */
	BasicMaterial.SPECULAR_MAP_ALL = 2;
	/**
	 * Used for specularMapMode to specify there is no explicit specular map, but roughness data is present in the alpha channel of the normal map.
	 */
	BasicMaterial.SPECULAR_MAP_SHARE_NORMAL_MAP = 3;
	/**
	 * Used for specularMapMode to specify the specular map has gb channels containing metallicness and roughness. This is the glTF standard.
	 */
	BasicMaterial.SPECULAR_MAP_METALLIC_ROUGHNESS = 4;


	BasicMaterial.prototype = Object.create(Material.prototype,
	    {
	        doubleSided: {
	            get: function()
	            {
	                return this._doubleSided;
	            },

	            set: function(value)
	            {
	                if (this._doubleSided !== value)
	                    this._invalidate();

	                this._doubleSided = value;
	                this.cullMode = value? CullMode.NONE : CullMode.BACK;
	            }
	        },

	        alpha: {
	            get: function ()
	            {
	                return this._alpha;
	            },
	            set: function (value)
	            {
	                this._alpha = MathX.saturate(value);
	                this.setUniform("alpha", this._alpha);
	            }
	        },

	        useVertexColors: {
	            get: function ()
	            {
	                return this._useVertexColors;
	            },
	            set: function (value)
	            {
	                if (this._useVertexColors !== value)
	                    this._invalidate();

	                this._useVertexColors = value;
	            }
	        },

	        color: {
	            get: function ()
	            {
	                return this._color;
	            },
	            set: function (value)
	            {
	                this._color = isNaN(value) ? value : new Color(value);
	                this.setUniform("color", this._color);
	            }
	        },

	        colorMap: {
	            get: function ()
	            {
	                return this._colorMap;
	            },

	            set: function (value)
	            {
	                if (!!this._colorMap !== !!value) {
	                    this._invalidate();
	                }

	                this._colorMap = value;

	                this.setTexture("colorMap", value);
	            }
	        },

	        normalMap: {
	            get: function ()
	            {
	                return this._normalMap;
	            },
	            set: function (value)
	            {
	                if (!!this._normalMap !== !!value)
	                    this._invalidate();

	                this.setTexture("normalMap", value);

	                this._normalMap = value;
	            }
	        },

	        occlusionMap: {
	            get: function ()
	            {
	                return this._occlusionMap;
	            },
	            set: function (value)
	            {
	                if (!!this._occlusionMap !== !!value)
	                    this._invalidate();

	                this.setTexture("occlusionMap", value);

	                this._occlusionMap = value;
	            }
	        },

	        emissiveColor: {
	            get: function ()
	            {
	                return this._emissiveColor;
	            },
	            set: function (value)
	            {
	                this._emissiveColor = isNaN(value) ? value : new Color(value);
	                this.setUniform("emissiveColor", this._emissiveColor);
	            }
	        },

	        emissionMap: {
	            get: function ()
	            {
	                return this._emissionMap;
	            },
	            set: function (value)
	            {
	                if (!!this._emissionMap !== !!value)
	                    this._invalidate();

	                this.setTexture("emissionMap", value);

	                this._emissionMap = value;
	            }
	        },

	        specularMap: {
	            get: function ()
	            {
	                return this._specularMap;
	            },
	            set: function (value)
	            {
	                if (!!this._specularMap !== !!value)
	                    this._invalidate();

	                this.setTexture("specularMap", value);

	                this._specularMap = value;
	            }
	        },

	        maskMap: {
	            get: function ()
	            {
	                return this._maskMap;
	            },
	            set: function (value)
	            {
	                if (!!this._maskMap !== !!value)
	                    this._invalidate();

	                this.setTexture("maskMap", value);

	                this._maskMap = value;
	            }
	        },

	        specularMapMode: {
	            get: function ()
	            {
	                return this._specularMapMode;
	            },
	            set: function (value)
	            {
	                if (this._specularMapMode !== value)
	                    this._invalidate();

	                this._specularMapMode = value;
	            }
	        },

	        metallicness: {
	            get: function ()
	            {
	                return this._metallicness;
	            },
	            set: function (value)
	            {
	                this._metallicness = MathX.saturate(value);
	                this.setUniform("metallicness", this._metallicness);
	            }
	        },

	        normalSpecularReflectance: {
	            get: function ()
	            {
	                return this._normalSpecularReflectance;
	            },
	            set: function (value)
	            {
	                this._normalSpecularReflectance = MathX.saturate(value);
	                this.setUniform("normalSpecularReflectance", this._normalSpecularReflectance);
	            }
	        },

	        roughness:
	            {
	                get: function ()
	                {
	                    return this._roughness;
	                },

	                set: function(value)
	                {
	                    this._roughness = value;
	                    this.setUniform("roughness", this._roughness);
	                }
	            },

	        roughnessRange:
	            {
	                get: function ()
	                {
	                    return this._roughnessRange;
	                },

	                set: function(value)
	                {
	                    this._roughnessRange = value;
	                    this.setUniform("roughnessRange", this._roughnessRange * 2.0);
	                }
	            },

	        alphaThreshold:
	            {
	                get: function() { return this._alphaThreshold; },
	                set: function(value) {
	                    value = MathX.saturate(value);
	                    if ((this._alphaThreshold === 1.0) !== (value === 1.0))
	                        this._invalidate();

	                    this._alphaThreshold = value;
	                    this.setUniform("alphaThreshold", value);
	                }
	            }
	    }
	);

	/**
	 * @ignore
	 */
	BasicMaterial.prototype.init = function()
	{
	    var defines = this._generateDefines();

	    this._geometryVertexShader = ShaderLibrary.get("default_geometry_vertex.glsl", defines);
	    this._geometryFragmentShader = ShaderLibrary.get("default_geometry_fragment.glsl", defines);

	    Material.prototype.init.call(this);
	};

	/**
	 * @ignore
	 */
	BasicMaterial.prototype._generateDefines = function()
	{
	    var defines = {};
	    if (this._colorMap) defines.COLOR_MAP = 1;
	    if (this._useVertexColors) defines.VERTEX_COLORS = 1;
	    if (this._normalMap) defines.NORMAL_MAP = 1;
	    if (this._occlusionMap) defines.OCCLUSION_MAP = 1;
	    if (this._emissionMap) defines.EMISSION_MAP = 1;
	    if (this._maskMap) defines.MASK_MAP = 1;
	    if (this._alphaThreshold < 1.0) defines.ALPHA_THRESHOLD = 1;

	    switch (this._specularMapMode) {
	        case BasicMaterial.SPECULAR_MAP_ROUGHNESS_ONLY:
	            if (this._specularMap) defines.ROUGHNESS_MAP = 1;
	            break;
	        case BasicMaterial.SPECULAR_MAP_ALL:
	            if (this._specularMap) defines.SPECULAR_MAP = 1;
	            break;
	        case BasicMaterial.SPECULAR_MAP_METALLIC_ROUGHNESS:
	            if (this._specularMap) defines.METALLIC_ROUGHNESS_MAP = 1;
	            break;
	        default:
	            defines.NORMAL_ROUGHNESS_MAP = 1;
	    }

	    if (this._doubleSided)
	        defines.DOUBLE_SIDED = 1;

	    return defines;
	};

	function DebugAxes()
	{
	    Entity.call(this);

	    var primitiveX = new CylinderPrimitive({
	        height: 1.0,
	        radius: .01,
	        alignment: CylinderPrimitive.ALIGN_X
	    });
	    var primitiveY = new CylinderPrimitive({
	        height: 1.0,
	        radius: .01,
	        alignment: CylinderPrimitive.ALIGN_Y
	    });
	    var primitiveZ = new CylinderPrimitive({
	        height: 1.0,
	        radius: .01,
	        alignment: CylinderPrimitive.ALIGN_Z
	    });

		primitiveX.translate(.5, 0, 0);
		primitiveY.translate(0, .5, 0);
		primitiveZ.translate(0, 0, .5);

	    var materialX = new BasicMaterial({color: 0xff0000, lightingModel: LightingModel.Unlit});
	    var materialY = new BasicMaterial({color: 0x00ff00, lightingModel: LightingModel.Unlit});
	    var materialZ = new BasicMaterial({color: 0x0000ff, lightingModel: LightingModel.Unlit});

	    this.addComponent(new MeshInstance(primitiveX, materialX));
	    this.addComponent(new MeshInstance(primitiveY, materialY));
	    this.addComponent(new MeshInstance(primitiveZ, materialZ));
	}


	DebugAxes.prototype = Object.create(SceneNode.prototype);

	/**
	 * EntitySet provides a way to keep collections of entities based on their Components. Collections should always
	 * be retrieved via {@linkcode EntitySystem}!
	 *
	 * @property {Signal} onEntityAdded Dispatched whenever an entity is added to the collection.
	 * @property {Signal} onEntityRemoved Dispatched whenever an entity is removed from the collection.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function EntitySet(hash)
	{
	    this.onEntityAdded = new Signal();
	    this.onEntityRemoved = new Signal();
	    this.onDisposed = new Signal();

	    this._hash = hash;
	    this._entities = [];
	    this._usageCount = 0;
	}

	EntitySet.prototype =
	{
	    /**
	     * The number of entities currently in the set.
	     */
	    get numEntities()
	    {
	        return this._entities.length;
	    },

	    /**
	     * Returns the entity at the given index.
	     */
	    getEntity: function(index)
	    {
	        return this._entities[index];
	    },


	    /**
	     * @ignore
	     */
	    _containsComponentHash: function(bitfield)
	    {
	        this._hash.contains(bitfield);
	    },

	    /**
	     * @ignore
	     */
	    _add: function(entity)
	    {
	        this._entities.push(entity);
	        this.onEntityAdded.dispatch(entity);
	    },

	    /**
	     * @ignore
	     */
	    _remove: function(entity)
	    {
	        this.onEntityRemoved.dispatch(entity);
	        var index = this._entities.indexOf(entity);
	        this._entities.splice(index, 1);
	    },

	    /**
	     * @ignore
	     */
	    _increaseUsage: function()
	    {
	        ++this._usageCount;
	    },

	    /**
	     * @ignore
	     */
	    free: function()
	    {
	        if (--this._usageCount === 0)
	            this.onDisposed.dispatch(this);
	    }
	};

	/**
	 * @classdesc
	 * Keeps track and updates entities
	 *
	 * @constructor
	 *
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function EntityEngine()
	{
	    this._updateableEntities = [];
	    this._entities = [];
	    this._entitySets = {};
	    this._systems = [];

	    // TODO: This would update the entity engine even if the current scene is not actually used!
	    onPreFrame.bind(this._update, this);
	}

	EntityEngine.prototype =
	{
	    startSystem: function(system)
	    {
	        if (this._systems.indexOf(system) >= 0)
	            throw new Error("System already running!");

	        this._systems.push(system);
	        system._onStarted(this);
	    },

	    stopSystem: function(system)
	    {
	        var index = this._systems.push(system);

	        if (index < 0)
	            throw new Error("System not running!");

	        this._systems.splice(index, 1);
	        system.onStopped();
	    },

	    getEntitySet: function(componentTypes)
	    {
	        var hash = new Bitfield();
	        var len = componentTypes.length;
	        for (var i = 0; i < len; ++i)
	            hash.setBit(componentTypes[i].COMPONENT_ID);

	        var str = hash.toString();
	        var set = this._entitySets[str];

	        if (!set) {
	            set = new EntitySet(hash);
				set.onDisposed.bind(this._onSetDisposed, this);
	            this._entitySets[str] = set;

	            len = this._entities.length;
	            for (i = 0; i < len; ++i) {
	                var entity = this._entities[i];
	                if (entity._componentHash.contains(hash))
	                    set._add(entity);
	            }
	        }

	        set._increaseUsage();
	        return set;
	    },

	    registerEntity: function(entity)
	    {
	        this._entities.push(entity);

	        entity._onComponentsChange.bind(this._onEntityComponentsChange, this);
	        if (entity._requiresUpdates)
	            this._addUpdatableEntity(entity);

	        ArrayUtils.forEach(this._entitySets, function(set) {
	            if (entity._componentHash.contains(set._hash))
	                set._add(entity);
	        });
	    },

	    unregisterEntity: function(entity)
	    {
	        var index = this._entities.indexOf(entity);
	        this._entities.splice(index);

	        entity._onComponentsChange.unbind(this);
	        if (entity._requiresUpdates)
	            this._removeUpdatableEntity(entity);

	        ArrayUtils.forEach(this._entitySets, function(set) {
	            if (entity._componentHash.contains(set._hash))
	                set._remove(entity);
	        });
	    },

	    _onEntityComponentsChange: function(entity, oldHash)
	    {
	        if (entity._requiresUpdates)
	            this._addUpdatableEntity(entity);
	        else
	            this._removeUpdatableEntity(entity);

	        // careful, the component is still in the entity components list, so EntitySets can dispatch onRemoved while
	        // it's still available (important to undo its state in a System).

	        ArrayUtils.forEach(this._entitySets, function(set) {
	            var containedOld = oldHash.contains(set._hash);
	            var containedNew = entity._componentHash.contains(set._hash);

	            if (!containedOld && containedNew)
	                set._add(entity);
	            else if (containedOld && !containedNew)
	                set._remove(entity);
	        });
	    },

	    _addUpdatableEntity: function(entity)
	    {
	        if (this._updateableEntities.indexOf(entity) < 0)
	            this._updateableEntities.push(entity);
	    },

	    _removeUpdatableEntity: function(entity)
	    {
	        var index = this._updateableEntities.indexOf(entity);
	        if (index >= 0)
	            this._updateableEntities.splice(index, 1);
	    },

	    _update: function(dt)
	    {
	        var entities = this._updateableEntities;
	        var len = entities.length;

	        for (var i = 0; i < len; ++i)
	            entities[i].update(dt);

	        // systems update after entities, because they usually need to updated transforms from them
	        var systems = this._systems;
	        len = systems.length;
	        for (i = 0; i < len; ++i)
	            systems[i].onUpdate(dt);
	    },

		_onSetDisposed: function(set)
	    {
	        delete this._entitySets[set._hash];
	    }
	};

	/**
	 * SpatialPartitioning forms a base class for spatial partitioning. Scene components such as MeshInstance, PointLightComponent, etc.
	 * Are placed in here to accelerate collection.
	 *
	 * @constructor
	 */
	function FlatPartitioning()
	{
		this._entities = [];
	}

	FlatPartitioning.prototype = {
		acceptVisitor: function(visitor)
		{
			var entities = this._entities;
			for (var i = 0, len = entities.length; i < len; ++i) {
				var entity = entities[i];
				if (visitor.qualifies(entity))
					entity.acceptVisitor(visitor);
			}
		},

		markEntityForUpdate: function(entity) {},

		registerEntity: function(entity)
		{
			this._entities.push(entity);
		},

		unregisterEntity: function(entity)
		{
			var index = this._entities.indexOf(entity);
			this._entities.splice(index, 1);
		}
	};

	var nameCounter$4 = 0;

	/**
	 * @classdesc
	 * Scene forms the base to contain the entire scene graph. It contains a hierarchical structure including
	 * {@linknode Entity}, lights, cameras, etc.
	 *
	 * @param {SceneNode} [rootNode] An optional scene node to use as a root. Useful if an entire scene hierarchy was already loaded.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Scene(rootNode)
	{
		this._name = "hx_scene_" + (nameCounter$4++);
		this._entityEngine = new EntityEngine();
		this._partitioning = new FlatPartitioning();
		this._rootNode = rootNode || new Entity();
		this._rootNode.name = "Root";
		this._skybox = null;
		this._rootNode._setScene(this);
	}

	Scene.prototype = {
		/**
	     * The name of the scene.
		 */
	    get name()
	    {
	        return this._name;
	    },

	    set name(value)
	    {
	        this._name = value;
	    },

	    /**
	     * The rootnode of the scene.
	     */
	    get rootNode() { return this._rootNode; },

	    /**
	     * The {@linkcode Skybox} to use when rendering the scene.
	     */
	    get skybox() { return this._skybox; },
	    set skybox(value) { this._skybox = value; },

	    /**
	     * Finds a scene node with the given name somewhere in the Scene.
	     */
	    findNodeByName: function(name)
	    {
	        return this._rootNode.findNodeByName(name);
	    },

	    /**
	     * Finds a material with the given name somewhere in the Scene.
	     */
	    findMaterialByName: function(name)
	    {
	        return this._rootNode.findMaterialByName(name);
	    },

	    /**
	     * Attaches a child to the root node.
	     */
	    attach: function(child)
	    {
	        this._rootNode.attach(child);
	    },

	    /**
	     * Removes a child from the root node.
	     */
	    detach: function(child)
	    {
	        this._rootNode.detach(child);
	    },

		/**
	     * Destroys the scene and all its children
		 */
		destroy: function()
	    {
	        this._rootNode.destroy();
	    },

	    /**
	     * The amount of children in the scene root node.
	     */
	    get numChildren()
	    {
	        return this._rootNode.numChildren;
	    },

	    /**
	     * Gets the child object at the given index.
	     */
	    getChild: function(index)
	    {
	        return this._rootNode.getChild(index);
	    },

	    /**
	     * Returns whether or not the child object is attached to the root node.
	     */
	    contains: function(child)
	    {
	        this._rootNode.contains(child);
	    },

	    /**
	     * @ignore
	     */
	    acceptVisitor: function(visitor)
	    {
	        visitor.visitScene(this);

	        // assume root node will always qualify
	        this._partitioning.acceptVisitor(visitor);
	    },

		/**
	     *
		 */
		getEntitySet: function(components)
	    {
	        return this._entityEngine.getEntitySet(components);
	    },

	    /**
	     * @ignore
	     */
	    get entityEngine()
	    {
	        return this._entityEngine;
	    },

		/**
	     * @ignore
		 */
		get partitioning()
	    {
	         return this._partitioning;
	    },

	    /**
	     * Starts a {@linkcode EntitySystem}. These are systems that allow adding more complex behaviours using components.
	     * The order of updates happen in the order they're added.
	     */
	    startSystem: function(system)
	    {
	        system._scene = this._scene;
	        this._entityEngine.startSystem(system);
	    },

	    /**
	     * Stops a {@linkcode EntitySystem}.
	     */
	    stopSystem: function(system)
	    {
	        system._scene = null;
	        this._entityEngine.stopSystem(system);
	    },

	    /**
	     * The bounding volume for the entire scene in world coordinates.
	     */
	    get worldBounds()
	    {
	        return this._rootNode.worldBounds;
	    },

	    /**
	     * Applies a function recursively to all child nodes.
	     * @param func The function to call (using the traversed node as argument)
	     * @param [thisRef] Optional reference to "this" in the calling function, to keep the scope of "this" in the called method.
	     */
	    applyFunction: function(func, thisRef)
	    {
	        this._rootNode.applyFunction(func, thisRef);
	    }
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SceneVisitor()
	{

	}

	SceneVisitor.prototype =
	{
	    // the entry point depends on the concrete subclass (collect, etc)
	    qualifies: function(object) {},
	    visitLight: function(light) {},
	    visitAmbientLight: function(light) {},
		visitMeshInstance: function (meshInstance) {},
	    visitScene: function (scene) {},
	    visitEffect: function(effect) {}
	};

	/**
	 * @classdesc
	 * SkyboxMaterial forms the default material to render skyboxes.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkyboxMaterial(texture)
	{
	    Material.call(this);

	    var vertexShader = ShaderLibrary.get("default_skybox_vertex.glsl");
	    var fragmentShader = ShaderLibrary.get("default_skybox_fragment.glsl");

	    this.writeDepth = false;
	    this.cullMode = CullMode.NONE;

	    var pass = new UnlitPass(vertexShader, fragmentShader);

	    // if no draw buffers, normals and specular don't need to be updated
	    this.setPass(MaterialPass.BASE_PASS, pass);
	    this._renderPath = RenderPath.FORWARD_FIXED;
	    this._initialized = true;
	    this._renderOrder = Number.POSITIVE_INFINITY;

	    this.setTexture("hx_skybox", texture);
	}

	SkyboxMaterial.prototype = Object.create(Material.prototype);

	/**
	 * @classdesc
	 * BoxPrimitive provides a primitive box {@linkcode Model}.
	 *
	 * @constructor
	 * @param definition An object containing the following (optional) parameters:
	 * <ul>
	 *     <li>numSegmentsW: The amount of segments along the X-axis</li>
	 *     <li>numSegmentsH: The amount of segments along the Y-axis</li>
	 *     <li>numSegmentsD: The amount of segments along the Z-axis</li>
	 *     <li>width: The width of the box</li>
	 *     <li>height: The height of the box</li>
	 *     <li>depth: The depth of the box</li>
	 *     <li>invert: Whether or not the faces should point inwards</li>
	 *     <li>doubleSided: Whether or not the faces should point both ways</li>
	 * </ul>
	 *
	 * @extends Primitive
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function BoxPrimitive(definition)
	{
	    Primitive.call(this, definition);
	}

	BoxPrimitive.prototype = Object.create(Primitive.prototype);

	BoxPrimitive.prototype._generate = function(target, definition)
	{
	    var numSegmentsW = definition.numSegmentsW || 1;
	    var numSegmentsH = definition.numSegmentsH || definition.numSegmentsW || 1;
	    var numSegmentsD = definition.numSegmentsD || definition.numSegmentsW || 1;
	    var width = definition.width || 1;
	    var height = definition.height || width;
	    var depth = definition.depth || width;
	    var flipSign = definition.invert? -1 : 1;
	    var doubleSided = definition.doubleSided === undefined? false : definition.doubleSided;

	    var rcpNumSegmentsW = 1/numSegmentsW;
	    var rcpNumSegmentsH = 1/numSegmentsH;
	    var rcpNumSegmentsD = 1/numSegmentsD;
	    var halfW = width * .5;
	    var halfH = height * .5;
	    var halfD = depth * .5;

	    var positions = target.positions;
	    var uvs = target.uvs;
	    var normals = target.normals;
	    var indices = target.indices;
	    var x, y, z;
	    var ratioU, ratioV;
	    var wSegment, hSegment, dSegment;


	    // front and back
	    for (hSegment = 0; hSegment <= numSegmentsH; ++hSegment) {
	        ratioV = hSegment * rcpNumSegmentsH;
	        y = height * ratioV - halfH;
	        if (flipSign < 0) ratioV = 1.0 - ratioV;

	        for (wSegment = 0; wSegment <= numSegmentsW; ++wSegment) {
	            ratioU = wSegment * rcpNumSegmentsW;
	            x = width * ratioU - halfW;

	            if (flipSign < 0) ratioU = 1.0 - ratioU;

	            // front and back
	            positions.push(x*flipSign, halfD*flipSign, y*flipSign);
	            positions.push(-x*flipSign, -halfD*flipSign, y*flipSign);

	            if (normals) {
	                normals.push(0, 1, 0);
	                normals.push(0, -1, 0);
	            }

	            if (uvs) {
	                uvs.push(ratioU, ratioV);
	                uvs.push(ratioU, ratioV);
	            }
	        }
	    }

	    for (hSegment = 0; hSegment <= numSegmentsH; ++hSegment) {
	        ratioV = hSegment * rcpNumSegmentsH;
	        y = height * ratioV - halfH;

	        for (dSegment = 0; dSegment <= numSegmentsD; ++dSegment) {
	            ratioU = dSegment * rcpNumSegmentsD;
	            z = depth * ratioU - halfD;

	            // left and right
	            positions.push(-halfW, z*flipSign, y);
	            positions.push(halfW, -z*flipSign, y);

	            if (normals) {
	                normals.push(-flipSign, 0, 0);
	                normals.push(flipSign, 0, 0);
	            }

	            if (uvs) {
	                uvs.push(ratioU, ratioV);
	                uvs.push(ratioU, ratioV);
	            }
	        }
	    }

	    for (dSegment = 0; dSegment <= numSegmentsD; ++dSegment) {
	        ratioV = dSegment * rcpNumSegmentsD;
	        z = depth * ratioV - halfD;

	        for (wSegment = 0; wSegment <= numSegmentsW; ++wSegment) {
	            ratioU = wSegment * rcpNumSegmentsW;
	            x = width * ratioU - halfW;

	            // top and bottom
	            positions.push(x, -z*flipSign, halfH);
	            positions.push(x, z*flipSign, -halfH);

	            if (normals) {
	                normals.push(0, 0, flipSign);
	                normals.push(0, 0, -flipSign);
	            }

	            if (uvs) {
	                uvs.push(1.0 - ratioU, 1.0 - ratioV);
	                uvs.push(1.0 - ratioU, 1.0 - ratioV);
	            }
	        }
	    }

	    var offset = 0;

	    for (var face = 0; face < 3; ++face) {
	        // order:
	        // front, back, left, right, bottom, top
	        var numSegmentsU = face === 1? numSegmentsD : numSegmentsW;
	        var numSegmentsV = face === 2? numSegmentsD : numSegmentsH;

	        for (var yi = 0; yi < numSegmentsV; ++yi) {
	            for (var xi = 0; xi < numSegmentsU; ++xi) {
	                var w = numSegmentsU + 1;
	                var base = offset + xi + yi*w;
	                var i0 = base << 1;
	                var i1 = (base + w + 1) << 1;
	                var i2 = (base + w) << 1;
	                var i3 = (base + 1) << 1;

	                indices.push(i0, i2, i1);
	                indices.push(i0, i1, i3);

	                indices.push(i0 | 1, i2 | 1, i1 | 1);
	                indices.push(i0 | 1, i1 | 1, i3 | 1);
	            }
	        }
	        offset += (numSegmentsU + 1) * (numSegmentsV + 1);
	    }

	    var indexIndex = 0;
	    if (doubleSided) {
	        var i = 0;

	        while (i < indexIndex) {
	            indices.push(indices[i], indices[i + 2], indices[i + 1]);
	            indices.push(indices[i + 3], indices[i + 5], indices[i + 4]);
	            indexIndex += 6;
	        }
	    }
	};

	/**
	 * @classdesc
	 * Frustum (a truncated pyramid) describes the set of planes bounding the camera's visible area.
	 *
	 * @constructor
	 *
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Frustum()
	{
	    this._planes = new Array(6);
	    this._corners = new Array(8);

	    for (var i = 0; i < 6; ++i)
	        this._planes[i] = new Float4();

	    for (i = 0; i < 8; ++i)
	        this._corners[i] = new Float4();
	}

	/**
	 * The index for the left plane.
	 */
	Frustum.PLANE_LEFT = 0;

	/**
	 * The index for the right plane.
	 */
	Frustum.PLANE_RIGHT = 1;

	/**
	 * The index for the bottom plane.
	 */
	Frustum.PLANE_BOTTOM = 2;

	/**
	 * The index for the top plane.
	 */
	Frustum.PLANE_TOP = 3;

	/**
	 * The index for the near plane.
	 */
	Frustum.PLANE_NEAR = 4;

	/**
	 * The index for the far plane.
	 */
	Frustum.PLANE_FAR = 5;

	/**
	 * @ignore
	 */
	Frustum.CLIP_SPACE_CORNERS = [
	    new Float4(-1.0, -1.0, -1.0, 1.0),
	    new Float4(1.0, -1.0, -1.0, 1.0),
	    new Float4(1.0, 1.0, -1.0, 1.0),
	    new Float4(-1.0, 1.0, -1.0, 1.0),
	    new Float4(-1.0, -1.0, 1.0, 1.0),
	    new Float4(1.0, -1.0, 1.0, 1.0),
	    new Float4(1.0, 1.0, 1.0, 1.0),
	    new Float4(-1.0, 1.0, 1.0, 1.0)
	];

	Frustum.prototype =
	    {
	        /**
	         * An Array of planes describing the frustum. The planes are in world space and point outwards.
	         */
	        get planes() { return this._planes; },

	        /**
	         * An array containing the 8 vertices of the frustum, in world space.
	         */
	        get corners() { return this._corners; },

	        /**
	         * @ignore
	         */
	        update: function(projection, inverseProjection)
	        {
	            this._updatePlanes(projection);
	            this._updateCorners(inverseProjection);
	        },

	        _updatePlanes: function(projection)
	        {
	            var m = projection._m;

	            var left = this._planes[Frustum.PLANE_LEFT];
	            var right = this._planes[Frustum.PLANE_RIGHT];
	            var top = this._planes[Frustum.PLANE_TOP];
	            var bottom = this._planes[Frustum.PLANE_BOTTOM];
	            var near = this._planes[Frustum.PLANE_NEAR];
	            var far = this._planes[Frustum.PLANE_FAR];

	            var r1x = m[0], r1y = m[4], r1z = m[8], r1w = m[12];
	            var r2x = m[1], r2y = m[5], r2z = m[9], r2w = m[13];
	            var r3x = m[2], r3y = m[6], r3z = m[10], r3w = m[14];
	            var r4x = m[3], r4y = m[7], r4z = m[11], r4w = m[15];

	            left.x = -(r4x + r1x);
	            left.y = -(r4y + r1y);
	            left.z = -(r4z + r1z);
	            left.w = -(r4w + r1w);
	            left.normalizeAsPlane();

	            right.x = r1x - r4x;
	            right.y = r1y - r4y;
	            right.z = r1z - r4z;
	            right.w = r1w - r4w;
	            right.normalizeAsPlane();

	            bottom.x = -(r4x + r2x);
	            bottom.y = -(r4y + r2y);
	            bottom.z = -(r4z + r2z);
	            bottom.w = -(r4w + r2w);
	            bottom.normalizeAsPlane();

	            top.x = r2x - r4x;
	            top.y = r2y - r4y;
	            top.z = r2z - r4z;
	            top.w = r2w - r4w;
	            top.normalizeAsPlane();

	            near.x = -(r4x + r3x);
	            near.y = -(r4y + r3y);
	            near.z = -(r4z + r3z);
	            near.w = -(r4w + r3w);
	            near.normalizeAsPlane();

	            far.x = r3x - r4x;
	            far.y = r3y - r4y;
	            far.z = r3z - r4z;
	            far.w = r3w - r4w;
	            far.normalizeAsPlane();
	        },

	        _updateCorners: function(inverseProjection)
	        {
	            for (var i = 0; i < 8; ++i) {
	                var corner = this._corners[i];
	                inverseProjection.transform(Frustum.CLIP_SPACE_CORNERS[i], corner);
	                corner.scale(1.0 / corner.w);
	            }
	        }
	    };

	/**
	 * @classdesc
	 * Camera is an abstract base class for camera objects.
	 *
	 * @constructor
	 *
	 * @property {number} nearDistance The minimum distance to be able to render. Anything closer gets cut off.
	 * @property {number} farDistance The maximum distance to be able to render. Anything farther gets cut off.
	 * @property {Matrix4x4} viewProjectionMatrix The matrix transforming coordinates from world space to the camera's homogeneous projective space.
	 * @property {Matrix4x4} viewMatrix The matrix transforming coordinates from world space to the camera's local coordinate system (eye space).
	 * @property {Matrix4x4} projectionMatrix The matrix transforming coordinates from eye space to the camera's homogeneous projective space.
	 * @property {Matrix4x4} inverseViewProjectionMatrix The matrix that transforms from the homogeneous projective space to world space.
	 * @property {Matrix4x4} inverseProjectionMatrix The matrix that transforms from the homogeneous projective space to view space.
	 *
	 * @see {@linkcode PerspectiveCamera}
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Camera()
	{
	    Entity.call(this);

	    this._renderTargetWidth = 0;
	    this._renderTargetHeight = 0;
	    this._viewProjectionMatrixInvalid = true;
	    this._viewProjectionMatrix = new Matrix4x4();
	    this._inverseProjectionMatrix = new Matrix4x4();
	    this._inverseViewProjectionMatrix = new Matrix4x4();
	    this._projectionMatrix = new Matrix4x4();
	    this._viewMatrix = new Matrix4x4();
	    this._projectionMatrixDirty = true;
		this._clusterPlanesDirty = true;
	    this._nearDistance = .1;
	    this._farDistance = 1000;
	    this._frustum = new Frustum();

	    this.position.set(0.0, -1.0, 0.0);
	}

	Camera.prototype = Object.create(Entity.prototype, {
	    nearDistance: {
	        get: function() {
	            return this._nearDistance;
	        },

	        set: function(value) {
	            if (this._nearDistance === value) return;
	            this._nearDistance = value;
	            this._invalidateProjectionMatrix();
	        }
	    },

	    farDistance: {
	        get: function() {
	            return this._farDistance;
	        },

	        set: function(value) {
	            if (this._farDistance === value) return;
	            this._farDistance = value;
	            this._invalidateProjectionMatrix();
	        }
	    },

	    // all x's are positive (point to the right)
	    clusterPlanesW: {
	        get: function() {
				if (this._viewProjectionMatrixInvalid)
					this._updateViewProjectionMatrix();

	            if (this._clusterPlanesDirty)
	                this._updateClusterPlanes();

	            return this._clusterPlanesW;
	        }
	    },

		// all z's are positive
	    clusterPlanesH: {
	        get: function() {
	            if (this._projectionMatrixDirty)
					this._updateProjectionMatrix();

	            if (this._clusterPlanesDirty)
	                this._updateClusterPlanes();

	            return this._clusterPlanesH;
	        }
	    },

	    viewProjectionMatrix: {
	        get: function() {
	            if (this._viewProjectionMatrixInvalid)
	                this._updateViewProjectionMatrix();

	            return this._viewProjectionMatrix;
	        }
	    },

	    viewMatrix: {
	        get: function()
	        {
	            if (this._viewProjectionMatrixInvalid)
	                this._updateViewProjectionMatrix();

	            return this._viewMatrix;
	        }
	    },

	    projectionMatrix: {
	        get: function()
	        {
	            if (this._projectionMatrixDirty)
	                this._updateProjectionMatrix();

	            return this._projectionMatrix;
	        }
	    },

	    inverseViewProjectionMatrix: {
	        get: function()
	        {
	            if (this._viewProjectionMatrixInvalid)
	                this._updateViewProjectionMatrix();

	            return this._inverseViewProjectionMatrix;
	        }
	    },

	    inverseProjectionMatrix: {
	        get: function()
	        {
	            if (this._projectionMatrixDirty)
	                this._updateProjectionMatrix();

	            return this._inverseProjectionMatrix;
	        }
	    },

	    frustum: {
	        get: function()
	        {
	            if (this._viewProjectionMatrixInvalid)
	                this._updateViewProjectionMatrix();

	            return this._frustum;
	        }
	    }
	});

	/**
	 * Returns a ray in world space at the given coordinates.
	 * @param x The x-coordinate in NDC [-1, 1] range.
	 * @param y The y-coordinate in NDC [-1, 1] range.
	 */
	Camera.prototype.getRay = function(x, y)
	{
	    var ray = new Ray();
	    var dir = ray.direction;
	    dir.set(x, y, 1, 1);
	    this.inverseProjectionMatrix.transform(dir, dir);
	    dir.homogeneousProject();
	    this.worldMatrix.transformVector(dir, dir);
	    dir.normalize();
	    this.worldMatrix.getColumn(3, ray.origin);
	    return ray;
	};

	/**
	 * @ignore
	 * @param width
	 * @param height
	 * @private
	 */
	Camera.prototype._setRenderTargetResolution = function(width, height)
	{
	    this._renderTargetWidth = width;
	    this._renderTargetHeight = height;
	};

	/**
	 * @ignore
	 */
	Camera.prototype._invalidateViewProjectionMatrix = function()
	{
	    this._viewProjectionMatrixInvalid = true;
	};

	/**
	 * @ignore
	 */
	Camera.prototype._invalidateWorldMatrix = function()
	{
	    Entity.prototype._invalidateWorldMatrix.call(this);
	    this._invalidateViewProjectionMatrix();
	};

	/**
	 * @ignore
	 */
	Camera.prototype._updateViewProjectionMatrix = function()
	{
	    this._viewMatrix.inverseAffineOf(this.worldMatrix);
	    this._viewProjectionMatrix.multiply(this.projectionMatrix, this._viewMatrix);
	    this._inverseProjectionMatrix.inverseOf(this._projectionMatrix);
	    this._inverseViewProjectionMatrix.inverseOf(this._viewProjectionMatrix);
	    this._frustum.update(this._viewProjectionMatrix, this._inverseViewProjectionMatrix);
	    this._viewProjectionMatrixInvalid = false;
	};

	/**
	 * @ignore
	 */
	Camera.prototype._invalidateProjectionMatrix = function()
	{
	    this._projectionMatrixDirty = true;
	    this._clusterPlanesDirty = true;
	    this._invalidateViewProjectionMatrix();
	};

	/**
	 * @ignore
	 */
	Camera.prototype._updateProjectionMatrix = function()
	{
	    throw new Error("Abstract method!");
	};

	/**
	 * @ignore
	 */
	Camera.prototype._updateBounds = function()
	{
	    this._bounds.clear(BoundingVolume.EXPANSE_INFINITE);
	};

	/**
	 * @ignore
	 */
	Camera.prototype.toString = function()
	{
	    return "[Camera(name=" + this._name + ")]";
	};

	/**
	 * @ignore
	 * @private
	 */
	Camera.prototype._initClusterPlanes = function()
	{
		this._clusterPlanesW = [];
		this._clusterPlanesH = [];

		for (var i = 0; i <= META.OPTIONS.numLightingCellsX; ++i) {
			this._clusterPlanesW[i] = new Float4();
	    }

		for (i = 0; i <= META.OPTIONS.numLightingCellsY; ++i) {
			this._clusterPlanesH[i] = new Float4();
		}
	};

	/**
	 * @ignore
	 * @private
	 */
	Camera.prototype._updateClusterPlanes = function()
	{
		var v1 = new Float4();
		var v2 = new Float4();
		var v3 = new Float4();

	    return function() {
	        if (!this._clusterPlanesDirty) return;

	        var ex = 2.0 / META.OPTIONS.numLightingCellsX;
	        var ey = 2.0 / META.OPTIONS.numLightingCellsY;

	        var p;

	        if (!this._clusterPlanesW)
	            this._initClusterPlanes();

	        var unproj = this._inverseProjectionMatrix;

			var x = -1.0;
	        for (var i = 0; i <= META.OPTIONS.numLightingCellsX; ++i) {
	            v1.set(x, 0.0, 0.0, 1.0);
	            v2.set(x, 0.0, 1.0, 1.0);
	            v3.set(x, 1.0, 0.0, 1.0);

				unproj.projectPoint(v1, v1);
				unproj.projectPoint(v2, v2);
				unproj.projectPoint(v3, v3);

	            this._clusterPlanesW[i].planeFromPoints(v1, v2, v3);

				x += ex;
	        }

	        var y = -1.0;
	        for (i = 0; i <= META.OPTIONS.numLightingCellsY; ++i) {
				p = this._clusterPlanesH[i];

				v1.set(0.0, y, 0.0, 1.0);
				v2.set(1.0, y, 0.0, 1.0);
				v3.set(0.0, y, 1.0, 1.0);

				unproj.projectPoint(v1, v1);
				unproj.projectPoint(v2, v2);
				unproj.projectPoint(v3, v3);

				this._clusterPlanesH[i].planeFromPoints(v1, v2, v3);

				y += ey;
			}

			this._clusterPlanesDirty = false;
	    }
	}();

	/**
	 * @ignore
	 */
	Camera.prototype.copyFrom = function(src)
	{
		Entity.prototype.copyFrom.call(this, src);
		this.nearDistance = src.nearDistance;
		this.farDistance = src.farDistance;
	};

	/**
	 * @ignore
	 */
	Camera.prototype.acceptVisitorPost = function(visitor)
	{
	    Entity.prototype.acceptVisitor.call(this, visitor);
	};

	// don't want effects etc to be added unless it's the render camera (which is handled by acceptVisitorPost)
	Camera.prototype.acceptVisitor = function(visitor)
	{
	    return;
	};

	/**
	 * @extends Camera
	 *
	 * @classdesc
	 * PerspectiveCamera is a Camera used for rendering with perspective.
	 *
	 * @property {number} verticalFOV The vertical field of view in radians.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PerspectiveCamera()
	{
	    Camera.call(this);

	    this._vFOV = 1.047198;  // radians!
	    this._aspectRatio = 1;
	}

	PerspectiveCamera.prototype = Object.create(Camera.prototype, {
	    verticalFOV: {
	        get: function()
	        {
	            return this._vFOV;
	        },
	        set: function(value)
	        {
	            if (this._vFOV === value) return;
	            this._vFOV = value;
	            this._invalidateProjectionMatrix();
	        }
	    }
	});

	/**
	 * @ignore
	 */
	PerspectiveCamera.prototype._setAspectRatio = function(value)
	{
	    if (this._aspectRatio === value) return;

	    this._aspectRatio = value;
	    this._invalidateProjectionMatrix();
	};

	/**
	 * @ignore
	 */
	PerspectiveCamera.prototype._setRenderTargetResolution = function(width, height)
	{
	    Camera.prototype._setRenderTargetResolution.call(this, width, height);
	    this._setAspectRatio(width / height);
	};

	/**
	 * @ignore
	 */
	PerspectiveCamera.prototype._updateProjectionMatrix = function()
	{
	    this._projectionMatrix.fromPerspectiveProjection(this._vFOV, this._aspectRatio, this._nearDistance, this._farDistance);
	    this._projectionMatrixDirty = false;
	};


	/**
	 * @ignore
	 */
	PerspectiveCamera.prototype.copyFrom = function(src)
	{
		Camera.prototype.copyFrom.call(this, src);
		this.verticalFOV = src.verticalFOV;
	};

	/**
	 * @inheritDoc
	 */
	PerspectiveCamera.prototype.clone = function()
	{
		var clone = new PerspectiveCamera();
		clone.copyFrom(this);
		return clone;
	};

	/**
	 * @classdesc
	 * Skybox provides a backdrop "at infinity" for the scene.
	 *
	 * @param materialOrTexture Either a {@linkcode TextureCube} or a {@linkcode Material} used to render the skybox. If a
	 * texture is passed, {@linkcode SkyboxMaterial} is used as material.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Skybox(materialOrTexture)
	{
	    Entity.call(this);

	    if (!(materialOrTexture instanceof Material))
	        materialOrTexture = new SkyboxMaterial(materialOrTexture);

	    //var model = new HX.PlanePrimitive({alignment: HX.PlanePrimitive.ALIGN_XY, width: 2, height: 2});
	    var mesh = new BoxPrimitive({width: 1, invert: true});
		mesh.bounds.clear(BoundingVolume.EXPANSE_INFINITE);
		mesh._boundsInvalid = false;

	    this._meshInstance = new MeshInstance(mesh, materialOrTexture);
	    this.addComponent(this._meshInstance);
	}

	Skybox.prototype = Object.create(Entity.prototype);

	/**
	 * @ignore
	 */
	Skybox.prototype.copyFrom = function(src)
	{
		Entity.prototype.copyFrom.call(this, src);

	};

	/**
	 * @inheritDoc
	 */
	Skybox.prototype.clone = function()
	{
		var clone = new Skybox(this._meshInstance.material);
		clone.copyFrom(this);
		return clone;
	};

	/**
	 *
	 * @classdesc
	 * ObjectPool allows pooling reusable objects. All it needs is a "next" property to keep it in the list.
	 *
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ObjectPool(type)
	{
	    var head = null;
	    var pool = null;

	    this.getItem = function()
	    {
	        var item;

	        if (head) {
	            item = head;
	            head = head.next;
	        }
	        else {
	            item = new type();
	            item.next = pool;
	            pool = item;
	        }

	        return item;
	    };

	    this.reset = function()
	    {
	        head = pool;
	    };
	}

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function RenderItem()
	{
	    this.worldMatrix = null;
	    this.meshInstance = null;
	    this.skeleton = null;
	    this.skeletonMatrices = null;
	    this.material = null;
	    this.renderOrderHint = 0;
	    this.worldBounds = null;

	    // to store this in a linked list for pooling
	    this.next = null;
	}

	var RenderSortFunctions = {
	    sortOpaques: function(a, b)
	    {
	        var diff;

	        diff = a.material._renderOrder - b.material._renderOrder;
	        if (diff !== 0) return diff;

	        diff = a.material._renderOrderHint - b.material._renderOrderHint;
	        if (diff !== 0) return diff;

	        return a.renderOrderHint - b.renderOrderHint;
	    },

	    sortTransparents: function(a, b)
	    {
	        var diff = a.material._renderOrder - b.material._renderOrder;
	        if (diff !== 0) return diff;
	        return b.renderOrderHint - a.renderOrderHint;
	    },

	    sortShadowCasters: function(a, b)
	    {
	        return a.shadowQualityBias - b.shadowQualityBias;
	    }
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function RenderCollector()
	{
	    SceneVisitor.call(this);

	    this._renderItemPool = new ObjectPool(RenderItem);

	    // Opaques are stored per RenderPath because the render path defines the order of rendering.
	    // Transparents need a single list for absolute ordering.
	    this._opaques = [];
	    this._transparents = null;
	    this._camera = null;
	    this._cameraYAxis = new Float4();
	    this._frustumPlanes = null;
	    this._lights = null;
	    this._ambientColor = new Color();
	    this._shadowCasters = null;
	    this._effects = null;
	    this._needsNormalDepth = false;
	    this._needsBackbuffer = false;
	    this._numShadowPlanes = 0;
	    this._shadowPlaneBuckets = null;
	}

	RenderCollector.MAX_SHADOW_QUALITY_BUCKETS = 4;

	RenderCollector.prototype = Object.create(SceneVisitor.prototype, {
	    numShadowPlanes: {
	        get: function() { return this._numShadowPlanes; }
	    },

	    shadowPlaneBuckets: {
	        get: function() { return this._shadowPlaneBuckets; }
	    },

	    ambientColor: {
	        get: function() { return this._ambientColor; }
	    },

	    needsNormalDepth: {
	        get: function() { return this._needsNormalDepth; }
	    },

	    needsBackbuffer: {
	        get: function() { return this._needsBackbuffer; }
	    }
	});

	RenderCollector.prototype.getOpaqueRenderList = function(path) { return this._opaques[path]; };
	RenderCollector.prototype.getTransparentRenderList = function() { return this._transparents; };
	RenderCollector.prototype.getLights = function() { return this._lights; };
	RenderCollector.prototype.getShadowCasters = function() { return this._shadowCasters; };
	RenderCollector.prototype.getEffects = function() { return this._effects; };

	RenderCollector.prototype.collect = function(camera, scene)
	{
	    this._camera = camera;
	    camera.worldMatrix.getColumn(1, this._cameraYAxis);
	    this._frustumPlanes = camera.frustum._planes;
	    this._reset();

	    scene.acceptVisitor(this);

	    for (var i = 0; i < RenderPath.NUM_PATHS; ++i)
	        this._opaques[i].sort(RenderSortFunctions.sortOpaques);

	    this._transparents.sort(RenderSortFunctions.sortTransparents);

	    // Do lights still require sorting?
	    this._shadowCasters.sort(RenderSortFunctions.sortShadowCasters);

		// add camera effects at the end
		this._camera.acceptVisitorPost(this);
	};

	RenderCollector.prototype.qualifies = function(object)
	{
	    return object.hierarchyVisible && object.worldBounds.intersectsConvexSolid(this._frustumPlanes, 6);
	};

	RenderCollector.prototype.visitScene = function (scene)
	{
	    var skybox = scene._skybox;
	    if (skybox)
	        this.visitMeshInstance(skybox._meshInstance);
	};

	RenderCollector.prototype.visitEffect = function(effect)
	{
		this._needsNormalDepth = this._needsNormalDepth || effect._needsNormalDepth;
	    this._effects.push(effect);
	};

	RenderCollector.prototype.visitMeshInstance = function (meshInstance)
	{
		if (!meshInstance.enabled) return;

		var entity = meshInstance.entity;
		var worldBounds = entity.worldBounds;
	    var cameraYAxis = this._cameraYAxis;
	    var cameraY_X = cameraYAxis.x, cameraY_Y = cameraYAxis.y, cameraY_Z = cameraYAxis.z;
	    var skeleton = meshInstance.skeleton;
	    var skeletonMatrices = meshInstance.skeletonMatrices;
	    var renderPool = this._renderItemPool;
	    var opaqueLists = this._opaques;
	    var transparentList = this._transparents;

	    var material = meshInstance.material;

	    var path = material.renderPath;

	    // only required for the default lighting model (if not unlit)
	    this._needsNormalDepth = this._needsNormalDepth || material._needsNormalDepth;
	    this._needsBackbuffer = this._needsBackbuffer || material._needsBackbuffer;

	    var renderItem = renderPool.getItem();

	    renderItem.material = material;
	    renderItem.meshInstance = meshInstance;
	    renderItem.skeleton = skeleton;
	    renderItem.skeletonMatrices = skeletonMatrices;
	    // distance along Z axis:
	    var center = worldBounds._center;
	    renderItem.renderOrderHint = center.x * cameraY_X + center.y * cameraY_Y + center.z * cameraY_Z;
	    renderItem.worldMatrix = entity.worldMatrix;
	    renderItem.worldBounds = worldBounds;

	    var bucket = (material.blendState || material._needsBackbuffer)? transparentList : opaqueLists[path];
	    bucket.push(renderItem);
	};

	RenderCollector.prototype.visitAmbientLight = function(light)
	{
	    var color = light._scaledIrradiance;
	    this._ambientColor.r += color.r;
	    this._ambientColor.g += color.g;
	    this._ambientColor.b += color.b;
	};

	RenderCollector.prototype.visitLight = function(light)
	{
	    this._lights.push(light);
	    if (light._castShadows) {
	        this._shadowCasters.push(light);
	        this._numShadowPlanes += light.numAtlasPlanes;

	        var bucketIndex = light.shadowQualityBias;
	        this._shadowPlaneBuckets[bucketIndex] += light.numAtlasPlanes;
	    }
	};

	RenderCollector.prototype._reset = function()
	{
	    this._renderItemPool.reset();

	    for (var i = 0; i < RenderPath.NUM_PATHS; ++i)
	        this._opaques[i] = [];

	    this._transparents = [];

	    this._lights = [];
	    this._shadowCasters = [];
	    this._effects = [];
	    this._needsNormalDepth = META.OPTIONS.ambientOcclusion;
	    this._ambientColor.set(0, 0, 0, 1);
	    this._numShadowPlanes = 0;
	    this._shadowPlaneBuckets = [];

	    for (i = 0; i < RenderCollector.MAX_SHADOW_QUALITY_BUCKETS; ++i) {
	        this._shadowPlaneBuckets[i] = 0;
	    }

	};

	/**
	 * Terrain provides a paged terrain engine with dynamic LOD. The heightmapping itself happens in the Material.
	 *
	 * @property {number} terrainSize The world size for the entire terrain.
	 *
	 * @param terrainSize The world size for the entire terrain's geometry. Generally smaller than the total world size of the height map.
	 * @param minElevation The minimum elevation for the terrain (maps to heightmap value 0)
	 * @param maxElevation The maximum elevation for the terrain (maps to heightmap value 1)
	 * @param numLevels The amount of levels the page tree should contain. More levels means more(!) triangles.
	 * @param material The {@linkcode Material} to use when rendering the terrain.
	 * @param detail The grid size.
	 * @constructor
	 *
	 * @extends SceneNode
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Terrain(terrainSize, minElevation, maxElevation, numLevels, material, detail)
	{
	    Component.call(this);

	    this._bounds = new BoundingAABB();
	    this._bounds.clear(BoundingVolume.EXPANSE_INFINITE);
	    this._terrainSize = terrainSize || 512;
	    this._minElevation = minElevation;
	    this._maxElevation = maxElevation;
	    this._numLevels = numLevels || 4;
	    // this container will move along with the "player"
	    // we use the extra container so the Terrain.position remains constant, so we can reliably translate and use rigid body components
	    this._container = new SceneNode();
	    this._detail = detail || 32;
	    var gridSize = Math.ceil(this._detail * .5) * 2.0; // round off to 2

	    // cannot bitshift because we need floating point result
	    this._snapSize = (this._terrainSize / this._detail) / Math.pow(2, this._numLevels);

	    this._material = material;
	    material.setUniform("hx_elevationOffset", minElevation);
	    material.setUniform("hx_elevationScale", maxElevation - minElevation);

	    this._initMeshes(gridSize);
	    this._initTree();
	}

	// TODO: Allow setting material
	Component.create(Terrain, {
	    terrainSize: {
	        get: function() {
	            return this._terrainSize;
	        }
	    }
	});

	/**
	 * @ignore
	 */
	Terrain.prototype.onAdded = function()
	{
	    this._entity.attach(this._container);
	};

	/**
	 * @ignore
	 */
	Terrain.prototype.onRemoved = function()
	{
		this._entity.detach(this._container);
	};

	/**
	 * @ignore
	 * @private
	 */
	Terrain.prototype._createMesh = function(size, numSegments, subDiv, lastLevel)
	{
	    var rcpNumSegments = 1.0 / numSegments;
	    var mesh = new Mesh();
	    var cellSize = size * rcpNumSegments;
	    var halfCellSize = cellSize * .5;

	    mesh.addVertexAttribute("hx_position", 3);
	    mesh.addVertexAttribute("hx_normal", 3);
	    mesh.addVertexAttribute("hx_cellSize", 1);

	    var vertices = [];
	    var indices = [];

	    var numZ = subDiv? numSegments - 1: numSegments;

	    var w = numSegments + 1;

	    for (var yi = 0; yi <= numZ; ++yi) {
	        var y = (yi*rcpNumSegments - .5) * size;

	        for (var xi = 0; xi <= numSegments; ++xi) {
	            var x = (xi*rcpNumSegments - .5) * size;

	            // the one corner that attaches to higher resolution neighbours needs to snap like them
	            var s = !lastLevel && xi === numSegments && yi === numSegments? halfCellSize : cellSize;
	            vertices.push(x, y, 0, 0, 0, 1, s);

	            if (xi !== numSegments && yi !== numZ) {
	                var base = xi + yi * w;

	                indices.push(base, base + w + 1, base + w);
	                indices.push(base, base + 1, base + w + 1);
	            }
	        }
	    }

	    var highIndexX = vertices.length / 7;

	    if (subDiv) {
	        y = (numSegments * rcpNumSegments - .5) * size;
	        for (xi = 0; xi <= numSegments; ++xi) {
	            x = (xi*rcpNumSegments - .5) * size;
	            vertices.push(x, y, 0, 0, 0, 1);
	            vertices.push(halfCellSize);

	            if (xi !== numSegments) {
	                base = xi + numZ * w;
	                vertices.push(x + halfCellSize, y, 0, 0, 0, 1, halfCellSize);
	                indices.push(base, highIndexX + xi * 2 + 1, highIndexX + xi * 2);
	                indices.push(base + 1, highIndexX + xi * 2 + 1, base);
	                indices.push(highIndexX + xi * 2 + 2, highIndexX + xi * 2 + 1, base + 1);
	            }
	        }
	    }

	    mesh.setVertexData(vertices, 0);
	    mesh.setIndexData(indices);
		mesh.dynamicBounds = false;
		mesh.bounds.clear();
		mesh.bounds.growToIncludeMinMax(new Float4(-size, -size, this._minElevation), new Float4(size, size, this._maxElevation));
	    return mesh;
	};

	/**
	 * @ignore
	 * @private
	 */
	Terrain.prototype._initMeshes = function(gridSize)
	{
	    this._meshes = [];
	    var meshSize = this._terrainSize * .25;

	    for (var level = 0; level < this._numLevels; ++level) {
	        if (level === this._numLevels - 1) {
	            // do not subdivide max detail
	            var mesh = this._createMesh(meshSize, gridSize, false, true);
	            this._meshes[level] = {
	                edge: mesh,
	                corner: mesh
	            };
	        }
	        else {
	            this._meshes[level] = {
	                edge: this._createMesh(meshSize, gridSize, true, false),
	                corner: this._createMesh(meshSize, gridSize, false, false)
	            };
	        }

	        meshSize *= .5;
	    }
	};

	/**
	 * @ignore
	 * @private
	 */
	Terrain.prototype._initTree = function()
	{
	    var level = 0;
	    var size = this._terrainSize * .25;
	    for (var yi = 0; yi < 4; ++yi) {
	        var y = this._terrainSize * (yi / 4 - .5) + size * .5;
	        for (var xi = 0; xi < 4; ++xi) {
	            var x = this._terrainSize * (xi / 4 - .5) + size * .5;
	            var subX = 0, subY = 0;

	            if (xi === 1)
	                subX = 1;
	            else if (xi === 2)
	                subX = -1;

	            if (yi === 1)
	                subY = 1;
	            else if (yi === 2)
	                subY = -1;

	            if (subX && subY) {
	                this._subDivide(x, y, subX, subY, level + 1, size * .5);
	            }
	            else {
	                var rotation = 0;
	                var mode = "edge";
	                // if both are 0, we have a corner
	                if (xi % 3 === yi % 3) {
	                    mode = "corner";
	                    if (xi === 0 && yi === 0) rotation = 0;
	                    if (xi === 0 && yi === 3) rotation = 1;
	                    if (xi === 3 && yi === 3) rotation = 2;
	                    if (xi === 3 && yi === 0) rotation = -1;
	                }
	                else {
	                    if (yi === 3) rotation = 2;
	                    if (xi === 3) rotation = -1;
	                    if (xi === 0) rotation = 1;
	                }
	                this._addMesh(x, y, level, rotation, mode);
	            }
	        }
	    }
	};

	/**
	 * @ignore
	 * @private
	 */
	Terrain.prototype._addMesh = function(x, y, level, rotation, mode)
	{
	    var entity = new Entity();
	    var meshInstance = new HX.MeshInstance(this._meshes[level][mode], this._material);
	    entity.addComponent(meshInstance);
	    entity.position.set(x, y, 0);
	    // this rotation aligns the higher triangle strips
	    entity.rotation.fromAxisAngle(Float4.Z_AXIS, -rotation * Math.PI * .5);
	    this._container.attach(entity);
	};

	/**
	 * @ignore
	 * @private
	 */
	Terrain.prototype._subDivide = function(x, y, subX, subY, level, size)
	{
	    size *= .5;

	    for (var yi = -1; yi <= 1; yi += 2) {
	        for (var xi = -1; xi <= 1; xi += 2) {
	            if((xi !== subX || yi !== subY) || level === this._numLevels - 1) {
	                var rotation = 0;
	                var mode = "corner";
	                // messy, I know
	                if (x < 0 && y < 0) {
	                    if (xi < 0 && yi > 0) {
	                        mode = "edge";
	                        rotation = 1;
	                    }
	                    else if (xi > 0 && yi < 0) {
	                        mode = "edge";
	                        rotation = 0;
	                    }
	                    else
	                        rotation = 0;
	                }
	                else if (x > 0 && y > 0) {
	                    if (xi > 0 && yi < 0) {
	                        mode = "edge";
	                        rotation = -1;
	                    }
	                    else if (xi < 0 && yi > 0) {
	                        mode = "edge";
	                        rotation = 2;
	                    }
	                    else
	                        rotation = 2;
	                }
	                else if (x < 0 && y > 0) {
	                    if (xi > 0 && yi > 0) {
	                        mode = "edge";
	                        rotation = 2;
	                    }
	                    else if (xi < 0 && yi < 0) {
	                        mode = "edge";
	                        rotation = 1;
	                    }
	                    else
	                        rotation = 1;
	                }
	                else if (x > 0 && y < 0) {
	                    if (xi < 0 && yi < 0) {
	                        mode = "edge";
	                        rotation = 0;
	                    }
	                    else if (xi > 0 && yi > 0) {
	                        mode = "edge";
	                        rotation = -1;
	                    }
	                    else
	                        rotation = -1;
	                }

	                this._addMesh(x + size * xi, y + size * yi, level, rotation, mode);
	            }
	        }
	    }

	    if (level < this._numLevels - 1)
	        this._subDivide(x + size * subX, y + size * subY, subX, subY, level + 1, size);
	};

	Terrain.prototype.onUpdate = function()
	{
	    if (this._camera) {
	        var cameraPos = this._camera.position;
	        var containerPos = this._container.position;
	        var entityPosition = this._entity.position;
	        containerPos.x = Math.round(cameraPos.x / this._snapSize) * this._snapSize - entityPosition.x;
	        containerPos.y = Math.round(cameraPos.y / this._snapSize) * this._snapSize - entityPosition.y;
		}
	};

	/**
	 * @ignore
	 */
	Terrain.prototype.acceptVisitor = function(visitor)
	{
	    // typechecking isn't nice, but it does what we want
	    if (visitor instanceof RenderCollector) {
			this._camera = visitor._camera;
	    }
	};

	/**
	 * @inheritDoc
	 */
	Terrain.prototype.clone = function()
	{
	    return new Terrain(this._terrainSize, this._minElevation, this._maxElevation, this._numLevels, this._material, this._detail);
	};

	/**
	 * @classdesc
	 *
	 * EntitySystems allow for more complex component-based logic. Using getEntitySet, all entities with a certain component
	 * can be retrieved. so they can update with knowledge of each-other, or of other components. (for example a
	 * HunterComponent vs PreyComponent). Other uses are if an external engine (physics, or so) needs to be updated.
	 * EntitySystems need to be started through {@linkcode Scene#startSystem}, where a strict order of updates is enforced.
	 * Systems are always updated in the order they were added, and after regular components have been updated.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function EntitySystem()
	{
	    this._entityEngine = null;
	    this._sets = [];
	    this._scene = null;
	}

	EntitySystem.prototype =
	{
	    /**
	     * The scene the EntitySystem is running on.
	     */
	    get scene()
	    {
	        return this._scene;
	    },

	    /**
	     * Called when a system is started.
	     */
	    onStarted: function()
	    {

	    },

	    /**
	     * Called when a system is stopped. Anything changed by the system should be undone here.
	     */
	    onStopped: function()
	    {

	    },

	    /**
	     * Called when a system needs to update.
	     * @param dt The time in milliseconds since last update.
	     */
	    onUpdate: function(dt)
	    {

	    },

	    /**
	     * Retrieves an {@linkcode EntitySet} containing entities matching the given components.
	     * @param components An Array of component types.
	     */
	    getEntitySet: function(components)
	    {
	        var set = this._entityEngine.getEntitySet(components);
	        this._sets.push(set);
	        return set;
	    },

	    /**
	     * @ignore
	     */
	    _onStarted: function(entityEngine)
	    {
	        this._entityEngine = entityEngine;
	        this.onStarted();
	    },

	    /**
	     * @ignore
	     */
	    _onStopped: function()
	    {
	        for (var i = 0; i < this._sets; ++i) {
	            this._sets[i].free();
	        }

	        this._sets = [];
	    }
	};

	/**
	 * @classdesc
	 * CompositeComponent is a {@linkcode Component} that can be used to group together multiple Components. It's usually
	 * subclassed to provide easy building blocks for certain combinations of Components.
	 *
	 * @constructor
	 *
	 * @extends Component
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function CompositeComponent()
	{
	    Component.call(this);
	    this._subs = [];
	}

	Component.create(CompositeComponent);

	/**
	 * Adds a {@linkcode Component} to the composite. Usually called in the constructor of the subclass.
	 */
	CompositeComponent.prototype.addComponent = function(comp)
	{
	    if (comp._entity)
	        throw new Error("Component already added to an entity!");

	    this._subs.push(comp);
	};

	/**
	 * Removes a {@linkcode Component} to the composite.
	 */
	CompositeComponent.prototype.removeComponent = function(comp)
	{
	    var index = this._subs.indexOf(comp);
	    if (index >= 0)
	        this._subs.splice(index, 1);
	};

	/**
	 * @inheritDoc
	 */
	CompositeComponent.prototype.onAdded = function()
	{
	    for (var i = 0; i < this._subs.length; ++i) {
	        var comp = this._subs[i];
	        comp._entity = this._entity;
	        comp.onAdded();
	    }
	};

	/**
	 * @inheritDoc
	 */
	CompositeComponent.prototype.onRemoved = function()
	{
	    for (var i = 0; i < this._subs.length; ++i) {
	        var comp = this._subs[i];
	        comp.onRemoved();
	        comp._entity = null;
	    }
	};

	/**
	 * @inheritDoc
	 */
	CompositeComponent.prototype.onUpdate = function(dt)
	{
	    var len = this._subs.length;
	    for (var i = 0; i < len; ++i) {
	        var comp = this._subs[i];
	        comp.onUpdate(dt);
	    }
	};

	/**
	 * @inheritDoc
	 */
	CompositeComponent.prototype.clone = function()
	{
	    var clone = new CompositeComponent();
	    for (var i = 0; i < this._subs.length; ++i) {
	        clone.addComponent(this._subs[i].clone());
	    }
	    return clone;
	};

	/**
	 * @classdesc
	 * KeyFrame is a time/value pair for use in {@AnimationClip}.
	 * @param time The time in milliseconds of the key frame.
	 * @param value The value of the key frame. This can for example be a {@linkcode SkeletonPose} for skinned animation clip.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function KeyFrame(time, value)
	{
	    this.time = time || 0.0;
	    this.value = value;
	}

	var nameCounter$5 = 0;

	/**
	 * @classdesc
	 * AnimationClip is a resource that contains key frames (time / value pairs). AnimationClip itself has no playback state,
	 * but is only used as a shareable data resource. It can be passed to {@linkcode AnimationPlayhead} or its wrappers
	 * (fe: {@linkcode SkeletonClipNode}) which will manage the play head position and allow animations.
	 *
	 * @constructor
	 *
	 * @see {@linkcode KeyFrame}
	 * @see {@linkcode AnimationPlayhead}
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AnimationClip()
	{
		this._name = "hx_animationclip_" + (nameCounter$5++);
	    this._keyFrames = [];
	    this._duration = 0;
	    this._looping = true;
	}

	AnimationClip.prototype =
	{
	    /**
	     * Defines whether this clip should repeat or not.
	     */
	    get looping()
	    {
	        return this._looping;
	    },

	    set looping(value)
	    {
	        this._looping = value;
	    },

	    /**
	     * The name of the animation clip.
	     */
	    get name()
	    {
	        return this._name;
	    },

	    set name(value)
	    {
	        this._name = value;
	    },

	    /**
	     * The amount of key frames in this clip.
	     */
	    get numKeyFrames()
	    {
	        return this._keyFrames.length;
	    },

	    /**
	     * The total duration of the clip, in milliseconds.
	     */
	    get duration()
	    {
	        return this._duration;
	    },

	    /**
	     * Adds a keyframe. Last keyframe is usually the same pose as the first and serves as an "end marker"
	     * @param frame A KeyFrame containing a SkeletonPose
	     */
	    addKeyFrame: function(frame)
	    {
	        this._keyFrames.push(frame);
	        if (frame.time > this._duration) this._duration = frame.time;
	    },

	    /**
	     * Sorts the key frames based on their time. Only call this if for some reason the keyframes were added out of order.
	     */
	    sortKeyFrames: function()
	    {
	        this._keyFrames.sort(function(a, b) {
	            return a.time - b.time;
	        });
	    },

	    /**
	     * Returns the key frame with the given index.
	     */
	    getKeyFrame: function(index)
	    {
	        return this._keyFrames[index];
	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        return "[AnimationClip(name=" + this.name + ")";
	    }
	};

	/**
	 * @classdesc
	 * AnimationPlayhead is a 'helper' class that just updates a play head. Returns the keyframes and the ratio between them.
	 * This is for example used in {@linkcode SkeletonClipNode}.
	 *
	 * @param clip {AnimationClip} The clip to play.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AnimationPlayhead(clip)
	{
	    this._clip = clip;
	    this._time = 0;
	    this._playbackRate = 1.0;
	    this._isPlaying = true;
	    this._currentFrameIndex = 0;
	    this._timeChanged = true;

	    this._looping = clip.looping;

	    /**
	     * The number of times the playhead has wrapped during the last update. Useful when moving skeleton root joint, fe.
	     * @type {number}
	     */
	    this.wraps = 0;

	    /**
	     * The first before frame the playhead's current position.
	     * @type {number}
	     */
	    this.frame1 = 0;

	    /**
	     * The frame right after the playhead's current position.
	     * @type {number}
	     */
	    this.frame2 = 0;

	    /**
	     * The ratio of the play head's position between frame1 and frame2. This is used to interpolate between frame1 and frame2's keyframe values.
	     * @type {number}
	     */
	    this.ratio = 0;
	}

	AnimationPlayhead.prototype =
	    {
	        /**
	         * A value to control the playback speed.
	         */
	        get playbackRate() { return this._playbackRate; },
	        set playbackRate(value) { this._playbackRate = value; },

	        /**
	         * Determines whether the animation should loop or not. By default, it uses the value determined by the
	         * AnimationClip, but can be overridden.
	         */
	        get looping() { return this._looping; },
	        set looping(value) { this._looping = value;},

	        /**
	         * The current time in milliseconds of the play head.
	         */
	        get time() { return this._time; },
	        set time(value)
	        {
	            if (!this._looping)
	                value = MathX.clamp(value, 0, this._clip.duration);

	            if (this._time === value) return;
	            this._time = value;
	            this._timeChanged = true;
	        },

	        /**
	         * Starts updating the play head when update(dt) is called.
	         */
	        play: function()
	        {
	            this._isPlaying = true;
	        },

	        /**
	         * Stops updating the play head when update(dt) is called.
	         */
	        stop: function()
	        {
	            this._isPlaying = false;
	        },

	        /**
	         * This needs to be called every frame.
	         * @param dt The time passed since last frame in milliseconds.
	         * @returns {boolean} Whether or not the playhead moved. This can be used to spare further calculations if the old state is kept.
	         */
	        update: function(dt)
	        {
	            var playheadUpdated = (this._isPlaying && dt !== 0.0);
	            if (!playheadUpdated && !this._timeChanged)
	                return false;

	            this._timeChanged = false;

	            if (this._isPlaying) {
	                dt *= this._playbackRate;
	                this._time += dt;
	            }

	            var clip = this._clip;
	            // the last keyframe is just an "end marker" to interpolate with, it has no duration
	            var numKeyFrames = clip.numKeyFrames;
	            var numBaseFrames = numKeyFrames - 1;
	            var duration = clip.duration;
	            var wraps = 0;

	            if (!this._looping) {
	                if (this._time > duration) {
	                    this._time = duration;
	                    this._isPlaying = false;
	                }
	                else if (this._time < 0) {
	                    this._time = 0;
	                    this._isPlaying = false;
	                }
	            }

	            var frameA, frameB;

	            if (dt >= 0) {
	                // could replace the while loop with an if loop and calculate wrap with division, but it's usually not more
	                // than 1 anyway
	                while (this._looping && this._time >= duration) {
	                    // reset playhead to make sure progressive update logic works
	                    this._currentFrameIndex = 0;
	                    this._time -= duration;
	                    ++wraps;
	                }

	                do {
	                    // advance play head
	                    if (++this._currentFrameIndex === numKeyFrames) this._currentFrameIndex = 0;
	                    frameB = clip.getKeyFrame(this._currentFrameIndex);
	                } while (frameB.time < this._time);

	                --this._currentFrameIndex;
	                frameA = clip.getKeyFrame(this._currentFrameIndex);
	            }
	            else {
	                while (this._looping && this._time < 0) {
	                    // reset playhead to make sure progressive update logic works
	                    this._currentFrameIndex = numBaseFrames;
	                    this._time += duration;
	                    ++wraps;
	                }

	                ++this._currentFrameIndex;
	                do {
	                    if (--this._currentFrameIndex < 0) this._currentFrameIndex = numKeyFrames;
	                    frameA = clip.getKeyFrame(this._currentFrameIndex);
	                } while (frameA.time > this._time);
	            }

	            this.wraps = wraps;
	            this.frame1 = frameA;
	            this.frame2 = frameB;
	            this.ratio = (this._time - frameA.time) / (frameB.time - frameA.time);

	            return true;
	        }
	    };

	/**
	 * @classdesc
	 * MorphPose defines a certain configuration for blending several morph targets. While this can be used to directly
	 * assign to a {@linkcode MeshInstance}, it's usually controlled through a component such as {@MorphAnimation}. Other
	 * components could use several MorphPose objects in keyframes and tween between them over a timeline.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function MorphPose()
	{
	    this._weights = {};
	    this._stateInvalid = true;
	    this._knownTargets = [];
	    this.onChange = new Signal();
	}

	MorphPose.prototype =
	{
	    /**
	     * Gets the weight of a morph target with the given name.
	     * @param {string} name The name of the morph target.
	     * @returns {number}
	     */
	    getWeight: function(name)
	    {
	        return this._weights[name];
	    },

		/**
	     * Gets the morph target name at the given index. The targets are sorted by importance.
		 */
		getMorphTargetName: function(index)
	    {
	        return this._knownTargets[index];
	    },

		/**
		 * Sets the weight of a morph target with the given name.
	     * @param {string} name The name of the morph target.
	     * @param {number} value The new weight.
	     */
	    setWeight: function(id, value)
	    {
	        var v = this._weights[id];

	        if (v === value) return;

	        if (v === undefined)
	            this._knownTargets.push(id);

	        this._stateInvalid = true;

	        this._weights[id] = value;
	    },

	    /**
	     * Updates the morph pose given the current weights. Usually called by a wrapping component. If no component is used,
	     * update needs to be called manually.
	     */
	    update: function()
	    {
	        if (!this._stateInvalid) return;

	        var w = this._weights;

	        // sort by weights
			this._knownTargets.sort(function(a, b) {
	            return w[b.name] - w[a.name];
	        });

	        this._stateInvalid = false;
	        this.onChange.dispatch();
	    },

		/**
	     * Creates a copy of this MorphPose object
		 */
		clone: function()
	    {
	        var clone = new MorphPose();

	        for (var name in this._weights) {
	            clone.setWeight(name, this._weights[name]);
	        }

	        return clone;
	    }
	};

	var nameCounter$6 = 0;

	/**
	 * @classdesc
	 * MorphAnimation is a {@linkcode Component} that can be added to an Entity to control morph target animations. The Mesh
	 * objects used by the Entity's MeshInstance components must contain morph targets assigned with
	 * {@linkcode Mesh#addMorphTarget}. Up to 8 morph targets can be active at a time. If more morph targets have a weight
	 * assigned to them, only those with the highest weights are used.
	 *
	 * @constructor
	 *
	 * @param [morphPose] An optional MorphPose. This allows sharing poses across entities.
	 *
	 * @see {@linkcode MorphPose}
	 * @see {@linkcode MorphTarget}
	 *
	 * @extends Component
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function MorphAnimation(morphPose)
	{
	    Component.call(this);

		this._name = "hx_morphanimation_" + (nameCounter$6++);

	    if (morphPose) {
	        this._morphPose = morphPose;
		}
		else {
			this._morphPose = new MorphPose();
		}
	}

	Component.create(MorphAnimation,
	    {
	        morphPose: {
	            get: function() { return this._morphPose; },
	            set: function(value) {
	                this._morphPose = value;
	                this._assignMorphPose(value);
	            }
	        }
	    }
	);

	/**
	 * Sets the weight of the morph target with the given name.
	 * @param {string} name The name of the morph target to influence.
	 * @param {number} value The new weight of the morph target.
	 */
	MorphAnimation.prototype.setWeight = function(name, value)
	{
	    this._morphPose.setWeight(name, value);
	};

	/**
	 * @ignore
	 */
	MorphAnimation.prototype.onAdded = function()
	{
	    this._assignMorphPose(this._morphPose);
	};

	/**
	 * @ignore
	 */
	MorphAnimation.prototype.onRemoved = function()
	{
	    this._assignMorphPose(null);
	};

	/**
	 * @ignore
	 */
	MorphAnimation.prototype.onUpdate = function(dt)
	{
	    this._morphPose.update();
	};

	/**
	 * @ignore
	 */

	MorphAnimation.prototype._assignMorphPose = function(pose)
	{
		var meshInstances = this.entity.getComponentsByType(MeshInstance);
		for (var i = 0, len = meshInstances.length; i < len; ++i) {
			meshInstances[i].morphPose = pose;
	    }
	};

	MorphAnimation.prototype.clone = function()
	{
		var clone = new MorphAnimation(this._morphPose.clone());
		clone._name = this._name;
		return clone;
	};

	var nameCounter$7 = 0;

	/**
	 * @classdesc
	 *
	 * LayeredAnimation is a Component that combines a set of AnimationLayer objects into a single manageable animation.
	 * The layer animations can act on any object, joint pose or morph pose in the hierarchy of the {@linkcode Entity} to
	 * which the Component was assigned. When added to the Scene's root node, it can be seen as a global keyframe animation
	 * system for the given scene.
	 *
	 * @constructor
	 *
	 * @extends Component
	 *
	 * @property name The name of the animation.
	 * @property playbackRate A value to control the playback speed.
	 * @property time The current time in milliseconds of the play head.
	 * @property looping Determines whether the animation should loop or not. By default, it uses the value determined by
	 * the AnimationClip, but can be overridden.
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function LayeredAnimation()
	{
		Component.call(this);
		this._layers = [];
		this._time = 0;
		this._playbackRate = 1;
		this._name = "hx_layeredanimation_" + (nameCounter$7++);
		this._looping = true;
	}

	Component.create(LayeredAnimation, {
		name: {
			get: function()
			{
				return this._name;
			},

			set: function(value)
			{
				this._name = value;
			}
		},

		playbackRate: {
			get: function()
			{
				return this._playbackRate;
			},

			set: function(value)
			{
				this._playbackRate = value;
			}
		},

		time: {
			get: function()
			{
				return this._time;
			},

			set: function(value)
			{
				this._time = value;
				for (var i = 0; i < this._layers.length; ++i) {
					this._layers[i].time = value;
				}
			}
		},

		looping: {
			get: function()
			{
				return this._looping;
			},

			set: function(value)
			{
				this._looping = value;
				for (var i = 0; i < this._layers.length; ++i) {
					this._layers[i].looping = true;
				}
			}
		}
	});

	/**
	 * Adds a layer to the animation
	 * @param layer
	 */
	LayeredAnimation.prototype.addLayer = function(layer)
	{
		this._layers.push(layer);
		layer.time = this._time;
		layer.looping = this._looping;
	};

	/**
	 * Removes a layer from the animation
	 * @param layer
	 */
	LayeredAnimation.prototype.removeLayer = function(layer)
	{
		var index = this._layers.indexOf(layer);
		if (index >= 0)
			this._layers.splice(index, 1);
	};

	LayeredAnimation.prototype.onAdded = function()
	{
		var lookups = this._collectPotentialTargets();

		for (var i = 0, len = this._layers.length; i < len; ++i) {
			this._layers[i].resolveTarget(lookups);
		}
	};

	LayeredAnimation.prototype.onRemoved = function()
	{
		for (var i = 0, len = this._layers.length; i < len; ++i) {
			this._layers[i].resolveTarget(null);
		}
	};

	LayeredAnimation.prototype.onUpdate = function(dt)
	{
		dt *= this._playbackRate;

		this._time += dt;

		var len = this._layers.length;
		for (var i = 0; i < len; ++i) {
			this._layers[i].update(dt);
		}
	};

	LayeredAnimation.prototype.clone = function()
	{
		var clone = new LayeredAnimation();
		clone.name = this.name;
		clone.looping = this.looping;
		clone.playbackRate = this.playbackRate;
		clone.time = this.time;

		for (var i = 0, len = this._layers.length; i < len; ++i) {
			var layer = this._layers[i];
			clone.addLayer(layer.clone());
		}

		return clone;
	};

	LayeredAnimation.prototype._collectPotentialTargets = function()
	{
		var targets = {};
		this._entity.applyFunction(function(node) {
			targets[node._name] = node;

			if (node instanceof Entity) {
				var meshInstances = node.getComponentsByType(MeshInstance);

				for (var i = 0, len = meshInstances.length; i < len; ++i) {
					targets[meshInstances[i].name] = meshInstances[i];
					this._collectPotentialJoints(meshInstances[i], targets);
				}

				var morphAnimations = node.getComponentsByType(MorphAnimation);
				for (i = 0, len = morphAnimations.length; i < len; ++i) {
					targets[morphAnimations[i].name] = morphAnimations[i];
				}
			}
		}, this);

		return targets;
	};

	/**
	 * @private
	 * @ignore
	 */
	LayeredAnimation.prototype._collectPotentialJoints = function(meshInstance, targets)
	{
		var skeleton = meshInstance.skeleton;

		if (!skeleton) return;

		for (var i = 0, len = skeleton.numJoints; i < len; ++i) {
			targets[skeleton.getJoint(i).name] = meshInstance.skeletonPose.getJointPose(i);
		}

		return false;
	};

	var nameCounter$8 = 0;

	/**
	 * @classdesc
	 * AnimationLayer is a wrapper for a clip and a playhead that targets a specific object and that can be used in
	 * LayeredAnimation.
	 *
	 * @param targetName The name of the target object. The name must match the name of an Entity, a MorphAnimation, a MeshInstance, or a SkeletonJoinr somewhere in the hierarchy of the animation's owning Entity
	 * @param propertyName The name of the target object's animated property. Usually 'position', 'rotation', 'scale' or the name of a morph target.
	 * @param clip The clip containing the keyframes for the animation
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AnimationLayer(targetName, propertyName, clip)
	{
	    this._name = "hx_animationlayer_" + (nameCounter$8++);
	    this._clip = clip;
	    this._playhead = new AnimationPlayhead(clip);
	    this._targetName = targetName;
	    this._targetObject = null;
	    this._propertyName = propertyName;
	}

	AnimationLayer.prototype =
	{
	    /**
	     * Defines whether this layer should repeat or not.
	     */
	    get looping()
	    {
	        return this._playhead.looping;
	    },

	    set looping(value)
	    {
	        this._playhead.looping = value;
	    },

	    /**
	     * The current time in milliseconds of the play head.
	     */
	    get time() { return this._playhead.time; },
	    set time(value) { this._playhead.time = value; },

	    /**
	     * The total duration of the layer, in milliseconds.
	     */
	    get duration()
	    {
	        return this._clip.duration;
	    },

	    /**
	     * Returns the key frame with the given index.
	     */
	    getKeyFrame: function(index)
	    {
	        return this._clip.getKeyFrame(index);
	    },

	    /**
	     * This needs to be called every frame.
	     * @param dt The time passed since last frame in milliseconds.
	     * @returns {boolean} Whether or not the playhead moved. This can be used to spare further calculations if the old state is kept.
	     */
	    update: function(dt)
	    {
	        // this._playhead.update(dt);
	    },

		/**
	     * This finds the concrete objects belonging to the layers
	     * @ignore
		 */
		resolveTarget: function(targets)
	    {
	        if (targets === null) {
	            this._targetObject = null;
	            return;
	        }

	        this._targetObject = targets[this._targetName];
	        if (!this._targetObject) console.warn("Animation target '" + this._targetName + "' not found");
	        this._verifyTarget();
	    },

		/**
	     * Allows testing whether the target is of the correct type for this layer.
	     * @ignore
		 * @private
		 */
		_verifyTarget: function()
	    {

	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        return "[AnimationLayer(name=" + this.name + ")";
	    },

		/**
		 * Creates a copy of this AnimationLayer object.
		 */
		clone: function()
	    {
	        throw new Error("Abstract method called!");
	    }
	};

	/**
	 * @classdesc
	 * SkeletonJointPose represents the translation, rotation, and scale for a joint to have. Used by {@linkcode SkeletonPose}.
	 * Generally not of interest to casual users.
	 *
	 * @constructor
	 *
	 * @see {@linkcode SkeletonPose}
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonJointPose()
	{
	    this.position = new Float4();
	    this.rotation = new Quaternion();
	    this.scale = new Float4(1, 1, 1);
	    this.skeletonPose = null;
	}

	SkeletonJointPose.prototype =
	    {
	        copyFrom: function(a)
	        {
	            this.rotation.copyFrom(a.rotation);
	            this.position.copyFrom(a.position);
	            this.scale.copyFrom(a.scale);
	        },

	        toString: function()
	        {
	            return "[SkeletonJointPose]";
	        }
	    };

	/**
	 * @classdesc
	 * AnimationLayerFloat4 is an {@linkcode AnimationLayer} targeting {@linkcode Float4} objects
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AnimationLayerFloat4(targetName, propertyName, clip)
	{
	    AnimationLayer.call(this, targetName, propertyName, clip);
	}

	AnimationLayerFloat4.prototype = Object.create(AnimationLayer.prototype);

	/**
	 * @ignore
	 * @private
	 */
	AnimationLayerFloat4.prototype._verifyTarget = function()
	{
		Debug.assert(this._targetObject[this._propertyName] instanceof Float4, "Type mismatch!");

		this._skeletonPose = this._targetObject instanceof SkeletonJointPose? this._targetObject.skeletonPose : null;
	};

	/**
	 * This needs to be called every frame.
	 * @param dt The time passed since last frame in milliseconds.
	 * @returns {boolean} Whether or not the playhead moved. This can be used to spare further calculations if the old state is kept.
	 */
	AnimationLayerFloat4.prototype.update = function (dt)
	{
	    var playhead = this._playhead;

	    if (playhead.update(dt)) {
	        this._targetObject[this._propertyName].lerp(playhead.frame1.value, playhead.frame2.value, playhead.ratio);
	        if (this._skeletonPose) this._skeletonPose.invalidateGlobalPose();
	    }
	};

	/**
	 * @inheritDoc
	 */
	AnimationLayerFloat4.prototype.clone = function()
	{
		return new AnimationLayerFloat4(this._targetName, this._propertyName, this._clip);
	};

	/**
	 * @classdesc
	 * AnimationLayerQuat is an {@linkcode AnimationLayer} targeting {@linkcode Quaternion} objects
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AnimationLayerQuat(targetName, propertyName, clip)
	{
	    AnimationLayer.call(this, targetName, propertyName, clip);
	}

	AnimationLayerQuat.prototype = Object.create(AnimationLayer.prototype);

	/**
	 * @ignore
	 * @private
	 */
	AnimationLayerQuat.prototype._verifyTarget = function()
	{
		Debug.assert(this._targetObject[this._propertyName] instanceof Quaternion, "Type mismatch!");
		this._skeletonPose = this._targetObject instanceof SkeletonJointPose? this._targetObject.skeletonPose : null;
	};



	/**
	 * This needs to be called every frame.
	 * @param dt The time passed since last frame in milliseconds.
	 * @returns {boolean} Whether or not the playhead moved. This can be used to spare further calculations if the old state is kept.
	 */
	AnimationLayerQuat.prototype.update = function (dt)
	{
	    var playhead = this._playhead;

	    if (playhead.update(dt)) {
	        this._targetObject[this._propertyName].slerp(playhead.frame1.value, playhead.frame2.value, playhead.ratio);
	        if (this._skeletonPose) this._skeletonPose.invalidateGlobalPose();
	    }
	};

	/**
	 * @inheritDoc
	 */
	AnimationLayerQuat.prototype.clone = function()
	{
		return new AnimationLayerQuat(this._targetName, this._propertyName, this._clip);
	};

	/**
	 * @classdesc
	 * AnimationLayerMorphPose is an {@linkcode AnimationLayer} targeting {@linkcode MorphPose} objects
	 *
	 * @constructor
	 *
	 * @param targetName The MorphPose to be targeted
	 * @param morphTargetName The name of the morph target to be played
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AnimationLayerMorphTarget(targetName, morphTargetName, clip)
	{
	    AnimationLayer.call(this, targetName, morphTargetName, clip);
	}

	AnimationLayerMorphTarget.prototype = Object.create(AnimationLayer.prototype);


	/**
	 * @ignore
	 * @private
	 */
	AnimationLayerMorphTarget.prototype._verifyTarget = function()
	{
	    if (this._targetObject instanceof MeshInstance)
			this._targetObject = this._targetObject.morphPose;
		else
	        Debug.assert(this._targetObject instanceof MorphAnimation, "Type mismatch!");
	};

	/**
	 * @inheritDoc
	 */
	AnimationLayerMorphTarget.prototype.update = function (dt)
	{
	    var playhead = this._playhead;

	    if (playhead.update(dt)) {
	        var value = MathX.lerp(playhead.frame1.value, playhead.frame2.value, playhead.ratio);
	        this._targetObject.setWeight(this._propertyName, value);

	    }
	};

	/**
	 * @inheritDoc
	 */
	AnimationLayerMorphTarget.prototype.clone = function()
	{
		return new AnimationLayerMorphTarget(this._targetName, this._propertyName, this._clip);
	};

	/**
	 * @classdesc
	 * Skeleton defines the collection of joints used by the model to handle skinned animations.
	 *
	 * @see {@linkcode SkeletonJoint}
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Skeleton()
	{
	    this._applyInverseBindPose = true;
	    this._joints = [];
	    this._name = "";
	}

	Skeleton.prototype =
	{
	    /**
	     * Defines whether or not the inverse bind pose should be applied for this skeleton.
	     */
	    get applyInverseBindPose()
	    {
	        return this._applyInverseBindPose;
	    },

	    set applyInverseBindPose(value)
	    {
	        this._applyInverseBindPose = value;
	    },

	    /**
	     * The amount of joints in the Skeleton.
	     * @returns {Number}
	     */
	    get numJoints()
	    {
	        return this._joints.length;
	    },

	    /**
	     * Adds a joint to the Skeleton.
	     * @param {SkeletonJoint} joint
	     */
	    addJoint: function(joint)
	    {
	        this._joints.push(joint);
	    },

	    /**
	     * Gets a joint at the specified index.
	     * @param {number} index
	     */
	    getJoint: function(index)
	    {
	        return this._joints[index];
	    },

	    /**
	     * The name of this Skeleton.
	     */
	    get name()
	    {
	        return this._name;
	    },

	    set name(value)
	    {
	        this._name = value;
	    },

	    /**
	     * @ignore
	     */
	    toString: function()
	    {
	        return "[Skeleton(name=" + this.name + ")";
	    }
	};

	/**
	 * @classdesc
	 * SkeletonPose represents an entire pose a {@linkcode Skeleton} can have. Usually, several poses are interpolated to create animations.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonPose()
	{
	    this._jointPoses = [];

	    this._skinningTexture = null;
	    // "global" is in fact model space
	    this._globalMatrices = null;
	    this._bindMatrices = null;
	    this._skeletonMatricesInvalid = true;
	}

	SkeletonPose.prototype = {
	    /**
	     * The number of joint poses.
	     */
	    get numJoints()
	    {
	        return this._jointPoses.length;
	    },

	    /**
	     * Returns the joint pose at a given position
	     */
	    getJointPose: function(index)
	    {
	        return this._jointPoses[index];
	    },

	    /**
	     * Assigns a joint pose.
	     */
	    setJointPose: function(index, value)
	    {
	        this._jointPoses[index] = value;
	        value.skeletonPose = this;
	    },

	    /**
	     * Lets the engine know the pose has been updated
	     */
	    invalidateGlobalPose: function()
	    {
	        this._skeletonMatricesInvalid = true;
	    },

	    /**
	     * Interpolates between two poses and stores it in the current
	     * @param a
	     * @param b
	     * @param factor
	     */
	    interpolate: function (a, b, factor)
	    {
	        a = a._jointPoses;
	        b = b._jointPoses;
	        var len = a.length;

	        if (this._jointPoses.length !== len)
	            this._initJointPoses(len);

	        var target = this._jointPoses;
	        for (var i = 0; i < len; ++i) {
	            var t = target[i];
	            t.rotation.slerp(a[i].rotation, b[i].rotation, factor);
	            t.position.lerp(a[i].position, b[i].position, factor);
	            t.scale.lerp(a[i].scale, b[i].scale, factor);
	        }
	    },

	    /**
	     * Grabs the inverse bind pose data from a skeleton and generates a local pose from it
	     * @param skeleton
	     */
	    copyBindPose: function (skeleton)
	    {
	        var m = new Matrix4x4();
	        for (var i = 0; i < skeleton.numJoints; ++i) {
	            var j = skeleton.getJoint(i);
	            var p = this._jointPoses[i] = new SkeletonJointPose();
	            // global bind pose matrix
	            m.inverseAffineOf(j.inverseBindPose);

	            // local bind pose matrix
	            if (j.parentIndex >= 0)
	                m.append(skeleton.getJoint(j.parentIndex).inverseBindPose);

	            m.decompose(p);
	        }
	    },

	    /**
	     * Copies another pose.
	     */
	    copyFrom: function (a)
	    {
	        a = a._jointPoses;
	        var target = this._jointPoses;
	        var len = a.length;

	        if (this._jointPoses.length !== len)
	            this._initJointPoses(len);

	        for (var i = 0; i < len; ++i)
	            target[i].copyFrom(a[i]);
	    },

	    /**
	     * @ignore
	     */
	    _initJointPoses: function (numJointPoses)
	    {
	        this._numJoints = numJointPoses;
	        this._jointPoses.length = numJointPoses;
	        for (var i = 0; i < numJointPoses; ++i)
	            this.setJointPose(i, new SkeletonJointPose());
	    },

	    /**
	     * @ignore
	     */
	    getBindMatrices: function(skeleton)
	    {
	        if (this._skeletonMatricesInvalid || this._skeleton !== skeleton)
	            this._updateSkeletonMatrices(skeleton);

	        this._skeleton = skeleton;

	        return this._skinningTexture || this._bindMatrices;
	    },

	    /**
	     * @ignore
	     */
	    _generateDefault: function (skeleton)
	    {
	        this._skeletonMatricesInvalid = false;
	        this._skeleton = skeleton;

	        this._initJointPoses(skeleton.numJoints);

	        var m = new HX.Matrix4x4();

	        for (var i = 0; i < this._jointPoses.length; ++i) {
	            m.inverseOf(skeleton.getJoint(i).inverseBindPose);
	            m.decompose(this._jointPoses[i]);
	        }

	        if (META.OPTIONS.useSkinningTexture) {
	            this._skinningTexture = DEFAULTS.DEFAULT_SKINNING_TEXTURE;
	            return;
	        }

	        this._globalMatrices = [];
	        this._bindMatrices = [];
	        for (i = 0; i < skeleton.numJoints; ++i) {
	            this._globalMatrices[i] = new Matrix4x4();
	            this._bindMatrices[i] = new Matrix4x4();
	        }
	    },

	    /**
	     * @ignore
	     */
	    _updateSkeletonMatrices: function (skeleton)
	    {
	        var globals = this._globalMatrices;
	        var binds = this._bindMatrices;

	        if (!globals || globals.length !== skeleton.numJoints) {
	            this._generateGlobalSkeletonData(skeleton);
	            globals = this._globalMatrices;
	            binds = this._bindMatrices;
	        }

	        var len = skeleton.numJoints;

	        for (var i = 0; i < len; ++i) {
	            var pose = this._jointPoses[i];
	            var global = globals[i];

	            var joint = skeleton.getJoint(i);
	            var parentIndex = joint.parentIndex;

	            global.compose(pose);

	            if (parentIndex !== -1)
	                global.append(globals[parentIndex]);

	            if (skeleton._applyInverseBindPose)
	                binds[i].multiplyAffine(global, joint.inverseBindPose);
	            else
	                binds[i].copyFrom(global);
	        }

	        if (META.OPTIONS.useSkinningTexture)
	            this._updateSkinningTexture();
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _generateGlobalSkeletonData: function (skeleton)
	    {
	        this._globalMatrices = [];
	        this._bindMatrices = [];

	        for (var i = 0; i < skeleton.numJoints; ++i) {
	            this._globalMatrices[i] = new Matrix4x4();
	            this._bindMatrices[i] = new Matrix4x4();
	        }

	        if (META.OPTIONS.useSkinningTexture) {
	            this._skinningTexture = new Texture2D();
	            this._skinningTexture.filter = TextureFilter.NEAREST_NOMIP;
	            this._skinningTexture.wrapMode = TextureWrapMode.CLAMP;
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _updateSkinningTexture: function ()
	    {
	        var data;

	        return function()
	        {
	            data = data || new Float32Array(META.OPTIONS.maxSkeletonJoints * 3 * 4);
	            var globals = this._bindMatrices;
	            var len = globals.length;
	            var j = 0;

	            for (var r = 0; r < 3; ++r) {
	                for (var i = 0; i < len; ++i) {
	                    var m = globals[i]._m;

	                    data[j++] = m[r];
	                    data[j++] = m[r + 4];
	                    data[j++] = m[r + 8];
	                    data[j++] = m[r + 12];
	                }

	                for (i = len; i < META.OPTIONS.maxSkeletonJoints; ++i) {
	                    data[j++] = 0.0;
	                    data[j++] = 0.0;
	                    data[j++] = 0.0;
	                    data[j++] = 0.0;
	                }
	            }

	            this._skinningTexture.uploadData(data, META.OPTIONS.maxSkeletonJoints, 3, false, TextureFormat.RGBA, DataType.FLOAT);
	        }
	    }(),

	    clone: function()
	    {
	        var clone = new SkeletonPose();
	        clone.copyFrom(this);
	        return clone;
	    }
	};

	/**
	 * @classdesc
	 * An abstract base class for nodes in a {@linkcode SkeletonBlendTree}
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonBlendNode()
	{
	    this._rootJointDeltaPosition = new Float4();
	    this._pose = new SkeletonPose();
	    this._name = null;
	}

	SkeletonBlendNode.prototype =
	{
	    /**
	     * The name of the node, by which it can be retrieved from {@linkcode SkeletonBlendTree} and {@linkcode SkeletonAnimation}
	     */
	    get name()
	    {
	        return this._name;
	    },

	    set name(value)
	    {
	        this._name = value;
	    },


	    /**
	     * @ignore
	     */
	    findNode: function(name)
	    {
	        if (this._name === name) return this;
	        return this._queryChildren(name);
	    },

	    /**
	     * @ignore
	     */
	    update: function(dt, transferRootJoint)
	    {
	    },

	    /**
	     * @ignore
	     */
	    get rootJointDeltaPosition() { return this._rootJointDeltaPosition; },

	    /**
	     * @ignore
	     */
	    get numJoints() { return -1; },

	    /**
	     * @ignore
	     */
	    _queryChildren: function(name)
	    {
	        throw new Error("Abstract method called!");
	    }
	};

	/**
	 * @classdesc
	 * A node in a SkeletonBlendTree to contain a single animation clip. An AnimationClip on its own is simply a resource and
	 * does not contain playback state so it can be used across different animation instances. That relevant state is kept here.
	 *
	 * @property {number} playbackRate A value to control the playback speed.
	 * @property {number} time The current time in milliseconds of the play head.
	 *
	 * @param {AnimationClip} clip The animation clip to be played.
	 * @constructor
	 *
	 * @extends  SkeletonBlendNode
	 *
	 * @see {@linkcode AnimationClip}
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonClipNode(clip)
	{
	    SkeletonBlendNode.call(this);
	    this._playhead = new AnimationPlayhead(clip);
	    this._rootPosition = new Float4();

	    this._name = clip.name;
	    this._numJoints = clip.getKeyFrame(0).value._jointPoses.length;

	    var lastFramePos = clip.getKeyFrame(clip.numKeyFrames - 1).value._jointPoses[0].position;
	    var firstFramePos = clip.getKeyFrame(0).value._jointPoses[0].position;
	    this._clipRootDelta = Float4.subtract(lastFramePos, firstFramePos);
	}

	SkeletonClipNode.prototype = Object.create(SkeletonBlendNode.prototype,
	    {
	        /**
	         * @ignore
	         */
	        numJoints: {
	            get: function() { return this._numJoints; }
	        },

	        /**
	         * Determines whether the animation should loop or not. By default, it uses the value determined by the
	         * AnimationClip, but can be overridden.
	         */
	        looping: {
	            get: function() { return this._playhead._looping; },
	            set: function(value) { this._playhead.looping = value; }
	        },

	        /**
	         * The duration of the clip.
	         */
	        duration: {
	            get: function() { return this._clip.duration; }
	        },

	        playbackRate: {
	            get: function() { return this._playhead.playbackRate; },
	            set: function(value) { this._playhead.playbackRate = value; }
	        },

	        time: {
	            get: function() { return this._playhead.time; },
	            set: function(value)
	            {
	                this._playhead.time = value;
	            }
	        }
	    });

	/**
	 * Starts playback.
	 */
	SkeletonClipNode.prototype.play = function()
	{
	    this._playhead.play();
	};

	/**
	 * Pauses playback.
	 */
	SkeletonClipNode.prototype.stop = function()
	{
	    this._playhead.stop();
	};

	/**
	 * @ignore
	 */
	SkeletonClipNode.prototype.update = function(dt, transferRootJoint)
	{
	    if (!this._playhead.update(dt))
	        return false;

	    var playhead = this._playhead;

	    this._pose.interpolate(playhead.frame1.value, playhead.frame2.value, playhead.ratio);

	    if (transferRootJoint)
	        this._transferRootJointTransform(playhead.wraps, dt);

	    return true;
	};

	/**
	 * @ignore
	 */
	SkeletonClipNode.prototype._transferRootJointTransform = function(numWraps, dt)
	{
	    var rootJointPos = this._pose._jointPoses[0].position;
	    var rootPos = this._rootPosition;
	    var rootDelta = this._rootJointDeltaPosition;

	    Float4.subtract(rootJointPos, rootPos, rootDelta);

	    if (dt > 0 && numWraps > 0) {
	        // apply the entire displacement for the amount of times it wrapped
	        rootDelta.addScaled(this._clipRootDelta, numWraps);
	    }
	    else if (dt < 0 && numWraps > 0) {
	        // apply the entire displacement for the amount of times it wrapped, in the other direction
	        rootDelta.addScaled(this._clipRootDelta, -numWraps);
	    }

	    this._rootPosition.copyFrom(rootJointPos);
	    rootJointPos.set(0.0, 0.0, 0.0);
	};

	SkeletonClipNode.prototype._queryChildren = function(name)
	{
	    // this is a leaf node
	    return null;
	};

	/**
	 * @classdesc
	 * A SkeletonBlendTree is used by {@linkcode SkeletonAnimation} internally to blend complex animation setups. Using this,
	 * we can crossfade between animation clips (such as walking/running) while additionally having extra modifiers applied,
	 * such as gun aiming, head turning, etc.
	 *
	 * @constructor
	 * @param {SkeletonBlendNode} rootNode The root node of the tree.
	 * @param {Skeleton} skeleton The skeleton to animate.
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonBlendTree(rootNode, skeleton)
	{
	    this._skeleton = skeleton;
	    this._rootNode = rootNode;
	    this._transferRootJoint = false;

	    if (skeleton) this.skeleton = skeleton;
	}

	SkeletonBlendTree.prototype =
	{
	    get transferRootJoint() { return this._transferRootJoint; },
	    set transferRootJoint(value) { this._transferRootJoint = value; },

	    get skeleton() { return this._skeleton; },
	    set skeleton(value)
	    {
	        this._skeleton = value;
	    },

	    get skeletonPose() { return this._rootNode._pose; },

	    get rootJointDeltaPosition() { return this._rootNode.rootJointDeltaPosition; },

	    get rootNode() { return this._rootNode; },
	    set rootNode(value) { this._rootNode = value; },

	    update: function(dt)
	    {
	        var updated = this._rootNode.update(dt, this._transferRootJoint);
	        if (updated)
	            this._rootNode._pose.invalidateGlobalPose();

	        return updated;
	    },

	    /**
	     * Gets a node in the tree with the given name.
	     */
	    getNode: function(name)
	    {
	        return this._rootNode.findNode(name);
	    }
	};

	/**
	 * @param {*} rootNode Either a {@linkcode SkeletonBlendNode} for more complex animations, or an {@linkcode AnimationClip} for single-clip start/stop animations.
	 *
	 * @classdesc
	 *
	 * SkeletonAnimation is a {@linkcode Component} that allows skinned animations on a Model. Internally, it uses a
	 * {@linkcode SkeletonBlendTree} for blending.
	 *
	 * @property {Boolean} transferRootJoint Defines whether the root joint's movement will be applied to the target Model's scene position. This way, scene movement can be synchronized to the animation.
	 * @property {Boolean} applyInverseBindPose Defines whether or not the inverse bind pose should be applied to the skeleton's pose.
	 * @property {SkeletonBlendNode} animationNode The root animation node of the blend tree.
	 *
	 * @constructor
	 *
	 * @see {@linkcode AnimationClip}
	 * @see {@linkcode SkeletonBlendNode}
	 * @see {@linkcode SkeletonXFadeNode}
	 *
	 * @extends Component
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonAnimation(rootNode)
	{
	    Component.call(this);
	    if (rootNode instanceof AnimationClip)
	        rootNode = new SkeletonClipNode(rootNode);
	    this._blendTree = new SkeletonBlendTree(rootNode);
	}

	Component.create(SkeletonAnimation,
	    {
	        transferRootJoint: {
	            get: function()
	            {
	                return this._blendTree.transferRootJoint;
	            },

	            set: function(value)
	            {
	                this._blendTree.transferRootJoint = value;
	            }
	        },

	        applyInverseBindPose: {
	            get: function()
	            {
	                return this._blendTree.applyInverseBindPose;
	            },

	            set: function(value)
	            {
	                this._blendTree.applyInverseBindPose = value;
	            }
	        },

	        animationNode: {
	            get: function ()
	            {
	                return this._blendTree.rootNode;
	            },
	            set function(value)
	            {
	                this._blendTree.rootNode = value;
	                if (this._entity) this._blendTree.skeleton = this._entity.skeleton;
	            }
	        }
	    }
	);

	/**
	 * @ignore
	 */
	SkeletonAnimation.prototype.onAdded = function()
	{
	    this._blendTree.skeleton = this._entity.skeleton;
	    this._entity.skeletonPose = this._blendTree.skeletonPose;
	};

	/**
	 * @ignore
	 */
	SkeletonAnimation.prototype.onUpdate = function(dt)
	{
	    if (this._blendTree.update(dt)) {
	        var matrix = this._entity.matrix;
	        var d = this._blendTree.rootJointDeltaPosition;
	        matrix.prependTranslation(d);
	        this._entity.matrix = matrix;
	        this._entity.skeletonPose = this._blendTree.skeletonPose;
	    }
	};

	/**
	 * Gets a node in the tree with the given name.
	 */
	SkeletonAnimation.prototype.getNode = function(name)
	{
	    return this._blendTree.getNode(name);
	};

	/**
	 * @inheritDoc
	 */
	SkeletonAnimation.prototype.clone = function()
	{
	    var clone = new SkeletonAnimation(this._blendTree.rootNode);
	    clone.transferRootJoint = this.transferRootJoint;
	    clone.applyInverseBindPose = this.applyInverseBindPose;
	    return clone;
	};

	/**
	 * @classdesc
	 * SkeletonBinaryLerpNode allows simple blending between 2 child nodes.
	 *
	 * @property {number} minValue The minimum value of the input range.
	 * @property {number} maxValue The maximum value of the input range.
	 * @property {number} value The value between minValue and maxValue that defines how to interpolate between the children.
	 * @property {SkeletonBlendNode} child1 The first child (matching minValue).
	 * @property {SkeletonBlendNode} child2 The second child (matching maxValue).
	 *
	 * @constructor
	 *
	 * @extends SkeletonBlendNode
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonBinaryLerpNode()
	{
	    SkeletonBlendNode.call(this);
	    this._value = 0;
	    this._child1 = null;
	    this._child2 = null;
	    this._minValue = 0;
	    this._maxValue = 1;
	    this._numJoints = 0;
	    this._t = 0;
	    this._valueChanged = false;
	}

	SkeletonBinaryLerpNode.prototype = Object.create(SkeletonBlendNode.prototype, {
	    numJoints: {
	        get: function() {return this._numJoints; }
	    },

	    minValue: {
	        get: function ()
	        {
	            return this._minValue;
	        },

	        set: function (value)
	        {
	            this._minValue = value;
	        }
	    },

	    maxValue: {
	        get: function()
	        {
	            return this._maxValue;
	        },

	        set: function(value)
	        {
	            this._maxValue = value;
	        }
	    },

	    value: {
	        get: function ()
	        {
	            return this._value;
	        },

	        set: function (v)
	        {
	            v = MathX.clamp(v, this._minValue, this._maxValue);
	            if (this._value !== v)
	                this._valueChanged = true;
	            this._value = v;
	            this._t = (this._value - this._minValue) / (this._maxValue - this._minValue);
	        }
	    },

	    child1: {
	        get: function()
	        {
	            return this._child1;
	        },

	        set: function(value)
	        {
	            this._child1 = value;
	            if (this._child2 && value.numJoints !== this._child2.numJoints) throw new Error("Incompatible child nodes (numJoints mismatch)!");
	            this._numJoints = value.numJoints;
	        }
	    },

	    child2: {
	        get: function ()
	        {
	            return this._child2;
	        },

	        set: function (value)
	        {
	            this._child2 = value;
	            if (this._child1 && value.numJoints !== this._child1.numJoints) throw new Error("Incompatible child nodes (numJoints mismatch)!");
	        }
	    }
	});

	/**
	 * @ignore
	 */
	SkeletonBinaryLerpNode.prototype.update = function(dt, transferRootJoint)
	{
	    var updated = this._child1.update(dt, transferRootJoint);
	    updated = this._child2.update(dt, transferRootJoint) || updated;
	    updated = updated || this._valueChanged;

	    var t = this._t;
	    if (updated) {
	        if (t > .999)
	            this._pose.copyFrom(this._child1._pose);
	        else if (t < .001)
	            this._pose.copyFrom(this._child2._pose);
	        else
	            this._pose.interpolate(this._child1._pose, this._child2._pose, this._t);

	        this._valueChanged = false;
	    }

	    return updated;
	};

	SkeletonBinaryLerpNode.prototype._queryChildren = function(name)
	{
	    return this._child1.findNode(name) || this._child2.findNode(name);
	};

	/**
	 * @param skeleton The original skeleton, needed to copy the bind pose.
	 *
	 * @classdesc
	 * <p>SkeletonFreePoseNode is a SkeletonBlendNode that allows freely setting any Skeleton joint's pose directly.</p>
	 *
	 * @constructor
	 *
	 * @extends  SkeletonBlendNode
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonFreePoseNode(skeleton)
	{
	    SkeletonBlendNode.call(this);
	    this._skeleton = skeleton;
	    this._poseInvalid = true;
	    this._pose.copyBindPose(skeleton);

	    this._poseLookUp = {};

	    for (var i = 0; i < skeleton.numJoints; ++i) {
	        var j = skeleton.getJoint(i);
	        this._poseLookUp[j.name] = this._pose._jointPoses[i];
	    }
	}

	SkeletonFreePoseNode.prototype = Object.create(SkeletonBlendNode.prototype, {
	    /**
	     * @ignore
	     */
	    numJoints: {
	        get function() { return this._skeleton.numJoints; }
	    }
	});

	/**
	 * @ignore
	 */
	SkeletonFreePoseNode.prototype.update = function(dt)
	{
	    var updated = this._poseInvalid;
	    this._poseInvalid = false;
	    return updated
	};

	/**
	 * Sets a joint's rotation.
	 * @param {*} indexOrName If a Number, the index of the joint in the skeleton, if a String, its name.
	 * @param {Quaternion} quaternion The new rotation.
	 */
	SkeletonFreePoseNode.prototype.setJointRotation = function(indexOrName, quaternion)
	{
	    var p = this._getJointPose(indexOrName);
	    p.rotation.copyFrom(quaternion);
	    this._poseInvalid = true;
	};

	/**
	 * Sets a joint's translation.
	 * @param {*} indexOrName If a Number, the index of the joint in the skeleton, if a String, its name.
	 * @param {Float4} value The new translation.
	 */
	SkeletonFreePoseNode.prototype.setJointTranslation = function(indexOrName, value)
	{
	    var p = this._getJointPose(indexOrName);
	    p.position.copyFrom(value);
	    this._poseInvalid = true;
	};

	/**
	 * Sets a joint's scale.
	 * @param {*} indexOrName If a Number, the index of the joint in the skeleton, if a String, its name.
	 * @param {Float4} value The new scale.
	 */
	SkeletonFreePoseNode.prototype.setJointScale = function(indexOrName, value)
	{
	    var p = this._getJointPose(indexOrName);
	    p.scale.copyFrom(value);
	    this._poseInvalid = true;
	};

	/**
	 * @ignore
	 */
	SkeletonFreePoseNode.prototype._getJointPose = function(indexOrName)
	{
	    if (indexOrName instanceof String)
	        return this._poseLookUp[indexOrName];
	    else
	        return this._pose._jointPoses[indexOrName];
	};

	SkeletonFreePoseNode.prototype._queryChildren = function(name)
	{
	    // this is a leaf node
	    return null;
	};

	var nameCounter$a = 0;

	/**
	 * @classdesc
	 * SkeletonJoint describes a single joint in a {@linkcode Skeleton}.
	 * (Pedantic note: some packages call these "bones", which is technically a slight misnomer.)
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonJoint()
	{
	    /**
	     * The name of the joint.
	     */
	    this.name = "hx_joint_" + (nameCounter$a++);

	    /**
	     * The index in the Skeleton of the parent joint.
	     */
	    this.parentIndex = -1;

	    /**
	     * The inverse bind pose of the joint. This was how the joint was positioned with the mesh in the default skinned state (usually the T-pose).
	     * @type {Matrix4x4}
	     */
	    this.inverseBindPose = new Matrix4x4();
	}

	SkeletonJoint.prototype =
	{
	    toString: function()
	    {
	        return "[SkeletonJoint]";
	    }
	};

	/**
	 * SkeletonXFadeNode is a {@linkcode SkeletonBlendNode} for simple cross-fading between child animation clips.
	 *
	 * @constructor
	 *
	 * @extends  SkeletonBlendNode
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SkeletonXFadeNode()
	{
	    SkeletonBlendNode.call(this);
	    this._children = [];
	    this._numJoints = 0;
	    this._clips = {};

	    // TODO: Add the possibility to sync times, useful for syncing walk -> run!
	    // in this case, the clips should have their timesteps recalculated
	}

	SkeletonXFadeNode.prototype = Object.create(SkeletonBlendNode.prototype, {
	    /**
	     * @ignore
	     */
	    numJoints: {
	        get: function() { return this._numJoints; }
	    }
	});

	/**
	 * This adds a clip that can be triggered by name in fadeTo.
	 */
	SkeletonXFadeNode.prototype.addClip = function(clip)
	{
	    this._clips[clip.name] = clip;
	};

	/**
	 * @classdesc
	 * Cross-fades the animation to a new target animation.
	 * @param node A {@linkcode SkeletonBlendTreeNode}, an {@linkcode AnimationClip}, or a string with the name of a clip.
	 * If using a string, the clip has to be added using {@linkcode addClip}.
	 * @param time The time the fade takes in milliseconds.
	 * @param [sync] An optional flag to make clips sync to eachother. All clips with sync = true will be synced, others will
	 * run independently. This only works if node is a (name of a) clip.
	 */
	SkeletonXFadeNode.prototype.fadeTo = function(node, time, sync)
	{
	    // immediately replace
	    if (time === 0 && node.looping === false) {
	        this._children = [];
	    }

	    if (node instanceof String) node = new SkeletonClipNode(this._clips[node]);
	    else if (node instanceof AnimationClip) node = new SkeletonClipNode(node);

	    this._numJoints = node.numJoints;
	    // put the new one in front, it makes the update loop more efficient
	    this._children.unshift({
	        node: node,
	        // make sure that these are immediately replaced
	        weight: time === 0? 1.0 : 0.0,
	        fadeSpeed: time === 0? 10000.0 : 1 / time,
	        sync: sync
	    });
	};

	/**
	 * @ignore
	 */
	SkeletonXFadeNode.prototype.update = function(dt, transferRootJoint)
	{
	    var len = this._children.length;

	    var syncedDuration = 0;
	    var totalWeight = 0;
	    var refChild = undefined;
	    for (i = len - 1; i >= 0; --i) {
	        var child = this._children[i];
	        var childNode = child.node;
	        if (child.sync) {
	            // the oldest clip defines the playhead position
	            refChild = refChild || child;
	            syncedDuration += child.node.duration * child.weight;
	            totalWeight += child.weight;
	        }
	    }
	    if (totalWeight !== 0.0)
	        syncedDuration /= totalWeight;

	    if (refChild) {
	        var syncedPlaybackRate = refChild.duration / syncedDuration;
	        var syncRatio = (refChild.time + dt * syncedPlaybackRate) / refChild.duration;
	    }

	    // we're still fading if len > 1
	    var updated = len > 1 && dt > 0;

	    // update weights and remove any node that's become unused
	    // do not interpolate the nodes into the pose yet, because if no updates occur, this is unnecessary
	    for (var i = 0; i < len; ++i) {
	        child = this._children[i];
	        childNode = child.node;

	        if (child.sync) {
	            // could also figure out a playbackRate to apply to dt, but assigning time and updating with dt = 0 is more
	            // robust.
	            childNode.time = childNode.duration * syncRatio;
	            updated = childNode.update(0, transferRootJoint) || updated;
	        }
	        else
	            updated = childNode.update(dt, transferRootJoint) || updated;

	        // handle one-shots:
	        var w = child.weight + dt * child.fadeSpeed;
	        if (childNode.looping === false) {
	            // need to fade out a one-shot at the end
	            var f = (childNode.duration - childNode.time) * child.fadeSpeed;
	            if (f <= 1) {
	                w *= f;
	                // delete one-shot when it's done, but ONLY if there's other clips to be played
	                if (f < .001 && len !== 1) {
	                    // the next index will be i again
	                    --len;
	                    this._children.splice(i--, 1);
	                }
	            }
	        }

	        // if looping === undefined, it's a node, and it's considered "endless"
	        if (w > .999 && childNode.looping !== false) {
	            child.weight = 1.0;
	            // we can safely remove any of the following child nodes, because their values will be lerped away
	            this._children.splice(i + 1);
	            break;
	        }

	        child.weight = w;
	    }


	    if (!updated) return false;


	    var last = this._children.length - 1;

	        // work backwards, so we can just override each old state progressively
	    childNode = this._children[last].node;
	    var delta = this._rootJointDeltaPosition;
	    var pose = this._pose;
	    pose.copyFrom(childNode._pose);

	    if (transferRootJoint)
	        delta.copyFrom(childNode._rootJointDeltaPosition);

	    for (i = last - 1; i >= 0; --i) {
	        child = this._children[i];
	        childNode = child.node;

	        if (transferRootJoint)
	            delta.lerp(delta, childNode._rootJointDeltaPosition, child.weight);

	        pose.interpolate(pose, childNode._pose, child.weight);
	    }

	    return true;
	};

	SkeletonClipNode.prototype._queryChildren = function(name)
	{
	    // this is a leaf node
	    // (actually, internally it uses child nodes, but those are of no business to the user)
	    return null;
	};

	/**
	 * @classdesc
	 * AudioClip provides the data for audio playback.
	 *
	 * @constructor
	 *
	 * @param {AudioBuffer} [audioBuffer] The AudioBuffer object containing the binary sound data.
	 * @param {Boolean} [looping] Whether or not the audio clip should loop.
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AudioClip(audioBuffer, looping)
	{
		this._buffer = audioBuffer || null;
		this._looping = looping || false;
	}

	AudioClip.prototype = {
		/**
		 * Indicates whether or not the audio clip should loop.
		 */
		get looping()
		{
			return this._looping;
		},

		set looping(value)
		{
			this._looping = value;
		},

		/**
		 * The AudioBuffer object containing the data for playback.
		 */
		get buffer()
		{
			return this._buffer;
		},

		set buffer(value)
		{
			this._buffer = value;
		}
	};

	/**
	 * AudioDistanceModel determines which algorithm to use to reduce the volume of the audio source as it moves away from the listener.
	 * @enum
	 *
	 * @see AudioEmitter
	 */
	var AudioDistanceModel = {
	    /**
	     *  A linear distance model: <code>1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)</code>
	     */
	    LINEAR: "linear",

	    /**
	     * An inverse distance model: <code>refDistance / (refDistance + rolloffFactor * (distance - refDistance))</code>
	     */
	    INVERSE: "inverse",

	    /**
	     * An exponential distance model: <code>pow(distance / refDistance, -rolloffFactor)</code>
	     */
	    EXPONENTIAL: "exponential"
	};

	/**
	 * AudioPanningModel determines which spatialisation algorithm to use to position the audio in 3D space.
	 * @enum
	 *
	 * @see AudioEmitter
	 */
	var AudioPanningModel = {
	    /**
	     * Represents the equal-power panning algorithm, generally regarded as simple and efficient.
	     */
	    EQUAL_POWER: "equalpower",

	    /**
	     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.
	     */
	    HRTF: "HRTF"
	};

	/**
	 * @classdesc
	 * AudioEmitter is a {@linkcode Component} that allows playing back audio from the Entity's position. If any component
	 * wishes to trigger playback from the Entity's origin, that Entity should have the AudioEmitter component assigned which
	 * in turn should be retrieved from the Component triggering the playback.
	 * Another way of triggering/stopping playback is broadcasting AudioEmitter.PLAY_MESSAGE or AudioEmitter.STOP_MESSAGE
	 * with the AudioEmitter's name as parameter.
	 * Most of the panning properties are wrappers for [PannerNode]{@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode}.
	 *
	 * @constructor
	 *
	 * @param clip The audio clip to be played by this AudioEmitter. Multiple AudioClips can be added to an Entity.
	 *
	 * @property name Allows tagging AudioEmitters with a name. For instance: collision sounds could have the name "collision"
	 * @property autoplay If true, playback starts when the component is added. Usually used with looping AudioClips.
	 * @property coneInnerAngle The angle in radians (!!!) of a cone inside of which there will be no volume reduction.
	 * @property coneOuterAngle The angle in radians (!!!) of a cone outside of which the volume will be reduced by a constant value, defined by the coneOuterGain attribute.
	 * @property coneOuterGain The amount of volume reduction outside the cone defined by the coneOuterAngle attribute. Its default value is 0, meaning that no sound can be heard.
	 * @property distanceModel One of {@linkcode AudioDistanceModel}, determining which algorithm to use to reduce the volume of the audio source as it moves away from the listener. Defaults to "linear".
	 * @property maxDistance Represents the maximum distance between the audio source and the listener, after which the volume is not reduced any further.
	 * @property panningModel One of {@linkcode AudioPanningModel}, determining which spatialisation algorithm to use to position the audio in 3D space. Defaults to "hrtf".
	 * @property refDistance Representing the reference distance for reducing volume as the audio source moves further from the listener. {@see AudioDistanceModel}
	 * @property rolloffFactor Describes how quickly the volume is reduced as the source moves away from the listener. This value is used by all distance models. {@see AudioDistanceModel}
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AudioEmitter(clip)
	{
		Component.call(this);

		this.name = "";
		this._autoplay = false;
		this._clip = clip;
		this._source = null;
	    this._gain = META.AUDIO_CONTEXT.createGain();
	    this._panner = META.AUDIO_CONTEXT.createPanner();
	    this._panner.connect(this._gain);
	}

	AudioEmitter.PLAY_MESSAGE = "hx_audioPlay";
	AudioEmitter.STOP_MESSAGE = "hx_audioStop";

	Component.create(AudioEmitter, {
		gain: {
			get: function() {
				return this._gain.gain.value;
			},

			set: function(value) {
	            this._gain.gain.value = value;
			}
		},

	    coneInnerAngle: {
	        get: function() {
	            return this._coneInnerAngle;
	        },

	        set: function(value) {
	        	// store a copy, so we always return exactly the same value
	        	this._coneInnerAngle = value;
	            this._panner.coneInnerAngle = value * MathX.RAD_TO_DEG;
	        }
		},

	    coneOuterAngle: {
	        get: function() {
	            return this._coneOuterAngle;
	        },

	        set: function(value) {
	        	// store a copy, so we always return exactly the same value
	        	this._coneOuterAngle = value;
	            this._panner.coneOuterAngle = value * MathX.RAD_TO_DEG;
	        }
		},

	    coneOuterGain: {
	        get: function() {
	            return this._panner.coneOuterGain;
	        },

	        set: function(value) {
	            this._panner.coneOuterGain = value;
	        }
		},

	    distanceModel: {
	        get: function() {
	            return this._panner.distanceModel;
	        },

	        set: function(value) {
	            this._panner.distanceModel = value;
	        }
		},

	    maxDistance: {
	        get: function() {
	            return this._panner.maxDistance;
	        },

	        set: function(value) {
	            this._panner.maxDistance = value;
	        }
		},

	    panningModel: {
	        get: function() {
	            return this._panner.panningModel;
	        },

	        set: function(value) {
	            this._panner.panningModel = value;
	        }
		},

	    refDistance: {
	        get: function() {
	            return this._panner.refDistance;
	        },

	        set: function(value) {
	            this._panner.refDistance = value;
	        }
		},

	    rolloffFactor: {
	        get: function() {
	            return this._panner.rolloffFactor;
	        },

	        set: function(value) {
	            this._panner.rolloffFactor = value;
	        }
		},

		autoplay: {
			get: function() {
				return this._autoplay;
			},

			set: function(value) {
				this._autoplay = value;
			}
		},

		clip: {
			get: function() {
				return this._clip;
			},

			set: function(value) {
				this._clip = value;
			}
		}
	});

	/**
	 * @inheritDoc
	 */
	AudioEmitter.prototype.onAdded = function()
	{
	    this._gain.connect(META.AUDIO_CONTEXT.destination);

	    if (this._autoplay)
	        this.play();

	    this.bindListener(AudioEmitter.PLAY_MESSAGE, this._onPlayMessage, this);
	    this.bindListener(AudioEmitter.STOP_MESSAGE, this._onStopMessage, this);
	};

	/**
	 * @inheritDoc
	 */
	AudioEmitter.prototype.onRemoved = function()
	{
	    this.unbindListener(AudioEmitter.PLAY_MESSAGE, this._onPlayMessage);
	    this.unbindListener(AudioEmitter.STOP_MESSAGE, this._onStopMessage);
		this.stop();
	};


	/**
	 * Starts playback of the audio clip.
	 *
	 * @param {Number} [gain] The gain of the volume. If provided, this parameter will override the currently assigned gain of the component.
	 */
	AudioEmitter.prototype.play = function(gain)
	{
		// make sure position updates immediately
	    var m = this._entity.worldMatrix._m;
		var panner = this._panner;

	    if (panner.positionX) {
	        panner.positionX.value = m[12];
	        panner.positionY.value = m[13];
	        panner.positionZ.value = m[14];

	        panner.orientationX.value = m[4];
	        panner.orientationY.value = m[5];
	        panner.orientationZ.value = m[6];
	    }
	    else {
	        panner.setPosition(m[12], m[13], m[14]);
	        panner.setOrientation(m[4], m[5], m[6]);
		}

		if (gain !== undefined)
	    	this._gain.gain.value = gain;

		this._source = META.AUDIO_CONTEXT.createBufferSource();
		this._source.buffer = this._clip.buffer;
		this._source.loop = this._clip.looping;
		this._source.connect(this._panner);
		this._source.start();
	};

	/**
	 * Stops playback of the audio clip.
	 */
	AudioEmitter.prototype.stop = function()
	{
		if (this._source) {
			this._source.stop();
			this._source.disconnect();
			this._source= null;
	        this._gain.disconnect();
	    }
	};

	/**
	 * @inheritDoc
	 * @returns {AudioEmitter}
	 */
	AudioEmitter.prototype.clone = function()
	{
		var emitter = new AudioEmitter(this._clip);
		emitter.name = this.name;
		return emitter;
	};

	AudioEmitter.prototype.onUpdate = function(dt)
	{
		if (!(this._source && this._source.isPlaying)) return;
		var time = META.AUDIO_CONTEXT.currentTime;

		var m = this._entity.worldMatrix._m;

		var panner = this._panner;
		if (panner.positionX) {
			panner.positionX.setValueAtTime(m[12], time);
			panner.positionY.setValueAtTime(m[13], time);
			panner.positionZ.setValueAtTime(m[14], time);

	        panner.orientationX.setValueAtTime(m[4], time);
	        panner.orientationY.setValueAtTime(m[5], time);
	        panner.orientationZ.setValueAtTime(m[6], time);
	    }
	    else {
	        panner.setPosition(m[12], m[13], m[14]);
	        panner.setOrientation(m[4], m[5], m[6]);
		}
	};

	AudioEmitter.prototype._onPlayMessage = function(message, audioName, gain)
	{
	    if (audioName === this.name)
	        this.play(gain);
	};

	AudioEmitter.prototype._onStopMessage = function(message, audioName)
	{
	    if (audioName === this.name)
	        this.stop();
	};

	// keeping this here so we can use it as a test for uniqueness
	var listener = null;

	/**
	 * @classdesc
	 * AudioListener is a Component that defines the position of the virtual microphone in the scene. It's usually attached
	 * to the camera
	 *
	 * @constructor
	 *
	 * @extends Component
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AudioListener()
	{
		Component.call(this);
	}

	Component.create(AudioListener);

	AudioListener.prototype.onAdded = function()
	{
		// TODO: Check it's the only listener in existence
		console.assert(!listener, "Can only have one active AudioListener!");
		listener = META.AUDIO_CONTEXT.listener;
	};

	AudioListener.prototype.onRemoved = function()
	{
	    if (listener.positionX) {
	        listener.positionX.value = 0;
	        listener.positionY.value = 0;
	        listener.positionZ.value = 0;
	        listener.forwardX.value = 0;
	        listener.forwardY.value = 0;
	        listener.forwardZ.value = 1;
	        listener.upX.value = 0;
	        listener.upY.value = 1;
	        listener.upZ.value = 0;
	    }
	    else {
	        listener.setPosition(0, 0, 0);
	        listener.setOrientation(0, 0, 1, 0, 1, 0);
	    }

		listener = null;
	};

	AudioListener.prototype.onUpdate = function(dt)
	{
	    var vrMatrix;

	    return function()
	    {
	        var time = META.AUDIO_CONTEXT.currentTime;
	        var m;

	        // Check it it's a VRCamera, so we need to provide a different matrix
	        if (this._entity.worldMatrixLeft) {
	            vrMatrix = Matrix4x4.add(this._entity.worldMatrixLeft, this._entity.worldMatrixRight, vrMatrix);
	            m = vrMatrix._m;
	            m[12] *= .5;
	            m[13] *= .5;
	            m[14] *= .5;
	        }
	        else {
	            m = this._entity.worldMatrix._m;
	        }

	        var m12 = m[12];
	        // isNaN test
	        if (m12 !== m12) return;

	        if (listener.positionX) {
	            listener.positionX.setValueAtTime(m12, time);
	            listener.positionY.setValueAtTime(m[13], time);
	            listener.positionZ.setValueAtTime(m[14], time);
	            listener.forwardX.setValueAtTime(m[4], time);
	            listener.forwardY.setValueAtTime(m[5], time);
	            listener.forwardZ.setValueAtTime(m[6], time);
	            listener.upX.setValueAtTime(m[8], time);
	            listener.upY.setValueAtTime(m[9], time);
	            listener.upZ.setValueAtTime(m[10], time);
	        }
	        else {
	            listener.setPosition(m12, m[13], m[14]);
	            listener.setOrientation(m[4], m[5], m[6], m[8], m[9], m[10]);
	        }
	    }
	}();

	/**
	 * @classdesc
	 * Only used for things like shadow map rendering.
	 *
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function OrthographicOffCenterCamera()
	{
	    Camera.call(this);
	    this._left = -1;
	    this._right = 1;
	    this._top = 1;
	    this._bottom = -1;
	}

	OrthographicOffCenterCamera.prototype = Object.create(Camera.prototype);

	OrthographicOffCenterCamera.prototype.setBounds = function(left, right, top, bottom)
	{
	    this._left = left;
	    this._right = right;
	    this._top = top;
	    this._bottom = bottom;
	    this._invalidateProjectionMatrix();
	};

	OrthographicOffCenterCamera.prototype._updateProjectionMatrix = function()
	{
	    this._projectionMatrix.fromOrthographicOffCenterProjection(this._left, this._right, this._top, this._bottom, this._nearDistance, this._farDistance);
	    this._projectionMatrixDirty = false;
	};

	/**
	 * @ignore
	 */
	OrthographicOffCenterCamera.prototype.copyFrom = function(src)
	{
		Camera.prototype.copyFrom.call(this, src);
		this.setBounds(src._left, src._right, src._top, src._bottom);
	};

	/**
	 * @inheritDoc
	 */
	OrthographicOffCenterCamera.prototype.clone = function()
	{
		var clone = new OrthographicOffCenterCamera();
		clone.copyFrom(this);
		return clone;
	};

	var swapMatrix = new Matrix4x4(
	    [
	        1, 0, 0, 0,
	        0, 0, -1, 0,
	        0, 1, 0, 0,
	        0, 0, 0, 1
	    ]);

	/**
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function VRDummyCamera()
	{
	    Camera.call(this);
	    this._projectionMatrixDirty = false;
	}

	VRDummyCamera.prototype = Object.create(Camera.prototype);

	VRDummyCamera.prototype._updateProjectionMatrix = function() {};
	VRDummyCamera.prototype._invalidateProjectionMatrix = function() {};

	VRDummyCamera.prototype.updateMatrices = function(viewMatrix, projectionMatrix)
	{
	    // WebVR uses Y up, Z out of screen
	    this._viewMatrix.set(viewMatrix);
	    this._viewMatrix.prepend(swapMatrix);

	    this._projectionMatrix.set(projectionMatrix);
	    // this._projectionMatrix.swapColums(1, 2);
	    this._projectionMatrixDirty = false;

	    // the first frame may contain invalid data (all 0s)
	    if (this._matrix.inverseAffineOf(this._viewMatrix))
	        this._applyMatrix();
	};

	/**
	 * @classdesc
	 *
	 * VRCamera provides a camera to use with {@linkcode VRRenderer}.
	 *
	 * @property {Boolean} useRoomScale If true, the view matrices will be transformed to match the VR room scale.
	 * @property {Matrix4x4} worldMatrixLeft The left eye's world matrix.
	 * @property {Matrix4x4} worldMatrixRight The right eye's world matrix.
	 *
	 * @see VRRenderer
	 */
	function VRCamera()
	{
	    VRDummyCamera.call(this);
	    this._cameraLeft = new VRDummyCamera();
	    this._cameraRight = new VRDummyCamera();
	    this.attach(this._cameraLeft);
	    this.attach(this._cameraRight);

	    this._frameData = new VRFrameData();
	}

	VRCamera.prototype = Object.create(VRDummyCamera.prototype, {
	    worldMatrixLeft: {
	        get: function() {
	            return this._cameraLeft.worldMatrix;
	        }
	    },

	    worldMatrixRight: {
	        get: function() {
	            return this._cameraRight.worldMatrix;
	        }
	    }
	});

	/**
	 * @ignore
	 */
	VRCamera.prototype._updateVR = function()
	{
	    META.VR_DISPLAY.getFrameData(this._frameData);
	    this._cameraLeft.updateMatrices(this._frameData.leftViewMatrix, this._frameData.leftProjectionMatrix, this.useRoomScale);
	    this._cameraRight.updateMatrices(this._frameData.rightViewMatrix, this._frameData.rightProjectionMatrix, this.useRoomScale);

	    var frustumLeft = this._cameraLeft.frustum;
	    var frustumRight = this._cameraRight.frustum;
	    var planes = this._frustum.planes;
	    var corners = this._frustum.corners;
	    var planesLeft = frustumLeft.planes;
	    var planesRight = frustumRight.planes;
	    var cornersLeft = frustumLeft.corners;
	    var cornersRight = frustumRight.corners;

	    // use all the left cam's planes, except the RIGHT plane
	    planes[Frustum.PLANE_LEFT] = planesLeft[Frustum.PLANE_LEFT];
	    planes[Frustum.PLANE_RIGHT] = planesRight[Frustum.PLANE_RIGHT];
	    planes[Frustum.PLANE_TOP] = planesLeft[Frustum.PLANE_TOP];
	    planes[Frustum.PLANE_BOTTOM] = planesLeft[Frustum.PLANE_BOTTOM];
	    planes[Frustum.PLANE_NEAR] = planesLeft[Frustum.PLANE_NEAR];
	    planes[Frustum.PLANE_FAR] = planesLeft[Frustum.PLANE_FAR];

	    corners[0] = cornersLeft[0];
	    corners[1] = cornersRight[1];
	    corners[2] = cornersRight[2];
	    corners[3] = cornersLeft[3];
	    corners[4] = cornersLeft[4];
	    corners[5] = cornersRight[5];
	    corners[6] = cornersRight[6];
	    corners[7] = cornersLeft[7];

	    // this camera should only be used for culling, so make sure frustum doesn't get re-updated
	    this._viewProjectionMatrixInvalid = false;
	    this._projectionMatrixDirty = false;
	};

	/**
	 * @ignore
	 */
	VRCamera.prototype.toString = function()
	{
	    return "[VRCamera(name=" + this._name + ")]";
	};

	/**
	 * @classdesc
	 * DataStream is a wrapper for DataView which allows reading the data as a linear stream of data.
	 * @param dataView the DataView object to read from.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function DataStream(dataView)
	{
	    this._dataView = dataView;
	    this._offset = 0;
	    this._endian = DataStream.LITTLE_ENDIAN;
	}

	/**
	 * Little Endian encoding
	 */
	DataStream.LITTLE_ENDIAN = true;

	/**
	 * Big Endian encoding
	 */
	DataStream.BIG_ENDIAN = false;

	DataStream.prototype =
	{
	    /**
	     * The current byte offset into the file.
	     */
	    get offset() { return this._offset; },
	    set offset(value) { this._offset = value; },

	    /**
	     * The endianness used by the data.
	     */
	    get endian() { return this._endian; },
	    set endian(value) { this._endian = value; },

	    /**
	     * The size of the data view in bytes.
	     */
	    get byteLength () { return this._dataView.byteLength; },

	    /**
	     * The amount of bytes still left in the file until EOF.
	     */
	    get bytesAvailable() { return this._dataView.byteLength - this._offset; },

	    /**
	     * Reads a single 8-bit string character from the stream.
	     */
	    getChar: function()
	    {
	        return String.fromCharCode(this.getUint8());
	    },

	    /**
	     * Reads a single unsigned byte integer from the string.
	     */
	    getUint8: function()
	    {
	        return this._dataView.getUint8(this._offset++);
	    },

	    /**
	     * Reads a single unsigned short integer from the string.
	     */
	    getUint16: function()
	    {
	        var data = this._dataView.getUint16(this._offset, this._endian);
	        this._offset += 2;
	        return data;
	    },

	    /**
	     * Reads a single unsigned 32-bit integer from the string.
	     */
	    getUint32: function()
	    {
	        var data = this._dataView.getUint32(this._offset, this._endian);
	        this._offset += 4;
	        return data;
	    },

	    /**
	     * Reads a single signed byte integer from the string.
	     */
	    getInt8: function()
	    {
	        return this._dataView.getInt8(this._offset++);
	    },

	    /**
	     * Reads a single signed short integer from the string.
	     */
	    getInt16: function()
	    {
	        var data = this._dataView.getInt16(this._offset, this._endian);
	        this._offset += 2;
	        return data;
	    },

	    /**
	     * Reads a single 32 bit integer from the string.
	     */
	    getInt32: function()
	    {
	        var data = this._dataView.getInt32(this._offset, this._endian);
	        this._offset += 4;
	        return data;
	    },

	    /**
	     * Reads a 64-bit integer and stores it in a Number. The read value is not necessarily the same as what's stored, but
	     * may provide an acceptable approximation.
	     */
	    getInt64AsFloat64: function()
	    {
	        var L, B;
	        if (this._endian === DataStream.LITTLE_ENDIAN) {
	            L = this._dataView.getUint32(this._offset, this._endian);
	            B = this._dataView.getInt32(this._offset + 4, this._endian);
	        }
	        else {
	            B = this._dataView.getInt32(this._offset, this._endian);
	            L = this._dataView.getUint32(this._offset + 4, this._endian);
	        }
	        this._offset += 8;
	        return L + B * 4294967296.0;
	    },

	    /**
	     * Reads a single float.
	     */
	    getFloat32: function()
	    {
	        var data = this._dataView.getFloat32(this._offset, this._endian);
	        this._offset += 4;
	        return data;
	    },

	    /**
	     * Reads a double float.
	     */
	    getFloat64: function()
	    {
	        var data = this._dataView.getFloat64(this._offset, this._endian);
	        this._offset += 8;
	        return data;
	    },

	    /**
	     * Reads an array of unsigned bytes.
	     *
	     * @param len The amount of elements to read.
	     */
	    getUint8Array: function(len)
	    {
	        return this._readArray(len, Uint8Array, this.getUint8);
	    },

	    /**
	     * Reads an array of unsigned shorts.
	     *
	     * @param len The amount of elements to read.
	     */
	    getUint16Array: function(len)
	    {
	        return this._readArray(len, Uint16Array, this.getUint16);
	    },

	    /**
	     * Reads an array of unsigned 32-bit integers.
	     *
	     * @param len The amount of elements to read.
	     */
	    getUint32Array: function(len)
	    {
	        return this._readArray(len, Uint32Array, this.getUint32);
	    },

	    /**
	     * Reads an array of signed bytes.
	     *
	     * @param len The amount of elements to read.
	     */
	    getInt8Array: function(len)
	    {
	        return this._readArray(len, Int8Array, this.getInt8);
	    },

	    /**
	     * Reads an array of signed shorts.
	     *
	     * @param len The amount of elements to read.
	     */
	    getInt16Array: function(len)
	    {
	        return this._readArray(len, Int16Array, this.getInt16);
	    },

	    /**
	     * Reads an array of signed 32-bit integers.
	     *
	     * @param len The amount of elements to read.
	     */
	    getInt32Array: function(len)
	    {
	        return this._readArray(len, Int32Array, this.getInt32);
	    },

	    /**
	     * Reads an array of 64-bit integers into floats.
	     *
	     * @param len The amount of elements to read.
	     */
	    getInt64AsFloat64Array: function(len)
	    {
	        return this._readArray(len, Float64Array, this.getInt64AsFloat64);
	    },

	    /**
	     * Reads an array of single floats.
	     *
	     * @param len The amount of elements to read.
	     */
	    getFloat32Array: function(len)
	    {
	        return this._readArray(len, Float32Array, this.getFloat32);
	    },

	    /**
	     * Reads an array of double floats.
	     *
	     * @param len The amount of elements to read.
	     */
	    getFloat64Array: function(len)
	    {
	        return this._readArray(len, Float64Array, this.getFloat64);
	    },

	    /**
	     * Reads a string.
	     *
	     * @param [len] The amount of characters in the string. If omitted, it reads until (and including) it encounters a "\0" character.
	     */
	    getString: function(len)
	    {
	        if (!len) return this._get0String();

	        var str = "";

	        for (var i = 0; i < len; ++i)
	            str += this.getChar();

	        return str;
	    },

	    /**
	     * @ignore
	     */
	    _get0String: function()
	    {
	        var str = "";

	        do {
	            var ch = this.getUint8();
	            if (ch) str += String.fromCharCode(ch);
	        } while (ch !== 0);

	        return str;
	    },

	    /**
	     * @ignore
	     */
	    _readArray: function(len, arrayType, func)
	    {
	        var arr = new arrayType(len);

	        for (var i = 0; i < len; ++i)
	            arr[i] = func.call(this);

	        return arr;
	    }
	};

	/**
	 * @classdesc
	 * EffectPass is used by {@linkcode Effect} classes to perform individual render tasks.
	 *
	 * @constructor
	 * @param {string} vertexShader The vertex shader code for this pass's shader.
	 * @param {string} fragmentShader The fragment shader code for this pass's shader.
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function EffectPass(vertexShader, fragmentShader)
	{
	    vertexShader = vertexShader || ShaderLibrary.get("default_post_vertex.glsl");
	    var shader = new Shader(vertexShader, fragmentShader);

	    MaterialPass.call(this, shader);

	    this._vertexLayout = null;
	    this._cullMode = CullMode.NONE;
	    this._depthTest = Comparison.DISABLED;
	    this._writeDepth = false;
	    this.setMesh(RectMesh.DEFAULT);

	    this.setTexture("hx_dither2D", DEFAULTS.DEFAULT_2D_DITHER_TEXTURE);
	}

	EffectPass.prototype = Object.create(MaterialPass.prototype);

	/**
	 * @ignore
	 */
	EffectPass.prototype.setMesh = function(mesh)
	{
	    if (this._mesh === mesh) return;
	    this._mesh = mesh;
	    this._vertexLayout = new VertexLayout(this._mesh, this);
	};

	/**
	 * @ignore
	 */
	EffectPass.prototype.updateRenderState = function(renderer)
	{
	    var cam = renderer._camera;
	    this.updateInstanceRenderState(cam);
	    this.updatePassRenderState(cam, renderer);

	    // TODO: Could we implement this by GL.setMesh(mesh, layout), also in renderer?
	    this._mesh._vertexBuffers[0].bind();
	    this._mesh._indexBuffer.bind();

	    var layout = this._vertexLayout;
	    var attributes = layout.attributes;
	    var len = attributes.length;

	    for (var i = 0; i < len; ++i) {
	        var attribute = attributes[i];
	        GL.gl.vertexAttribPointer(attribute.index, attribute.numComponents, GL.gl.FLOAT, false, attribute.stride, attribute.offset);
	    }

	    GL.enableAttributes(layout._numAttributes);
	};

	/**
	 * @classdesc
	 * GaussianBlurPass is an {@linkcode EffectPass} that performs a separable gaussian blur pass (ie: in one direction).
	 *
	 * @constructor
	 * @param radius The radius of the blur.
	 *
	 * @extends EffectPass
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function GaussianBlurPass(radius)
	{
	    radius = Math.floor(radius);

	    this._initWeights(radius);

	    var defines = {
	        RADIUS: radius,
	        NUM_WEIGHTS: radius + 1
	    };

	    var vertex = ShaderLibrary.get("gaussian_blur_vertex.glsl", defines);
	    var fragment = ShaderLibrary.get("gaussian_blur_fragment.glsl", defines);

	    EffectPass.call(this, vertex, fragment);

	    this.setUniformArray("gaussianWeights", new Float32Array(this._weights));
	}

	GaussianBlurPass.prototype = Object.create(EffectPass.prototype);

	/**
	 * @ignore
	 */
	GaussianBlurPass.prototype._initWeights = function(radius)
	{
	    this._weights = [];

	    var gaussian = CenteredGaussianCurve.fromRadius(radius, .01);

	    var total = 0;
	    for (var j = 0; j <= radius; ++j) {
	        this._weights[j] = gaussian.getValueAt(j);
	        total += j > 0? this._weights[j] * 2.0 : 1.0;
	    }

	    total = 1.0 / total;

	    for (j = 0; j <= radius; ++j) {
	        this._weights[j] *= total;
	    }
	};

	/**
	 * @classdesc
	 * Effect is a {@linkcode Component} that will be picked up by the renderer for post-processing. Most effects are added
	 * to the Camera, but some could be tied to a different Entity (for example: a DirectionalLight for crepuscular rays)
	 *
	 * @property {boolean} needsNormalDepth Defines whether this Effect needs normal/depth information from the renderer.
	 * @property {FrameBuffer} hdrTarget The current full-resolution render target.
	 * @property {Texture2D} hdrSource The current full-resolution source texture.
	 *
	 * @constructor
	 *
	 * @extends Component
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Effect()
	{
	    Component.call(this);
	    this._isSupported = true;
	    this._mesh = null;
	    this._outputsGamma = false;
	    this._needsNormalDepth = false;
	}

	Component.create(Effect,
	    {
	        needsNormalDepth: {
	            get: function() { return this._needsNormalDepth; },
	            set: function(value) { this._needsNormalDepth = value; }
	        },

	        hdrTarget: {
	            get: function() { return this._renderer._hdrFront.fbo; }
	        },

	        hdrSource: {
	            get: function() { return this._renderer._hdrBack.texture; }
	        }
	    }
	);

	/**
	 * Returns whether this Effect is supported considering the current capabilities.
	 */
	Effect.prototype.isSupported = function()
	{
	    return this._isSupported;
	};

	/**
	 * @ignore
	 */
	Effect.prototype.render = function(renderer, dt)
	{
	    this._renderer = renderer;
	    this.draw(dt);
	};

	/**
	 * This method needs to be implemented by child classes.
	 */
	Effect.prototype.draw = function(dt)
	{
	    throw new Error("Abstract method error!");
	};

	/**
	 * @ignore
	 */
	Effect.prototype._drawPass = function(pass)
	{
	    pass.updateRenderState(this._renderer);
	    GL.drawElements(GL.gl.TRIANGLES, 6, 0);
	};

	/**
	 * @ignore
	 */
	Effect.prototype.onAdded = function()
	{
	};

	/**
	 * @ignore
	 */
	Effect.prototype.onRemoved = function()
	{
	};

	/**
	 * Child classes need to call this when rendering to and from full-resolution textures. This will effectively swap hdrSource and hdrTarget to allow ping-ponging.
	 */
	Effect.prototype._swapHDRFrontAndBack = function()
	{
	    this._renderer._swapHDRFrontAndBack();
	};

	Effect.prototype.acceptVisitor = function(visitor)
	{
		visitor.visitEffect(this);
	};

	/**
	 * @classdesc
	 * Bloom is an {@linkcode Effect} added to the Camera that allows bright areas in the image to bleed into less bright areas.
	 *
	 * @property {number} strength The strength of the bloom effect.
	 * @property {number} thresholdLuminance The threshold luminance for pixels that are allowed to bleed.
	 *
	 * @param radius The radius of the bloom effect.
	 * @param strength The strength of the bloom effect.
	 * @param [downScale] How many times smaller the bloom should be calculated relative to the render target.
	 * @param [anisotropy] Defines the ratio between the horizontal and vertical bloom. For the JJ Abrams people among us.
	 *
	 * @constructor
	 *
	 * @extends Effect
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Bloom(radius, strength, downScale, anisotropy)
	{
	    Effect.call(this);

	    this._downScale = downScale || 4;

	    this._targetWidth = -1;
	    this._targetHeight = -1;

	    radius = radius || 100;
	    radius /= this._downScale;
	    this._thresholdPass = new EffectPass(null, ShaderLibrary.get("bloom_threshold_fragment.glsl"));
	    this._compositePass = new EffectPass(ShaderLibrary.get("bloom_composite_vertex.glsl"), ShaderLibrary.get("bloom_composite_fragment.glsl"));
	    this._blurPass = new GaussianBlurPass(radius);
	    this._blurSourceSlot = this._blurPass.getTextureSlot("sourceTexture");
	    this._thresholdWidth = -1;
	    this._thresholdHeight = -1;

	    this._thresholdMaps = [];
	    this._smallFBOs = [];

	    for (var i = 0; i < 2; ++i) {
	        this._thresholdMaps[i] = new Texture2D();
	        this._thresholdMaps[i].filter = TextureFilter.BILINEAR_NOMIP;
	        this._thresholdMaps[i].wrapMode = TextureWrapMode.CLAMP;
	        this._smallFBOs[i] = new FrameBuffer([this._thresholdMaps[i]]);
	    }

	    this._anisotropy = anisotropy || 1;

	    this._strength = strength === undefined ? 1.0 : strength;

	    if (capabilities.EXT_HALF_FLOAT_TEXTURES_LINEAR && capabilities.EXT_HALF_FLOAT_TEXTURES)
	        this.thresholdLuminance = META.OPTIONS.hdr;
	    else
	        this.thresholdLuminance = .9;

	    this._compositePass.setTexture("bloomTexture", this._thresholdMaps[0]);

	    this.strength = this._strength;
	}

	Bloom.prototype = Object.create(Effect.prototype,
	    {
	        strength: {
	            get: function ()
	            {
	                return this._strength;
	            },

	            set: function (value)
	            {
	                this._strength = value;
	                this._compositePass.setUniform("strength", this._strength);
	            }
	        },

	        thresholdLuminance: {
	            get: function ()
	            {
	                return this._thresholdLuminance;
	            },

	            set: function (value)
	            {
	                this._thresholdLuminance = value;
	                this._thresholdPass.setUniform("threshold", value);
	            }
	        }
	    }
	);

	/**
	 * @ignore
	 */
	Bloom.prototype._initTextures = function ()
	{
	    for (var i = 0; i < 2; ++i) {
	        this._thresholdWidth = Math.ceil(this._targetWidth / this._downScale);
	        this._thresholdHeight = Math.ceil(this._targetHeight / this._downScale);
	        this._thresholdMaps[i].initEmpty(this._thresholdWidth, this._thresholdHeight, TextureFormat.RGB, capabilities.HDR_FORMAT);
	        this._smallFBOs[i].init();
	    }
	};

	/**
	 * @ignore
	 */
	Bloom.prototype.draw = function (dt)
	{
	    if (this._renderer._width !== this._targetWidth || this._renderer._height !== this._targetHeight) {
	        this._targetWidth = this._renderer._width;
	        this._targetHeight = this._renderer._height;
	        this._initTextures();
	    }

	    GL.setRenderTarget(this._smallFBOs[0]);
	    GL.clear();
	    this._drawPass(this._thresholdPass);

	    GL.setRenderTarget(this._smallFBOs[1]);
	    GL.clear();
	    this._blurSourceSlot.texture = this._thresholdMaps[0];
	    this._blurPass.setUniform("stepSize", {x: 1.0 / this._thresholdWidth, y: 0.0});
	    this._drawPass(this._blurPass);

	    GL.setRenderTarget(this._smallFBOs[0]);
	    GL.clear();
	    this._blurSourceSlot.texture = this._thresholdMaps[1];
	    this._blurPass.setUniform("stepSize", {x: 0.0, y: this._anisotropy / this._thresholdHeight});
	    this._drawPass(this._blurPass);

	    GL.setRenderTarget(this.hdrTarget);
	    GL.clear();
	    this._drawPass(this._compositePass);
	};

	/**
	 * @classdesc
	 * Blur is an {@linkcode Effect} added to the Camera that simply applies a gaussian blur to the screen.
	 *
	 * @param {number} radius The radius of the blur.
	 *
	 * @param numSamples The amount of samples used to calculate the blur in each direction. Cannot be changed after creation.
	 * @param radius The radius of the blur.
	 * @constructor
	 *
	 * @extends Effect
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Blur(numSamples, radius)
	{
	    if (!radius) radius = numSamples;
	    Effect.call(this);

	    this._blurPass = new GaussianBlurPass(radius);
	    this._blurSourceSlot = this._blurPass.getTextureSlot("sourceTexture");
	    this._radius = radius;
	    this._numSamples = numSamples;
	}

	Blur.prototype = Object.create(Effect.prototype,
	    {
	        radius: {
	            get: function() {
	                return this._radius;
	            },

	            set: function(value) {
	                this._radius = value;
	            }
	        }
	    });

	/**
	 * @ignore
	 */
	Blur.prototype.draw = function(dt)
	{
	    var ratio = this._radius / this._numSamples;
	    // we're manually setting source textures instead of using hx_backbuffer because the GaussianBlurPass needs to
	    // handle different textures too (see bloom)
	    GL.setRenderTarget(this.hdrTarget);
	    GL.clear();
	    this._blurSourceSlot.texture = this.hdrSource;
	    this._blurPass.setUniform("stepSize", {x: ratio / this.hdrSource.width, y: 0.0});
	    this._drawPass(this._blurPass);

	    this._swapHDRFrontAndBack();

	    GL.setRenderTarget(this.hdrTarget);
	    GL.clear();
	    this._blurSourceSlot.texture = this.hdrSource;
	    this._blurPass.setUniform("stepSize", {x: 0.0, y: ratio / this.hdrSource.height});
	    this._drawPass(this._blurPass);
	};

	/**
	 * @classdesc
	 * CopyTexturePass is an {@linkcode EffectPass} that simply copies a texture. Used for downscaling etc.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function CopyTexturePass()
	{
	    EffectPass.call(this, null, ShaderLibrary.get("copy_fragment.glsl"));
	}

	CopyTexturePass.prototype = Object.create(EffectPass.prototype);

	/**
	 * Sets the texture to copy from.
	 */
	CopyTexturePass.prototype.setSourceTexture = function(value)
	{
	    this.setTexture("sampler", value);
	};

	/**
	 * @classdesc
	 * A base class for tone mapping effects.
	 *
	 * @property {number} exposure The exposure value (in "stops"). Higher values will result in brighter results.
	 * @property {number} key The intended average luminosity in the scene. Gives a hint whether the scene should be dark (low-key) or bright (high-key).
	 * @property {number} adaptionRate The amount of time in milliseconds for the "lens" to adapt to the scene's brightness.
	 *
	 * @constructor
	 * @param adaptive Defines whether or not the brightness should adapt to the average brightness of the scene. If not supported, it will disable.
	 *
	 * @ignore
	 *
	 * @extends Effect
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ToneMapEffect(adaptive)
	{
	    this._adaptive = adaptive === undefined? false : adaptive;

	    if (this._adaptive && (!capabilities.EXT_SHADER_TEXTURE_LOD || !capabilities.EXT_COLOR_BUFFER_HALF_FLOAT)) {
	        console.log("Warning: adaptive tone mapping not supported, using non-adaptive");
	        this._adaptive = false;
	        return;
	    }

	    Effect.call(this);

	    this._toneMapPass = this._createToneMapPass();

	    if (this._adaptive) {
	        this._extractLuminancePass = new EffectPass(null, ShaderLibrary.get("tonemap_reference_fragment.glsl"));
	        this._extractLuminancePass.blendState = new BlendState(BlendFactor.CONSTANT_ALPHA, BlendFactor.ONE_MINUS_CONSTANT_ALPHA, BlendOperation.ADD, new Color(1.0, 1.0, 1.0, 1.0));

	        this._luminanceMap = new Texture2D();
	        this._luminanceMap.initEmpty(256, 256, TextureFormat.RGBA, capabilities.EXT_HALF_FLOAT_TEXTURES.HALF_FLOAT_OES);
	        this._luminanceFBO = new FrameBuffer(this._luminanceMap);
	        this._luminanceFBO.init();

	        this._adaptationRate = 500.0;

	        this._toneMapPass.setTexture("hx_luminanceMap", this._luminanceMap);
	        this._toneMapPass.setUniform("hx_luminanceMipLevel", MathX.log2(this._luminanceMap._width));
	    }

	    this.key = .25;
	    this.exposure = 0.0;
	}

	ToneMapEffect.prototype = Object.create(Effect.prototype, {
	    exposure: {
	        get: function()
	        {
	            return this._exposure;
	        },
	        set: function(value)
	        {
	            this._exposure = value;
	            if (this._isSupported)
	                this._toneMapPass.setUniform("hx_exposure", Math.pow(2.0, value));
	        }
	    },

	    key: {
	        get: function()
	        {
	            return this._key;
	        },
	        set: function(value)
	        {
	            this._key = value;
	            if (this._isSupported)
	                this._toneMapPass.setUniform("hx_key", value);
	        }
	    },

	    adaptationRate: {
	        get: function()
	        {
	            return this._adaptationRate;
	        },

	        set: function(value)
	        {
	            this._adaptationRate = value;
	        }
	    }
	});

	ToneMapEffect.prototype._createToneMapPass = function()
	{
	    throw new Error("Abstract method called!");
	};


	ToneMapEffect.prototype.draw = function(dt)
	{
	    if (this._adaptive) {
	        var amount = this._adaptationRate > 0 ? dt / this._adaptationRate : 1.0;
	        if (amount > 1) amount = 1;

	        this._extractLuminancePass.blendState.color.a = amount;

	        GL.setRenderTarget(this._luminanceFBO);
	        // can't clear at this point
	        this._drawPass(this._extractLuminancePass);
	        this._luminanceMap.generateMipmap();
	    }

	    GL.setRenderTarget(this.hdrTarget);
	    GL.clear();
	    this._drawPass(this._toneMapPass);
	};

	/**
	 * @classdesc
	 * FilmicToneMapping is an {@linkcode Effect} added to the Camera that applies filmic tone mapping.
	 *
	 * @constructor
	 * @param adaptive Whether or not the brightness should adapt to the average brightness of the scene. If not supported, it will disable.
	 *
	 * @extends ToneMapping
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function FilmicToneMapping(adaptive)
	{
	    ToneMapEffect.call(this, adaptive);
	    this._outputsGamma = true;

	}

	FilmicToneMapping.prototype = Object.create(ToneMapEffect.prototype);

	/**
	 * @ignore
	 */
	FilmicToneMapping.prototype._createToneMapPass = function()
	{
	    var defines = {};
	    var extensions = "";

	    if (this._adaptive) {
	        defines.HX_ADAPTIVE = 1;
	        extensions = "#texturelod\n";
	    }

	    return new EffectPass(
	        null,
	        extensions + ShaderLibrary.get("snippets_tonemap.glsl", defines) + "\n" + ShaderLibrary.get("tonemap_filmic_fragment.glsl")
	    );
	};

	/**
	 * @classdesc
	 * Fog is an {@linkcode Effect} added to the Camera that applies a fog effect to the scene.
	 *
	 * @property {number} density The "thickness" of the fog. Keep it tiny.
	 * @property {Color} tint The color of the fog.
	 * @property {number} heightFallOff The fall-off based on the height. This is to simulate a thinning atmosphere.
	 * @property {number} startDistance The distance from the camera at which the effect should start to be applied.
	 *
	 * @constructor
	 * @param {Number} [density] The "thickness" of the fog. Keep it tiny.
	 * @param {Color} [tint] The color of the fog.
	 * @param {Number} [heightFallOff] The fall-off based on the height. This is to simulate a thinning atmosphere.
	 * @param {Number} [startDistance] The distance from the camera at which the effect should start to be applied.
	 *
	 * @extends Effect
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */


	function Fog(density, tint, heightFallOff, startDistance)
	{
	    Effect.call(this);

	    this._fogPass = new EffectPass(ShaderLibrary.get("fog_vertex.glsl"), ShaderLibrary.get("fog_fragment.glsl"));
	    this.needsNormalDepth = true;
	    this.density = density === undefined? .001 : density;
	    this._tint = new Color(1, 1, 1, 1);
	    if (tint !== undefined)
	        this.tint = tint;
	    this.startDistance = startDistance === undefined? 0 : startDistance;
	    this.heightFallOff = heightFallOff === undefined? 0.01 : heightFallOff;
	}

	Fog.prototype = Object.create(Effect.prototype,
	    {
	        density: {
	            get: function()
	            {
	                return this._density;
	            },
	            set: function(value)
	            {
	                this._density = value;
	                this._fogPass.setUniform("density", value);
	            }
	        },

	        tint: {
	            get: function ()
	            {
	                return this._tint;
	            },
	            set: function (value)
	            {
	                this._tint.copyFrom(value);

	                if (META.OPTIONS.useGammaCorrection)
	                    this._tint.gammaToLinear();

	                this._fogPass.setUniform("tint", {x: value.r, y: value.g, z: value.b});
	            }
	        },

	        startDistance: {
	            get: function()
	            {
	                return this._startDistance;
	            },
	            set: function(value)
	            {
	                this._startDistance = value;
	                this._fogPass.setUniform("startDistance", value);
	            }
	        },

	        heightFallOff: {
	            get: function()
	            {
	                return this._heightFallOff;
	            },
	            set: function(value)
	            {
	                this._heightFallOff = value;
	                this._fogPass.setUniform("heightFallOff", value);
	            }
	        }
	    }
	);

	/**
	 * @ignore
	 */
	Fog.prototype.draw = function(dt)
	{
	    GL.setRenderTarget(this.hdrTarget);
	    GL.clear();
	    this._drawPass(this._fogPass);
	};

	/**
	 * @classdesc
	 * FXAA is an {@linkcode Effect} added to the Camera that applies "Fast approXimate Anti-Aliasing" on the render.
	 *
	 * @constructor
	 *
	 * @extends Effect
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function FXAA()
	{
	    Effect.call(this);

	    this._pass = new EffectPass(null, ShaderLibrary.get("fxaa_fragment.glsl"));
	    this._pass.setUniform("edgeThreshold", 1/4);
	    this._pass.setUniform("edgeThresholdMin", 1/16);
	    this._pass.setUniform("edgeSharpness", 100.0);
	}

	FXAA.prototype = Object.create(Effect.prototype);

	/**
	 * @ignore
	 */
	FXAA.prototype.draw = function(dt)
	{
	    GL.setRenderTarget(this.hdrTarget);
	    GL.clear();
	    this._drawPass(this._pass);
	};

	/**
	 * @classdesc
	 * HBAO adds Horizon-Based Ambient Occlusion to the renderer.
	 *
	 * @property {number} sampleRadius The sample radius in world space to search for occluders.
	 * @property {number} fallOffDistance The maximum distance for occluders to still count.
	 * @property {number} strength The strength of the ambient occlusion effect.
	 * @property {number} bias The angle bias to prevent some artifacts.
	 * @property {number} scale The scale at which to calculate the ambient occlusion (usually 0.5, half-resolution)
	 *
	 * @constructor
	 * @param numRays The amount of rays to march over.
	 * @param numSamplesPerRay The samples per ray during a march.
	 *
	 * @see {@linkcode Renderer#ambientOcclusion}
	 *
	 * @extends Effect
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function HBAO(numRays, numSamplesPerRay)
	{
	    numRays = numRays || 4;
	    numSamplesPerRay = numSamplesPerRay || 4;
	    if (numRays > 32) numRays = 32;
	    if (numSamplesPerRay > 32) numSamplesPerRay = 32;

	    this._numRays = numRays;
	    this._numSamplesPerRay = numSamplesPerRay;
	    this._strength = 1.0;
	    this._bias = .1;
	    this._fallOffDistance = 1.0;
	    this._radius = .5;
	    this._scale = .5;
	    this._sampleDirTexture = null;
	    this._ditherTexture = null;

	    Effect.call(this);
	}

	HBAO.prototype = Object.create(Effect.prototype, {
	    sampleRadius: {
	        get: function ()
	        {
	            return this._radius;
	        },

	        set: function (value)
	        {
	            this._radius = value;
	            if (this._aoPass)
	                this._aoPass.setUniform("halfSampleRadius", this._radius * .5);
	        }
	    },

	    fallOffDistance: {
	        get: function ()
	        {
	            return this._fallOffDistance;
	        },
	        set: function (value)
	        {
	            this._fallOffDistance = value;
	            if (this._aoPass)
	                this._aoPass.setUniform("rcpFallOffDistance", 1.0 / this._fallOffDistance);
	        }
	    },

	    strength: {
	        get: function()
	        {
	            return this._strength;
	        },
	        set: function (value)
	        {
	            this._strength = value;
	            if (this._aoPass)
	                this._aoPass.setUniform("strengthPerRay", this._strength / this._numRays);
	        }
	    },

	    bias: {
	        get: function()
	        {
	            return this._bias;
	        },
	        set: function (value)
	        {
	            this._bias = value;
	            if (this._aoPass)
	                this._aoPass.setUniform("bias", this._bias);
	        }
	    },

	    scale: {
	        get: function() { return this._scale; },
	        set: function(value) { this._scale = value; }
	    }
	});

	/**
	 * Called by Helix when initialized
	 * @ignore
	 */
	HBAO.prototype.init = function()
	{
	    this._aoPass = new EffectPass(
	        ShaderLibrary.get("hbao_vertex.glsl"),
	        ShaderLibrary.get("hbao_fragment.glsl", {
	            NUM_RAYS: this._numRays,
	            NUM_SAMPLES_PER_RAY: this._numSamplesPerRay
	        })
	    );

	    this._blurPass = new EffectPass(ShaderLibrary.get("ao_blur_vertex.glsl"), ShaderLibrary.get("ao_blur_fragment.glsl"));

	    this._initSampleDirTexture();
	    this._initDitherTexture();
	    this._aoPass.setUniform("strengthPerRay", this._strength / this._numRays);
	    this._aoPass.setUniform("rcpFallOffDistance", 1.0 / this._fallOffDistance);
	    this._aoPass.setUniform("halfSampleRadius", this._radius *.5);
	    this._aoPass.setUniform("bias", this._bias);
	    this._aoPass.setTexture("ditherTexture", this._ditherTexture);
	    this._aoPass.setTexture("sampleDirTexture", this._sampleDirTexture);
	    this._sourceTextureSlot = this._blurPass.getTextureSlot("source");

	    this._aoTexture = new Texture2D();
	    this._aoTexture.filter = TextureFilter.BILINEAR_NOMIP;
	    this._aoTexture.wrapMode = TextureWrapMode.CLAMP;
	    this._backTexture = new Texture2D();
	    this._backTexture.filter = TextureFilter.BILINEAR_NOMIP;
	    this._backTexture.wrapMode = TextureWrapMode.CLAMP;
	    this._fbo1 = new FrameBuffer(this._backTexture);
	    this._fbo2 = new FrameBuffer(this._aoTexture);
	};

	/**
	 * Returns the texture containing the ambient occlusion values.
	 *
	 * @returns {Texture2D}
	 * @ignore
	 */
	HBAO.prototype.getAOTexture = function()
	{
	    return this._aoTexture;
	};

	/**
	 * @ignore
	 */
	HBAO.prototype.draw = function(dt)
	{
	    var w = this._renderer._width * this._scale;
	    var h = this._renderer._height * this._scale;

	    if (TextureUtils.assureSize(w, h, this._aoTexture, this._fbo2)) {
	        TextureUtils.assureSize(w, h, this._backTexture, this._fbo1);
	        this._aoPass.setUniform("ditherScale", {x: w * .25, y: h * .25});
	    }

	    GL.setClearColor(Color.WHITE);

	    GL.setRenderTarget(this._fbo1);
	    GL.clear();
	    this._drawPass(this._aoPass);

	    GL.setRenderTarget(this._fbo2);
	    GL.clear();
	    this._blurPass.setUniform("pixelSize", {x: 1.0 / w, y: 1.0 / h});
	    this._sourceTextureSlot.texture = this._backTexture;
	    this._drawPass(this._blurPass);

	    GL.setClearColor(Color.BLACK);
	};

	/**
	 * @ignore
	 * @private
	 */
	HBAO.prototype._initSampleDirTexture = function()
	{
	    this._sampleDirTexture = new Texture2D();
	    var data = [];
	    var j = 0;

	    for (var i = 0; i < 256; ++i)
	    {
	        var angle = i / 256 * 2.0 * Math.PI;
	        var r = Math.cos(angle)*.5 + .5;
	        var g = Math.sin(angle)*.5 + .5;
	        data[j] = Math.round(r * 0xff);
	        data[j+1] = Math.round(g * 0xff);
	        data[j+2] = 0x00;
	        data[j+3] = 0xff;
	        j += 4;
	    }

	    this._sampleDirTexture.uploadData(new Uint8Array(data), 256, 1, false);
	    this._sampleDirTexture.filter = TextureFilter.NEAREST_NOMIP;
	    this._sampleDirTexture.wrapMode = TextureWrapMode.REPEAT;
	};

	/**
	 * @ignore
	 * @private
	 */
	HBAO.prototype._initDitherTexture = function()
	{
	    this._ditherTexture = new Texture2D();
	    var data = [];

	    var i;
	    var j = 0;
	    var offsets1 = [];
	    var offsets2 = [];

	    for (i = 0; i < 16; ++i) {
	        offsets1.push(i / 16.0);
	        offsets2.push(i / 15.0);
	    }

	    ArrayUtils.shuffle(offsets1);
	    ArrayUtils.shuffle(offsets2);

	    i = 0;

	    for (var y = 0; y < 4; ++y) {
	        for (var x = 0; x < 4; ++x) {
	            var r = offsets1[i];
	            var g = offsets2[i];

	            ++i;

	            data[j] = Math.round(r * 0xff);
	            data[j + 1] = Math.round(g * 0xff);
	            data[j + 2] = 0x00;
	            data[j + 3] = 0xff;

	            j += 4;
	        }
	    }

	    this._ditherTexture.uploadData(new Uint8Array(data), 4, 4, false);
	    this._ditherTexture.filter = TextureFilter.NEAREST_NOMIP;
	    this._ditherTexture.wrapMode = TextureWrapMode.REPEAT;
	};

	/**
	 * @classdesc
	 * SSAO adds Screen-Space Ambient Occlusion to the renderer.
	 *
	 * @property {number} sampleRadius The sample radius in world space to search for occluders.
	 * @property {number} fallOffDistance The maximum distance for occluders to still count.
	 * @property {number} strength The strength of the ambient occlusion effect.
	 * @property {number} scale The scale at which to calculate the ambient occlusion (usually 0.5, half-resolution)
	 *
	 * @constructor
	 * @param numSamples The amount of samples to take per pixel.
	 *
	 * @see {@linkcode Renderer#ambientOcclusion}
	 *
	 * @extends Effect
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SSAO(numSamples)
	{
	    numSamples = numSamples || 16;
	    if (numSamples > 64) numSamples = 64;

	    this._numSamples = numSamples;
	    this._strength = 1.0;
	    this._fallOffDistance = 1.0;
	    this._radius = .5;
	    this._scale = .5;
	    this._ditherTexture = null;

	    Effect.call(this);
	}

	SSAO.prototype = Object.create(Effect.prototype, {
	    sampleRadius: {
	        get: function ()
	        {
	            return this._radius;
	        },
	        set: function (value)
	        {
	            this._radius = value;
	            if (this._ssaoPass)
	                this._ssaoPass.setUniform("sampleRadius", this._radius);
	        }
	    },

	    fallOffDistance: {
	        get: function ()
	        {
	            return this._fallOffDistance;
	        },
	        set: function (value)
	        {
	            this._fallOffDistance = value;
	            if (this._ssaoPass)
	                this._ssaoPass.setUniform("rcpFallOffDistance", 1.0 / this._fallOffDistance);
	        }
	    },

	    strength: {
	        get: function()
	        {
	            return this._strength;
	        },
	        set: function (value)
	        {
	            this._strength = value;
	            if (this._ssaoPass)
	                this._ssaoPass.setUniform("strengthPerSample", 2.0 * this._strength / this._numSamples);
	        }
	    },

	    scale: {
	        get: function() { return this._scale; },
	        set: function(value) { this._scale = value; }
	    }
	});

	/**
	 * Called by Helix when initialized
	 * @ignore
	 */
	SSAO.prototype.init = function()
	{
	    this._ssaoPass = new EffectPass(null,
	        ShaderLibrary.get("ssao_fragment.glsl",
	            {
	                NUM_SAMPLES: this._numSamples
	            }
	        ));
	    this._blurPass = new EffectPass(ShaderLibrary.get("ao_blur_vertex.glsl"), ShaderLibrary.get("ao_blur_fragment.glsl"));

	    this._initSamples();
	    this._initDitherTexture();
	    this._ssaoPass.setUniform("strengthPerSample", 2.0 * this._strength / this._numSamples);
	    this._ssaoPass.setUniform("rcpFallOffDistance", 1.0 / this._fallOffDistance);
	    this._ssaoPass.setUniform("sampleRadius", this._radius);
	    this._ssaoPass.setTexture("ditherTexture", this._ditherTexture);
	    this._sourceTextureSlot = this._blurPass.getTextureSlot("source");

	    this._ssaoTexture = new Texture2D();
	    this._ssaoTexture.filter = TextureFilter.BILINEAR_NOMIP;
	    this._ssaoTexture.wrapMode = TextureWrapMode.CLAMP;
	    this._backTexture = new Texture2D();
	    this._backTexture.filter = TextureFilter.BILINEAR_NOMIP;
	    this._backTexture.wrapMode = TextureWrapMode.CLAMP;
	    this._fbo1 = new FrameBuffer(this._backTexture);
	    this._fbo2 = new FrameBuffer(this._ssaoTexture);
	};

	/**
	 * Returns the texture containing the ambient occlusion values.
	 * @returns {Texture2D}
	 *
	 * @ignore
	 */
	SSAO.prototype.getAOTexture = function()
	{
	    return this._ssaoTexture;
	};

	/**
	 * @ignore
	 * @private
	 */
	SSAO.prototype._initSamples = function()
	{
	    var samples = [];
	    var j = 0;
	    var poissonPoints = PoissonSphere.DEFAULT.getPoints();

	    for (var i = 0; i < this._numSamples; ++i) {
	        var point = poissonPoints[i];

	        // power of two, to create a bit more for closer occlusion
	        samples[j++] = Math.pow(point.x, 2);
	        samples[j++] = Math.pow(point.y, 2);
	        samples[j++] = Math.pow(point.z, 2);
	    }

	    this._ssaoPass.setUniformArray("samples", new Float32Array(samples));
	};

	/**
	 * @ignore
	 */
	SSAO.prototype.draw = function(dt)
	{
	    var w = this._renderer._width * this._scale;
	    var h = this._renderer._height * this._scale;

	    if (TextureUtils.assureSize(w, h, this._ssaoTexture, this._fbo2)) {
	        TextureUtils.assureSize(w, h, this._backTexture, this._fbo1);
	        this._ssaoPass.setUniform("ditherScale", {x: w *.25, y: h *.25});
	    }

	    GL.setClearColor(Color.WHITE);

	    GL.setRenderTarget(this._fbo1);
	    GL.clear();
	    this._drawPass(this._ssaoPass);

	    GL.setRenderTarget(this._fbo2);
	    GL.clear();
	    this._blurPass.setUniform("pixelSize", {x: 1.0 / w, y: 1.0 / h});
	    this._sourceTextureSlot.texture = this._backTexture;
	    this._drawPass(this._blurPass);

	    GL.setClearColor(Color.BLACK);
	};

	/**
	 * @ignore
	 * @private
	 */
	SSAO.prototype._initDitherTexture = function()
	{
	    var data = [ 126, 255, 126, 255, 135, 253, 105, 255, 116, 51, 26, 255, 137, 57, 233, 255, 139, 254, 121, 255, 56, 61, 210, 255, 227, 185, 73, 255, 191, 179, 30, 255, 107, 245, 173, 255, 205, 89, 34, 255, 191, 238, 138, 255, 56, 233, 125, 255, 198, 228, 161, 255, 85, 13, 164, 255, 140, 248, 168, 255, 147, 237, 65, 255 ];

	    // in case you're wondering, below is how the list above is generated:
	    // We're just using fixed data to prevent poor random results
	    /*var n = new HX.Float4();
	    for (var i = 0; i < 16; ++i) {
	        var azimuthal = Math.random() * Math.PI * 2.0;
	        var polar = Math.random() * Math.PI;
	        n.fromSphericalCoordinates(1.0, azimuthal, polar);
	        data[i * 4] = Math.round((n.x * .5 + .5) * 0xff);
	        data[i * 4 + 1] = Math.round((n.y * .5 + .5) * 0xff);
	        data[i * 4 + 2] = Math.round((n.z * .5 + .5) * 0xff);
	        data[i * 4 + 3] = 0xff;
	    }
	    console.log(data.join(", "));*/

	    this._ditherTexture = new Texture2D();
	    this._ditherTexture.uploadData(new Uint8Array(data), 4, 4, false);
	    this._ditherTexture.filter = TextureFilter.NEAREST_NOMIP;
	    this._ditherTexture.wrapMode = TextureWrapMode.REPEAT;
	};

	/**
	 * @classdesc
	 * ReinhardToneMapping is an {@linkcode Effect} added to the Camera that applies Reinhard tone mapping.
	 *
	 * @constructor
	 * @param adaptive Whether or not the brightness should adapt to the average brightness of the scene. If not supported, it will disable.
	 *
	 * @extends ToneMapping
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ReinhardToneMapping(adaptive)
	{
	    ToneMapEffect.call(this, adaptive);
	}

	ReinhardToneMapping.prototype = Object.create(ToneMapEffect.prototype);

	/**
	 * @ignore
	 * @private
	 */
	ReinhardToneMapping.prototype._createToneMapPass = function()
	{
	    var defines = {};
	    var extensions = "";

	    if (this._adaptive) {
	        defines.HX_ADAPTIVE = 1;
	        extensions += "#texturelod\n";
	    }

	    return new EffectPass(
	        null,
	        extensions + ShaderLibrary.get("snippets_tonemap.glsl", defines) + "\n" + ShaderLibrary.get("tonemap_reinhard_fragment.glsl")
	    );
	};

	/**
	 * @classdesc
	 *
	 * The Input class allows mapping user input to named actions to simplify handling different input types. For example,
	 * Mouse's movement and TouchInput's touch movements can both be used to look around. This can be done by enabling their
	 * input plugins {@linkcode Mouse} and {@linkcode Touch} while mapping their axes (for example: {@linkcode Mouse#MOVE_X},
	 * {@linkcode Mouse#MOVE_Y}, {@linkcode Touch#MOVE_X}, {@linkcode Touch#MOVE_X}} to "actions" (usually strings or enum
	 * values). You can then poll the actions to get the input value assigned to it from any input device.
	 * When supporting multiple users on a single device, multiple Input classes can be created with each having their own
	 * mappings.
	 *
	 * @property {Signal} onAction A {@linkcode Signal} that dispatches whenever an action value changes. This should be
	 * listened to for "triggered" events, not for continuous "while button down" events. For example: jumping is normally
	 * a triggered event, while walking is continuous and would be polled using {@linkcode Input#getValue}.
	 *
	 * @constructor
	 */
	function Input()
	{
		this.onAction = new Signal(/* name, value */);

		this._values = {};
		this._plugins = [];
	}

	Input.prototype =
	{
		/**
		 * Enables an input plugin.
		 *
		 * {@see Gamepad}
		 * {@see Keyboard}
		 * {@see Mouse}
		 * {@see MouseLock}
		 * {@see Touch}
		 */
		enable: function(input)
		{
			if (this._plugins.indexOf(input) >= 0)
				return;

			this._plugins.push(input);
			input._setInput(this);
		},

		/**
		 * Disables an input plugin.
		 *
	     * {@see Gamepad}
	     * {@see Keyboard}
	     * {@see Mouse}
	     * {@see MouseLock}
	     * {@see Touch}
		 */
		disable: function(input)
		{
			var index = this._plugins.indexOf(input);
			this._plugins.splice(index, 1);
			input._setInput(null);
		},

		/**
		 * @ignore
		 */
		setActionValue: function(name, value)
		{
			if (this._values[name] === value) return;
			this._values[name] = value;
			this.onAction.dispatch(name, value);
		},

		/**
		 * Gets the value currently associated with an action.
		 */
		getValue: function(name)
		{
			return this._values[name] || 0;
		}
	};

	/**
	 * @classdesc
	 *
	 * The Keyboard class enabled keyboard input in {@linkcode Input} The mapped "buttons" are the key codes or the character
	 * values. Which of the two depends on the {@linkcode Keyboard#useCode} property.
	 *
	 * @property mode If {@linkcode Keyboard#MODE_KEY_LOCATION}, the button mappings apply to key "codes" representing the
	 * key locations on the keyboard ("KeyA", "LeftShift", etc) as specified on a QWERTY keyboard. If {Keyboard.MODE_KEY_VALUE},
	 * they apply to the pressed characters. By default it uses locations, making for example WASD controls work on
	 * Azerty keyboards where W = Z, A = Q. In either case, the old API's keycode will always be used as fallback so
	 * until the new KeyboardEvent API is implemented reliably by browsers, you should also map the old integer keyCodes.
	 *
	 * {@see KeyboardEvent#code}
	 * {@see KeyboardEvent#key}
	 *
	 * @constructor
	 */
	function Keyboard()
	{
		InputPlugin.call(this);
		this.mode = Keyboard.MODE_KEY_LOCATION;
		this._onKeyUp = this._onKeyUp.bind(this);
		this._onKeyDown = this._onKeyDown.bind(this);
		this._signs = {};
	}

	Keyboard.MODE_KEY_VALUE = 0;
	Keyboard.MODE_KEY_LOCATION = 1;

	Keyboard.prototype = Object.create(InputPlugin.prototype);

	/**
	 * Maps two keys to represent an axis. For example mapping "ArrowLeft" and "ArrowRight" can be mapped to (-1, 1).
	 * @param {string} negKey The key or character to represent the negative end of the axis.
	 * @param {string} posKey The key or character to represent the positive end of the axis.
	 * @param action The action to map the axis on.
	 * @param {number} [range] The maximum value the key represents. Defaults to 1.
	 */
	Keyboard.prototype.mapAxis = function(negKey, posKey, action, range)
	{
		var range = range || 1;
		this._signs[negKey] = -range;
		this._signs[posKey] = range;
		this.map(negKey, action);
		this.map(posKey, action);
	};

	/**
	 * @inheritDoc
	 */
	Keyboard.prototype.unmap = function(key)
	{
		InputPlugin.prototype.unmap.call(key);
		delete this._signs[key];
	};

	/**
	 * @ignore
	 */
	Keyboard.prototype.onEnabled = function()
	{
	    document.addEventListener("keydown", this._onKeyDown);
	    document.addEventListener("keyup", this._onKeyUp);
	};

	/**
	 * @ignore
	 */
	Keyboard.prototype.onDisabled = function()
	{
	    document.removeEventListener("keydown", this._onKeyDown);
	    document.removeEventListener("keyup", this._onKeyUp);
	};

	/**
	 * @ignore
	 * @private
	 */
	Keyboard.prototype._onKeyDown = function(event)
	{
		var key = this.mode? event.code || event.keyCode : event.key || event.keyCode;

		if (this.isMapped(key)) {
			this.setValue(key, this._signs[key] || 1);
			event.preventDefault();
		}
	};

	/**
	 * @ignore
	 * @private
	 */
	Keyboard.prototype._onKeyUp = function(event)
	{
	    var key = this.mode? event.code || event.keyCode : event.key || event.keyCode;

		if (this.isMapped(key)) {
			this.setValue(key, 0);
			event.preventDefault();
		}
	};

	/**
	 * @classdesc
	 *
	 * The Mouse class enables Mouse input in {@linkcode Input}. When listening to {@linkcode Mouse#BUTTON_RIGHT}, the
	 * context menu is disabled. When mapping {@linkcode Mouse#WHEEL_X} or {@linkcode Mouse#WHEEL_Y}, scrolling is disabled.
	 *
	 * @property sensitivityX The horizontal mouse movement sensitivity
	 * @property sensitivityY The vertical mouse movement sensitivity
	 * @property sensitivityScroll The scroll wheel sensitivity
	 *
	 * @constructor
	 *
	 * @see {Input}
	 */
	function Mouse()
	{
		InputPlugin.call(this);

		this.sensitivityX = 1;
		this.sensitivityY = -1;	 // invert by default
		this.sensitivityWheel = -.0035; // invert by default for zooming

		this._onMouseMove = this._onMouseMove.bind(this);
		this._onMouseDown = this._onMouseDown.bind(this);
		this._onMouseWheel = this._onMouseWheel.bind(this);
		this._onMouseUp = this._onMouseUp.bind(this);
		this._onMouseEnter = this._onMouseEnter.bind(this);
		this._onMouseLeave = this._onMouseLeave.bind(this);

		this._previousX = undefined;
		this._previousY = undefined;
		this._mouseX = undefined;
		this._mouseY = undefined;
		this._wheelX = null;
		this._wheelY = null;

		this._buttonMask = 0;
	}

	/**
	 * The axis name for when the mouse moves horizontally over the canvas
	 */
	Mouse.MOVE_X = 0;

	/**
	 * The axis name for when the mouse moves vertically over the canvas
	 */
	Mouse.MOVE_Y = 1;

	/**
	 * The left button name
	 */
	Mouse.BUTTON_LEFT = 2;

	/**
	 * The right button name
	 */
	Mouse.BUTTON_RIGHT = 3;

	/**
	 * The middle (usually scroll) button name
	 */
	Mouse.BUTTON_MIDDLE = 4;

	/**
	 * The axis name when the horizontal scroll wheel moves
	 */
	Mouse.WHEEL_X = 5;

	/**
	 * The axis name when the vertical scroll wheel moves
	 */
	Mouse.WHEEL_Y = 6;

	/**
	 * The axis name for the mouse position on the canvas. 0 means all the way left, 1 means all the way right.
	 */
	Mouse.POS_X = 7;

	/**
	 * The axis name for the mouse position on the canvas. 0 means all the way to the top, 1 means all the way to the bottom.
	 */
	Mouse.POS_Y = 8;

	/**
	 * The axis name for when the mouse moves over the canvas with the left mouse button down
	 */
	Mouse.DRAG_X = 9;

	/**
	 * The axis name for when the mouse moves over the canvas with the left mouse button down
	 */
	Mouse.DRAG_Y = 10;

	Mouse.prototype = Object.create(InputPlugin.prototype);

	// maps event buttons to our buttons
	var BUTTON_MAP = {
		0: Mouse.BUTTON_LEFT,
		1: Mouse.BUTTON_MIDDLE,
		2: Mouse.BUTTON_RIGHT
	};

	/**
	 * @ignore
	 */
	Mouse.prototype.onEnabled = function()
	{
		onPreFrame.bind(this._onPreFrame, this);
		document.addEventListener("mousemove", this._onMouseMove); // mouse can move over the document
		META.TARGET_CANVAS.addEventListener("mouseenter", this._onMouseEnter);
		META.TARGET_CANVAS.addEventListener("mouseleave", this._onMouseLeave);
		META.TARGET_CANVAS.addEventListener("mousedown", this._onMouseDown);
		document.addEventListener("mouseup", this._onMouseUp);		// mouse can go up over the document
		META.TARGET_CANVAS.addEventListener("wheel", this._onMouseWheel);
	};

	/**
	 * @ignore
	 */
	Mouse.prototype.onDisabled = function()
	{
		onPreFrame.unbind(this._onPreFrame);
		document.removeEventListener("mousemove", this._onMouseMove);
		META.TARGET_CANVAS.removeEventListener("mouseenter", this._onMouseEnter);
		META.TARGET_CANVAS.removeEventListener("mouseleave", this._onMouseLeave);
		META.TARGET_CANVAS.removeEventListener("mousedown", this._onMouseDown);
		document.removeEventListener("mouseup", this._onMouseUp);
		META.TARGET_CANVAS.removeEventListener("wheel", this._onMouseWheel);

		document.body.oncontextmenu = null;
	};

	/**
	 * @inheritDoc
	 */
	Mouse.prototype.map = function(buttonOrAxis, actionName)
	{
		InputPlugin.prototype.map.call(this, buttonOrAxis, actionName);

		// disable context menu
		if (buttonOrAxis === Mouse.BUTTON_RIGHT)
			document.body.oncontextmenu = function() { return false; };
	};

	/**
	 * @inheritDoc
	 */
	Mouse.prototype.unmap = function(buttonOrAxis)
	{
		InputPlugin.prototype.unmap.call(this, buttonOrAxis);

		// disable context menu
		if (buttonOrAxis === Mouse.BUTTON_RIGHT)
			document.body.oncontextmenu = null;
	};

	/**
	 * @ignore
	 * @private
	 */
	Mouse.prototype._onMouseDown = function(event)
	{
		this._buttonMask = event.buttons;
		var button = BUTTON_MAP[event.button];
		if (!button) return;
		this.setValue(button, 1);
	};

	/**
	 * @ignore
	 * @private
	 */
	Mouse.prototype._onMouseUp = function(event)
	{
		this._buttonMask = event.buttons;
		var button = BUTTON_MAP[event.button];
		if (button)
			this.setValue(button, 0);
	};

	/**
	 * @ignore
	 * @private
	 */
	Mouse.prototype._onMouseMove = function(event)
	{
		this._updatePos(event.clientX, event.clientY);
	};

	/**
	 * @ignore
	 * @private
	 */
	Mouse.prototype._updatePos = function(x, y)
	{
		var rect = META.TARGET_CANVAS.getBoundingClientRect();

		// we're measuring mouse move over the whole document, but need the coordinates relative to the canvas
		// clamp to 0, 1 so we don't register moves outside the canvas (need to listen to moves over the document so it
		// won't get blocked by other DOM elements)
		this._mouseX = MathX.saturate((x - rect.left) / rect.width);
		this._mouseY = MathX.saturate((y - rect.top) / rect.height);
	};

	/**
	 * @ignore
	 * @private
	 */
	Mouse.prototype._onPreFrame = function()
	{
		var mouseX = this._mouseX;
		var mouseY = this._mouseY;
		var aspect = META.TARGET_CANVAS.width / META.TARGET_CANVAS.height;

		if (this._previousX !== undefined) {
			var dx = (mouseX - this._previousX) * this.sensitivityX;
			var dy = (mouseY - this._previousY) * this.sensitivityY;

			this.setValue(Mouse.MOVE_X, dx * aspect);
			this.setValue(Mouse.MOVE_Y, dy);

			var isDown = this._buttonMask & 1;
			if (isDown) {
				this.setValue(Mouse.DRAG_X, dx * aspect);
				this.setValue(Mouse.DRAG_Y, dy);
			}
			else {
				this.setValue(Mouse.DRAG_X, 0);
				this.setValue(Mouse.DRAG_Y, 0);
			}
		}

		this._previousX = mouseX;
		this._previousY = mouseY;

		this.setValue(Mouse.POS_X, mouseX);
		this.setValue(Mouse.POS_Y, mouseY);

		this.setValue(Mouse.WHEEL_X, this._wheelX * this.sensitivityWheel);
		this.setValue(Mouse.WHEEL_Y, this._wheelY * this.sensitivityWheel);

		this._wheelX = 0;
		this._wheelY = 0;
	};

	/**
	 * @ignore
	 * @private
	 */
	Mouse.prototype._onMouseLeave = function(event)
	{
		this._updatePos(event.clientX, event.clientY);
	};

	/**
	 * @ignore
	 * @private
	 */
	Mouse.prototype._onMouseEnter = function(event)
	{
		this._updatePos(event.clientX, event.clientY);

		var buttonMask = this._buttonMask;
		var newButtonMask = event.buttons;

		// check if a button went "up" while not over the canvas
		if (((buttonMask & 1) !== 0) && ((newButtonMask & 1) === 0))
			this.setValue(Mouse.BUTTON_LEFT, 0);

		if (((buttonMask & 2) !== 0) && ((newButtonMask & 2) === 0))
			this.setValue(Mouse.BUTTON_RIGHT, 0);

		if (((buttonMask & 4) !== 0) && ((newButtonMask & 4) === 0))
			this.setValue(Mouse.BUTTON_MIDDLE, 0);

		this._buttonMask = newButtonMask;
	};

	/**
	 * @ignore
	 * @private
	 */
	Mouse.prototype._onMouseWheel = function(event)
	{
		if (!(this.isMapped(Mouse.WHEEL_X) || this.isMapped(Mouse.WHEEL_Y))) return;

		// sadly, we're limited to binary scroll information, because Firefox broadcasts the scroll distance in lines, which
		// is too hairy to convert.
		this._wheelX += MathX.sign(event.deltaX);
		this._wheelY += MathX.sign(event.deltaY);

		event.preventDefault();
	};

	/**
	 * @classdesc
	 *
	 * The MouseLock enables locked-pointer mouse input in {@Input}. Before the pointer is locked, the canvas must be clicked.
	 *
	 * @property sensitivityX The horizontal mouse movement sensitivity
	 * @property sensitivityY The vertical mouse movement sensitivity
	 * @property sensitivityScroll The scroll wheel sensitivity
	 *
	 * @constructor
	 */
	function MouseLock()
	{
		InputPlugin.call(this);

		this.sensitivityX = 1;
		this.sensitivityY = -1;	 // invert by default
		this.sensitivityWheel = -.0035; // invert by default for zooming

		this._onMouseMove = this._onMouseMove.bind(this);
		this._onMouseDown = this._onMouseDown.bind(this);
		this._onMouseWheel = this._onMouseWheel.bind(this);
		this._onMouseUp = this._onMouseUp.bind(this);
	    this._onCanvasClick = this._onCanvasClick.bind(this);
	    this._onPointerLockChange = this._onPointerLockChange.bind(this);

		this._wheelX = null;
		this._wheelY = null;
		this._movementX = null;
		this._movementY = null;
	}

	/**
	 * Returns true if the MouseLock is supported.
	 */
	MouseLock.isSupported = function()
	{
	    return !!META.TARGET_CANVAS.requestPointerLock;
	};

	/**
	 * The axis name for when the mouse moves horizontally over the canvas
	 */
	MouseLock.MOVE_X = 0;

	/**
	 * The axis name for when the mouse moves vertically over the canvas
	 */
	MouseLock.MOVE_Y = 1;

	/**
	 * The left button name
	 */
	MouseLock.BUTTON_LEFT = 2;

	/**
	 * The right button name
	 */
	MouseLock.BUTTON_RIGHT = 3;

	/**
	 * The middle (usually scroll) button name
	 */
	MouseLock.BUTTON_MIDDLE = 4;

	/**
	 * The axis name when the horizontal scroll wheel moves
	 */
	MouseLock.WHEEL_X = 5;

	/**
	 * The axis name when the vertical scroll wheel moves
	 */
	MouseLock.WHEEL_Y = 6;


	MouseLock.prototype = Object.create(InputPlugin.prototype);

	// maps event buttons to our buttons
	var BUTTON_MAP$1 = {
		0: MouseLock.BUTTON_LEFT,
		1: MouseLock.BUTTON_MIDDLE,
		2: MouseLock.BUTTON_RIGHT
	};


	/**
	 * @ignore
	 */
	MouseLock.prototype.onEnabled = function()
	{
	    META.TARGET_CANVAS.addEventListener("click", this._onCanvasClick);

		onPreFrame.bind(this._onPreFrame, this);
		document.addEventListener("mousemove", this._onMouseMove);
		META.TARGET_CANVAS.addEventListener("mousedown", this._onMouseDown);
		document.addEventListener("mouseup", this._onMouseUp);
		META.TARGET_CANVAS.addEventListener("wheel", this._onMouseWheel);
		document.addEventListener("pointerlockchange", this._onPointerLockChange);
		document.addEventListener("mozpointerlockchange", this._onPointerLockChange);
	};

	/**
	 * @ignore
	 */
	MouseLock.prototype.onDisabled = function()
	{
	    META.TARGET_CANVAS.removeEventListener("click", this._onCanvasClick);
	    document.exitPointerLock();

		onPreFrame.unbind(this._onPreFrame);
		document.removeEventListener("mousemove", this._onMouseMove);
		META.TARGET_CANVAS.removeEventListener("mousedown", this._onMouseDown);
		document.removeEventListener("mouseup", this._onMouseUp);
		META.TARGET_CANVAS.removeEventListener("wheel", this._onMouseWheel);
	    document.removeEventListener("pointerlockchange", this._onPointerLockChange);
	    document.removeEventListener("mozpointerlockchange", this._onPointerLockChange);
	};

	MouseLock.prototype._onCanvasClick = function()
	{
	    META.TARGET_CANVAS.requestPointerLock();
	};

	/**
	 * @ignore
	 * @private
	 */
	MouseLock.prototype._onMouseDown = function(event)
	{
		var button = BUTTON_MAP$1[event.button];
		if (!button) return;
		this.setValue(button, 1);
	};

	/**
	 * @ignore
	 * @private
	 */
	MouseLock.prototype._onMouseUp = function(event)
	{
		var button = BUTTON_MAP$1[event.button];
		if (button)
			this.setValue(button, 0);
	};

	/**
	 * @ignore
	 * @private
	 */
	MouseLock.prototype._onMouseMove = function(event)
	{
	    var rect = META.TARGET_CANVAS.getBoundingClientRect();

	    // we're measuring mouse move over the whole document, but need the coordinates relative to the canvas
	    // clamp to 0, 1 so we don't register moves outside the canvas (need to listen to moves over the document so it
	    // won't get blocked by other DOM elements)
	    this._movementX = event.movementX / rect.width;
	    this._movementY = event.movementY / rect.height;
	};

	/**
	 * @ignore
	 * @private
	 */
	MouseLock.prototype._onPreFrame = function()
	{
		var canvas = META.TARGET_CANVAS;
		if (document.pointerLockElement !== canvas) return;
		var aspect = canvas.width / canvas.height;

		this.setValue(MouseLock.MOVE_X, this._movementX * aspect * this.sensitivityX);
		this.setValue(MouseLock.MOVE_Y, this._movementY * this.sensitivityY);

		this._movementX = 0;
	    this._movementY = 0;

		this.setValue(MouseLock.WHEEL_X, this._wheelX * this.sensitivityWheel);
		this.setValue(MouseLock.WHEEL_Y, this._wheelY * this.sensitivityWheel);

		this._wheelX = 0;
		this._wheelY = 0;
	};

	/**
	 * @ignore
	 * @private
	 */
	MouseLock.prototype._onMouseWheel = function(event)
	{
		if (!(this.isMapped(MouseLock.WHEEL_X) || this.isMapped(MouseLock.WHEEL_Y))) return;

		// sadly, we're limited to binary scroll information, because Firefox broadcasts the scroll distance in lines, which
		// is too hairy to convert.
		this._wheelX += MathX.sign(event.deltaX);
		this._wheelY += MathX.sign(event.deltaY);

		event.preventDefault();
	};

	/**
	 * @private
	 * @ignore
	 */
	MouseLock.prototype._onPointerLockChange = function(event)
	{
		this._movementX = 0;
		this._movementY = 0;

	    this.setValue(MouseLock.MOVE_X, 0);
	    this.setValue(MouseLock.MOVE_Y, 0);
	    this.setValue(MouseLock.WHEEL_X, 0);
	    this.setValue(MouseLock.WHEEL_Y, 0);
	    this.setValue(MouseLock.BUTTON_LEFT, 0);
	    this.setValue(MouseLock.BUTTON_RIGHT, 0);
	    this.setValue(MouseLock.BUTTON_MIDDLE, 0);
	};

	/**
	 * @classdesc
	 *
	 * The Touch class enables touch input in {@linkcode Input}.
	 *
	 * @property sensitivityX The horizontal single-finger movement sensitivity
	 * @property sensitivityY The vertical single-finger movement sensitivity
	 * @property sensitivityPinch The sensitivity for two-finger pinching
	 *
	 * @constructor
	 */
	function Touch()
	{
		// TODO: Add a way to map regions on the screen that can be tapped

		// TODO: In the callback, should we always check if the first touch is in the list of target touches?

		InputPlugin.call(this);

		this.sensitivityX = 1;
		this.sensitivityY = 1;
		this.sensitivityPinch = 1;

		this._onTouchMove = this._onTouchMove.bind(this);
		this._onTouchStart = this._onTouchStart.bind(this);
		this._onTouchEnd = this._onTouchEnd.bind(this);

		this._previousX = undefined;
		this._previousY = undefined;
		this._touchX = undefined;
		this._touchY = undefined;
		this._pinchDistance = 0;
	}

	/**
	 * The axis name for when the finger moves horizontally over the canvas
	 */
	Touch.MOVE_X = 0;

	/**
	 * The axis name for when the finger moves vertically over the canvas
	 */
	Touch.MOVE_Y = 1;

	/**
	 * The axis name for the finger position on the canvas. 0 means all the way left, 1 means all the way right.
	 */
	Touch.POS_X = 2;

	/**
	 * The axis name for the finger position on the canvas. 0 means all the way to the top, 1 means all the way to the bottom.
	 */
	Touch.POS_Y = 3;

	/**
	 * The axis name for the pinch gesture on the canvas. Positive means growth, negative means shrinkage.
	 */
	Touch.PINCH = 4;

	Touch.prototype = Object.create(InputPlugin.prototype);

	/**
	 * @ignore
	 */
	Touch.prototype.onEnabled = function()
	{
		onPreFrame.bind(this._onPreFrame, this);
		document.addEventListener("touchmove", this._onTouchMove); // finger can move over the document
		document.addEventListener("touchstart", this._onTouchStart);
		document.addEventListener("touchend", this._onTouchEnd);		// finger can go up over the document
	};

	/**
	 * @ignore
	 */
	Touch.prototype.onDisabled = function()
	{
		onPreFrame.unbind(this._onPreFrame);
		document.removeEventListener("touchmove", this._onTouchMove);
		document.removeEventListener("touchstart", this._onTouchStart);
		document.removeEventListener("touchend", this._onTouchEnd);
	};

	/**
	 * @ignore
	 * @private
	 */
	Touch.prototype._onTouchStart = function(event)
	{
		var numTouches = event.touches.length;

		this._previousX = undefined;
		this._previousY = undefined;

		var touch1 = event.touches[0];
		// update the main touch
		if (numTouches === 1) {
			this._updatePos(touch1.clientX, touch1.clientY);
		}
		else if (numTouches === 2) {
			var touch2 = event.touches[1];
			var dx = touch1.screenX - touch2.screenX;
			var dy = touch1.screenY - touch2.screenY;
			this._pinchDistance = Math.sqrt(dx*dx + dy*dy);

			// won't be handling moves anymore
			this._touchX = undefined;
			this._touchY = undefined;
		}
	};

	/**
	 * @ignore
	 * @private
	 */
	Touch.prototype._onTouchEnd = function(event)
	{
		this._previousX = undefined;
		this._previousY = undefined;

		var numTouches = event.touches.length;
		var touch1 = event.touches[0];
		if (numTouches === 0) ;
		else if (numTouches === 1) {
			this._updatePos(touch1.clientX, touch1.clientY);
			this._updatePos(touch1.clientX, touch1.clientY);
		}
	};

	/**
	 * @ignore
	 * @private
	 */
	Touch.prototype._onTouchMove = function(event)
	{
		event.preventDefault();

		var numTouches = event.touches.length;
		var touch1 = event.touches[0];

		if (numTouches === 1) {
			this._updatePos(touch1.clientX, touch1.clientY);
		}
		else if (numTouches === 2) {
			var touch2 = event.touches[1];
			var dx = touch1.screenX - touch2.screenX;
			var dy = touch1.screenY - touch2.screenY;
			var dist = Math.sqrt(dx*dx + dy*dy);
			var diff = (dist - this._pinchDistance) / this._pinchDistance;
			this._pinchDistance = dist;
			this.setValue(Touch.PINCH, diff * this.sensitivityPinch);
		}

	};

	/**
	 * @ignore
	 * @private
	 */
	Touch.prototype._updatePos = function(x, y)
	{
		this._touchX = x / window.innerWidth;
		this._touchY = y / window.innerHeight;
	};

	/**
	 * @ignore
	 * @private
	 */
	Touch.prototype._onPreFrame = function()
	{
		var touchX = this._touchX;
		var touchY = this._touchY;
		var aspect = window.innerWidth / window.innerHeight;

		if (this._previousX !== undefined) {
			var dx = (touchX - this._previousX) * this.sensitivityX;
			var dy = (touchY - this._previousY) * this.sensitivityY;

			this.setValue(Touch.MOVE_X, dx * aspect);
			this.setValue(Touch.MOVE_Y, dy);
		}

		this._previousX = touchX;
		this._previousY = touchY;

		this.setValue(Touch.POS_X, touchX);
		this.setValue(Touch.POS_Y, touchY);
	};

	/**
	 * @ignore
	 * @author derschmale <http://www.derschmale.com>
	 */
	var FileUtils =
	{
	    extractPathAndFilename: function(filename)
	    {
	        var index = filename.lastIndexOf("/");
	        var obj = {};

	        if (index >= 0) {
	            obj.path = filename.substr(0, index + 1);
	            obj.filename = filename.substr(index + 1);
	        }
	        else {
	            obj.path = "./";
	            obj.filename = filename;
	        }

	        return obj;
	    }
	};

	/**
	 * @ignore
	 *
	 * @classdesc
	 * URLLoader loads any sort of file. It exists only to hide ugly XMLHttpRequest stuff.
	 *
	 * @param [headers] Optional headers (key/value pairs) to pass along to the request.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function URLLoader(headers)
	{
	    this._params = undefined;
	    this._data = null;
	    this._timeout = 0;
	    this._method = 'GET';
	    this._type = URLLoader.DATA_TEXT;
	    this._headers = headers || {};
	}

	URLLoader.ERROR_TIME_OUT = 408;
	URLLoader.METHOD_GET = 'get';
	URLLoader.METHOD_POST = 'post';

	URLLoader.DATA_TEXT = 0;
	URLLoader.DATA_BINARY = 1;

	URLLoader.prototype =
	{
	    get type()
	    {
	        return this._type;
	    },

	    set type(value)
	    {
	        this._type = value;
	    },

	    get method()
	    {
	        return this._method;
	    },

	    set method(value)
	    {
	        this._method = value;
	    },

	    get timeoutDuration()
	    {
	        return this._timeout;
	    },

	    set timeoutDuration(milliseconds)
	    {
	        this._timeout = milliseconds;
	    },

	    get parameters()
	    {
	        return this._params;
	    },

	    set parameters(params)
	    {
	        this._params = params;
	    },

	    get data()
	    {
	        return this._data;
	    },

	    setRequestHeader: function(name, value)
	    {
	        this._headers[name] = value;
	    },

	    load: function (url)
	    {
	        var request = new XMLHttpRequest();
	        request.open(this._method, url, true);

	        for (var key in this._headers) {
	            if (this._headers.hasOwnProperty(key))
	                request.setRequestHeader(key, this._headers[key]);
	        }

	        if (this._timeout) {
	            request.timeout = this._timeout;

	            request.ontimeout = function ()
	            {
	                self.onError(URLLoader.ERROR_TIME_OUT);
	            };
	        }

	        if (this._type === URLLoader.DATA_BINARY)
	            request.responseType = "arraybuffer";
	        else
	            request.overrideMimeType("application/json");

	        var self = this;

	        request.onreadystatechange = function ()
	        {
	            var DONE = this.DONE || 4;
	            if (this.readyState === DONE) {
	                if (this.status === 200) {
	                    this._data = self._type === URLLoader.DATA_TEXT? request.responseText : new DataView(request.response);
	                    if (self.onComplete) self.onComplete(this._data);
	                }
	                else if (self.onError)
	                    self.onError(this.status);
	            }
	        };

	        request.send(this._params);
	    },

	    // made to assign
	    onComplete: function (data)
	    {
	    },

	    onError: function (errorStatus)
	    {
	    }
	};

	/**
	 * @classdesc
	 * A base class for importers.
	 *
	 * @ignore
	 * @param containerType
	 * @param dataType
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Importer(containerType, dataType)
	{
	    this._dataType = dataType === undefined? URLLoader.DATA_TEXT : dataType;
	    this._containerType = containerType;
	    this.onComplete = null;
	    this.onProgress = null;
	    this.onFail = null;
	    this.fileMap = null;
	    // be able to pass importer specific settings. crossOrigin is used for images, fe.
	    this.options = {};
	    this.path = "";
	    this.filename = "";
	}

	Importer.prototype =
	    {
	        get dataType() { return this._dataType; },
	        createContainer: function() { return new this._containerType(); },

	        parse: function(data, target) {},

	        _notifyComplete: function(asset)
	        {
	            if (!this.onComplete) return;

	            if (this.onComplete instanceof Signal)
	                this.onComplete.dispatch(asset);
	            else
	                this.onComplete(asset);
	        },

	        _notifyProgress: function(ratio)
	        {
	            if (!this.onProgress) return;

	            if (this.onProgress instanceof Signal)
	                this.onProgress.dispatch(ratio);
	            else
	                this.onProgress(ratio);
	        },

	        _notifyFailure: function(message)
	        {
	            if (this.onFail instanceof Signal) {
	                if (!this.onFail.hasListeners) {
	                    console.error(message);
	                }
	                this.onFail.dispatch(message);
	            }
	            else
	                this.onFail(message);
	        },

	        // expresses a url in the file relative to the original file being loaded
	        _correctURL: function(url)
	        {
	            return this.path + (this.fileMap.hasOwnProperty(url)? this.fileMap[url] : url).replace("\\", "/");
	        }
	    };

	Importer.TYPE_TEXT = URLLoader.DATA_TEXT;
	Importer.TYPE_BINARY = URLLoader.DATA_BINARY;
	Importer.TYPE_IMAGE = 2;

	/**
	 * @classdesc
	 * AssetLoader allows loading of any sort of asset. It can be used to load several assets, but onComplete and onFail will be called for each.
	 * @param ImporterType ImporterType The type of importer to use for the asset. For example: JPG, HCM (material), OBJ, ... Do NOT pass in an instance, just the class name!
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AssetLoader(ImporterType)
	{
	    // this can either be listened to, or overwritten by a function
	    this.onComplete = new Signal();
	    this.onProgress = new Signal();
	    this.onFail = new Signal();

	    /**
	     * Key/value pairs that allows replacing file names with new ones.
	     */
	    this.fileMap = {};

	    /**
	     * Key/value pairs that specify options to be passed on to the Importers. See the importer documentation for details
	     * on which options can be set.
	     */
	    this.options = {};

	    this._headers = {};

	    this._importerType = ImporterType;

	    /**
	     * Allow setting a cross-origin string when loading images.
	     */
	    this.crossOrigin = undefined;
	}

	AssetLoader.prototype =
	{
	    /**
	     * Set custom http request headers.
	     * @param name The name of the header.
	     * @param value The value of the header.
	     */
	    setRequestHeader: function(name, value)
	    {
	        this._headers[name] = value;
	    },

	    /**
		 * Loads the asset.
		 * @param file The filename/url to load, or a File object.
		 * @param [target] An optional empty target asset. This allows lazy loading.
	     * @returns {*} Immediately returns an empty version of the assets that will be populated eventually during parsing.
	     */
	    load: function (file, target)
	    {
	        var importer = new this._importerType();
	        target = target || importer.createContainer();
	        importer.onComplete = this.onComplete;
	        importer.onProgress = this.onProgress;
	        importer.onFail = this.onFail;
	        importer.fileMap = this.fileMap;
	        importer.options = this.options;

	        file instanceof Blob?
				this._importFromFile(file, target, importer) :
	            this._importFromFilename(file, target, importer);

	        return target;
	    },

		_fail: function(code) {
			console.warn("Failed loading " + filename + ". Error code: " + code);
			if (this.onFail) {
				if (this.onFail instanceof Signal)
					this.onFail.dispatch(code);
				else
					this.onFail(code);
			}
		},

		_importFromFile: function(file, target, importer)
	    {
	        var fileReader = new FileReader();
			fileReader.onerror = function(code) {
				self._fail.call(self, code);
			};


			switch (importer.dataType) {
	            case Importer.TYPE_TEXT:
					fileReader.onload = function() {
						importer.parse(fileReader.result, target);
					};
					fileReader.readAsText(file);
					break;
	            case Importer.TYPE_BINARY:
					fileReader.onload = function() {
						importer.parse(new DataView(fileReader.result), target);
					};
					fileReader.readAsArrayBuffer(file);
	                break;
	            case Importer.TYPE_IMAGE:
					var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

					fileReader.onload = function() {
						image.src = fileReader.result;
						importer.parse(image, target);
					};

					fileReader.readAsDataURL(file);
	                break;
	        }
	    },

	    _importFromFilename: function(filename, target, importer)
	    {
			var file = FileUtils.extractPathAndFilename(filename);
			importer.path = file.path;
			importer.filename = file.filename;

			if (importer.dataType === Importer.TYPE_IMAGE) {
				var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
				image.crossOrigin = this.options.crossOrigin;
				image.addEventListener("load", function() {
					importer.parse(image, target);
				});

				image.addEventListener("error", function() {
					console.warn("Failed loading asset '" + filename + "'");
					self._fail.call(self);
				});
				image.src = filename;
			}
			else {
				var self = this;
				var urlLoader = new URLLoader(this._headers);
				urlLoader.type = importer.dataType;

				urlLoader.onComplete = function (data)
				{
					importer.parse(data, target);
				};

				urlLoader.onError = function (code)
				{
					self._fail.call(self, code);
				};

				urlLoader.load(filename);
			}
	    }
	};

	/**
	 * @constructor
	 * @param {string} basePath The base path or url to load the assets from. All filenames will have this value prepended.
	 * @param {string} [crossOrigin] An optional cross origin string. This is used when loading images from a different domain.
	 *
	 * @classdesc
	 * AssetLibrary provides a way to load a collection of assets. These can be textures, models, plain text, json, ...
	 * Assets need to be queued with a given ID and loading starts when requested. When loading completes, the ID can be used
	 * to retrieve the loaded asset.
	 *
	 * @example
	 * var assetLibrary = new HX.AssetLibrary("assets/");
	 * assetLibrary.queueAsset("some-model", "models/some-model.obj", HX.AssetLibrary.Type.ASSET, HX_IO.OBJ);
	 * assetLibrary.queueAsset("some-texture", "textures/some_texture.png", HX.AssetLibrary.Type.ASSET, HX.PNG);
	 * assetLibrary.onComplete.bind(onAssetsLoaded);
	 * assetLibrary.onProgress.bind(onAssetsProgress);
	 * assetLibrary.load();
	 *
	 * function onAssetsLoaded()
	 * {
	 * // do something
	 * }
	 *
	 * function onAssetsProgress(ratio)
	 * {
	 *      var percent = ratio * 100
	 * }
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */

	function AssetLibrary(basePath, crossOrigin)
	{
	    this.fileMap = {};
	    this._numLoaded = 0;
	    this._queue = [];
	    this._assets = {};
	    if (basePath && basePath.charAt(basePath.length - 1) !== "/") basePath += "/";
	    this._basePath = basePath || "";
	    this._onComplete = new Signal(/* void */);
	    this._onProgress = new Signal(/* number */);
	    this._crossOrigin = crossOrigin;
	}

	/**
	 * The type of asset to load. For example: <code>AssetLibrary.Type.JSON</code> for a JSON object.
	 * @enum
	 */
	AssetLibrary.Type = {
	    /**
	     * A JSON data object.
	     */
	    JSON: 0,

	    /**
	     * A Helix-based asset.
	     */
	    ASSET: 1,

	    /**
	     * A plain text file.
	     */
	    PLAIN_TEXT: 2,

	    /**
	     * Raw binary data
	     */
	    RAW_BINARY: 3
	};

	AssetLibrary.prototype =
	{
	    /**
	     * The {@linkcode Signal} dispatched when all assets have completed loading. Its payload object is a reference to
	     * the assetLibrary itself.
	     * @see {@linkcode Signal}.
	     */
	    get onComplete()
	    {
	        return this._onComplete;
	    },

	    /**
	     * The {@linkcode Signal} dispatched when all assets have completed loading. Its payload is the ratio of loaded
	     * objects for 0 to 1.
	     * @see {@linkcode Signal}
	     */
	    get onProgress()
	    {
	        return this._onProgress;
	    },

	    /**
	     * The base path relative to which all the filenames are defined. This value is set in the constructor.
	     */
	    get basePath()
	    {
	        return this._basePath;
	    },

	    /**
	     * The cross origin string passed to the constructor.
	     */
	    get crossOrigin()
	    {
	        return this._crossOrigin;
	    },

	    /**
	     * Adds an asset to the loading queue.
	     * @param {string} id The ID that will be used to retrieve the asset when loaded.
	     * @param {string} file Either a File object or a filename relative to the base path provided in the constructor.
	     * @param {AssetLibrary.Type} type The type of asset to be loaded.
	     * @param parser The parser used to parse the loaded data.
	     * @param [options] An optional options object (importer-dependent)
	     * @param [target] An optional empty target to contain the parsed asset. This allows lazy loading.
	     * @see {@linkcode AssetLibrary#Type}
	     */
	    queueAsset: function(id, file, type, parser, options, target)
	    {
	        this._queue.push({
	            id: id,
	            file: (file instanceof Blob)? file : this._basePath + file,
	            type: type,
	            parser: parser,
	            options: options,
	            target: target
	        });
	    },

	    /**
	     * Start loading all the assets. Every time a single asset finished loading, <code>onProgress</code> is dispatched.
	     * When all assets have finished loading, <code>onComplete</code> is dispatched.
	     */
	    load: function()
	    {
	        if (this._queue.length === 0) {
	            this.onComplete.dispatch(this);
	            return;
	        }

	        var asset = this._queue[this._numLoaded];

	        switch (asset.type) {
	            case AssetLibrary.Type.JSON:
	                this._json(asset.file, asset.id);
	                break;
	            case AssetLibrary.Type.PLAIN_TEXT:
	                this._plainText(asset.file, asset.id);
	                break;
	            case AssetLibrary.Type.RAW_BINARY:
	                this._rawBinary(asset.file, asset.id);
	                break;
	            case AssetLibrary.Type.ASSET:
	                this._asset(asset.file, asset.id, asset.parser, asset.options, asset.target);
	                break;
	            default:
	                throw new Error("Unknown asset type " + asset.type + "!");
	        }
	    },

	    /**
	     * Retrieves a loaded asset from the asset library. This method should only be called once <code>onComplete</code>
	     * has been dispatched.
	     * @param {string} id The ID assigned to the loaded asset when calling <code>queueAsset</code>
	     * @returns {*} The loaded asset.
	     */
	    get: function(id) { return this._assets[id]; },

	    /**
	     * Adds an asset explicitly.
	     * @param {string} id The ID assigned to the asset when calling <code>get</code>
	     * @param asset The asset to add to the library
	     */
	    addAsset: function(id, asset)
	    {
	        this._assets[id] = asset;
	    },

	    /**
	     * Merges the contents of another library into the current.
	     * @param {AssetLibrary} library The library to add.
	     */
	    mergeLibrary: function(library)
	    {
	        ArrayUtils.forEach(library._assets, (function (obj, key)
	        {
	            this.addAsset(key, obj);
	        }).bind(this));
	    },

	    _json: function(file, id)
	    {
	        var self = this;

	        this._loadText(file, function(result) {
				self._assets[id] = JSON.parse(result);
				self._onAssetLoaded();
	        });

	    },

	    _plainText: function(file, id)
	    {
	        var self = this;

	        this._loadText(file, function(result) {
				self._assets[id] = result;
				self._onAssetLoaded();
	        });
	    },

		_loadText: function(file, callback)
		{
			if (file instanceof Blob) {
				var reader = new FileReader();
				reader.onload = function() {
					callback(reader.result);
				};
				reader.readAsText(file);
			}
			else {
				var loader = new XMLHttpRequest();
				loader.overrideMimeType("application/json");
				loader.open('GET', file, true);
				loader.onreadystatechange = function()
				{
					if (loader.readyState === 4 && loader.status === 200) {
						callback(loader.responseText);
					}
				};
				loader.send(null);
			}
		},

	    _rawBinary: function(file, id)
	    {
	        var self = this;
	        if (file instanceof Blob) {
				var reader = new FileReader();
				reader.onload = function() {
					self._assets[id] = data;
					self._onAssetLoaded();
				};
				reader.readAsArrayBuffer(file);
	        }
	        else {
				var loader = new URLLoader();
				loader.type = URLLoader.DATA_BINARY;
				loader.onComplete = function (data)
				{
					self._assets[id] = data;
					self._onAssetLoaded();
				};

				loader.load(file);
			}
	    },

	    _asset: function(file, id, parser, options, target)
	    {
	        var loader = new AssetLoader(parser);
	        loader.fileMap = this.fileMap;
	        loader.options = options || {};
	        loader.options.crossOrigin = this._crossOrigin;
	        loader.onComplete.bind(function()
	        {
	            this._onAssetLoaded();
	        }, this);

	        loader.onProgress.bind(function(ratio)
	        {
	            this._onProgress.dispatch((this._numLoaded + ratio) / this._queue.length);
	        }, this);

	        this._assets[id] = loader.load(file, target);
			this._assets[id].name = id;
	    },

	    _onAssetLoaded: function()
	    {
	        ++this._numLoaded;

	        this._onProgress.dispatch(this._numLoaded / this._queue.length);

	        if (this._numLoaded === this._queue.length)
	            this._onComplete.dispatch(this);
	        else
	            this.load();
	    }
	};

	/**
	 * @classdesc
	 *
	 * AudioFile is an importer for audio files. Yields an {@see AudioClip} object.
	 *
	 * @constructor
	 *
	 * @extends Importer
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AudioFile()
	{
		Importer.call(this, AudioClip, Importer.TYPE_BINARY);
	}

	AudioFile.prototype = Object.create(Importer.prototype);

	/**
	 * @ignore
	 */
	AudioFile.prototype.parse = function(data, target)
	{
		META.AUDIO_CONTEXT.decodeAudioData(data.buffer, this._onDecoded.bind(this, target), this._onFailed.bind(this));
	};

	/**
	 * @ignore
	 * @private
	 */
	AudioFile.prototype._onDecoded = function(target, buffer)
	{
		target.buffer = buffer;
		this._notifyComplete(target);
	};

	/**
	 * @ignore
	 * @private
	 */
	AudioFile.prototype._onFailed = function()
	{
		this._notifyFailure("Failed to decode audio data");
	};

	/**
	 * @classdesc
	 * HCLIP is an Importer for Helix' (binary) animation clip format. Yields an {@linkcode AnimationClip} object.
	 *
	 * @constructor
	 *
	 * @extends Importer
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function HCLIP()
	{
	    Importer.call(this, AnimationClip, URLLoader.DATA_BINARY);
	}

	HCLIP.prototype = Object.create(Importer.prototype);

	HCLIP.VERSION = "0.1.0";

	HCLIP.VALUE_TYPE_SKELETON_POSE = 1;
	HCLIP.VALUE_TYPE_NUMBER = 2;
	HCLIP.VALUE_TYPE_FLOAT3 = 3;
	HCLIP.VALUE_TYPE_QUATERNION = 4;


	HCLIP.prototype.parse = function(data, target)
	{
	    var stream = new DataStream(data);

	    var hash = stream.getString(7);
	    if (hash !== "HX_CLIP")
	        throw new Error("Invalid file hash!");

	    var version = stream.getUint16Array(3).join(".");
	    // pointless to check this now, only know when to support which versions in the future
	    // if (version !== HCLIP.VERSION)
	    //     throw new Error("Unsupported file version!");

	// figure out type:
	    var valueType = stream.getUint8();
	    var numFrames = stream.getUint32();
	    var info = stream.getUint8(); // numJoints in SkeletonPose

	    for (var i = 0; i < numFrames; ++i) {
	        var keyFrame = new HX.KeyFrame();
	        keyFrame.time = stream.getUint32();
	        keyFrame.value = this._readValue(stream, valueType, info);
	        target.addKeyFrame(keyFrame);
	    }

	    this._notifyComplete(target);
	};

	HCLIP.prototype._readValue = function(stream, type, info)
	{
	    if (type === HCLIP.VALUE_TYPE_SKELETON_POSE) {
	        var numJoints = info;
	        var pose = new SkeletonPose();

	        for (var i = 0; i < numJoints; ++i) {
	            var jointPose = new SkeletonJointPose();

	            jointPose.position.set(stream.getFloat32(), stream.getFloat32(), stream.getFloat32());
	            jointPose.rotation.set(stream.getFloat32(), stream.getFloat32(), stream.getFloat32(), stream.getFloat32());
	            jointPose.scale.set(stream.getFloat32(), stream.getFloat32(), stream.getFloat32());

	            pose.setJointPose(i, jointPose);
	        }

	        return pose;
	    }
	    else if (type === AnimationClipExporter.VALUE_TYPE_FLOAT3) {
	        return new HX.Float4(stream.getFloat32(), stream.getFloat32(), stream.getFloat32(), 0.0);
	    }
	    else if(type === AnimationClipExporter.VALUE_TYPE_QUATERNION) {
	        return new HX.Quaternion(stream.getFloat32(), stream.getFloat32(), stream.getFloat32(), stream.getFloat32());
	    }
	    else if (type === AnimationClipExporter.VALUE_TYPE_NUMBER) {
	        return stream.getFloat32();
	    }
	};

	/**
	 * @classdesc
	 * HCM is an Importer for Helix' json-based cube map formats. Yields a {@linkcode TextureCube} object.
	 *
	 * @constructor
	 *
	 * @extends Importer
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function HCM()
	{
	    Importer.call(this, TextureCube);
	}

	HCM.prototype = Object.create(Importer.prototype);

	HCM.prototype.parse = function(file, target)
	{
	    var data = JSON.parse(file);

	    var urls = [
	        data.files.posX,
	        data.files.negX,
	        data.files.posY,
	        data.files.negY,
	        data.files.posZ,
	        data.files.negZ
	    ];

	    if (data.loadMips)
	        this._loadMipChain(urls, target);
	    else
	        this._loadFaces(urls, target);
	};

	HCM.prototype._loadFaces = function(urls, target)
	{
	    var generateMipmaps = this.options.generateMipmaps === undefined? true : this.options.generateMipmaps;
	    var images = [];
	    var self = this;

	    var onError = function() {
	        self._notifyFailure("Failed loading texture '" + urls[0] + "'");
	    };

	    var onLoad = function()
	    {
	        self._notifyProgress(this.nextID / 6);
	        images[this.nextID].src = self.path + urls[this.nextID];
	    };

	    var onLoadLast = function() {
	        target.uploadImages(images, generateMipmaps);
	        self._notifyComplete(target);
	    };

	    for (var i = 0; i < 6; ++i) {
	        var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
	        image.crossOrigin = this.options.crossOrigin;
	        image.nextID = i + 1;
	        if (i < 5) {
	            image.addEventListener("load", onLoad);
	        }
	        // last image to load
	        else {
	            image.addEventListener("load", onLoadLast);
	        }

	        image.addEventListener("error", onError);

	        images[i] = image;
	    }

	    images[0].src = self.path + urls[0];
	};

	HCM.prototype._loadMipChain = function(urls, target)
	{
	    var images = [];

	    var numMips;

	    var self = this;
	    var firstImage = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
	    var realURLs = [];

	    for (var i = 0; i < 6; ++i) {
	        realURLs[i] = urls[i].replace("%m", "0");
	    }

	    firstImage.addEventListener("load", function()
	    {
	        if (firstImage.naturalWidth !== firstImage.naturalHeight || !MathX.isPowerOfTwo(firstImage.naturalWidth)) {
	            self._notifyFailure("Failed loading mipchain: incorrect dimensions");
	        }
	        else {
	            numMips = MathX.log2(firstImage.naturalWidth) + 1;
	            loadTheRest();
	            images[0] = firstImage;
	        }
	    });

	    firstImage.addEventListener("error", function()
	    {
	        self._notifyFailure("Failed loading texture");
	    });

	    firstImage.src = self.path + realURLs[0];

	    function loadTheRest()
	    {
	        var progressRatios = [];
	        var len = numMips * 6;
	        var r = 1, totalRatio = 0;
	        for (var i = 1; i < numMips; ++i) {
	            for (var j = 0; j < 6; ++j) {
	                realURLs.push(urls[j].replace("%m", i.toString()));
	                progressRatios.push(r);
	                totalRatio += r;
	            }
	            r *= .5;
	        }

	        var onError = function ()
	        {
	            self._notifyFailure("Failed loading texture");
	        };

	        var onLoad = function ()
	        {
	            self._notifyProgress(progressRatios[this.nextID] / totalRatio);
	            images[this.nextID].src = self.path + realURLs[this.nextID];
	        };

	        var onLoadLast = function ()
	        {
	            for (var m = 0; m < numMips; ++m)
	                target.uploadImagesToMipLevel(images.slice(m * 6, m * 6 + 6), m);

	            target._isReady = true;
	            self._notifyComplete(target);
	        };

	        for (i = 1; i < len; ++i) {
	            var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
	            image.crossOrigin = self.options.crossOrigin;
	            image.nextID = i + 1;
	            if (i < len - 1) {
	                image.addEventListener("load", onLoad);
	            }
	            // last image to load
	            else {
	                image.addEventListener("load", onLoadLast);
	            }

	            image.addEventListener("onError", onError);

	            images[i] = image;
	        }

	        images[1].src = self.path + realURLs[1];
	    }
	};

	/**
	 * @classdesc
	 *
	 * JPG is an importer for JPG images as textures. Yields a {@linkcode Texture2D} object.
	 *
	 * @constructor
	 *
	 * @extends Importer
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function JPG()
	{
	    Importer.call(this, Texture2D, Importer.TYPE_IMAGE);
	}

	JPG.prototype = Object.create(Importer.prototype);

	JPG.prototype.parse = function(data, target)
	{
	    var generateMipmaps = this.options.generateMipmaps === undefined? true : this.options.generateMipmaps;
	    target.uploadImage(data, data.naturalWidth, data.naturalHeight, generateMipmaps);
	    this._notifyComplete(target);
	};

	/**
	 * @classdesc
	 * Synonymous to {@linkcode JPG}.
	 *
	 * @constructor
	 */
	var PNG = JPG;

	/**
	 * @classdesc
	 * HCM is an Importer for Helix' json-based material formats. Yields a {@linkcode Material} object.
	 *
	 * @constructor
	 *
	 * @extends Importer
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function HMAT()
	{
	    Importer.call(this, Material);
	    HMAT._initPropertyMap();
	}

	HMAT.prototype = Object.create(Importer.prototype);

	HMAT.prototype.parse = function(data, target)
	{
	    data = JSON.parse(data);

	    if (data.class) {
	        this._isClass = true;
	        // TODO: We already have a constructed Material
	        this._applyClass(data.class, target);
	    }
	    else
	        this._isClass = false;

	    this._loadShaders(data, target);
	};

	HMAT.prototype._applyClass = function(className, target)
	{
	    var matClass;
	    switch (className) {
	        case "BasicMaterial":
	            matClass = BasicMaterial;
	            break;
	        default:
	            throw new Error("Unknown material class!");
	    }

	    // adds the required properties
	    // Object assign does NOT copy getters/setters, just assigns the values returned by the getter!
	    // it's a pretty dirty thing to do, but it works and makes the API much friendlier
	    Object.assign(target, matClass.prototype);

	    for (var key in matClass.prototype) {
	        if (Object.prototype.hasOwnProperty.call(matClass.prototype, key)) {
	            target[key] = matClass.prototype[key];
	        }
	    }

	    var names = Object.getOwnPropertyNames(matClass.prototype);
	    for (var i = 0; i < names.length; ++i) {
	        var name = names[i];
	        var desc =  Object.getOwnPropertyDescriptor(matClass.prototype, name);
	        Object.defineProperty(target, name, desc);
	    }
	    // call the constructor
	    matClass.call(target);
	};

	HMAT.prototype._gatherShaderFiles = function(data)
	{
	    var files = [];
	    if (!this._isClass) {
	        var geometry = data.geometry;

	        var vertex = geometry.vertexShader;
	        var fragment = geometry.fragmentShader;
	        if (files.indexOf(vertex) < 0) files.push(this._correctURL(vertex));
	        if (files.indexOf(fragment) < 0) files.push(this._correctURL(fragment));
	    }
	    var lighting = data.lightingModel;

	    if (lighting && lighting !== "unlit" && files.indexOf(lighting) < 0) files.push(this._correctURL(lighting));

	    return files;
	};

	HMAT.prototype._loadShaders = function(data, material)
	{
	    // urls will already be correctURL'ed
	    var shaderFiles = this._gatherShaderFiles(data);
	    this._shaderLibrary = new AssetLibrary(null, this.options.crossOrigin);
	    this._shaderLibrary.fileMap = this.fileMap;

	    for (var i = 0; i < shaderFiles.length; ++i) {
	        this._shaderLibrary.queueAsset(shaderFiles[i], shaderFiles[i], AssetLibrary.Type.PLAIN_TEXT);
	    }

	    this._shaderLibrary.onComplete.bind(function()
	    {
	        this._processMaterial(data, material);
	        this._loadTextures(data, material);
	    }, this);

	    // this._shaderLibrary.onFail.bind(function(code)
	    // {
	    //     this._notifyFailure("Error loading shaders: " + code);
	    // }, this);
	    this._shaderLibrary.load();
	};


	HMAT.prototype._processMaterial = function(data, material)
	{
	    var defines = "";

	    if (!this._isClass) {
	        if (this.options.defines) {
	            ArrayUtils.forEach(this.options.defines, (function(obj, key) {
	                defines += "#define " + key + " " + obj + "\n";
	            }).bind(this));
	        }

	        var geometryVertex = defines + this._shaderLibrary.get(this._correctURL(data.geometry.vertexShader));
	        var geometryFragment = defines + this._shaderLibrary.get(this._correctURL(data.geometry.fragmentShader));

	        material._geometryVertexShader = geometryVertex;
	        material._geometryFragmentShader = geometryFragment;
	        material.init();
	    }

	    if (data.lightingModel === "unlit")
			material.lightingModel = LightingModel.Unlit;
		else if (data.lightingModel)
	        material.lightingModel = this._shaderLibrary.get(this._correctURL(data.lightingModel));

	    this._applyUniforms(data, material);
	    if (this._isClass)
	        this._applyProperties(data, material);

	    if (data.hasOwnProperty("elementType"))
	        material.elementType = HMAT._PROPERTY_MAP[data.elementType];

	    if (data.hasOwnProperty("cullMode"))
	        material.cullMode = HMAT._PROPERTY_MAP[data.cullMode];

	    if (data.hasOwnProperty("writeDepth"))
	        material.writeDepth = data.writeDepth;

	    if (data.hasOwnProperty("blend")) {
	        var blendState = new BlendState();
	        var blend = data.blend;

	        if (blend.hasOwnProperty("source"))
	            blendState.srcFactor = HMAT._PROPERTY_MAP[blend.source];

	        if (blend.hasOwnProperty("destination"))
	            blendState.dstFactor = HMAT._PROPERTY_MAP[blend.destination];

	        if (blend.hasOwnProperty("operator"))
	            blendState.operator = HMAT._PROPERTY_MAP[blend.operator];

	        material.blendState = blendState;
	    }
	};

	HMAT.prototype._applyProperties = function(data, material)
	{
	    if (!data.properties) return;

	    // how to know which type of properties to assign?
	    for (var key in data.properties) {
	        if (!data.properties.hasOwnProperty(key)) continue;

	        var value = data.properties[key];
	        var type = typeof material[key];
	        if (type === "number" || type === "boolean")
	            material[key] = value;
	        else if (material[key] instanceof Color)
	            material[key] = new Color(value[0], value[1], value[2], value[3]);
	        else if (material[key] instanceof Float2)
	            material[key] = new Color(value[0], value[1]);
	        else if (material[key] instanceof Float4)
	            material[key] = new Float4(value[0], value[1], value[2], value[3]);
	        else
	            throw new Error("Unsupport property format!");
	    }
	};

	HMAT.prototype._applyUniforms = function(data, material)
	{
	    if (!data.uniforms) return;

	    for (var key in data.uniforms) {
	        if (!data.uniforms.hasOwnProperty(key)) continue;

	        var value = data.uniforms[key];
	        if (isNaN(value))
	            material.setUniform(key, {
	                x: value[0],
	                y: value[1],
	                z: value[2],
	                w: value[3]
	            }, false);
	        else
	            material.setUniform(key, value, false);
	    }
	};

	HMAT.prototype._loadTextures = function(data, material)
	{
	    var files = [];

	    for (var key in data.textures) {
	        if (data.textures.hasOwnProperty(key)) {
	            files.push(this._correctURL(data.textures[key]));
	            material.setTexture(key, Texture2D.DEFAULT);
	        }
	    }

	    this._textureLibrary = new AssetLibrary(null, this.options.crossOrigin);
	    this._textureLibrary.fileMap = this.fileMap;

	    for (var i = 0; i < files.length; ++i) {
	        this._textureLibrary.queueAsset(files[i], files[i], AssetLibrary.Type.ASSET, JPG);
	    }

	    this._textureLibrary.onComplete.bind(function()
	    {
	        for (var key in data.textures) {
	            if (data.textures.hasOwnProperty(key)) {
	                // if it's a class, the textures need to be setters
	                if (this._isClass)
	                    material[key] = this._textureLibrary.get(this._correctURL(data.textures[key]));
	                else
	                    material.setTexture(key, this._textureLibrary.get(this._correctURL(data.textures[key])));
	            }
	        }
	        this._notifyComplete(material);
	    }, this);

	    this._textureLibrary.load();
	};


	HMAT._PROPERTY_MAP = null;

	HMAT._initPropertyMap = function() {
	    HMAT._PROPERTY_MAP = HMAT._PROPERTY_MAP || {
	        back: CullMode.BACK,
	        front: CullMode.FRONT,
	        both: CullMode.ALL,
	        none: null,
	        lines: ElementType.LINES,
	        points: ElementType.POINTS,
	        triangles: ElementType.TRIANGLES,
	        one: BlendFactor.ONE,
	        zero: BlendFactor.ZERO,
	        sourceColor: BlendFactor.SOURCE_COLOR,
	        oneMinusSourceColor: BlendFactor.ONE_MINUS_SOURCE_COLOR,
	        sourceAlpha: BlendFactor.SOURCE_ALPHA,
	        oneMinusSourceAlpha: BlendFactor.ONE_MINUS_SOURCE_ALPHA,
	        destinationAlpha: BlendFactor.DST_ALPHA,
	        oneMinusDestinationAlpha: BlendFactor.ONE_MINUS_DESTINATION_ALPHA,
	        destinationColor: BlendFactor.DESTINATION_COLOR,
	        sourceAlphaSaturate: BlendFactor.SOURCE_ALPHA_SATURATE,
	        add: BlendOperation.ADD,
	        subtract: BlendOperation.SUBTRACT,
	        reverseSubtract: BlendOperation.REVERSE_SUBTRACT,

	        // depth tests
	        always: Comparison.ALWAYS,
	        disabled: Comparison.DISABLED,
	        equal: Comparison.EQUAL,
	        greater: Comparison.GREATER,
	        greaterEqual: Comparison.GREATER_EQUAL,
	        less: Comparison.LESS,
	        lessEqual: Comparison.LESS_EQUAL,
	        never: Comparison.NEVER,
	        notEqual: Comparison.NOT_EQUAL
	    };
	};

	/**
	 * @classdesc
	 * HMESH is an Importer for Helix' (binary) model format. Yields a {@linkcode Model} object.
	 *
	 * @constructor
	 *
	 * @extends Importer
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function HMESH()
	{
	    Importer.call(this, Mesh, URLLoader.DATA_BINARY);
	}

	HMESH.prototype = Object.create(Importer.prototype);

	HMESH.VERSION = "0.1.0";

	HMESH.prototype.parse = function(data, target)
	{
	    var stream = new DataStream(data);

	    var hash = stream.getString(7);
	    if (hash !== "HX_MESH")
	        throw new Error("Invalid file hash!");

	    var version = stream.getUint16Array(3).join(".");
	    // pointless to check this now, only know when to support which versions in the future
	    // if (version !== HMESH.VERSION)
	    //     throw new Error("Unsupported file version!");

	    this._parseMesh(stream, target);
	    target.skeleton = this._parseSkeleton(stream);

	    this._notifyComplete(target);
	};

	HMESH.prototype._parseMesh = function(stream, mesh)
	{
	    var numIndices = stream.getUint32();
	    var indexSize = stream.getUint8();
	    var indices;

	    if (indexSize === 16)
	        indices = stream.getUint16Array(numIndices);
	    else
	        indices = stream.getUint32Array(numIndices);

	    mesh.setIndexData(indices);

	    var numVertices = stream.getUint32();
	    var numAttributes = stream.getUint8();

	    for (var i = 0; i < numAttributes; ++i) {
	        var nameLen = stream.getUint8();
	        var name = stream.getString(nameLen);
	        var streamIndex = stream.getUint8();
	        var numComponents = stream.getUint8();
	        mesh.addVertexAttribute(name, numComponents, streamIndex);
	    }

	    var numStreams = stream.getUint8();
	    for (i = 0; i < numStreams; ++i) {
	        var len = stream.getUint32();
	        var data = stream.getFloat32Array(len);
	        mesh.setVertexData(data, i);
	    }

	    return mesh;
	};

	HMESH.prototype._parseSkeleton = function(stream)
	{
	    var numJoints = stream.getUint8();
	    if (numJoints === 0) return null;

	    var skeleton = new Skeleton();
	    for (var i = 0; i < numJoints; ++i) {
	        var joint = new SkeletonJoint();
	        var nameLen = stream.getUint8();
	        if (nameLen !== 0)
	            joint.name = stream.getString(nameLen);
	        var parentIndex = stream.getUint8();
	        joint.parentIndex = parentIndex === 0xff? -1 : parentIndex;

	        for (var j = 0; j < 16; ++j)
	            joint.inverseBindPose._m[j] = stream.getFloat32();

	        skeleton.addJoint(joint);
	    }

	    return skeleton;
	};

	/**
	 * EquirectangularTexture is a utility class that converts equirectangular environment {@linknode Texture2D} to a
	 * {@linkcode TextureCube}.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var EquirectangularTexture =
	{
	    /**
	     * Convert an equirectangular environment {@linknode Texture2D} to a {@linkcode TextureCube}.
	     * @param source The source {@linknode Texture2D}
	     * @param [size] The size of the target cube map.
	     * @param [generateMipmaps] Whether or not a mip chain should be generated.
	     * @param [target] An optional target {@linkcode TextureCube} to contain the converted data.
	     * @returns {TextureCube} The environment map in a {@linkcode TextureCube}
	     */
	    toCube: function(source, size, generateMipmaps, target)
	    {
	        generateMipmaps = generateMipmaps || true;
	        size = size || source.height;

	        if (!EquirectangularTexture._EQUI_TO_CUBE_SHADER)
	            EquirectangularTexture._EQUI_TO_CUBE_SHADER = new Shader(ShaderLibrary.get("2d_to_cube_vertex.glsl"), ShaderLibrary.get("equirectangular_to_cube_fragment.glsl"));

	        this._createRenderCubeGeometry();

	        var gl = GL.gl;
	        target = target || new TextureCube();
	        target.initEmpty(size, source.format, source.dataType);
	        var faces = [ CubeFace.POSITIVE_X, CubeFace.NEGATIVE_X, CubeFace.POSITIVE_Y, CubeFace.NEGATIVE_Y, CubeFace.POSITIVE_Z, CubeFace.NEGATIVE_Z ];

	        EquirectangularTexture._EQUI_TO_CUBE_SHADER.updatePassRenderState();

	        var textureLocation = EquirectangularTexture._EQUI_TO_CUBE_SHADER.getUniformLocation("source");
	        var posLocation = EquirectangularTexture._EQUI_TO_CUBE_SHADER.getAttributeLocation("hx_position");
	        var cornerLocation = EquirectangularTexture._EQUI_TO_CUBE_SHADER.getAttributeLocation("corner");

	        gl.uniform1i(textureLocation, 0);
	        source.bind(0);

	        EquirectangularTexture._TO_CUBE_VERTICES.bind();
	        EquirectangularTexture._TO_CUBE_INDICES.bind();
	        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 20, 0);
	        gl.vertexAttribPointer(cornerLocation, 3, gl.FLOAT, false, 20, 8);

	        GL.enableAttributes(2);
	        var old = GL.getCurrentRenderTarget();

	        for (var i = 0; i < 6; ++i) {
	            var fbo = new FrameBuffer(target, null, faces[i]);
	            fbo.init();

	            GL.setRenderTarget(fbo);
	            GL.drawElements(gl.TRIANGLES, 6, i * 6);
	        }

	        GL.setRenderTarget(old);

	        if (generateMipmaps)
	            target.generateMipmap();

	        // TODO: for some reason, if EXT_shader_texture_lod is not supported, mipmapping of rendered-to cubemaps does not work
	        if (!capabilities.EXT_SHADER_TEXTURE_LOD)
	            target.filter = TextureFilter.BILINEAR_NOMIP;

	        return target;
	    },

	    _createRenderCubeGeometry: function()
	    {
	        if (EquirectangularTexture._TO_CUBE_VERTICES) return;
	        var vertices = [
	            // pos X
	            1.0, 1.0, 1.0, -1.0, -1.0,
	            -1.0, 1.0, 1.0, -1.0, 1.0,
	            -1.0, -1.0, 1.0, 1.0, 1.0,
	            1.0, -1.0, 1.0, 1.0, -1.0,

	            // neg X
	            1.0, 1.0, -1.0, -1.0, 1.0,
	            -1.0, 1.0, -1.0, -1.0, -1.0,
	            -1.0, -1.0, -1.0, 1.0, -1.0,
	            1.0, -1.0, -1.0, 1.0, 1.0,

	            // pos Y
	            1.0, 1.0, 1.0, -1.0, 1.0,
	            -1.0, 1.0, -1.0, -1.0, 1.0,
	            -1.0, -1.0, -1.0, 1.0, 1.0,
	            1.0, -1.0, 1.0, 1.0, 1.0,

	            // neg Y
	            1.0, 1.0, -1.0, -1.0, -1.0,
	            -1.0, 1.0, 1.0, -1.0, -1.0,
	            -1.0, -1.0, 1.0, 1.0, -1.0,
	            1.0, -1.0, -1.0, 1.0, -1.0,

	            // pos Z
	            -1.0, -1.0, -1.0, 1.0, -1.0,
	            1.0, -1.0, 1.0, 1.0, -1.0,
	            1.0, 1.0, 1.0, 1.0, 1.0,
	            -1.0, 1.0, -1.0, 1.0, 1.0,

	            // neg Z
	            -1.0, -1.0, -1.0, -1.0, 1.0,
	            1.0, -1.0, 1.0, -1.0, 1.0,
	            1.0, 1.0, 1.0, -1.0, -1.0,
	            -1.0, 1.0, -1.0, -1.0, -1.0
	        ];
	        var indices = [
	            0, 1, 2, 0, 2, 3,
	            4, 5, 6, 4, 6, 7,
	            8, 9, 10, 8, 10, 11,
	            12, 13, 14, 12, 14, 15,
	            16, 17, 18, 16, 18, 19,
	            20, 21, 22, 20, 22, 23
	        ];
	        EquirectangularTexture._TO_CUBE_VERTICES = new VertexBuffer();
	        EquirectangularTexture._TO_CUBE_INDICES = new IndexBuffer();
	        EquirectangularTexture._TO_CUBE_VERTICES.uploadData(new Float32Array(vertices));
	        EquirectangularTexture._TO_CUBE_INDICES.uploadData(new Uint16Array(indices));
	    }
	};

	/**
	 * @classdesc
	 * JPG_EQUIRECTANGULAR loads a JPG containing an equirectangular environment map and converts it to a cube map for use
	 * in shaders. Yields a {@linkcode TextureCube} object.
	 *
	 * @constructor
	 *
	 * @extends Importer
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function JPG_EQUIRECTANGULAR()
	{
	    Importer.call(this, TextureCube, Importer.TYPE_IMAGE);
	}

	JPG_EQUIRECTANGULAR.prototype = Object.create(Importer.prototype);

	JPG_EQUIRECTANGULAR.prototype.parse = function(data, target)
	{
	    var texture2D = new Texture2D();
	    texture2D.wrapMode = TextureWrapMode.REPEAT;
	    texture2D.uploadImage(data, data.naturalWidth, data.naturalHeight, true);

	    var generateMipmaps = this.options.generateMipmaps === undefined? true : this.options.generateMipmaps;
	    EquirectangularTexture.toCube(texture2D, this.options.size, generateMipmaps, target);
	    this._notifyComplete(target);
	};

	var PNG_EQUIRECTANGULAR = JPG_EQUIRECTANGULAR;

	/**
	 * HeightMap contains some utilities for height maps.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var HeightMap =
	{
	    /**
	     * Smooths out an 8-bit per channel texture to serve as a height map. Otherwise, the limited 8 bit precision would
	     * result in a stair-case effect.
	     *
	     * @param texture The source 8-bit per channel texture.
	     * @param [generateMipmaps] Whether or not to generate a mip chain.
	     * @param [target] An optional target texture.
	     */
	    from8BitTexture: function(texture, generateMipmaps, target)
	    {
	        var gl = GL.gl;
	        generateMipmaps = generateMipmaps || true;
	        var tex1 = target || new Texture2D();
	        tex1.initEmpty(texture.width, texture.height);
	        var fbo1 = new FrameBuffer(tex1);
	        fbo1.init();

	        var tex2 = new Texture2D();
	        tex2.initEmpty(texture.width, texture.height);
	        var fbo2 = new FrameBuffer(tex2);
	        fbo2.init();

	        var toRGBA8 = new CustomCopyShader(ShaderLibrary.get("greyscale_to_rgba8.glsl"));
	        var oldRT = GL.getCurrentRenderTarget();

	        GL.setRenderTarget(fbo1);
	        GL.clear();
	        toRGBA8.execute(RectMesh.DEFAULT, texture);

	        if (generateMipmaps)
	            target.generateMipmap();

	        var smooth = new CustomCopyShader(ShaderLibrary.get("smooth_heightmap_fragment.glsl"));
	        var textureLocation = gl.getUniformLocation(smooth._program, "reference");
	        var offsetLocation = gl.getUniformLocation(smooth._program, "stepSize");
	        gl.uniform1i(textureLocation, 1);

	        texture.bind(1);

	        GL.setRenderTarget(fbo2);
	        GL.clear();
	        gl.uniform2f(offsetLocation, 1.0 / texture.width, 0.0);
	        smooth.execute(RectMesh.DEFAULT, tex1);
	        tex2.generateMipmap();

	        GL.setRenderTarget(fbo1);
	        GL.clear();
	        gl.uniform2f(offsetLocation, 0.0, 1.0 / texture.height);
	        smooth.execute(RectMesh.DEFAULT, tex2);

	        if (generateMipmaps)
	            target.generateMipmap();

	        GL.setRenderTarget(oldRT);

	        return tex1;
	    }
	};

	/**
	 * @classdesc
	 * JPG_HEIGHTMAP imports an 8-bit per channel image and smooths it out to serve as a height map. Otherwise, the limited
	 * 8 bit precision would result in a stair-case effect. Yields a {@linkcode Texture2D} object.
	 *
	 * @constructor
	 *
	 * @extends Importer
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function JPG_HEIGHTMAP()
	{
	    Importer.call(this, Texture2D, Importer.TYPE_IMAGE);
	}

	JPG_HEIGHTMAP.prototype = Object.create(Importer.prototype);

	JPG_HEIGHTMAP.prototype.parse = function(data, target)
	{
	    var texture2D = new Texture2D();
	    texture2D.wrapMode = TextureWrapMode.REPEAT;
	    texture2D.uploadImage(data, data.naturalWidth, data.naturalHeight, true);

	    var generateMipmaps = this.options.generateMipmaps === undefined? true : this.options.generateMipmaps;
	    HeightMap.from8BitTexture(texture2D, generateMipmaps, target);
	    this._notifyComplete(target);
	};

	var PNG_HEIGHTMAP = JPG_HEIGHTMAP;

	/**
	 * @classdesc
	 * AmbientLight can be added to the scene to provide a minimum (single-color) amount of light in the scene.
	 *
	 * @property {Color} color The color of the ambient light.
	 * @property {number} intensity The intensity of the ambient light.
	 *
	 * @constructor
	 *
	 * @extends Light
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function AmbientLight()
	{
		Light.call(this);
		this._bounds = new BoundingAABB();
	}

	Component.create(AmbientLight, {}, Light);

	/**
	 * @ignore
	 */
	AmbientLight.prototype.acceptVisitor = function (visitor)
	{
	    visitor.visitAmbientLight(this);
	};

	AmbientLight.prototype._updateBounds = function()
	{
		this._bounds.clear(BoundingVolume.EXPANSE_INFINITE);
	};

	/**
	 * @ignore
	 */
	AmbientLight.prototype.clone = function()
	{
		var clone = new AmbientLight();
		clone.copyFrom(this);
		return clone;
	};

	/**
	 * @classdesc
	 * WriteOnlyDepthBuffer is a depth buffer that can be used with {@linkcode FrameBuffer} as a depth buffer if read-backs
	 * are not required.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function WriteOnlyDepthBuffer()
	{
	    this._renderBuffer = GL.gl.createRenderbuffer();
	    this._format = null;
	}

	WriteOnlyDepthBuffer.prototype = {
	    /**
	     * The width of the depth buffer.
	     */
	    get width() { return this._width; },

	    /**
	     * The height of the depth buffer.
	     */
	    get height() { return this._height; },

	    /**
	     * The format of the depth buffer.
	     */
	    get format() { return this._format; },

	    /**
	     * Initializes the depth buffer.
	     * @param width The width of the depth buffer.
	     * @param height The height of the depth buffer.
	     * @param stencil Whether or not a stencil buffer is required.
	     */
	    init: function(width, height, stencil)
	    {
	        var gl = GL.gl;
	        stencil = stencil === undefined? true : stencil;
	        this._width = width;
	        this._height = height;
	        this._format = stencil? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT16;

	        gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffer);
	        gl.renderbufferStorage(gl.RENDERBUFFER, this._format, width, height);
	        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	    }
	};

	/**
	 * @ignore
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var RenderUtils =
	{
	    /**
	     * @param renderer The actual renderer doing the rendering.
	     * @param passType
	     * @param renderItems
	     * @param data (optional) depending on the type of pass being rendered, data could contain extra stuff to be injected
	     * For example. Dynamic dir lights will use this
	     * @returns The index for the first unrendered renderItem in the list
	     * @private
	     */
	    renderPass: function (renderer, camera, passType, renderItems, data, forceCamera)
	    {
	        var len = renderItems.length;
	        var activePass = null;
	        var lastMesh = null;

	        for(var i = 0; i < len; ++i) {
	            var renderItem = renderItems[i];
	            var material = renderItem.material;
	            var pass = material.getPass(passType);
	            if (!pass) continue;
	            var meshInstance = renderItem.meshInstance;

	            if (pass !== activePass) {
	                pass.updatePassRenderState(camera, renderer, data);
	                activePass = pass;
	                lastMesh = null;    // need to reset mesh data too
	            }

	            // make sure renderstate is propagated
	            pass.updateInstanceRenderState(camera, renderItem, data);

	            if (lastMesh !== meshInstance._mesh) {
					meshInstance.updateRenderState(passType);
	                lastMesh = meshInstance._mesh;
	            }

	            var mesh = meshInstance._mesh;
	            GL.drawElements(pass._elementType, mesh._numIndices, 0, mesh._indexType);
	        }

	        GL.setBlendState(null);
	        return len;
	    }
	};

	/**
	 * @classdesc
	 * Rect is a value object describing an axis-aligned rectangle.
	 * @param x The x-coordinate of the "top-left" corner.
	 * @param y The y-coordinate of the "top-left" corner.
	 * @param width The width of the rectangle.
	 * @param height The height of the rectangle.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Rect(x, y, width, height)
	{
	    this.x = x || 0;
	    this.y = y || 0;
	    this.width = width || 0;
	    this.height = height || 0;
	}

	function ShadowAtlas()
	{
	    this._texture = new Texture2D();
	    // TODO: Allow mips for VSM/ESM
	    this._depthBuffer = new WriteOnlyDepthBuffer();
	    this._fbo = new FrameBuffer(this._texture, this._depthBuffer);

	    if (META.OPTIONS.shadowFilter.blurShader) {
	        this._fboNoDepth = new FrameBuffer(this._texture, null);
	        this._texture2 = new Texture2D();
	        this._fbo2 = new FrameBuffer(this._texture2, null);
	    }
	}

	ShadowAtlas.prototype =
	{
	    get fbo() { return this._fbo; },
	    get texture() { return this._texture; },

	    get size() { return this._size; },

	    resize: function(size)
	    {
	        if (this._size === size) return;
	        this._size = size;
	        this._texture.initEmpty(size, size, META.OPTIONS.shadowFilter.getShadowMapFormat(), META.OPTIONS.shadowFilter.getShadowMapDataType());
	        this._texture.filter = META.OPTIONS.shadowFilter.shadowMapFilter;
	        if (this._texture.filter !== TextureFilter.NEAREST_NOMIP && this._texture.filter !== TextureFilter.BILINEAR_NOMIP) {
	            // We can't use mipmap filtering because it's an *atlas*
	            throw new Error("ShadowAtlas does not support mipmaps!");
	        }
	        this._depthBuffer.init(size, size, false);
	        this._fbo.init();

	        if (this._texture2) {
	            this._texture2.initEmpty(size, size, META.OPTIONS.shadowFilter.getShadowMapFormat(), META.OPTIONS.shadowFilter.getShadowMapDataType());
	            this._texture2.filter = TextureFilter.NEAREST_NOMIP;
	            this._fboNoDepth.init();
	            this._fbo2.init();
	        }
	    },

	    // this is called while rendering shadow maps
	    // it's required that the lights are ordered according to their quality bucket
	    getNextRect: function()
	    {
	        return this._rects[this._currentRectIndex++];
	    },

	    /**
	     * mapsPerLevel is an array containing the count per quality levels
	     * totalMaps is the total amount of maps required
	     */
	    initRects: function (mapsPerLevel, totalMaps)
	    {
	        this._currentRectIndex = 0;
	        this._rects = [new Rect(0, 0, this._size, this._size)];

	        var numLevels = mapsPerLevel.length;

	        for (var i = 0; i < numLevels; ++i) {
	            var count = mapsPerLevel[i];
	            totalMaps -= count;

	            // this means there's more maps in lower qualities, so we need to generate an extra rect to contain them
	            if (totalMaps > 0)
	                this._divideLast(count + 1, this._rects);
	            else {
	                this._divideLast(count, this._rects);
	                return;
	            }
	        }
	    },

	    blur: function()
	    {
	        var shadowFilter = META.OPTIONS.shadowFilter;
	        var shader = shadowFilter.blurShader;

	        if (!shader) return;

	        this._texture.filter = TextureFilter.NEAREST_NOMIP;

	        var numPasses = shadowFilter.numBlurPasses;

	        for (var i = 0; i < numPasses; ++i) {
	            GL.setRenderTarget(this._fbo2);
	            GL.clear();
	            shader.execute(RectMesh.DEFAULT, this._texture, 1.0 / this._size, 0.0);

	            GL.setRenderTarget(this._fboNoDepth);
	            GL.clear();
	            shader.execute(RectMesh.DEFAULT, this._texture2, 0.0, 1.0 / this._size);
	        }

	        this._texture.filter = shadowFilter.shadowMapFilter;
	    },

	    _divideLast: function(count, flatList)
	    {
	        // No need to divide if the current quality level has none (but lower do)
	        if (count <= 1) return;

	        var parentRect = flatList[flatList.length - 1];
	        // try to get as many horizontal as vertical, or near enough
	        var numX = Math.floor(Math.sqrt(count));
	        var numY = Math.ceil(count / numX);
	        var baseX = parentRect.x;
	        var baseY = parentRect.y;
	        var w = parentRect.width / numX;
	        var h = parentRect.height / numY;
	        var i = 0;

	        // TODO: Should we make sure we don't dig below a certain level to prevent degenerate maps?

	        for (var y = 0; y < numY; ++y) {
	            for (var x = 0; x < numX; ++x) {
	                var rect;

	                if (parentRect) {
	                    // re-use parentRect instead of throwing it away
	                    rect = parentRect;
	                    parentRect = null;
	                }
	                else {
	                    // pool these rects?
	                    rect = new Rect();
	                    flatList.push(rect);
	                }

	                rect.x = baseX + x * w;
	                rect.y = baseY + y * h;
	                rect.width = w;
	                rect.height = h;

	                if (++i === count) return rect;
	            }
	        }
	    }
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function CascadeShadowCasterCollector()
	{
	    SceneVisitor.call(this);
	    this._renderCameras = null;
	    this._cameraYAxis = new Float4();
	    this._bounds = new BoundingAABB();
	    this._cullPlanes = null;
	    this._numCullPlanes = 0;
	    this._renderList = [];
	    this._renderItemPool = new ObjectPool(RenderItem);
	}

	CascadeShadowCasterCollector.prototype = Object.create(SceneVisitor.prototype);

	CascadeShadowCasterCollector.prototype.getRenderList = function(index) { return this._renderList[index]; };

	CascadeShadowCasterCollector.prototype.collect = function(camera, scene)
	{
	    this._collectorCamera = camera;
	    camera.worldMatrix.getColumn(1, this._cameraYAxis);
	    this._bounds.clear();
	    this._renderItemPool.reset();

	    var numCascades = META.OPTIONS.numShadowCascades;
	    for (var i = 0; i < numCascades; ++i) {
	        this._renderList[i] = [];
	    }

	    scene.acceptVisitor(this);

	    for (i = 0; i < numCascades; ++i)
	        this._renderList[i].sort(RenderSortFunctions.sortOpaques);
	};

	CascadeShadowCasterCollector.prototype.getBounds = function()
	{
	    return this._bounds;
	};

	CascadeShadowCasterCollector.prototype.setRenderCameras = function(cameras)
	{
	    this._renderCameras = cameras;
	};

	CascadeShadowCasterCollector.prototype.setCullPlanes = function(cullPlanes, numPlanes)
	{
	    this._cullPlanes = cullPlanes;
	    this._numCullPlanes = numPlanes;
	};

	CascadeShadowCasterCollector.prototype.visitMeshInstance = function (meshInstance)
	{
	    if (!meshInstance._castShadows || !meshInstance.enabled) return;

	    var skeleton = meshInstance.skeleton;
		var skeletonMatrices = meshInstance.skeletonMatrices;
	    var entity = meshInstance._entity;
	    var worldBounds = entity.worldBounds;
	    this._bounds.growToIncludeBound(worldBounds);

	    var passIndex = MaterialPass.DIR_LIGHT_SHADOW_MAP_PASS;
	    var numCascades = META.OPTIONS.numShadowCascades;    var cameraYAxis = this._cameraYAxis;
	    var cameraY_X = cameraYAxis.x, cameraY_Y = cameraYAxis.y, cameraY_Z = cameraYAxis.z;

	    for (var cascade = 0; cascade < numCascades; ++cascade) {
	        var renderList = this._renderList[cascade];
	        var renderCamera = this._renderCameras[cascade];

	        var contained = worldBounds.intersectsConvexSolid(renderCamera.frustum.planes, 4);

	        if (contained) {
	            var material = meshInstance.material;

	            if (material.hasPass(passIndex)) {
	                var renderItem = this._renderItemPool.getItem();
	                renderItem.pass = material.getPass(passIndex);
	                renderItem.meshInstance = meshInstance;
	                renderItem.worldMatrix = entity.worldMatrix;
	                renderItem.material = material;
	                renderItem.skeleton = skeleton;
	                renderItem.skeletonMatrices = skeletonMatrices;
	                var center = worldBounds._center;
	                renderItem.renderOrderHint = center.x * cameraY_X + center.y * cameraY_Y + center.z * cameraY_Z;

	                renderList.push(renderItem);
	            }
	        }
	    }
	};

	CascadeShadowCasterCollector.prototype.qualifies = function(object)
	{
	        return object.hierarchyVisible && object.worldBounds.intersectsConvexSolid(this._cullPlanes, this._numCullPlanes);
	};

	/**
	 * @ignore
	 * @param light
	 * @param shadowMapSize
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function CascadeShadowMapRenderer()
	{
	    this._inverseLightMatrix = new Matrix4x4();
	    this._shadowMapCameras = null;
	    this._collectorCamera = new OrthographicOffCenterCamera();
	    this._maxY = 0;
	    this._numCullPlanes = 0;
	    this._cullPlanes = [];
	    this._localBounds = new BoundingAABB();
	    this._casterCollector = new CascadeShadowCasterCollector();

	    this._initCameras();
	}

	CascadeShadowMapRenderer.prototype =
	{
	    render: function(light, atlas, viewCamera, scene)
	    {
	        this._inverseLightMatrix.inverseAffineOf(light.entity.worldMatrix);
	        this._updateCollectorCamera(light, viewCamera);
	        this._updateSplits(light, viewCamera);
	        this._updateCullPlanes(light, viewCamera);
	        this._collectShadowCasters(scene);
	        this._updateCascadeCameras(light, atlas, viewCamera, this._casterCollector.getBounds());

	        var passType = MaterialPass.DIR_LIGHT_SHADOW_MAP_PASS;
	        var numCascades = META.OPTIONS.numShadowCascades;

	        var atlasSize = 1.0 / atlas.size;

	        for (var c = 0; c < numCascades; ++c) {
	            var rect = atlas.getNextRect();
	            GL.setViewport(rect);

	            var m = light._shadowMatrices[c];
	            var camera = this._shadowMapCameras[c];
	            m.copyFrom(camera.viewProjectionMatrix);

	            // can probably optimize all the calls above into a simpler multiplication/translation
	            // TODO: Do the math

	            // transform [-1, 1] to [0 - 1] (also for Z)
	            m.appendScale(.5);
	            m.appendTranslation(.5, .5, .5);
	            // transform to tiled size
	            m.appendScale(rect.width * atlasSize, rect.height * atlasSize, 1.0);
	            m.appendTranslation(rect.x * atlasSize, rect.y * atlasSize, 0.0);

	            RenderUtils.renderPass(this, camera, passType, this._casterCollector.getRenderList(c));
	        }
	    },

	    _updateCollectorCamera: function(light, viewCamera)
	    {
	        var corners = viewCamera.frustum._corners;
	        var min = new Float4();
	        var max = new Float4();
	        var tmp = new Float4();

	        this._inverseLightMatrix.transformPoint(corners[0], min);
	        max.copyFrom(min);

	        for (var i = 1; i < 8; ++i) {
	            this._inverseLightMatrix.transformPoint(corners[i], tmp);
	            min.minimize(tmp);
	            max.maximize(tmp);
	        }

	        this._maxY = max.y;

	        this._collectorCamera.matrix.copyFrom(light.entity.worldMatrix);
	        this._collectorCamera._invalidateWorldMatrix();
	        this._collectorCamera.setBounds(min.x, max.x + 1, max.z + 1, min.z);
	    },

	    _updateSplits: function(light, viewCamera)
	    {
	        var nearDist = viewCamera.nearDistance;
	        var frustumRange = viewCamera.farDistance - nearDist;
	        var numCascades = META.OPTIONS.numShadowCascades;
	        var dists = light._cascadeSplitDistances;
	        var ratios = light._cascadeSplitRatios;

	        for (var i = 0; i < numCascades; ++i) {
	            dists[i] = nearDist + ratios[i] * frustumRange;
	        }
	    },

	    _updateCascadeCameras: function(light, atlas, viewCamera, bounds)
	    {
	        this._localBounds.transformFrom(bounds, this._inverseLightMatrix);

	        var minBound = this._localBounds.minimum;
	        var maxBound = this._localBounds.maximum;

	        var scaleSnap = 1.0;	// always scale snap to a meter

	        var localNear = new Float4();
	        var localFar = new Float4();
	        var min = new Float4();
	        var max = new Float4();

	        var corners = viewCamera.frustum.corners;

	        // camera distances are suboptimal? need to constrain to local near too?

	        var nearRatio = 0;
	        var numCascades = META.OPTIONS.numShadowCascades;
	        for (var cascade = 0; cascade < numCascades; ++cascade) {
	            var farRatio = light._cascadeSplitRatios[cascade];
	            var camera = this._shadowMapCameras[cascade];

	            camera.matrix = light.entity.worldMatrix;

	            // figure out frustum bound
	            for (var i = 0; i < 4; ++i) {
	                var nearCorner = corners[i];
	                var farCorner = corners[i + 4];

	                var nx = nearCorner.x;
	                var ny = nearCorner.y;
	                var nz = nearCorner.z;
	                var dx = farCorner.x - nx;
	                var dy = farCorner.y - ny;
	                var dz = farCorner.z - nz;
	                localNear.x = nx + dx*nearRatio;
	                localNear.y = ny + dy*nearRatio;
	                localNear.z = nz + dz*nearRatio;
	                localFar.x = nx + dx*farRatio;
	                localFar.y = ny + dy*farRatio;
	                localFar.z = nz + dz*farRatio;

	                this._inverseLightMatrix.transformPoint(localNear, localNear);
	                this._inverseLightMatrix.transformPoint(localFar, localFar);

	                if (i === 0) {
	                    min.copyFrom(localNear);
	                    max.copyFrom(localNear);
	                }
	                else {
	                    min.minimize(localNear);
	                    max.maximize(localNear);
	                }

	                min.minimize(localFar);
	                max.maximize(localFar);
	            }

	            nearRatio = farRatio;

	            // do not render beyond range of view camera or scene depth
	            max.y = Math.min(this._maxY, max.y);

	            var left = Math.max(min.x, minBound.x);
	            var right = Math.min(max.x, maxBound.x);
	            var bottom = Math.max(min.z, minBound.z);
	            var top = Math.min(max.z, maxBound.z);

	            var width = right - left;
	            var height = top - bottom;

	            width = Math.ceil(width / scaleSnap) * scaleSnap;
	            height = Math.ceil(height / scaleSnap) * scaleSnap;
	            width = Math.max(width, scaleSnap);
	            height = Math.max(height, scaleSnap);

	            // snap to pixels
	            var offsetSnapH = atlas.size / width * .5;
	            var offsetSnapV = atlas.size / height * .5;

	            left = Math.floor(left * offsetSnapH) / offsetSnapH;
	            bottom = Math.floor(bottom * offsetSnapV) / offsetSnapV;
	            right = left + width;
	            top = bottom + height;

	            var softness = META.OPTIONS.shadowFilter.softness ? META.OPTIONS.shadowFilter.softness : .002;

	            camera.setBounds(left - softness, right + softness, top + softness, bottom - softness);

	            // cannot clip nearDistance to frustum, because casters in front may cast into this frustum
	            camera.nearDistance = minBound.y;
	            camera.farDistance = max.y;
	        }
	    },

	    _updateCullPlanes: function(light, viewCamera)
	    {
	        var frustum = this._collectorCamera.frustum;
	        var planes = frustum._planes;

	        for (var i = 0; i < 4; ++i)
	            this._cullPlanes[i] = planes[i];

	        this._numCullPlanes = 4;

	        frustum = viewCamera.frustum;
	        planes = frustum._planes;

	        var dir = light.direction;

	        for (var j = 0; j < 6; ++j) {
	            var plane = planes[j];

	            // view frustum planes facing away from the light direction mark a boundary beyond which no shadows need to be known
	            if (plane.dot3(dir) > 0.001)
	                this._cullPlanes[this._numCullPlanes++] = plane;
	        }
	    },

	    _collectShadowCasters: function(scene)
	    {
	        this._casterCollector.setCullPlanes(this._cullPlanes, this._numCullPlanes);
	        this._casterCollector.setRenderCameras(this._shadowMapCameras);
	        this._casterCollector.collect(this._collectorCamera, scene);
	    },

	    _initCameras: function()
	    {
	        this._shadowMapCameras = [];
	        for (var i = 0; i < META.OPTIONS.numShadowCascades; ++i)
	        {
	            this._shadowMapCameras[i] = new OrthographicOffCenterCamera();
	        }
	    }
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function OmniShadowCasterCollector()
	{
	    SceneVisitor.call(this);
	    this._lightBounds = null;
	    this._renderLists = [];
	    this._renderItemPool = new ObjectPool(RenderItem);
	    this._octantPlanes = [];
	    this._cameraPos = null;

	    this._octantPlanes[0] = new Float4(0.0, 1.0, -1.0, 0.0);
	    this._octantPlanes[1] = new Float4(1.0, 0.0, -1.0, 0.0);
	    this._octantPlanes[2] = new Float4(-1.0, 0.0, -1.0, 0.0);
	    this._octantPlanes[3] = new Float4(0.0, -1.0, -1.0, 0.0);
	    this._octantPlanes[4] = new Float4(1.0, 1.0, 0.0, 0.0);
	    this._octantPlanes[5] = new Float4(-1.0, 1.0, 0.0, 0.0);

	    for (var i = 0; i < 6; ++i) {
	        this._octantPlanes[i].normalize();
	    }
	}

	OmniShadowCasterCollector.prototype = Object.create(SceneVisitor.prototype);

	OmniShadowCasterCollector.prototype.getRenderList = function(faceIndex) { return this._renderLists[faceIndex]; };

	OmniShadowCasterCollector.prototype.setLightBounds = function(value)
	{
	    this._lightBounds = value;
	};

	OmniShadowCasterCollector.prototype.collect = function(cameras, scene)
	{
	    this._cameras = cameras;
	    this._renderLists = [];

	    var pos = this._cameraPos = cameras[0].position;

	    for (var i = 0; i < 6; ++i) {
	        var plane = this._octantPlanes[i];
	        plane.w = -(pos.x * plane.x + pos.y * plane.y + pos.z * plane.z);
	        this._renderLists[i] = [];
	    }

	    this._renderItemPool.reset();

	    scene.acceptVisitor(this);

	    for (i = 0; i < 6; ++i)
	        this._renderLists[i].sort(RenderSortFunctions.sortOpaques);
	};

	OmniShadowCasterCollector.prototype.visitMeshInstance = function (meshInstance)
	{
		if (!meshInstance._castShadows || !meshInstance.enabled) return;

		var entity = meshInstance.entity;
		var worldBounds = entity.worldBounds;
		var worldMatrix = entity.worldMatrix;
	    // basically, this does 6 frustum tests at once
	    var planes = this._octantPlanes;
	    var side0 = worldBounds.classifyAgainstPlane(planes[0]);
	    var side1 = worldBounds.classifyAgainstPlane(planes[1]);
	    var side2 = worldBounds.classifyAgainstPlane(planes[2]);
	    var side3 = worldBounds.classifyAgainstPlane(planes[3]);
	    var side4 = worldBounds.classifyAgainstPlane(planes[4]);
	    var side5 = worldBounds.classifyAgainstPlane(planes[5]);

	    if (side1 >= 0 && side2 <= 0 && side4 >= 0 && side5 <= 0)
	        this._addTo(meshInstance, 0, worldBounds, worldMatrix);

	    if (side1 <= 0 && side2 >= 0 && side4 <= 0 && side5 >= 0)
	        this._addTo(meshInstance, 1, worldBounds, worldMatrix);

	    if (side0 >= 0 && side3 <= 0 && side4 >= 0 && side5 >= 0)
	        this._addTo(meshInstance, 2, worldBounds, worldMatrix);

	    if (side0 <= 0 && side3 >= 0 && side4 <= 0 && side5 <= 0)
	        this._addTo(meshInstance, 3, worldBounds, worldMatrix);

	    if (side0 <= 0 && side1 <= 0 && side2 <= 0 && side3 <= 0)
	        this._addTo(meshInstance, 4, worldBounds, worldMatrix);

	    if (side0 >= 0 && side1 >= 0 && side2 >= 0 && side3 >= 0)
	        this._addTo(meshInstance, 5, worldBounds, worldMatrix);
	};

	OmniShadowCasterCollector.prototype._addTo = function(meshInstance, cubeFace, worldBounds, worldMatrix)
	{
	    var skeleton = meshInstance.skeleton;
	    var skeletonMatrices = meshInstance.skeletonMatrices;
	    var renderPool = this._renderItemPool;
	    var camPos = this._cameraPos;
	    var camPosX = camPos.x, camPosY = camPos.y, camPosZ = camPos.z;
	    var renderList = this._renderLists[cubeFace];
	    var camera = this._cameras[cubeFace];

	    var material = meshInstance.material;

	    var renderItem = renderPool.getItem();

	    renderItem.material = material;
	    renderItem.meshInstance = meshInstance;
	    renderItem.skeleton = skeleton;
	    renderItem.skeletonMatrices = skeletonMatrices;
	    var center = worldBounds._center;
	    var dx = camPosX - center.x;
	    var dy = camPosY - center.y;
	    var dz = camPosZ - center.z;
	    renderItem.renderOrderHint = dx * dx + dy * dy + dz * dz;
	    renderItem.worldMatrix = worldMatrix;
	    renderItem.worldBounds = worldBounds;

	    renderList.push(renderItem);
	};

	OmniShadowCasterCollector.prototype.qualifies = function(object)
	{
	    // for now, only interested if it intersects the point light volume at all
	    return object.hierarchyVisible && object.worldBounds.intersectsBound(this._lightBounds);
	};

	/**
	 * @ignore
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function OmniShadowMapRenderer()
	{
	    this._casterCollector = new OmniShadowCasterCollector();
	    this._scene = null;

	    this._initFaces();

	}

	OmniShadowMapRenderer.prototype =
	{
	    render: function (light, atlas, viewCamera, scene) {
	        var pos = new Float4();
	        return function(light, atlas, viewCamera, scene)
	        {
	            var entity = light.entity;
	            entity.worldMatrix.getColumn(3, pos);

	            for (var i = 0; i < 6; ++i) {
	                var cam = this._cameras[i];
	                var radius = light._radius;
	                cam.farDistance = radius;
	                cam.position.copyFrom(pos);
	            }

	            this._casterCollector.setLightBounds(entity.worldBounds);
	            this._casterCollector.collect(this._cameras, scene);

	            GL.setInvertCulling(true);

	            var atlasSize = 1.0 / atlas.size;

	            for (i = 0; i < 6; ++i) {
	                var rect = atlas.getNextRect();
	                var camera = this._cameras[i];
	                GL.setViewport(rect);

	                var sx = rect.width * atlasSize;
	                var sy = rect.height * atlasSize;
	                var tx = rect.x * atlasSize;
	                var ty = rect.y * atlasSize;

	                light._shadowTiles[i].set(.5 * sx, .5 * sy, .5 * sx + tx, .5 * sy + ty);

	                RenderUtils.renderPass(this, camera, MaterialPass.POINT_LIGHT_SHADOW_MAP_PASS, this._casterCollector.getRenderList(i), light);
	            }

	            GL.setInvertCulling(false);

	            GL.setColorMask(true);
	        }
	    }(),

	    _initFaces: function()
	    {
	        this._cameras = [];

	        var flipY = new Quaternion();
	        flipY.fromAxisAngle(Float4.Z_AXIS, Math.PI);

	        var rotations = [];
	        for (var i = 0; i < 6; ++i)
	            rotations[i] = new Quaternion();

	        rotations[0].fromAxisAngle(Float4.Z_AXIS, -Math.PI * .5);
	        rotations[1].fromAxisAngle(Float4.Z_AXIS, Math.PI * .5);
	        rotations[2].fromAxisAngle(Float4.Z_AXIS, 0);
	        rotations[3].fromAxisAngle(Float4.Z_AXIS, Math.PI);
	        rotations[4].fromAxisAngle(Float4.X_AXIS, Math.PI * .5);
	        rotations[5].fromAxisAngle(Float4.X_AXIS, -Math.PI * .5);

	        for (i = 0; i < 6; ++i) {
	            var camera = new PerspectiveCamera();
	            camera.nearDistance = 0.01;
	            camera.verticalFOV = Math.PI * .5;
	            camera.rotation.copyFrom(rotations[i]);
	            camera.scale.set(1, 1, -1);
	            this._cameras.push(camera);
	        }
	    }
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SpotShadowCasterCollector()
	{
	    SceneVisitor.call(this);
	    this._frustumPlanes = null;
	    this._renderList = [];
	    this._renderItemPool = new ObjectPool(RenderItem);
	    this._cameraYAxis = new Float4();
	}
	SpotShadowCasterCollector.prototype = Object.create(SceneVisitor.prototype);

	SpotShadowCasterCollector.prototype.getRenderList = function() { return this._renderList; };

	SpotShadowCasterCollector.prototype.collect = function(camera, scene)
	{
	    this._camera = camera;
	    this._renderList = [];
	    camera.worldMatrix.getColumn(1, this._cameraYAxis);
	    this._frustumPlanes = camera.frustum._planes;
	    this._renderItemPool.reset();

	    scene.acceptVisitor(this);

	    this._renderList.sort(RenderSortFunctions.sortOpaques);
	};

	SpotShadowCasterCollector.prototype.visitMeshInstance = function (meshInstance)
	{
	    if (!meshInstance._castShadows || !meshInstance.enabled) return;

	    var entity = meshInstance.entity;
	    var worldBounds = entity.worldBounds;
	    var cameraYAxis = this._cameraYAxis;
	    var cameraY_X = cameraYAxis.x, cameraY_Y = cameraYAxis.y, cameraY_Z = cameraYAxis.z;
	    var skeleton = meshInstance.skeleton;
	    var skeletonMatrices = meshInstance.skeletonMatrices;
	    var renderPool = this._renderItemPool;
	    var camera = this._camera;
	    var renderList = this._renderList;

	    var material = meshInstance.material;

	    var renderItem = renderPool.getItem();

	    renderItem.material = material;
	    renderItem.meshInstance = meshInstance;
	    renderItem.skeleton = skeleton;
	    renderItem.skeletonMatrices = skeletonMatrices;
	    // distance along Z axis:
	    var center = worldBounds._center;
	    renderItem.renderOrderHint = center.x * cameraY_X + center.y * cameraY_Y + center.z * cameraY_Z;
	    renderItem.worldMatrix = entity.worldMatrix;
	    renderItem.worldBounds = worldBounds;

	    renderList.push(renderItem);
	};

	SpotShadowCasterCollector.prototype.qualifies = function(object)
	{
	    return object.visible && object.worldBounds.intersectsConvexSolid(this._frustumPlanes, 6);
	};

	/**
	 * @ignore
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SpotShadowMapRenderer()
	{
		this._casterCollector = new SpotShadowCasterCollector();

		this._camera = new PerspectiveCamera();
		this._camera.nearDistance = .01;
	}

	SpotShadowMapRenderer.prototype =
		{
			render: function (light, atlas, viewCamera, scene)
			{
				this._camera.verticalFOV = light.outerAngle;
				this._camera.farDistance = light._radius;
				this._camera.matrix.copyFrom(light.entity.worldMatrix);
				this._camera._invalidateWorldMatrix();

				this._casterCollector.collect(this._camera, scene);

				var rect = atlas.getNextRect();
				var atlasSize = 1.0 / atlas.size;

				GL.setViewport(rect);

				var m = light.shadowMatrix;
				m.copyFrom(this._camera.viewProjectionMatrix);

				// also includes NDC [-1, 1] -> UV [0, 1]
				var sx = rect.width * atlasSize;
				var sy = rect.height * atlasSize;
				var tx = rect.x * atlasSize;
				var ty = rect.y * atlasSize;
				light._shadowTile.set(.5 * sx, .5 * sy, .5 * sx + tx, .5 * sy + ty);

				RenderUtils.renderPass(this, this._camera, MaterialPass.POINT_LIGHT_SHADOW_MAP_PASS, this._casterCollector.getRenderList(), light);
			}
		};

	/**
	 * @classdesc
	 * Renderer performs the actual rendering of a {@linkcode Scene} as viewed by a {@linkcode Camera} to the screen.
	 *
	 * @param {RenderTarget} [renderTarget] An optional render target for the Renderer to draw to.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function Renderer(renderTarget)
	{
	    this._renderTarget = renderTarget || null;
	    this._width = 0;
	    this._height = 0;

	    this._depthPrepass = false;
	    this._gammaApplied = false;

	    this._copyTextureShader = new CopyChannelsShader("xyzw", true);
	    this._applyGamma = new ApplyGammaShader();

	    this._camera = null;
	    this._activeCamera = null;
	    this._scene = null;
	    this._depthBuffer = this._createDepthBuffer();
	    this._hdrBack = new Renderer.HDRBuffers(this._depthBuffer);
	    this._hdrFront = new Renderer.HDRBuffers(this._depthBuffer);
	    this._renderCollector = new RenderCollector();
	    this._normalDepthBuffer = new Texture2D();
	    this._normalDepthBuffer.filter = TextureFilter.BILINEAR_NOMIP;
	    this._normalDepthBuffer.wrapMode = TextureWrapMode.CLAMP;
	    this._normalDepthFBO = new FrameBuffer(this._normalDepthBuffer, this._depthBuffer);

	    this._backgroundColor = Color.BLACK.clone();
	    //this._previousViewProjection = new Matrix4x4();
	    this._debugMode = Renderer.DebugMode.NONE;
	    this._ssaoTexture = null;

	    this._cascadeShadowRenderer = new CascadeShadowMapRenderer();
	    this._omniShadowRenderer = new OmniShadowMapRenderer();
	    this._spotShadowRenderer = new SpotShadowMapRenderer();
	    this._shadowAtlas = new ShadowAtlas(!!META.OPTIONS.shadowFilter.blurShader);
	    this._shadowAtlas.resize(2048, 2048);

	    if (capabilities.WEBGL_2) {
			var size = 16 + META.OPTIONS.maxDirLights * 320 + META.OPTIONS.maxLightProbes * 16 + META.OPTIONS.maxPointSpotLights * 224;
			this._diffuseProbeArray = [];
			this._specularProbeArray = [];
			this._lightingUniformBuffer = new UniformBuffer(size);
			this._lightingDataView = new DataView(new ArrayBuffer(size));
			// these will contain all the indices into the light buffer
	        // reserve space for every cell AND the count inside them!
			this._numCells = META.OPTIONS.numLightingCellsX * META.OPTIONS.numLightingCellsY;
			this._cellStride = META.OPTIONS.maxPointSpotLights + 1;

			// this throws errors
			this._lightingCellsUniformBuffer = new UniformBuffer(this._numCells * this._cellStride * 4);
			this._cellData = new Int32Array(this._numCells * this._cellStride);

			for (var i = 0; i < size; ++i)
			    this._lightingDataView.setInt8(i, 0);

			// if we want to test the layout of the uniform buffer as defined in the shader:
			/*var material = new BasicMaterial({ lightingModel: LightingModel.GGX });
			var pass = material.getPass(MaterialPass.BASE_PASS);
			this._lightingUniformBuffer = pass.createUniformBufferFromShader("hx_lights");
			this._lightingCellsUniformBuffer = pass.createUniformBufferFromShader("hx_lightingCells");
			console.log(this._lightingCellsUniformBuffer);*/
	    }
	}

	/**
	 * A collection of debug render modes to inspect some steps in the render pipeline.
	 * @enum
	 */
	Renderer.DebugMode = {
	    NONE: 0,
	    SSAO: 1,
	    NORMAL_DEPTH: 2,
	    SHADOW_MAP: 3
	};

	/**
	 * @ignore
	 */
	Renderer.HDRBuffers = function(depthBuffer)
	{
	    this.texture = new Texture2D();
	    this.texture.filter = TextureFilter.BILINEAR_NOMIP;
	    this.texture.wrapMode = TextureWrapMode.CLAMP;
	    this.fbo = new FrameBuffer(this.texture);
	    this.fboDepth = new FrameBuffer(this.texture, depthBuffer);
	};

	Renderer.HDRBuffers.prototype =
	{
	    resize: function(width, height)
	    {
	        this.texture.initEmpty(width, height, TextureFormat.RGBA, capabilities.HDR_FORMAT);
	        this.fbo.init();
	        this.fboDepth.init();
	    }
	};

	Renderer.prototype =
	{
	    /**
	     * One of {Renderer.DebugMode}
	     */
	    get debugMode()
	    {
	        return this._debugMode;
	    },

	    set debugMode(value)
	    {
	        this._debugMode = value;
	    },

	    /**
	     * The size of the shadow atlas texture.
	     */
	    get shadowMapSize()
	    {
	        return this._shadowAtlas.width;
	    },

	    set shadowMapSize(value)
	    {
	        this._shadowAtlas.resize(value, value);
	    },

	    /**
	     * Defines whether or not a depth pre-pass needs to be performed when rendering. This may improve rendering by
	     * spending less time calculating lighting on invisible fragments.
	     */
	    get depthPrepass()
	    {
	        return this._depthPrepass;
	    },

	    set depthPrepass(value)
	    {
	        this._depthPrepass = value;
	    },

	    get renderTarget()
	    {
	        return this._renderTarget;
	    },

	    set renderTarget(value)
	    {
	        this._renderTarget = value;
	    },

	    /**
	     * The background {@linkcode Color}.
	     */
	    get backgroundColor()
	    {
	        return this._backgroundColor;
	    },

	    set backgroundColor(value)
	    {
	        if (value instanceof Color)
	            this._backgroundColor.copyFrom(value);
	        else
	            this._backgroundColor.set(value);
	    },

	    /**
	     * The Camera currently being used for rendering.
	     */
	    get camera()
	    {
	        return this._camera;
	    },

	    /**
	     * Renders the scene through a camera.
	     * It's not recommended changing render targets if they have different sizes (so splitscreen should be fine). Otherwise, use different renderer instances.
	     * @param camera The {@linkcode Camera} from which to view the scene.
	     * @param scene The {@linkcode Scene} to render.
	     * @param dt The milliseconds passed since last frame.
	     */
	    render: function (camera, scene, dt)
	    {
	        this._camera = camera;
	        this._scene = scene;

	        this._updateSize(this._renderTarget);
	        camera._setRenderTargetResolution(this._width, this._height);

	        this._renderCollector.collect(camera, scene);

	        this._ambientColor = this._renderCollector._ambientColor;

	        this._renderShadowCasters();

	        this._renderView(camera, scene, dt);

	        this._renderToScreen();

	        GL.setBlendState();
	        GL.setDepthMask(true);
	    },

	    _renderView: function(camera, scene, dt)
	    {
	        this._gammaApplied = false;
	        this._activeCamera = camera;
	        this._scene = scene;

	        if (capabilities.WEBGL_2)
	            camera._updateClusterPlanes();

	        GL.setDepthMask(true);
	        GL.setColorMask(true);

	        this._renderNormalDepth();
	        this._renderAO();

	        GL.setRenderTarget(this._hdrFront.fboDepth);
	        GL.setClearColor(this._backgroundColor);
	        GL.clear();

	        this._renderDepthPrepass();

	        if (capabilities.WEBGL_2)
	            this._renderClustered();
	        else {
	            this._renderForward();
	        }

	        this._swapHDRFrontAndBack();
	        this._renderEffects(dt);

	        GL.setColorMask(true);

	        // for the future, if we ever need back-projection
	        //this._previousViewProjection.copyFrom(this._camera.viewProjectionMatrix);
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _renderDepthPrepass: function ()
	    {
	        if (!this._depthPrepass) return;

	        GL.lockColorMask(false);
	        RenderUtils.renderPass(this, this._activeCamera, MaterialPass.NORMAL_DEPTH_PASS, this._renderCollector.getOpaqueRenderList(RenderPath.FORWARD_FIXED));
	        RenderUtils.renderPass(this, this._activeCamera, MaterialPass.NORMAL_DEPTH_PASS, this._renderCollector.getOpaqueRenderList(RenderPath.FORWARD_DYNAMIC));
	        GL.unlockColorMask(true);
	    },

	    _renderClustered: function()
	    {
	        var lights = this._renderCollector.getLights();
	        var numLights = lights.length;
	        var data = this._lightingDataView;
	        var cells = this._cellData;
	        var camera = this._camera;
	        var maxDirLights = META.OPTIONS.maxDirLights, maxProbes = META.OPTIONS.maxLightProbes, maxPoints = META.OPTIONS.maxPointSpotLights;
			var dirLightStride = 320, probeStride = 16, pointStride = 224;
			var dirLightOffset = 16;
			var probeOffset = maxDirLights * dirLightStride + dirLightOffset;
			var pointOffset = maxProbes * probeStride + probeOffset;
	        var numDirLights = 0, numPointLights = 0, numProbes = 0;
	        var numCells = META.OPTIONS.numLightingCellsX * META.OPTIONS.numLightingCellsY;
	        var cellStride = this._cellStride;
	        var i;

	        for (i = 0; i < numCells; ++i) {
	            // reset light counts to 0
				cells[i * cellStride] = 0;
			}

	        for (i = 0; i < maxProbes; ++i) {
	            this._diffuseProbeArray[i] = TextureCube.DEFAULT;
	            this._specularProbeArray[i] = TextureCube.DEFAULT;
	        }

	        for (i = 0; i < numLights; ++i) {
	            var light = lights[i];

	            if (light instanceof DirectionalLight && numDirLights < maxDirLights) {
	                this.writeDirectionalLight(light, camera, data, dirLightOffset);

	                dirLightOffset += dirLightStride;
	                ++numDirLights;
	            }
	            else if (light instanceof LightProbe && numProbes < maxProbes) {
	                this.writeLightProbe(light, data, probeOffset);

	                if (light.diffuseTexture)
	                    this._diffuseProbeArray[numProbes] = light.diffuseTexture;

	                if (light.specularTexture)
	                    this._specularProbeArray[numProbes] = light.specularTexture;

	                probeOffset += probeStride;
	                ++numProbes;
	            }
	            else if (light instanceof PointLight && numPointLights < maxPoints) {
	                this.writePointSpotLight(light, camera, data, pointOffset, false, cells, numPointLights);

	                pointOffset += pointStride;
	                ++numPointLights;
	            }
	            else if (light instanceof SpotLight && numPointLights < maxPoints) {
	                this.writePointSpotLight(light, camera, data, pointOffset, true, cells, numPointLights);

	                pointOffset += pointStride;
	                ++numPointLights;
	            }
	        }

	        data.setInt32(0, numDirLights, true);
	        data.setInt32(4, numProbes, true);
	        data.setInt32(8, numPointLights, true);

	        this._lightingUniformBuffer.uploadData(this._lightingDataView);
	        this._lightingCellsUniformBuffer.uploadData(this._cellData);

	        RenderUtils.renderPass(this, this._activeCamera, MaterialPass.BASE_PASS, this._renderCollector.getOpaqueRenderList(RenderPath.FORWARD_FIXED));
	        RenderUtils.renderPass(this, this._activeCamera, MaterialPass.BASE_PASS, this._renderCollector.getOpaqueRenderList(RenderPath.FORWARD_DYNAMIC));

			if (this._renderCollector.needsBackbuffer)
				this._copyBackbuffer();

	        RenderUtils.renderPass(this, this._activeCamera, MaterialPass.BASE_PASS, this._renderCollector.getTransparentRenderList(RenderPath.FORWARD_FIXED));
	        RenderUtils.renderPass(this, this._activeCamera, MaterialPass.BASE_PASS, this._renderCollector.getTransparentRenderList(RenderPath.FORWARD_DYNAMIC));
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    writePointSpotLight: function(light, camera, target, offset, isSpot, cells, index)
	    {
	        var pos = new Float4();
	        var dir = new Float4();
	        var matrix = new Matrix4x4();
	        return function(light, camera, target, offset, isSpot, cells, index)
	        {
	            var o;
	            var col = light._scaledIrradiance;
	            var lightMatrix = light.entity.worldMatrix;
	            var viewMatrix = camera.viewMatrix;
	            target.setFloat32(offset, col.r, true);
	            target.setFloat32(offset + 4, col.g, true);
	            target.setFloat32(offset + 8, col.b, true);

	            target.setFloat32(offset + 12, light.radius, true);

				lightMatrix.getColumn(3, pos);
				viewMatrix.transformPoint(pos, pos);
	            target.setFloat32(offset + 16, pos.x, true);
	            target.setFloat32(offset + 20, pos.y, true);
	            target.setFloat32(offset + 24, pos.z, true);

	            target.setFloat32(offset + 28, 1.0 / light.radius, true);

	            if (isSpot) {
					lightMatrix.getColumn(1, dir);
					viewMatrix.transformVector(dir, dir);
					target.setFloat32(offset + 32, dir.x, true);
					target.setFloat32(offset + 36, dir.y, true);
					target.setFloat32(offset + 40, dir.z, true);

	                target.setUint32(offset + 112, 1, true);
	                target.setFloat32(offset + 120, light._cosOuter, true);
	                target.setFloat32(offset + 124, 1.0 / Math.max((light._cosInner - light._cosOuter), .00001), true);
	            }
	            else {
	                target.setUint32(offset + 112, 0, true);
	            }

	            target.setUint32(offset + 116, light.castShadows? 1 : 0, true);

	            if (light.castShadows) {
	                target.setFloat32(offset + 44, light.depthBias, true);

	                var m;

	                if (isSpot) {
	                    matrix.multiply(light._shadowMatrix, camera.worldMatrix);
	                    m = matrix._m;

	                    var tile = light._shadowTile;
	                    target.setFloat32(offset + 128, tile.x, true);
	                    target.setFloat32(offset + 132, tile.y, true);
	                    target.setFloat32(offset + 136, tile.z, true);
	                    target.setFloat32(offset + 140, tile.w, true);
	                }
	                else {
	                    m = camera.worldMatrix._m;

	                    o = offset + 128;
	                    for (var face = 0; face < 6; ++face) {
	                        tile = light._shadowTiles[face];
	                        target.setFloat32(o, tile.x, true);
	                        target.setFloat32(o + 4, tile.y, true);
	                        target.setFloat32(o + 8, tile.z, true);
	                        target.setFloat32(o + 12, tile.w, true);
	                        o += 16;
	                    }
	                }

	                o = offset + 48;

	                for (var l = 0; l < 16; ++l) {
	                    target.setFloat32(o, m[l], true);
	                    o += 4;
	                }

	            }

	            if (isSpot)
					viewMatrix.transformPoint(light.entity.worldBounds.center, pos);

	            this.assignToCells(light, camera, index, pos, cells, isSpot? dir : null);
			}
	    }(),

		assignToCells: function(light, camera, index, viewPos, cells, dir)
	    {
	    	var p = new Float4();
	    	return function(light, camera, index, viewPos, cells, dir) {
				var cellStride = this._cellStride;
				var bounds = light.entity.worldBounds;
				var radius = bounds.getRadius();

				var nx = META.OPTIONS.numLightingCellsX;
				var ny = META.OPTIONS.numLightingCellsY;

				var planesW = camera._clusterPlanesW;
				var planesH = camera._clusterPlanesH;

				// should we project viewPos to NDC to figure out which frustum we're in?
				// then we don't need to calculate all of the above, only until it's considered "outside"
				camera.projectionMatrix.projectPoint(viewPos, p);

				var fX = Math.floor((p.x * .5 + .5) * nx);
				var fY = Math.floor((p.y * .5 + .5) * ny);
				if (fX < 0) fX = 0;
				else if (fX >= nx) fX = nx - 1;
				if (fY < 0) fY = 0;
				else if (fY >= ny) fY = ny - 1;

				// left and right plane distances1
				var minX = fX, maxX = fX;

				for (var x = fX; x >= 0; --x) {
					minX = x;
					if (planesW[x].dot4(viewPos) > radius) break;
				}

				for (x = fX + 1; x < nx; ++x) {
					maxX = x;
					if (-planesW[x + 1].dot4(viewPos) > radius) break;
				}

				var i, pi, c;
				for (var y = fY; y >= 0; --y) {
					for (x = minX; x <= maxX; ++x) {
						// TODO: Another test to check if the nearest corner actually falls inside the sphere
						i = x + y * nx;
						pi = i * cellStride;
						c = ++cells[pi];
						cells[pi + c] = index;
					}

					if (planesH[y].dot4(viewPos) > radius) break;
				}

				for (y = fY + 1; y < ny; ++y) {
					for (x = minX; x <= maxX; ++x) {
						// TODO: Another test to check if the nearest corner actually falls inside the sphere
						i = x + y * nx;
						pi = i * cellStride;
						c = ++cells[pi];
						cells[pi + c] = index;
					}

					if (-planesH[y + 1].dot4(viewPos) > radius) break;
				}
	    	}
	    }(),

	    /**
	     * @ignore
	     * @private
	     */
	    writeLightProbe: function(light, target, offset)
	    {
	        target.setUint32(offset, light.diffuseTexture? 1: 0, true);

	        var specularTex = light.specularTexture;
	        if (specularTex) {
	            target.setUint32(offset + 4, 1, true);
	            var numMips = Math.floor(MathX.log2(specularTex.size));
	            target.setFloat32(offset + 8, numMips, true);
	        }
	        else {
	            target.setUint32(offset + 4, 0, true);
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    writeDirectionalLight: function(light, camera, target, offset)
	    {
	        var dir = new Float4();
	        var matrix = new Matrix4x4();
	        return function(light, camera, target, offset)
	        {
	            var col = light._scaledIrradiance;
	            target.setFloat32(offset, col.r, true);
	            target.setFloat32(offset + 4, col.g, true);
	            target.setFloat32(offset + 8, col.b, true);

	            camera.viewMatrix.transformVector(light.direction, dir);
	            target.setFloat32(offset + 16, dir.x, true);
	            target.setFloat32(offset + 20, dir.y, true);
	            target.setFloat32(offset + 24, dir.z, true);

	            target.setUint32(offset + 28, light.castShadows? 1 : 0, true);

	            if (light.castShadows) {
	                var numCascades = META.OPTIONS.numShadowCascades;
	                var splits = light._cascadeSplitDistances;

	                var m = matrix._m;
	                var o = offset + 32;

	                for (var j = 0; j < numCascades; ++j) {
	                    matrix.multiply(light.getShadowMatrix(j), camera.worldMatrix);

	                    for (var l = 0; l < 16; ++l) {
	                        target.setFloat32(o, m[l], true);
	                        o += 4;
	                    }
	                }

	                target.setFloat32(offset + 288, splits[0], true);
	                target.setFloat32(offset + 292, splits[1], true);
	                target.setFloat32(offset + 296, splits[2], true);
	                target.setFloat32(offset + 300, splits[3], true);
	                target.setFloat32(offset + 304, light.depthBias, true);
	                target.setFloat32(offset + 308, splits[numCascades - 1], true);
	            }
	        }
	    }(),

		/**
		 * @ignore
		 * @private
		 */
		_copyBackbuffer: function()
		{
			GL.setRenderTarget(this._hdrBack.fbo);
			GL.clear();
			this._copyTextureShader.execute(RectMesh.DEFAULT, this._hdrFront.texture);
			GL.setRenderTarget(this._hdrFront.fboDepth);
		},

	    /**
	     * @ignore
	     * @private
	     */
	    _renderForward: function()
	    {
			this._renderForwardOpaque();

			if (this._renderCollector.needsBackbuffer)
				this._copyBackbuffer();

			this._renderForwardTransparent();
		},

		/**
	     * @ignore
	     * @private
	     */
	    _renderForwardOpaque: function()
	    {
	        RenderUtils.renderPass(this, this._activeCamera, MaterialPass.BASE_PASS, this._renderCollector.getOpaqueRenderList(RenderPath.FORWARD_FIXED));

	        var list = this._renderCollector.getOpaqueRenderList(RenderPath.FORWARD_DYNAMIC);
	        if (list.length === 0) return;

	        this._renderOpaqueDynamicMultipass(list);
	    },

	    _renderOpaqueDynamicMultipass: function(list)
	    {
	        RenderUtils.renderPass(this, this._activeCamera, MaterialPass.BASE_PASS, list);

	        var lights = this._renderCollector.getLights();
	        var numLights = lights.length;

	        for (var i = 0; i < numLights; ++i) {
	            var light = lights[i];

	            // I don't like type checking, but lighting support is such a core thing...
	            // maybe we can work in a more plug-in like light system
	            if (light instanceof LightProbe) {
	                RenderUtils.renderPass(this, this._activeCamera, MaterialPass.LIGHT_PROBE_PASS, list, light);
	            }
	            else if (light instanceof DirectionalLight) {
	                // PASS IN LIGHT AS DATA, so the material can update it
	                RenderUtils.renderPass(this, this._activeCamera, MaterialPass.DIR_LIGHT_PASS, list, light);
	            }
	            else if (light instanceof PointLight) {
	                // cannot just use renderPass, need to do intersection tests
	                this._renderLightPassIfIntersects(light, MaterialPass.POINT_LIGHT_PASS, list);
	            }
	            else if (light instanceof SpotLight) {
	                this._renderLightPassIfIntersects(light, MaterialPass.SPOT_LIGHT_PASS, list);
	            }
	        }
	    },

	    _renderForwardTransparent: function()
	    {
	        var lights = this._renderCollector.getLights();
	        var numLights = lights.length;

	        var list = this._renderCollector.getTransparentRenderList();

	        // transparents need to be rendered one-by-one, not light by light
	        var numItems = list.length;
	        for (var r = 0; r < numItems; ++r) {

	            var renderItem = list[r];

	            this._renderSingleItemSingleLight(MaterialPass.BASE_PASS, renderItem);

	            var material = renderItem.material;

	            // these won't have the correct pass
	            if (material._renderPath !== RenderPath.FORWARD_DYNAMIC) continue;

	            for (var i = 0; i < numLights; ++i) {
	                var light = lights[i];

	                // I don't like type checking, but lighting support is such a core thing...
	                // maybe we can work in a more plug-in like light system
	                if (light instanceof LightProbe) {
	                    this._renderSingleItemSingleLight(MaterialPass.LIGHT_PROBE_PASS, renderItem, light);
	                }
	                else if (light instanceof DirectionalLight) {
	                    // if non-global, do intersection tests
	                    var passType = light.castShadows? MaterialPass.DIR_LIGHT_SHADOW_PASS : MaterialPass.DIR_LIGHT_PASS;
	                    this._renderSingleItemSingleLight(passType, renderItem, light);
	                }
	                else if (light instanceof PointLight) {
	                    // cannot just use renderPass, need to do intersection tests
	                    this._renderLightPassIfIntersects(light, MaterialPass.POINT_LIGHT_PASS, list);
	                }
	                else if (light instanceof SpotLight) {
	                    // cannot just use renderPass, need to do intersection tests
	                    this._renderLightPassIfIntersects(light, MaterialPass.SPOT_LIGHT_PASS, list);
	                }
	            }
	        }

	        GL.setBlendState();
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _renderLightPassIfIntersects: function(light, passType, renderList)
	    {
	        var lightBound = light.entity.worldBounds;
	        var len = renderList.length;

	        for (var r = 0; r < len; ++r) {
	            var renderItem = renderList[r];
	            var material = renderItem.material;
	            var pass = material.getPass(passType);
	            if (!pass) continue;

	            if (lightBound.intersectsBound(renderItem.worldBounds))
	                this._renderSingleItemSingleLight(passType, renderItem, light);
	        }
	    },

	    _renderSingleItemSingleLight: function(passType, renderItem, light)
	    {
	        var pass = renderItem.material.getPass(passType);
	        if (!pass) return;
	        var meshInstance = renderItem.meshInstance;
	        pass.updatePassRenderState(this._activeCamera, this, light);
	        pass.updateInstanceRenderState(this._activeCamera, renderItem, light);
			meshInstance.updateRenderState(passType);
	        var mesh = meshInstance._mesh;
	        GL.drawElements(pass._elementType, mesh._numIndices, 0, mesh._indexType);
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _renderNormalDepth: function()
	    {
	        var rc = this._renderCollector;
	        var dynamic = rc.getOpaqueRenderList(RenderPath.FORWARD_DYNAMIC);
	        var fixed = rc.getOpaqueRenderList(RenderPath.FORWARD_FIXED);

	        if (rc.needsNormalDepth) {
	            GL.setRenderTarget(this._normalDepthFBO);
	            GL.setClearColor(Color.BLUE);
	            GL.clear();
	            RenderUtils.renderPass(this, this._activeCamera, MaterialPass.NORMAL_DEPTH_PASS, dynamic, null);
	            RenderUtils.renderPass(this, this._activeCamera, MaterialPass.NORMAL_DEPTH_PASS, fixed, null);
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _renderAO: function()
	    {
	        var ssao = META.OPTIONS.ambientOcclusion;
	        if (ssao) {
	            this._ssaoTexture = ssao.getAOTexture();
	            ssao.render(this, 0);
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _renderShadowCasters: function()
	    {
	        this._shadowAtlas.initRects(this._renderCollector.shadowPlaneBuckets, this._renderCollector.numShadowPlanes);

	        var casters = this._renderCollector.getShadowCasters();
	        var len = casters.length;

	        GL.setRenderTarget(this._shadowAtlas.fbo);
	        GL.setClearColor(Color.WHITE);
	        GL.clear();

	        for (var i = 0; i < len; ++i) {
	            var light = casters[i];

	            // TODO: Reintroduce light types, use lookup

	            if (light instanceof DirectionalLight) {
	                this._cascadeShadowRenderer.render(light, this._shadowAtlas, this._camera, this._scene);
	            }
	            else if (light instanceof PointLight) {
	                this._omniShadowRenderer.render(light, this._shadowAtlas, this._camera, this._scene);
	            }
	            else if (light instanceof SpotLight) {
	                this._spotShadowRenderer.render(light, this._shadowAtlas, this._camera, this._scene);
	            }
	        }

	        this._shadowAtlas.blur();
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _renderEffect: function (effect, dt)
	    {
	        this._gammaApplied = this._gammaApplied || effect._outputsGamma;
	        effect.render(this, dt);
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _renderToScreen: function ()
	    {
	        GL.setRenderTarget(this._renderTarget);
	        GL.clear();

	        if (this._debugMode) {
	            var tex;
	            switch (this._debugMode) {
	                case Renderer.DebugMode.NORMAL_DEPTH:
	                    tex = this._normalDepthBuffer;
	                    break;
	                case Renderer.DebugMode.SHADOW_MAP:
	                    tex = this._shadowAtlas.texture;
	                    break;
	                case Renderer.DebugMode.SSAO:
	                    tex = this._ssaoTexture;
	                    break;
	                default:
	                    // nothing
	            }
	            this._copyTextureShader.execute(RectMesh.DEFAULT, tex);
	            return;
	        }

	        this._present();
	    },

	    /**
	     * @ignore
		 * @private
	     */
	    _present: function()
	    {
	        if (this._gammaApplied)
	            this._copyTextureShader.execute(RectMesh.DEFAULT, this._hdrBack.texture);
	        else
	            this._applyGamma.execute(RectMesh.DEFAULT, this._hdrBack.texture);
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _renderEffects: function (dt)
	    {
	        var effects = this._renderCollector.getEffects();
	        if (!effects) return;

	        var len = effects.length;

	        for (var i = 0; i < len; ++i) {
	            var effect = effects[i];
	            if (effect.isSupported()) {
	                this._renderEffect(effect, dt);
	                this._swapHDRFrontAndBack();
	            }
	        }
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _updateSize: function ()
	    {
	        var width, height;
	        if (this._renderTarget) {
	            width = this._renderTarget.width;
	            height = this._renderTarget.height;
	        }
	        else {
	            width = META.TARGET_CANVAS.width;
	            height = META.TARGET_CANVAS.height;
	        }

	        if (this._width !== width || this._height !== height) {
	            this._width = width;
	            this._height = height;
	            this._depthBuffer.init(this._width, this._height, true);
	            this._hdrBack.resize(this._width, this._height);
	            this._hdrFront.resize(this._width, this._height);
	            this._normalDepthBuffer.initEmpty(width, height);
	            this._normalDepthFBO.init();
	        }
	    },

	    /**
	     * @ignore
	     */
	    _swapHDRFrontAndBack: function()
	    {
	        var tmp = this._hdrBack;
	        this._hdrBack = this._hdrFront;
	        this._hdrFront = tmp;
	    },

	    /**
	     * @ignore
	     * @private
	     */
	    _createDepthBuffer: function()
	    {
	        /*if (HX.EXT_DEPTH_TEXTURE) {
	            this._depthBuffer = new HX.Texture2D();
	            this._depthBuffer.filter = HX.TextureFilter.BILINEAR_NOMIP;
	            this._depthBuffer.wrapMode = HX.TextureWrapMode.CLAMP;
	        }
	        else {*/
	            return new WriteOnlyDepthBuffer();
	    }
	};

	/**
	 * @classdesc
	 * DynamicLightProbe is a {@linkcode LightProbe} that is rendered from the scene dynamically.
	 *
	 * @constructor
	 *
	 * @extends LightProbe
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function DynamicLightProbe(textureSize, textureDataType, near, far)
	{
	    var diffuse = new TextureCube();
	    var specular = new TextureCube();

	    textureDataType = textureDataType || DataType.UNSIGNED_BYTE;

	    diffuse.initEmpty(4, null, textureDataType);
	    specular.initEmpty(textureSize, null, textureDataType);

	    near = near || .1;
	    far = far || 1000.0;

	    LightProbe.call(this, diffuse, specular);
	    this._cameras = [];
	    this._specularFBOs = [];
	    this._diffuseFBOs = [];

	    var depthBuffer = new WriteOnlyDepthBuffer();
	    depthBuffer.init(textureSize, textureSize, false);

	    var rotations = [];
	    for (var i = 0; i < 6; ++i) {
	        rotations[i] = new Quaternion();
	    }

	    rotations[0].fromAxisAngle(Float4.Y_AXIS, Math.PI * .5);
	    rotations[1].fromAxisAngle(Float4.Y_AXIS, -Math.PI * .5);
	    rotations[2].fromAxisAngle(Float4.X_AXIS, -Math.PI * .5);
	    rotations[3].fromAxisAngle(Float4.X_AXIS, Math.PI * .5);
	    rotations[4].fromAxisAngle(Float4.Y_AXIS, 0);
	    rotations[5].fromAxisAngle(Float4.Y_AXIS, Math.PI);

	    this._diffuseScene = new Scene();
	    this._diffuseScene.skybox = new Skybox(specular);

	    var cubeFaces = [ CubeFace.POSITIVE_X, CubeFace.NEGATIVE_X, CubeFace.POSITIVE_Y, CubeFace.NEGATIVE_Y, CubeFace.POSITIVE_Z, CubeFace.NEGATIVE_Z ];
	    for (i = 0; i < 6; ++i) {
	        var camera = new PerspectiveCamera();
	        camera.nearDistance = near;
	        camera.farDistance = far;
	        camera.verticalFOV = Math.PI * .5;
	        camera.rotation.copyFrom(rotations[i]);
	        camera.scale.set(1, -1, 1);
	        this._cameras.push(camera);

	        var fbo = new FrameBuffer(specular, depthBuffer, cubeFaces[i]);
	        fbo.init();
	        this._specularFBOs.push(fbo);

	        fbo = new FrameBuffer(diffuse, null, cubeFaces[i]);
	        fbo.init();
	        this._diffuseFBOs.push(fbo);
	    }

	    this._renderer = new Renderer();
	}

	Component.create(DynamicLightProbe, {}, LightProbe);

	/**
	 * Triggers an update of the light probe.
	 */
	DynamicLightProbe.prototype.render = function()
	{
	    var specularTexture = this._specularTexture;
	    var diffuseTexture = this._diffuseTexture;

	    this._specularTexture = DEFAULTS.DARK_CUBE_TEXTURE;
	    this._diffuseTexture = DEFAULTS.DARK_CUBE_TEXTURE;

	    var pos = this._entity.worldMatrix.getColumn(3);
	    var scene = this._entity._scene;

	    GL.setInvertCulling(true);

	    for (var i = 0; i < 6; ++i) {
	        this._cameras[i].position.copyFrom(pos);
	        this._renderer.render(this._cameras[i], scene, 0, this._specularFBOs[i]);
	    }

	    specularTexture.generateMipmap();

	    for (i = 0; i < 6; ++i)
	        this._renderer.render(this._cameras[i], this._diffuseScene, 0, this._diffuseFBOs[i]);

	    diffuseTexture.generateMipmap();

	    GL.setInvertCulling(false);

	    this._diffuseTexture = diffuseTexture;
	    this._specularTexture = specularTexture;
	};

	DynamicLightProbe.prototype.clone = function()
	{
		var clone = new DynamicLightProbe(this._diffuseTexture.size, this._diffuseTexture.dataType, this._cameras[0].nearDistance, this._cameras[0].farDistance);
		clone.size = this.size;
		return clone;
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ESMBlurShader(blurRadius)
	{
	    Shader.call(this);
	    var gl = GL.gl;

	    var defines = {
	        RADIUS: blurRadius,
	        RCP_NUM_SAMPLES: "float(" + (1.0 / (1.0 + 2.0 * blurRadius)) + ")"
	    };

	    var vertex = ShaderLibrary.get("copy_vertex.glsl", defines);
	    var fragment = ShaderLibrary.get("esm_blur_fragment.glsl", defines);

	    this.init(vertex, fragment);

	    this._textureLocation = gl.getUniformLocation(this._program, "source");
	    this._directionLocation = gl.getUniformLocation(this._program, "direction");
	    this._positionAttributeLocation = gl.getAttribLocation(this._program, "hx_position");
	    this._texCoordAttributeLocation = gl.getAttribLocation(this._program, "hx_texCoord");

	    gl.useProgram(this._program);
	    gl.uniform1i(this._textureLocation, 0);
	}

	ESMBlurShader.prototype = Object.create(Shader.prototype);

	ESMBlurShader.prototype.execute = function(rect, texture, dirX, dirY)
	{
	    var gl = GL.gl;

	    GL.setDepthTest(Comparison.DISABLED);
	    GL.setCullMode(CullMode.NONE);

	    rect._vertexBuffers[0].bind();
	    rect._indexBuffer.bind();

	    this.updatePassRenderState();

	    texture.bind(0);

	    gl.vertexAttribPointer(this._positionAttributeLocation, 2, gl.FLOAT, false, 16, 0);
	    gl.vertexAttribPointer(this._texCoordAttributeLocation, 2, gl.FLOAT, false, 16, 8);

	    GL.enableAttributes(2);

	    gl.uniform2f(this._directionLocation, dirX, dirY);

	    GL.drawElements(ElementType.TRIANGLES, 6, 0);
	};

	/**
	 * @classdesc
	 * ExponentialShadowFilter is a shadow filter for directional lights that provides exponential soft shadow
	 * mapping. The implementation is highly experimental at this point.
	 *
	 * @property {number} blurRadius The blur radius for the soft shadows.
	 * @property {number} darkeningFactor A darkening factor of the shadows. Counters some artifacts of the technique.
	 * @property {number} expScaleFactor The exponential scale factor. Probably you shouldn't touch this.
	 *
	 * @see {@linkcode InitOptions#shadowFilter}
	 *
	 * @constructor
	 *
	 * @extends ShadowFilter
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ExponentialShadowFilter()
	{
	    ShadowFilter.call(this);
	    this._expScaleFactor = 80;
	    this._blurRadius = 1;
	    this._darkeningFactor = .35;
	}


	ExponentialShadowFilter.prototype = Object.create(ShadowFilter.prototype,
	    {
	        shadowMapFilter: {
	            get: function() {
	                return TextureFilter.BILINEAR_NOMIP;
	            }
	        },

	        blurRadius: {
	            get: function()
	            {
	                return this._blurRadius;
	            },

	            set: function(value)
	            {
	                this._blurRadius = value;
	                this._invalidateBlurShader();
	            }
	        },

	        darkeningFactor: {
	            get: function()
	            {
	                return this._darkeningFactor;
	            },

	            set: function(value)
	            {
	                this._darkeningFactor = value;
	            }
	        },

	        expScaleFactor: {
	            get: function()
	            {
	                return this._expScaleFactor;
	            },

	            set: function(value)
	            {
	                this._expScaleFactor = value;
	            }
	        }
	    });

	/**
	 * @ignore
	 */
	ExponentialShadowFilter.prototype.getShadowMapFormat = function()
	{
	    return TextureFormat.RG || TextureFormat.RGB;
	};

	/**
	 * @ignore
	 */
	ExponentialShadowFilter.prototype.getShadowMapDataType = function()
	{
	    return DataType.FLOAT;
	};

	/**
	 * @ignore
	 */
	ExponentialShadowFilter.prototype.getGLSL = function()
	{
	    var defines = this._getDefines();
	    return ShaderLibrary.get("shadow_esm.glsl", defines);
	};

	/**
	 * @ignore
	 */
	ExponentialShadowFilter.prototype._getDefines = function()
	{
	    return {
	        HX_ESM_CONSTANT: "float(" + this._expScaleFactor + ")",
	        HX_ESM_DARKENING: "float(" + this._darkeningFactor + ")"
	    };
	};

	/**
	 * @ignore
	 */
	ExponentialShadowFilter.prototype._createBlurShader = function()
	{
	    return new ESMBlurShader(this._blurRadius);
	};

	/**
	 * @classdesc
	 * PCFShadowFilter is a shadow filter that provides percentage closer soft shadow mapping. However, WebGL does not
	 * support shadow test interpolations, so the results aren't as great as its GL/DX counterpart.
	 *
	 * @property {number} softness The softness of the shadows in shadow map space.
	 * @property {number} numShadowSamples The amount of shadow samples to take.
	 * @property {boolean} dither Whether or not the samples should be randomly rotated per screen pixel. Introduces noise but can improve the look.
	 *
	 * @see {@linkcode InitOptions#shadowFilter}
	 *
	 * @constructor
	 *
	 * @extends ShadowFilter
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PCFShadowFilter()
	{
	    ShadowFilter.call(this);
	    this._softness = .001;
	    this._numShadowSamples = 6;
	    this._dither = false;
	}

	PCFShadowFilter.prototype = Object.create(ShadowFilter.prototype,
	    {
	        softness: {
	            get: function ()
	            {
	                return this._softness;
	            },

	            set: function (value)
	            {
	                if (this._softness !== value) {
	                    this._softness = value;
	                }
	            }
	        },

	        numShadowSamples: {
	            get: function ()
	            {
	                return this._numShadowSamples;
	            },

	            set: function (value)
	            {
	                value = MathX.clamp(value, 1, 32);
	                if (this._numShadowSamples !== value) {
	                    this._numShadowSamples = value;
	                }
	            }
	        },

	        dither: {
	            get: function ()
	            {
	                return this._dither;
	            },

	            set: function (value)
	            {
	                if (this._dither !== value) {
	                    this._dither = value;
	                }
	            }
	        }
	    }
	);

	/**
	 * @ignore
	 */
	PCFShadowFilter.prototype.getGLSL = function ()
	{
	    var defines = {
	        HX_PCF_NUM_SHADOW_SAMPLES: this._numShadowSamples,
	        HX_PCF_RCP_NUM_SHADOW_SAMPLES: "float(" + (1.0 / this._numShadowSamples) + ")",
	        HX_PCF_SOFTNESS: this._softness
	    };

	    if (this._dither)
	        defines.HX_PCF_DITHER_SHADOWS = 1;

	    return ShaderLibrary.get("shadow_pcf.glsl", defines);
	};

	/**
	 * @ignore
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function VSMBlurShader(blurRadius)
	{
	    var gl = GL.gl;
	    Shader.call(this);

	    var defines = {
	        RADIUS: blurRadius,
	        RCP_NUM_SAMPLES: "float(" + (1.0 / (1.0 + 2.0 * blurRadius)) + ")"
	    };

	    var vertex = ShaderLibrary.get("copy_vertex.glsl", defines);
	    var fragment = ShaderLibrary.get("vsm_blur_fragment.glsl", defines);

	    this.init(vertex, fragment);

	    this._textureLocation = gl.getUniformLocation(this._program, "source");
	    this._directionLocation = gl.getUniformLocation(this._program, "direction");
	    this._positionAttributeLocation = gl.getAttribLocation(this._program, "hx_position");
	    this._texCoordAttributeLocation = gl.getAttribLocation(this._program, "hx_texCoord");

	    gl.useProgram(this._program);
	    gl.uniform1i(this._textureLocation, 0);
	}
	VSMBlurShader.prototype = Object.create(Shader.prototype);

	VSMBlurShader.prototype.execute = function (rect, texture, dirX, dirY)
	{
	    var gl = GL.gl;
	    GL.setDepthTest(Comparison.DISABLED);
	    GL.setCullMode(CullMode.NONE);

	    rect._vertexBuffers[0].bind();
	    rect._indexBuffer.bind();

	    this.updatePassRenderState();

	    texture.bind(0);

	    gl.vertexAttribPointer(this._positionAttributeLocation, 2, DataType.FLOAT, false, 16, 0);
	    gl.vertexAttribPointer(this._texCoordAttributeLocation, 2, DataType.FLOAT, false, 16, 8);

	    GL.enableAttributes(2);

	    gl.uniform2f(this._directionLocation, dirX, dirY);

	    GL.drawElements(gl.TRIANGLES, 6, 0);
	};

	/**
	 * @classdesc
	 * VarianceShadowFilter is a shadow filter that provides variance soft shadow mapping. The implementation is highly
	 * experimental at this point.
	 *
	 * @property {Number} blurRadius The blur radius for the soft shadows.
	 * @property {Number} lightBleedReduction A value to counter light bleeding, an artifact of the technique.
	 * @property {Number} minVariance The minimum amount of variance.
	 * @property {Boolean} useHalfFloat Uses half float textures for the shadow map, if available. This may result in
	 * performance improvements, but also precision artifacts. Defaults to true.
	 *
	 * @see {@linkcode InitOptions#shadowFilter}
	 *
	 * @constructor
	 *
	 * @extends ShadowFilter
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function VarianceShadowFilter()
	{
	    ShadowFilter.call(this);
	    this._blurRadius = 2;
	    this._lightBleedReduction = .5;
	    this._minVariance = .001;
	    this._useHalfFloat = true;
	    this._cullMode = CullMode.BACK;
	}

	VarianceShadowFilter.prototype = Object.create(ShadowFilter.prototype,
	    {
	        shadowMapFilter: {
	            get: function() {
	                return TextureFilter.BILINEAR_NOMIP;
	            }
	        },

	        minVariance: {
	            get: function()
	            {
	                return this._minVariance;
	            },

	            set: function(value)
	            {
	                this._minVariance = value;
	            }
	        },

	        blurRadius: {
	            get: function()
	            {
	                return this._blurRadius;
	            },

	            set: function(value)
	            {
	                this._blurRadius = value;
	                this._invalidateBlurShader();
	            }
	        },

	        lightBleedReduction: {
	            get: function()
	            {
	                return this._lightBleedReduction;
	            },

	            set: function(value)
	            {
	                this._lightBleedReduction = value;
	            }
	        },

	        useHalfFloat: {
	            get: function()
	            {
	                return this._useHalfFloat;
	            },

	            set: function(value)
	            {
	                this._useHalfFloat = value;
	            }
	        }
	    });

	/**
	 * @ignore
	 */
	VarianceShadowFilter.prototype.getGLSL = function()
	{
	    var defines = this._getDefines();
	    return ShaderLibrary.get("shadow_vsm.glsl", defines);
	};

	VarianceShadowFilter.prototype.getShadowMapFormat = function()
	{
	    return capabilities.EXT_COLOR_BUFFER_HALF_FLOAT || capabilities.EXT_COLOR_BUFFER_FLOAT? TextureFormat.RG || TextureFormat.RGB : TextureFormat.RGBA;
	};

	VarianceShadowFilter.prototype.getShadowMapDataType = function()
	{
	    return capabilities.EXT_COLOR_BUFFER_HALF_FLOAT && this._useHalfFloat? DataType.HALF_FLOAT :
	            capabilities.EXT_COLOR_BUFFER_FLOAT? DataType.FLOAT : DataType.UNSIGNED_BYTE;
	};

	/**
	 * @ignore
	 */
	VarianceShadowFilter.prototype._createBlurShader = function()
	{
	    return new VSMBlurShader(this._blurRadius);
	};

	/**
	 * @ignore
	 */
	VarianceShadowFilter.prototype._getDefines = function()
	{
	    var range = 1.0 - this._lightBleedReduction;
	    return {
	        HX_VSM_MIN_VARIANCE: "float(" + this._minVariance + ")",
	        HX_VSM_LIGHT_BLEED_REDUCTION: "float(" + this._lightBleedReduction + ")",
	        HX_VSM_RCP_LIGHT_BLEED_REDUCTION_RANGE: "float(" + (1.0 / range) + ")"
	    };
	};

	/**
	 * @classdesc
	 * SpherePrimitive provides a primitive cylinder {@linkcode Model}.
	 *
	 * @constructor
	 * @param definition An object containing the following (optional) parameters:
	 * <ul>
	 *     <li>numSegmentsW: The amount of horizontal segments</li>
	 *     <li>numSegmentsH: The amount of vertical segments </li>
	 *     <li>radius: The radius of the sphere</li>
	 *     <li>invert: Whether or not the faces should point inwards</li>
	 *     <li>doubleSided: Whether or not the faces should point both ways</li>
	 * </ul>
	 *
	 * @extends Primitive
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function SpherePrimitive(definition)
	{
	    Primitive.call(this, definition);
	}

	SpherePrimitive.prototype = Object.create(Primitive.prototype);

	SpherePrimitive.prototype._generate = function(target, definition)
	{
	    definition = definition || {};
	    var numSegmentsW = definition.numSegmentsW || 16;
	    var numSegmentsH = definition.numSegmentsH || 10;
	    var radius = definition.radius || .5;

	    var flipSign = definition.invert? -1 : 1;

	    var doubleSided = definition.doubleSided === undefined? false : definition.doubleSided;

	    var positions = target.positions;
	    var uvs = target.uvs;
	    var normals = target.normals;

	    var rcpNumSegmentsW = 1/numSegmentsW;
	    var rcpNumSegmentsH = 1/numSegmentsH;

	    for (var polarSegment = 0; polarSegment <= numSegmentsH; ++polarSegment) {
	        var ratioV = polarSegment * rcpNumSegmentsH;
	        var theta = ratioV * Math.PI;

	        var y = -Math.cos(theta);
	        var segmentUnitRadius = Math.sin(theta);

	        if (flipSign < 0) ratioV = 1.0 - ratioV;

	        for (var azimuthSegment = 0; azimuthSegment <= numSegmentsW; ++azimuthSegment) {
	            var ratioU = azimuthSegment * rcpNumSegmentsW;
	            var phi = ratioU * Math.PI * 2.0;

	            if (flipSign) ratioU = 1.0 - ratioU;

	            var normalX = Math.cos(phi) * segmentUnitRadius * flipSign;
	            var normalY = y * flipSign;
	            var normalZ = Math.sin(phi) * segmentUnitRadius * flipSign;

	            // position
	            positions.push(normalX*radius, normalZ*radius, normalY*radius);

	            if (normals)
	                normals.push(normalX * flipSign, normalZ * flipSign, normalY * flipSign);

	            if (uvs)
	                uvs.push(ratioU, ratioV);
	        }
	    }

	    var indices = target.indices;

	    for (polarSegment = 0; polarSegment < numSegmentsH; ++polarSegment) {
	        for (azimuthSegment = 0; azimuthSegment < numSegmentsW; ++azimuthSegment) {
	            var w = numSegmentsW + 1;
	            var base = azimuthSegment + polarSegment*w;

	            indices.push(base, base + w + 1, base + w);
	            indices.push(base, base + 1, base + w + 1);

	            if (doubleSided) {
	                indices.push(base, base + w, base + w + 1);
	                indices.push(base, base + w + 1, base + 1);
	            }
	        }
	    }
	};

	SpherePrimitive.prototype._getBounds = function()
	{
	    return new BoundingSphere();
	};

	/**
	 * @classdesc
	 * ConePrimitive provides a primitive cone {@linkcode Model}.
	 *
	 * @constructor
	 * @param definition An object containing the following (optional) parameters:
	 * <ul>
	 *     <li>numSegmentsW: The amount of horizontal segments</li>
	 *     <li>numSegmentsH: The amount of vertical segments </li>
	 *     <li>radius: The radius of the cone base</li>
	 *     <li>height: The height of the cone</li>
	 *     <li>doubleSided: Whether or not the faces should point both ways</li>
	 * </ul>
	 *
	 * @extends Primitive
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function ConePrimitive(definition)
	{
	    Primitive.call(this, definition);
	}

	ConePrimitive.prototype = Object.create(Primitive.prototype);

	/**
	 * The alignment dictates which access should be parallel to the sides of the cone
	 * @type {number}
	 */
	ConePrimitive.ALIGN_X = 1;
	ConePrimitive.ALIGN_Y = 2;
	ConePrimitive.ALIGN_Z = 3;

	ConePrimitive.prototype._generate = function(target, definition)
	{
	    definition = definition || {};
	    var alignment = definition.alignment || ConePrimitive.ALIGN_Z;
	    var numSegmentsH = definition.numSegmentsH || 1;
	    var numSegmentsW = definition.numSegmentsW || 16;
	    var radius = definition.radius || .5;
	    var height = definition.height || 1;
	    var doubleSided = definition.doubleSided === undefined? false : definition.doubleSided;

	    var positions = target.positions;
	    var uvs = target.uvs;
	    var normals = target.normals;
	    var indices = target.indices;
	    var hi, ci;
	    var cx, cy;
	    var angle;

	    var rcpNumSegmentsW = 1/numSegmentsW;
	    var rcpNumSegmentsH = 1/numSegmentsH;

	    // sides
	    for (hi = 0; hi <= numSegmentsH; ++hi) {
	        var rad = (1.0 - hi * rcpNumSegmentsH) * radius;
	        var h = (hi*rcpNumSegmentsH - .5)*height;
	        for (ci = 0; ci <= numSegmentsW; ++ci) {
	            angle = ci * rcpNumSegmentsW * Math.PI * 2;
	            var nx = Math.sin(angle);
	            var ny = Math.cos(angle);
	            cx = nx * rad;
	            cy = ny * rad;

	            switch (alignment) {
	                case ConePrimitive.ALIGN_X:
	                    positions.push(h, cy, cx);
	                    if (normals) normals.push(0, ny, nx);
	                    break;
	                case ConePrimitive.ALIGN_Z:
	                    positions.push(cx, -cy, h);
	                    if (normals) normals.push(nx, -ny, 0);
	                    break;
	                default:
	                    // Y
	                    positions.push(cx, h, cy);
	                    if (normals) normals.push(nx, 0, ny);
	                    break;
	            }

	            if (uvs) uvs.push(1.0 - ci*rcpNumSegmentsW, hi*rcpNumSegmentsH);
	        }
	    }

	    var w = numSegmentsW + 1;
	    var base;
	    for (ci = 0; ci < numSegmentsW; ++ci) {
	        for (hi = 0; hi < numSegmentsH - 1; ++hi) {
	            base = ci + hi*w;
	            indices.push(base, base + w + 1, base + w);
	            indices.push(base, base + 1, base + w + 1);

	            if (doubleSided) {
	                indices.push(base, base + w, base + w + 1);
	                indices.push(base, base + w + 1, base + 1);
	            }
	        }

	        // tip only needs 1 tri
	        base = ci + (numSegmentsH - 1)*w;
	        indices.push(base, base + 1, base + w + 1);
	    }

	    // bottom
	    var indexOffset = positions.length / 3;
	    var halfH = height * .5;
	    for (ci = 0; ci < numSegmentsW; ++ci) {
	        angle = ci * rcpNumSegmentsW * Math.PI * 2;
	        var u = Math.sin(angle);
	        var v = Math.cos(angle);
	        cx = u * radius;
	        cy = v * radius;

	        u = -u * .5 + .5;
	        v = v * .5 + .5;

	        switch (alignment) {
	            case ConePrimitive.ALIGN_X:
	                positions.push(-halfH, cy, cx);
	                if (normals) normals.push(-1, 0, 0);
	                if (uvs) uvs.push(v, 1.0 - u);
	                break;

	            case ConePrimitive.ALIGN_Z:
	                positions.push(cx, -cy, -halfH);
	                if (normals) normals.push(0, 0, -1);
	                if (uvs) uvs.push(u, v);
	                break;
	            default:
	                positions.push(cx, -halfH, cy);
	                if (normals) normals.push(0, -1, 0);
	                if (uvs) uvs.push(u, v);
	                break;
	        }
	    }

	    for (ci = 1; ci < numSegmentsW - 1; ++ci)
	        indices.push(indexOffset, indexOffset + ci + 1, indexOffset + ci);
	};

	/**
	 * @classdesc
	 * PlanePrimitive provides a primitive plane {@linkcode Model}.
	 *
	 * @constructor
	 * @param definition An object containing the following (optional) parameters:
	 * <ul>
	 *     <li>numSegmentsW: The amount of horizontal segments</li>
	 *     <li>numSegmentsH: The amount of vertical segments </li>
	 *     <li>width: The width of the plane</li>
	 *     <li>height: The height of the plane</li>
	 *     <li>doubleSided: Whether or not the faces should point both ways</li>
	 *     <li>alignment: The axes along which to orient the plane. One of {@linkcode PlanePrimitive#ALIGN_XZ}, {@linkcode PlanePrimitive#ALIGN_XY}, {@linkcode PlanePrimitive#ALIGN_YZ}</li>
	 * </ul>
	 *
	 * @extends Primitive
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function PlanePrimitive(definition)
	{
	    Primitive.call(this, definition);
	}

	PlanePrimitive.prototype = Object.create(Primitive.prototype);

	PlanePrimitive.ALIGN_XZ = 1;
	PlanePrimitive.ALIGN_XY = 2;
	PlanePrimitive.ALIGN_YZ = 3;

	PlanePrimitive.prototype._generate = function(target, definition)
	{
	    definition = definition || {};
	    var alignment = definition.alignment || PlanePrimitive.ALIGN_XY;
	    var numSegmentsW = definition.numSegmentsW || 1;
	    var numSegmentsH = definition.numSegmentsH || 1;
	    var width = definition.width || 1;
	    var height = definition.height || 1;
	    var doubleSided = definition.doubleSided === undefined? false : definition.doubleSided;

	    var positions = target.positions;
	    var uvs = target.uvs;
	    var normals = target.normals;
	    var indices = target.indices;

	    var rcpNumSegmentsW = 1/numSegmentsW;
	    var rcpNumSegmentsH = 1/numSegmentsH;
	    var posX = 0, posY = 0, posZ = 0;
	    var normalX = 0, normalY = 0, normalZ = 0;
	    var uvU = 0, uvV = 0;

	    if (alignment === PlanePrimitive.ALIGN_XY)
	        normalZ = 1;
	    else if (alignment === PlanePrimitive.ALIGN_XZ)
	        normalY = 1;
	    else
	        normalX = 1;

	    for (var yi = 0; yi <= numSegmentsH; ++yi) {
	        var y = (yi*rcpNumSegmentsH - .5)*height;

	        for (var xi = 0; xi <= numSegmentsW; ++xi) {
	            var x = (xi*rcpNumSegmentsW - .5)*width;

	            if (alignment === PlanePrimitive.ALIGN_XY) {
	                posX = x;
	                posY = y;
	                uvU = 1.0 - xi*rcpNumSegmentsW;
	                uvV = yi*rcpNumSegmentsH;
	            }
	            else if (alignment === PlanePrimitive.ALIGN_XZ) {
	                posX = x;
	                posZ = y;
	                uvU = 1.0 - xi*rcpNumSegmentsW;
	                uvV = yi*rcpNumSegmentsH;
	            }
	            else {
	                posY = x;
	                posZ = y;
	                uvU = 1.0 - xi*rcpNumSegmentsW;
	                uvV = yi*rcpNumSegmentsH;
	            }

	            positions.push(posX, posY, posZ);

	            if (normals)
	                normals.push(normalX, normalY, normalZ);

	            if (uvs)
	                uvs.push(uvU, uvV);

	            // add vertex with same position, but with inverted normal & tangent
	            if (doubleSided) {
	                positions.push(posX, posY, posZ);

	                if (normals)
	                    normals.push(-normalX, -normalY, -normalZ);

	                if (uvs)
	                    uvs.push(1.0 - uvU, uvV);
	            }

	            if (xi !== numSegmentsW && yi !== numSegmentsH) {
	                var w = numSegmentsW + 1;
	                var base = xi + yi*w;
	                var mult = doubleSided ? 1 : 0;

	                indices.push(base << mult, (base + w + 1) << mult, (base + w) << mult);
	                indices.push(base << mult, (base + 1) << mult, (base + w + 1) << mult);

	                if(doubleSided) {
	                    indices.push(((base + w) << mult) + 1, ((base + w + 1) << mult) + 1, (base << mult) + 1);
	                    indices.push(((base + w + 1) << mult) + 1, ((base + 1) << mult) + 1, (base << mult) + 1);
	                }
	            }
	        }
	    }
	};

	/**
	 * @classdesc
	 * TorusPrimitive provides a primitive cylinder {@linkcode Model}.
	 *
	 * @constructor
	 * @param definition An object containing the following (optional) parameters:
	 * <ul>
	 *     <li>numSegmentsW: The amount of horizontal segments</li>
	 *     <li>numSegmentsH: The amount of vertical segments </li>
	 *     <li>radius: The radius of the torus</li>
	 *     <li>tubeRadius: The radius of the torus's tube</li>
	 *     <li>invert: Whether or not the faces should point inwards</li>
	 *     <li>doubleSided: Whether or not the faces should point both ways</li>
	 *     <li>alignment: The axes along which to orient the torus. One of {@linkcode TorusPrimitive#ALIGN_XZ}, {@linkcode TorusPrimitive#ALIGN_XY}, {@linkcode TorusPrimitive#ALIGN_YZ}</li>
	 * </ul>
	 *
	 * @extends Primitive
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function TorusPrimitive(definition)
	{
	    Primitive.call(this, definition);
	}

	TorusPrimitive.prototype = Object.create(Primitive.prototype);

	TorusPrimitive.ALIGN_XY = 1;
	TorusPrimitive.ALIGN_XZ = 2;
	TorusPrimitive.ALIGN_YZ = 3;

	TorusPrimitive.prototype._generate = function(target, definition)
	{
	    definition = definition || {};
	    var numSegmentsW = definition.numSegmentsW || 15;
	    var numSegmentsH = definition.numSegmentsH || 20;
	    var radius = definition.radius || .5;
	    var tubeRadius = definition.tubeRadius || .1;
	    var alignment = definition.alignment || TorusPrimitive.ALIGN_XY;

	    var doubleSided = definition.doubleSided === undefined? false : definition.doubleSided;

	    var positions = target.positions;
	    var uvs = target.uvs;
	    var normals = target.normals;

	    var rcpNumSegmentsW = 1/numSegmentsW;
	    var rcpNumSegmentsH = 1/numSegmentsH;

	    for (var poloidalSegment = 0; poloidalSegment <= numSegmentsH; ++poloidalSegment) {
	        var ratioV = poloidalSegment * rcpNumSegmentsH;
	        var theta = ratioV * Math.PI * 2.0;
	        var px = Math.cos(theta);
	        var py = Math.sin(theta);

	        for (var toroidalSegment = 0; toroidalSegment <= numSegmentsW; ++toroidalSegment) {
	            var ratioU = toroidalSegment * rcpNumSegmentsW;
	            var phi = ratioU * Math.PI * 2.0;
	            var tx = Math.cos(phi);
	            var tz = Math.sin(phi);
	            var rad = radius + px  * tubeRadius;

	            switch(alignment) {
	                case TorusPrimitive.ALIGN_XZ:
	                    positions.push(tx * rad, -py  * tubeRadius, tz * rad);

	                    if (normals)
	                        normals.push(tx * px, -py, tz * px);

	                    break;
	                case TorusPrimitive.ALIGN_XY:
	                    positions.push(tx * rad, tz * rad, py  * tubeRadius);

	                    if (normals)
	                        normals.push(tx * px, tz * px, py);
	                    break;
	                case TorusPrimitive.ALIGN_YZ:
	                    positions.push(py  * tubeRadius, tx * rad, tz * rad);

	                    if (normals)
	                        normals.push(py, tx * px, tz * px);
	                    break;

	                default:
	                    // nothing

	            }

	            if (uvs)
	                uvs.push(ratioU, 1.0 - ratioV);
	        }
	    }

	    var indices = target.indices;

	    for (var polarSegment = 0; polarSegment < numSegmentsH; ++polarSegment) {
	        for (var azimuthSegment = 0; azimuthSegment < numSegmentsW; ++azimuthSegment) {
	            var w = numSegmentsW + 1;
	            var base = azimuthSegment + polarSegment*w;

	            indices.push(base, base + w + 1, base + w);
	            indices.push(base, base + 1, base + w + 1);

	            if (doubleSided) {
	                indices.push(base, base + w, base + w + 1);
	                indices.push(base, base + w + 1, base + 1);
	            }
	        }
	    }
	};

	/**
	 * @classdesc
	 * WireBoxPrimitive provides a primitive box {@linkcode Model} to use with line types, useful for debugging.
	 *
	 * @constructor
	 * @param definition An object containing the following (optional) parameters:
	 * <ul>
	 *     <li>width: The width of the box</li>
	 *     <li>height: The height of the box</li>
	 *     <li>depth: The depth of the box</li>
	 * </ul>
	 *
	 * @extends Primitive
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function WireBoxPrimitive(definition)
	{
	    Primitive.call(this, definition);
	}

	WireBoxPrimitive.prototype = Object.create(Primitive.prototype);

	WireBoxPrimitive.prototype._generate = function(target, definition)
	{
	    var width = definition.width || 1;
	    var height = definition.height || width;
	    var depth = definition.depth || width;

	    var halfW = width * .5;
	    var halfH = height * .5;
	    var halfD = depth * .5;

	    var positions = target.positions;
	    var indices = target.indices;

	    positions.push(-halfW, -halfD, -halfH);
	    positions.push(halfW, -halfD, -halfH);
	    positions.push(-halfW, -halfD, halfH);
	    positions.push(halfW, -halfD, halfH);

	    positions.push(-halfW, halfD, -halfH);
	    positions.push(halfW, halfD, -halfH);
	    positions.push(-halfW, halfD, halfH);
	    positions.push(halfW, halfD, halfH);

	    indices.push(0, 1);
	    indices.push(2, 3);
	    indices.push(0, 2);
	    indices.push(1, 3);

	    indices.push(4, 5);
	    indices.push(6, 7);
	    indices.push(4, 6);
	    indices.push(5, 7);

	    indices.push(0, 4);
	    indices.push(2, 6);
	    indices.push(1, 5);
	    indices.push(3, 7);
	};

	/**
	 * @classdesc
	 * WirePlanePrimitive provides a primitive plane {@linkcode Model} to use with line types, useful for debugging.
	 *
	 * @constructor
	 * @param definition An object containing the following (optional) parameters:
	 * <ul>
	 *     <li>numSegmentsW: The amount of horizontal segments</li>
	 *     <li>numSegmentsH: The amount of vertical segments </li>
	 *     <li>width: The width of the plane</li>
	 *     <li>height: The height of the plane</li>
	 *     <li>alignment: The axes along which to orient the plane. One of {@linkcode WirePlanePrimitive#ALIGN_XZ}, {@linkcode WirePlanePrimitive#ALIGN_XY}, {@linkcode WirePlanePrimitive#ALIGN_YZ}</li>
	 * </ul>
	 *
	 * @extends Primitive
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function WirePlanePrimitive(definition)
	{
	    Primitive.call(this, definition);
	}

	WirePlanePrimitive.prototype = Object.create(Primitive.prototype);

	WirePlanePrimitive.ALIGN_XZ = 1;
	WirePlanePrimitive.ALIGN_XY = 2;
	WirePlanePrimitive.ALIGN_YZ = 3;

	WirePlanePrimitive.prototype._generate = function(target, definition)
	{
	    definition = definition || {};
	    var alignment = definition.alignment || WirePlanePrimitive.ALIGN_XY;
	    var numSegmentsW = definition.numSegmentsW || 1;
	    var numSegmentsH = definition.numSegmentsH || 1;
	    var width = definition.width || 1;
	    var height = definition.height || 1;

	    var positions = target.positions;
	    var indices = target.indices;

	    var rcpNumSegmentsW = 1/numSegmentsW;
	    var rcpNumSegmentsH = 1/numSegmentsH;
	    var posX = 0, posY = 0, posZ = 0;

	    for (var yi = 0; yi <= numSegmentsH; ++yi) {
	        var y = (yi*rcpNumSegmentsH - .5)*height;

	        for (var xi = 0; xi <= numSegmentsW; ++xi) {
	            var x = (xi*rcpNumSegmentsW - .5)*width;

	            if (alignment === WirePlanePrimitive.ALIGN_XY) {
	                posX = x;
	                posY = y;
	            }
	            else if (alignment === WirePlanePrimitive.ALIGN_XZ) {
	                posX = x;
	                posZ = y;
	            }
	            else {
	                posY = x;
	                posZ = y;
	            }

	            positions.push(posX, posY, posZ);

	            if (xi !== numSegmentsW && yi !== numSegmentsH) {
	                var w = numSegmentsW + 1;
	                var base = xi + yi*w;

	                indices.push(base, base + 1);
	                indices.push(base + 1, base + w + 1);
	                indices.push(base + w + 1, base + w);
	                indices.push(base + w, base);
	            }
	        }
	    }
	};

	/**
	 * @classdesc
	 * VRRenderer is a renderer to WebVR. This can only be used if `HX.enableVR` is called
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function VRRenderer()
	{
	    Renderer.call(this);
	    this._leftTarget = new Renderer.HDRBuffers(this._depthBuffer);
	    this._leftRect = new Rect();
	    this._rightRect = new Rect();
	}

	VRRenderer.prototype = Object.create(Renderer.prototype);

	/**
	 * @inheritDoc
	 */
	VRRenderer.prototype.render = function(camera, scene, dt)
	{
	    console.assert(camera instanceof VRCamera, "Must use VRCamera with VRRenderer!");

	    // TODO: Render to two intermediate renderTargets
	    META.VR_DISPLAY.depthNear = camera.nearDistance;
	    META.VR_DISPLAY.depthFar = camera.farDistance;

	    this._camera = camera;
	    this._scene = scene;

	    camera._updateVR();

	    this._updateSize(this._renderTarget);
	    this._camera._setRenderTargetResolution(this._width, this._height);

	    this._renderCollector.collect(camera, scene);
	    this._ambientColor = this._renderCollector._ambientColor;

	    this._renderShadowCasters();

	    // TODO: Can we set _activeCamera instead of keeping renderItem.camera?
	    this._renderView(camera._cameraLeft, scene, dt);

	    // swap buffers so leftTarget contains the left target
	    var tmp = this._leftTarget;
	    this._leftTarget = this._hdrBack;
	    this._hdrBack = tmp;

	    this._renderView(camera._cameraRight, scene, dt);

	    this._renderToScreen();
	};

	/**
	 * @ignore
	 */
	VRRenderer.prototype._present = function()
	{
	    if (this._gammaApplied) {
	        GL.setViewport(this._leftRect);
	        this._copyTextureShader.execute(RectMesh.DEFAULT, this._leftTarget.texture);
	        GL.setViewport(this._rightRect);
	        this._copyTextureShader.execute(RectMesh.DEFAULT, this._hdrBack.texture);
	    }
	    else {
	        GL.setViewport(this._leftRect);
	        this._applyGamma.execute(RectMesh.DEFAULT, this._leftTarget.texture);
	        GL.setViewport(this._rightRect);
	        this._applyGamma.execute(RectMesh.DEFAULT, this._hdrBack.texture);
	    }

	    GL.setViewport();
	};

	/**
	 * @ignore
	 */
	VRRenderer.prototype._updateSize = function()
	{
	    var width, height;
	    if (this._renderTarget) {
	        width = this._renderTarget.width * .5;
	        height = this._renderTarget.height;
	    }
		else {
	        width = META.TARGET_CANVAS.width * .5;
	        height = META.TARGET_CANVAS.height;
	    }

	    if (this._width !== width || this._height !== height) {
	        this._width = width;
	        this._height = height;
	        this._depthBuffer.init(this._width, this._height, true);
	        this._hdrBack.resize(this._width, this._height);
	        this._hdrFront.resize(this._width, this._height);
	        this._leftTarget.resize(this._width, this._height);
	        this._normalDepthBuffer.initEmpty(width, height);
	        this._normalDepthFBO.init();
	        this._leftRect.width = width;
	        this._leftRect.height = height;
	        this._rightRect.width = width;
	        this._rightRect.height = height;
	        this._rightRect.x = width;
	    }
	};

	/**
	 * @classdesc
	 * View represents a renderable area on screen with the data it should render.
	 *
	 * @param scene The {@linkcode Scene} to render to this view.
	 * @param camera The {@linkcode Camera} to use for this view.
	 * @param xRatio The ratio (0 - 1) of the top-left corner of the view's horizontal position relative to the screen width.
	 * @param yRatio The ratio (0 - 1) of the top-left corner of the view vertical position relative to the screen height.
	 * @param widthRatio The ratio (0 - 1) of the top-left corner of the view's width relative to the screen width.
	 * @param heightRatio The ratio (0 - 1) of the top-left corner of the view's height relative to the screen height.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function View(scene, camera, xRatio, yRatio, widthRatio, heightRatio)
	{
	    /**
	     * The {@linkcode Scene} to render to this view.
	     */
	    this.scene = scene;

	    /**
	     * The {@linkcode Camera} to use for this view.
	     */
	    this.camera = camera;

	    this._renderer = null;
	    this._texture = null;
	    this._fbo = null;

	    /**
	     * The ratio (0 - 1) of the top-left corner of the view's horizontal position relative to the screen width.
	     */
	    this.xRatio = xRatio || 0;

	    /**
	     * The ratio (0 - 1) of the top-left corner of the view's vertical position relative to the screen height.
	     */
	    this.yRatio = yRatio || 0;

	    /**
	     * The ratio (0 - 1) of the top-left corner of the view's width relative to the screen width.
	     */
	    this.widthRatio = widthRatio || 1;

	    /**
	     * The ratio (0 - 1) of the top-left corner of the view's height relative to the screen height.
	     */
	    this.heightRatio = heightRatio || 1;
	}

	/**
	 * MultiRenderer is a renderer for multiple simultaneous viewports. Multiple scenes can be rendered, with multiple
	 * cameras.
	 *
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function MultiRenderer()
	{
	    this._views = [];
	}

	MultiRenderer.prototype =
	{
	    /**
	     * Adds a {@linkcode View} to be rendered.
	     */
	    addView: function (view)
	    {
	        view._texture = new Texture2D();
	        view._texture.filter = TextureFilter.BILINEAR_NOMIP;
	        view._texture.wrapMode = TextureWrapMode.CLAMP;
	        view._fbo = new FrameBuffer(view._texture);
	        view._renderer = new Renderer(view._fbo);
	        this._views.push(view);
	    },

	    /**
	     * Removes a {@linkcode View}.
	     */
	    removeView: function (view)
	    {
	        view._fbo = null;
	        view._texture = null;
	        view._renderer = null;
	        var index = this._views.indexOf(view);
	        this._views.splice(index, 1);
	    },

	    /**
	     * Renders all views.
	     * @param dt The milliseconds passed since last frame.
	     * @param [renderTarget] An optional {@linkcode FrameBuffer} object to render to.
	     */
	    render: function (dt, renderTarget)
	    {
	        var screenWidth = META.TARGET_CANVAS.clientWidth;
	        var screenHeight = META.TARGET_CANVAS.clientHeight;
	        var numViews = this._views.length;
	        for (var i = 0; i < numViews; ++i) {
	            var view = this._views[i];
	            var w = Math.floor(screenWidth * view.widthRatio);
	            var h = Math.floor(screenHeight * view.heightRatio);

	            if (view._texture.width !== w || view._texture.height !== h) {
	                view._texture.initEmpty(w, h);
	                view._fbo.init();
	            }

	            view._renderer.render(view.camera, view.scene, dt);
	        }

	        GL.setRenderTarget(renderTarget);
	        GL.clear();

	        var viewport = new Rect();

	        for (i = 0; i < numViews; ++i) {
	            view = this._views[i];
	            viewport.x = Math.floor(view.xRatio * screenWidth);
	            viewport.y = Math.floor((1.0 - view.yRatio - view.heightRatio) * screenHeight);
	            viewport.width = view._texture.width;
	            viewport.height = view._texture.height;
	            GL.setViewport(viewport);
	            DEFAULTS.COPY_SHADER.execute(RectMesh.DEFAULT, view._texture);
	        }
	    }
	};

	/**
	 * @classdesc
	 * StencilState defines the stencil mode the renderer should use.
	 * @param reference The stencil reference value.
	 * @param comparison The stencil comparison.
	 * @param onStencilFail The operation to use when the stencil test fails.
	 * @param onDepthFail The operation to use when the depth test fails.
	 * @param onPass The operation to use when both tests succeed.
	 * @param readMask The stencil read mask.
	 * @param writeMask The stencil write mask.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function StencilState(reference, comparison, onStencilFail, onDepthFail, onPass, readMask, writeMask)
	{
	    this.enabled = true;
	    this.reference = reference || 0;
	    this.comparison = comparison || Comparison.ALWAYS;
	    this.onStencilFail = onStencilFail || StencilOp.KEEP;
	    this.onDepthFail = onDepthFail || StencilOp.KEEP;
	    this.onPass = onPass || StencilOp.KEEP;
	    this.readMask = readMask === undefined || readMask === null? 0xffffffff : readMask;
	    this.writeMask = writeMask === undefined || writeMask === null? 0xffffffff: writeMask;
	}

	/**
	 * AsyncTaskQueue allows queueing a bunch of functions which are executed "whenever", in order.
	 *
	 * TODO: Allow dynamically adding tasks while running
	 *  -> should we have a AsyncTaskQueue.runChildQueue() which pushed that into a this._childQueues array.
	 *  _executeImpl would then first process these.
	 *  The queue itself can just be passed along the regular queued function parameters if the child methods need access to
	 *  add child queues hierarchically.
	 *
	 * @classdesc
	 *
	 * @ignore
	 *
	 * @constructor
	 */
	function AsyncTaskQueue()
	{
	    this.onComplete = new Signal();
	    this.onProgress = new Signal();
	    this._queue = [];
	    this._childQueues = [];
	    this._currentIndex = 0;
	    this._isRunning = false;
	}

	AsyncTaskQueue.prototype = {
	    queue: function(func, rest)
	    {
	        // V8 engine doesn't perform well if not copying the array first before slicing
	        var args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));

	        this._queue.push({
	            func: func,
	            args: args.slice(1)
	        });
	    },

	    // this allows adding more subtasks to tasks while running
	    // No need to call "execute" on child queues
	    addChildQueue: function(queue)
	    {
	        this._childQueues.push(queue);
	    },

	    execute: function()
	    {
	        if (this._isRunning)
	            throw new Error("Already running!");

	        this._isRunning = true;
	        this._currentIndex = 0;

	        this._executeTask();
	    },

	    _executeTask: function()
	    {
	        setTimeout(this._executeImpl.bind(this));
	    },

	    _executeImpl: function()
	    {
	        this.onProgress.dispatch(this._currentIndex / this._queue.length);

	        if (this._childQueues.length > 0) {
	            var queue = this._childQueues.shift();
	            queue.onComplete.bind(this._executeImpl, this);
	            queue.execute();
	        }
	        else if (this._queue.length === this._currentIndex) {
	            this.onComplete.dispatch();
	        }
	        else {
	            var elm = this._queue[this._currentIndex];
	            elm.func.apply(this, elm.args);
	            ++this._currentIndex;
	            this._executeTask();
	        }
	    }
	};

	var BlitTexture =
	{
	    execute: function(tex)
	    {
			DEFAULTS.COPY_SHADER.execute(RectMesh.DEFAULT, tex);
	    }
	};

	/**
	 * ImageData provides some utilities for images.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var ImageData =
	{
	    /**
	     * Gets image data from an Image.
	     */
	    getFromImage: function(image)
	    {
	        var canvas = document.createElement("canvas");
	        canvas.width = image.naturalWidth;
	        canvas.height = image.naturalHeight;
	        var context = canvas.getContext("2d");
	        context.drawImage(image, 0, 0);
	        return canvas.getImageData(0, 0, canvas.width, canvas.height);
	    }
	};

	/**
	 * MergeSpecularTextures is a utility that generates a single roughness/normalSpecularReflection/metallicness texture
	 * from 3 (optionally) provided separate textures.
	 *
	 * @namespace
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	var MergeSpecularTextures =
	{
	    /**
	     * Merges the 3 provided specular textures into a single one for use with {@linkcode BasicMaterial}.
	     * @param {Texture2D} [roughness] The texture containing monochrome roughness data
	     * @param {Texture2D} [normalSpecular] The texture containing monochrome normal specular reflection data
	     * @param {Texture2D} [metallicness] The texture containing monochrome normal metallicness reflection data
	     * @returns {Texture2D} A texture containing (roughness, normalSpecular, metallicness) on (r,g,b) respectively
	     */
	    merge: function(roughness, normalSpecular, metallicness)
	    {
	        var tex = new Texture2D();
	        tex.initEmpty(roughness.width, roughness.height);
	        var fbo = new FrameBuffer(tex);
	        GL.setRenderTarget(fbo);
	        GL.setClearColor(Color.WHITE);
	        GL.clear();

	        var gl = GL.gl;

	        if (roughness) {
	            gl.colorMask(true, false, false, false);
	            DEFAULTS.COPY_SHADER.execute(RectMesh.DEFAULT, roughness);
	        }

	        if (normalSpecular) {
	            gl.colorMask(false, true, false, false);
	            DEFAULTS.COPY_SHADER.execute(RectMesh.DEFAULT, normalSpecular);
	        }

	        if (metallicness) {
	            gl.colorMask(false, false, true, false);
	            DEFAULTS.COPY_SHADER.execute(RectMesh.DEFAULT, metallicness);
	        }

	        gl.colorMask(true, true, true, true);
	        GL.setRenderTarget(null);
	        GL.setClearColor(Color.BLACK);

	        return tex;
	    }
	};

	/**
	 * Platform contains some platform-dependent utility functions.
	 * @namespace
	 */
	var Platform =
	{
	    _isMobile: undefined,

	    /**
	     * Specifies whether the current platform is a mobile device or not.
	     */
	    get isMobile()
	    {
	        if (this._isMobile === undefined) {
	            var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
	            // This is woefully incomplete. Suggestions for alternative methods welcome.
	            this._isMobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
	        }

	        return this._isMobile;
	    }
	};

	function IntersectionData()
	{
	    this.entity = null;
	    this.component = null;
	    this.point = new Float4();
	    this.faceNormal = new Float4();
	    this.t = Infinity;
	}

	function Potential()
	{
	    this.meshInstance = null;
	    this.closestDistanceSqr = 0;
	    this.objectMatrix = new Matrix4x4();

	    // to store this in a linked list for pooling
	    this.next = null;
	}

	/**
	 * @classdec
	 *
	 * RayCaster sends a ray through the scene and finds the closest intersector.
	 *
	 * @constructor
	 */
	function RayCaster()
	{
	    SceneVisitor.call(this);
	    this._potentials = null;
	    this._potentialPool = new ObjectPool(Potential);
	    this._localRay = new Ray();
	}

	RayCaster.prototype = Object.create(SceneVisitor.prototype);

	/**
	 * Finds the closest intersection point in the scene for the ray.
	 * @param ray The ray in world space coordinates.
	 * @param scene The scene containing the geometry to test.
	 *
	 * TODO: Should also be able to provide a set of objects instead of the scene?
	 */
	RayCaster.prototype.cast = function(ray, scene)
	{
	    this._potentials = [];
	    this._ray = ray;
	    this._scene = scene;

	    this._potentialPool.reset();

	    scene.acceptVisitor(this);

	    this._potentials.sort(this._sortPotentialFunc);
	    var hitData = this._findClosest();

	    // TODO: Provide MeshInstance.rayCastProxy

	    return hitData.entity? hitData : null;
	};

	/**
	 * @ignore
	 */
	RayCaster.prototype.qualifies = function(object)
	{
	    return object.raycast && object.visible && object.worldBounds.intersectsRay(this._ray);
	};

	/**
	 * @ignore
	 */
	RayCaster.prototype.visitMeshInstance = function (meshInstance)
	{
	    var entity = meshInstance._entity;
	    var potential = this._potentialPool.getItem();
	    potential.meshInstance = meshInstance;
	    var dir = this._ray.direction;
	    var dirX = dir.x, dirY = dir.y, dirZ = dir.z;
	    var origin = this._ray.origin;
	    var bounds = entity.worldBounds;
	    var center = bounds.center;
	    var ex = bounds._halfExtentX;
	    var ey = bounds._halfExtentY;
	    var ez = bounds._halfExtentZ;
	    ex = dirX > 0? center.x - ex : center.x + ex;
	    ey = dirY > 0? center.y - ey : center.y + ey;
	    ez = dirZ > 0? center.z - ez : center.z + ez;

	    // this is not required for the order, but when testing the intersection distances
	    ex -= origin.x;
	    ey -= origin.y;
	    ez -= origin.z;

	    // the closest projected point on the ray is the order
	    potential.closestDistanceSqr = ex * dirX + ey * dirY + ez * dirZ;
	    potential.objectMatrix.inverseAffineOf(entity.worldMatrix);

	    this._potentials.push(potential);
	};

	RayCaster.prototype._findClosest = function()
	{
	    var set = this._potentials;
	    var len = set.length;
	    var hitData = new IntersectionData();
	    var worldRay = this._ray;
	    var localRay = this._localRay;

	    for (var i = 0; i < len; ++i) {
	        var elm = set[i];

	        // we can stop searching, everything will be farther from now on
	        if (elm.closestDistanceSqr > hitData.t * hitData.t)
	            break;

	        localRay.transformFrom(worldRay, elm.objectMatrix);

	        if (this._testMesh(localRay, elm.meshInstance.mesh, hitData)) {
	            hitData.entity = elm.meshInstance.entity;
	            hitData.component = elm.meshInstance;
	        }

	    }

	    if (hitData.entity) {
	        var worldMatrix = hitData.entity.worldMatrix;
			worldMatrix.transformPoint(hitData.point, hitData.point);
			worldMatrix.transformNormal(hitData.faceNormal, hitData.faceNormal);
		}

	    return hitData;
	};

	RayCaster.prototype._testMesh = function(ray, mesh, hitData)
	{
	    // to we need to closest position from the others?
	    var dir = ray.direction;
	    var origin = ray.origin;
	    var oX = origin.x, oY = origin.y, oZ = origin.z;
	    var dirX = dir.x, dirY = dir.y, dirZ = dir.z;
	    var attrib = mesh.getVertexAttributeByName("hx_position");
	    var vertices = mesh.getVertexData(attrib.streamIndex);
	    var indices = mesh.getIndexData();
	    var stride = mesh.getVertexStride(attrib.streamIndex);
	    var numIndices = indices.length;
	    var offset = attrib.offset;
	    var updated = false;

	    for (var i = 0; i < numIndices; i += 3) {
	        var i1 = indices[i] * stride + offset;
	        var i2 = indices[i + 1] * stride + offset;
	        var i3 = indices[i + 2] * stride + offset;
	        var x0 = vertices[i1], y0 = vertices[i1 + 1], z0 = vertices[i1 + 2];
	        var x1 = vertices[i2], y1 = vertices[i2 + 1], z1 = vertices[i2 + 2];
	        var x2 = vertices[i3], y2 = vertices[i3 + 1], z2 = vertices[i3 + 2];
	        var dx1 = x1 - x0, dy1 = y1 - y0, dz1 = z1 - z0;
	        var dx2 = x2 - x0, dy2 = y2 - y0, dz2 = z2 - z0;

	        // unnormalized face normal
	        var nx = dy1*dz2 - dz1*dy2;
	        var ny = dz1*dx2 - dx1*dz2;
	        var nz = dx1*dy2 - dy1*dx2;
	        // var rcpLen = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
	        // nx *= rcpLen;
	        // ny *= rcpLen;
	        // nz *= rcpLen;
	        var dot = nx * dirX + ny * dirY + nz * dirZ;

	        // face pointing away from the ray, assume it's invisible
	        if (dot >= 0) continue;

	        // triangle plane through point:
	        var d = -(nx * x0 + ny * y0 + nz * z0);

	        // perpendicular distance origin to plane
	        var t = (nx * oX + ny * oY + nz * oZ + d);

	        if (t < 0) continue;

	        t /= -dot;

	        // behind ray or too far, no need to test if inside
	        if (t >= hitData.t) continue;

	        var px = t * dirX + oX, py = t * dirY + oY, pz = t * dirZ + oZ;

	        var dpx = px - x0, dpy = py - y0, dpz = pz - z0;
	        var dot11 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;
	        var dot22 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;
	        var dot12 = dx1 * dx2 + dy1 * dy2 + dz1 * dz2;
	        var denom = dot11 * dot22 - dot12 * dot12;

	        // degenerate triangles
	        if (denom === 0.0) continue;

	        var dotp1 = dpx * dx1 + dpy * dy1 + dpz * dz1;
	        var dotp2 = dpx * dx2 + dpy * dy2 + dpz * dz2;

	        var rcpDenom = 1.0 / denom;

	        var u = (dot22 * dotp1 - dot12 * dotp2) * rcpDenom;
	        var v = (dot11 * dotp2 - dot12 * dotp1) * rcpDenom;

	        if ((u >= 0) && (v >= 0) && (u + v <= 1.0)) {
	            hitData.faceNormal.set(nx, ny, nz, 0.0);
	            hitData.point.set(px, py, pz, 1.0);
	            hitData.t = t;
	            updated = true;
	        }
	    }

		hitData.faceNormal.normalize();
	    return updated;
	};

	RayCaster.prototype._sortPotentialFunc = function(a, b)
	{
	    return a.closestDistanceSqr - b.closestDistanceSqr;
	};

	/**
	 * @classdesc
	 * A utility class to keep track of teh frame rate. It keeps a running average for the last few frames.
	 *
	 * @param numFrames The amount of frames to average.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */
	function FPSCounter(numFrames)
	{
	    this._numFrames = numFrames || 1;
	    this._frames = [ ];
	    this._maxFPS = undefined;
	    this._minFPS = undefined;
	    this._currentFPS = 0;
	    this._averageFPS = 0;
	    this._runningSum = 0;

	    for (var i = 0; i < this._numFrames; ++i)
	        this._frames[i] = 0;

	    this._index = 0;
	}

	FPSCounter.prototype =
	{
	    /**
	     * Updates the counter with a new frame time
	     * @param dt The time in milliseconds since the last frame
	     */
	    update: function(dt)
	    {
	        this._currentFPS = 1000 / dt;

	        this._runningSum -= this._frames[this._index];
	        this._runningSum += this._currentFPS;
	        this._averageFPS = this._runningSum / this._numFrames;
	        this._frames[this._index++] = this._currentFPS;

	        if (this._index === this._numFrames) this._index = 0;

	        if (this._maxFPS === undefined || this._currentFPS > this._maxFPS)
	            this._maxFPS = this._currentFPS;

	        if (this._minFPS === undefined || this._currentFPS < this._minFPS)
	            this._minFPS = this._currentFPS;


	    },

	    /**
	     * Returns the last frame's fps.
	     */
	    get lastFrameFPS()
	    {
	        return Math.round(this._currentFPS);
	    },

	    /**
	     * Returns the running average fps.
	     */
	    get averageFPS()
	    {
	        return Math.round(this._averageFPS);
	    },

	    /**
	     * Returns the maximum fps since last reset.
	     */
	    get maxFPS()
	    {
	        return Math.round(this._maxFPS);
	    },

	    /**
	     * Returns the minimum fps since last reset.
	     */
	    get minFPS()
	    {
	        return Math.round(this._minFPS);
	    },

	    /**
	     * Resets minimum and maximum fps stats.
	     */
	    reset: function()
	    {
	        this._maxFPS = undefined;
	        this._minFPS = undefined;
	    }
	};

	/**
	 * @classdesc
	 * StatsDisplay is a simple display for render statistics.
	 *
	 * @param container The DOM element to add the stats to.
	 * @constructor
	 *
	 * @author derschmale <http://www.derschmale.com>
	 */

	function StatsDisplay(container)
	{
	    this._fpsCounter = new FPSCounter(30);
	    this._width = 100;
	    this._height = 95;

	    this._dpr = window.devicePixelRatio || 1;

	    this._elm = document.createElement("canvas");
	    this._elm.style.position = "fixed";
	    this._elm.style.left = "5px";
	    this._elm.style.top = "5px";
	    this._elm.style.width = this._width + "px";
	    this._elm.style.height = this._height + "px";
	    this._elm.width = this._pixelWidth = this._width * this._dpr;
	    this._elm.height = this._pixelHeight = this._height * this._dpr;

	    var fontSize = 10 * this._dpr;
	    this._context = this._elm.getContext( '2d' );
	    this._context.font = fontSize + 'px "Lucida Console",Monaco,monospace';
	    // this._context.globalAlpha = 0;

	    container = container || document.getElementsByTagName("body")[0];
	    container.appendChild(this._elm);

	    onPreFrame.bind(this._update, this);
	}

	StatsDisplay.prototype =
	{
	    /**
	     * Removes the stats display from the container.
	     */
	    remove: function()
	    {
	        this._elm.parentNode.removeChild(this._elm);
	    },

	    _update: function(dt)
	    {
	        // when switching to VR context
	        if (dt === 0.0) dt = 16;

	        this._fpsCounter.update(dt);

	        var ctx = this._context;

	        ctx.fillStyle = "rgba(0, 0, 0, .5)";
	        ctx.fillRect(0, 0, this._pixelWidth, this._pixelHeight);

	        var innerTime = frameTime.toFixed(1);
	        var outerTime = dt.toFixed(1);

	        ctx.fillStyle = "#fff";
	        ctx.fillText("FPS: " + this._fpsCounter.averageFPS, 10 * this._dpr, 15 * this._dpr);
	        ctx.fillText("Time: " + innerTime + " (" + outerTime + ") ", 10 * this._dpr, 30 * this._dpr);
	        ctx.fillText("Draws: " + _glStats.numDrawCalls, 10 * this._dpr, 45 * this._dpr);
	        ctx.fillText("Tris: " + _glStats.numTriangles, 10 * this._dpr, 60 * this._dpr);
	        ctx.fillText("Clears: " + _glStats.numClears, 10 * this._dpr, 75 * this._dpr);
	    }
	};

	try {
	    var webvrPolyFill = new WebVRPolyfill();
	}
	catch(err) {
	    // probably IE's lack of Promise, just swallow the error
	}

	exports.ShaderLibrary = ShaderLibrary;
	exports.init = init;
	exports.destroy = destroy;
	exports.start = start;
	exports.stop = stop;
	exports.META = META;
	exports.capabilities = capabilities;
	exports.onPreFrame = onPreFrame;
	exports.onFrame = onFrame;
	exports.TextureFilter = TextureFilter;
	exports.CullMode = CullMode;
	exports.StencilOp = StencilOp;
	exports.Comparison = Comparison;
	exports.ElementType = ElementType;
	exports.BlendFactor = BlendFactor;
	exports.BlendOperation = BlendOperation;
	exports.ClearMask = ClearMask;
	exports.InitOptions = InitOptions;
	exports.TextureFormat = TextureFormat;
	exports.DataType = DataType;
	exports.BufferUsage = BufferUsage;
	exports.CubeFace = CubeFace;
	exports.getVRDisplays = getVRDisplays;
	exports.enableVR = enableVR;
	exports.disableVR = disableVR;
	exports.onGamepadConnected = onGamepadConnected;
	exports.onGamepadDisconnected = onGamepadDisconnected;
	exports.getGamepads = getGamepads;
	exports.getGamepad = getGamepad;
	exports.Float2 = Float2;
	exports.Float4 = Float4;
	exports.CenteredGaussianCurve = CenteredGaussianCurve;
	exports.MathX = MathX;
	exports.Matrix4x4 = Matrix4x4;
	exports.PlaneSide = PlaneSide;
	exports.PoissonDisk = PoissonDisk;
	exports.PoissonSphere = PoissonSphere;
	exports.Quaternion = Quaternion;
	exports.Ray = Ray;
	exports.Transform = Transform;
	exports.Debug = Debug;
	exports.DebugAxes = DebugAxes;
	exports.BoundingVolume = BoundingVolume;
	exports.BoundingAABB = BoundingAABB;
	exports.BoundingSphere = BoundingSphere;
	exports.SceneNode = SceneNode;
	exports.Scene = Scene;
	exports.SceneVisitor = SceneVisitor;
	exports.Skybox = Skybox;
	exports.Terrain = Terrain;
	exports.Entity = Entity;
	exports.EntitySystem = EntitySystem;
	exports.EntitySet = EntitySet;
	exports.Component = Component;
	exports.CompositeComponent = CompositeComponent;
	exports.KeyFrame = KeyFrame;
	exports.AnimationClip = AnimationClip;
	exports.AnimationPlayhead = AnimationPlayhead;
	exports.LayeredAnimation = LayeredAnimation;
	exports.AnimationLayer = AnimationLayer;
	exports.AnimationLayerFloat4 = AnimationLayerFloat4;
	exports.AnimationLayerQuat = AnimationLayerQuat;
	exports.AnimationLayerMorphTarget = AnimationLayerMorphTarget;
	exports.MorphAnimation = MorphAnimation;
	exports.MorphPose = MorphPose;
	exports.MorphTarget = MorphTarget;
	exports.Skeleton = Skeleton;
	exports.SkeletonAnimation = SkeletonAnimation;
	exports.SkeletonBinaryLerpNode = SkeletonBinaryLerpNode;
	exports.SkeletonBlendNode = SkeletonBlendNode;
	exports.SkeletonBlendTree = SkeletonBlendTree;
	exports.SkeletonClipNode = SkeletonClipNode;
	exports.SkeletonFreePoseNode = SkeletonFreePoseNode;
	exports.SkeletonJoint = SkeletonJoint;
	exports.SkeletonJointPose = SkeletonJointPose;
	exports.SkeletonPose = SkeletonPose;
	exports.SkeletonXFadeNode = SkeletonXFadeNode;
	exports.AudioClip = AudioClip;
	exports.AudioDistanceModel = AudioDistanceModel;
	exports.AudioPanningModel = AudioPanningModel;
	exports.AudioEmitter = AudioEmitter;
	exports.AudioListener = AudioListener;
	exports.Camera = Camera;
	exports.Frustum = Frustum;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicOffCenterCamera = OrthographicOffCenterCamera;
	exports.VRCamera = VRCamera;
	exports.Color = Color;
	exports.DataStream = DataStream;
	exports.GL = GL;
	exports.Signal = Signal;
	exports.Messenger = Messenger;
	exports.Bloom = Bloom;
	exports.Blur = Blur;
	exports.CopyTexturePass = CopyTexturePass;
	exports.Effect = Effect;
	exports.EffectPass = EffectPass;
	exports.FilmicToneMapping = FilmicToneMapping;
	exports.Fog = Fog;
	exports.FXAA = FXAA;
	exports.GaussianBlurPass = GaussianBlurPass;
	exports.HBAO = HBAO;
	exports.SSAO = SSAO;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Input = Input;
	exports.Gamepad = Gamepad;
	exports.Keyboard = Keyboard;
	exports.Mouse = Mouse;
	exports.MouseLock = MouseLock;
	exports.Touch = Touch;
	exports.AssetLibrary = AssetLibrary;
	exports.AssetLoader = AssetLoader;
	exports.AudioFile = AudioFile;
	exports.URLLoader = URLLoader;
	exports.HCLIP = HCLIP;
	exports.HCM = HCM;
	exports.HMAT = HMAT;
	exports.HMESH = HMESH;
	exports.Importer = Importer;
	exports.JPG_EQUIRECTANGULAR = JPG_EQUIRECTANGULAR;
	exports.PNG_EQUIRECTANGULAR = PNG_EQUIRECTANGULAR;
	exports.JPG_HEIGHTMAP = JPG_HEIGHTMAP;
	exports.PNG_HEIGHTMAP = PNG_HEIGHTMAP;
	exports.JPG = JPG;
	exports.PNG = PNG;
	exports.AmbientLight = AmbientLight;
	exports.DirectionalLight = DirectionalLight;
	exports.Light = Light;
	exports.DirectLight = DirectLight;
	exports.LightProbe = LightProbe;
	exports.DynamicLightProbe = DynamicLightProbe;
	exports.PointLight = PointLight;
	exports.SpotLight = SpotLight;
	exports.ShadowFilter = ShadowFilter;
	exports.ExponentialShadowFilter = ExponentialShadowFilter;
	exports.HardShadowFilter = HardShadowFilter;
	exports.PCFShadowFilter = PCFShadowFilter;
	exports.VarianceShadowFilter = VarianceShadowFilter;
	exports.MaterialPass = MaterialPass;
	exports.Material = Material;
	exports.BasicMaterial = BasicMaterial;
	exports.SkyboxMaterial = SkyboxMaterial;
	exports.Mesh = Mesh;
	exports.MeshInstance = MeshInstance;
	exports.SpherePrimitive = SpherePrimitive;
	exports.BoxPrimitive = BoxPrimitive;
	exports.Primitive = Primitive;
	exports.ConePrimitive = ConePrimitive;
	exports.CylinderPrimitive = CylinderPrimitive;
	exports.PlanePrimitive = PlanePrimitive;
	exports.TorusPrimitive = TorusPrimitive;
	exports.WireBoxPrimitive = WireBoxPrimitive;
	exports.WirePlanePrimitive = WirePlanePrimitive;
	exports.BlendState = BlendState;
	exports.Renderer = Renderer;
	exports.VRRenderer = VRRenderer;
	exports.LightingModel = LightingModel;
	exports.View = View;
	exports.MultiRenderer = MultiRenderer;
	exports.StencilState = StencilState;
	exports.FrameBuffer = FrameBuffer;
	exports.Texture2D = Texture2D;
	exports.TextureCube = TextureCube;
	exports.TextureUtils = TextureUtils;
	exports.WriteOnlyDepthBuffer = WriteOnlyDepthBuffer;
	exports.AsyncTaskQueue = AsyncTaskQueue;
	exports.ArrayUtils = ArrayUtils;
	exports.BlitTexture = BlitTexture;
	exports.EquirectangularTexture = EquirectangularTexture;
	exports.HeightMap = HeightMap;
	exports.ImageData = ImageData;
	exports.MergeSpecularTextures = MergeSpecularTextures;
	exports.NormalTangentGenerator = NormalTangentGenerator;
	exports.Platform = Platform;
	exports.RayCaster = RayCaster;
	exports.StatsDisplay = StatsDisplay;
	exports.VRDisplay = VRDisplay;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
