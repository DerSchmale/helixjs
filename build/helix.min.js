HX={VERSION:"0.1",TypedArray:"undefined"!=typeof Float32Array?Float32Array:Array},HX.InitOptions=function(){this.useHDR=!1,this.useLinearSpace=!0,this.customLights=[],this.debug=!1,this.ignoreDrawBuffersExtension=!1,this.ignoreDepthTexturesExtension=!1,this.ignoreTextureLODExtension=!1,this.ignoreHalfFloatTextureExtension=!1,this.throwOnShaderError=!0,this.lightingModel=HX.BlinnPhongSimpleLightingModel},HX.ShaderLibrary={get:function(t,e){var i="";for(var r in e)e.hasOwnProperty(r)&&(i+="#define "+r+" "+e[r]+"\n");return i+HX.ShaderLibrary[t]}},HX._numActiveAttributes=0,HX._numActiveTextures=0,HX.initFromContext=function(t,e){function i(t){return r.indexOf(t)>=0?HX.GL.getExtension(t):null}HX.OPTIONS=e||new HX.InitOptions,HX.GL=t;var r=HX.GL.getSupportedExtensions();HX._initLights(),HX.LIGHTING_MODEL=HX.OPTIONS.lightingModel;var n="";HX.OPTIONS.useLinearSpace!==!1&&(n+="#define HX_LINEAR_SPACE\n"),HX.OPTIONS.ignoreDrawBuffersExtension||(HX.EXT_DRAW_BUFFERS=i("WEBGL_draw_buffers")),HX.EXT_DRAW_BUFFERS&&HX.EXT_DRAW_BUFFERS.MAX_DRAW_BUFFERS_WEBGL>=3?n+="#extension GL_EXT_draw_buffers : require\n":(n+="#define HX_SEPARATE_GEOMETRY_PASSES\n",console.warn("WEBGL_draw_buffers extension not supported!"),HX.EXT_DRAW_BUFFERS=null),HX.MaterialPass.NUM_PASS_TYPES+=HX.EXT_DRAW_BUFFERS?0:2,HX.EXT_FLOAT_TEXTURES=i("OES_texture_float"),HX.EXT_FLOAT_TEXTURES||console.warn("OES_texture_float extension not supported!"),HX.OPTIONS.ignoreHalfFloatTextureExtension||(HX.EXT_HALF_FLOAT_TEXTURES=i("OES_texture_half_float")),HX.EXT_HALF_FLOAT_TEXTURES||console.warn("OES_texture_half_float extension not supported!"),HX.EXT_FLOAT_TEXTURES_LINEAR=i("OES_texture_float_linear"),HX.EXT_FLOAT_TEXTURES_LINEAR||console.warn("OES_texture_float_linear extension not supported!"),HX.EXT_HALF_FLOAT_TEXTURES_LINEAR=i("OES_texture_half_float_linear"),HX.EXT_HALF_FLOAT_TEXTURES_LINEAR||console.warn("OES_texture_half_float_linear extension not supported!"),HX.OPTIONS.ignoreDepthTexturesExtension||(HX.EXT_DEPTH_TEXTURE=i("WEBGL_depth_texture")),HX.EXT_DEPTH_TEXTURE||(console.warn("WEBGL_depth_texture extension not supported!"),n+="#define HX_NO_DEPTH_TEXTURES\n",HX.MaterialPass.SHADOW_MAP_PASS=HX.MaterialPass.NUM_PASS_TYPES++),HX.EXT_STANDARD_DERIVATIVES=i("OES_standard_derivatives"),HX.EXT_STANDARD_DERIVATIVES||console.warn("OES_standard_derivatives extension not supported!"),HX.OPTIONS.ignoreTextureLODExtension||(HX.EXT_SHADER_TEXTURE_LOD=i("EXT_shader_texture_lod")),HX.EXT_SHADER_TEXTURE_LOD||console.warn("EXT_shader_texture_lod extension not supported!"),HX.EXT_TEXTURE_FILTER_ANISOTROPIC=i("EXT_texture_filter_anisotropic"),HX.EXT_TEXTURE_FILTER_ANISOTROPIC||console.warn("EXT_texture_filter_anisotropic extension not supported!"),HX.DEFAULT_TEXTURE_MAX_ANISOTROPY=HX.EXT_TEXTURE_FILTER_ANISOTROPIC?HX.GL.getParameter(HX.EXT_TEXTURE_FILTER_ANISOTROPIC.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,HX.EXT_HALF_FLOAT_TEXTURES_LINEAR&&HX.EXT_HALF_FLOAT_TEXTURES||(HX.OPTIONS.useHDR=!1),HX.HDR_FORMAT=HX.OPTIONS.useHDR?HX.EXT_HALF_FLOAT_TEXTURES.HALF_FLOAT_OES:HX.GL.UNSIGNED_BYTE,HX.GLSLIncludeGeneral=n+HX.GLSLIncludeGeneral,HX._initGLProperties();var a=new Uint8Array([255,0,255,255]);HX.DEFAULT_TEXTURE_2D=new HX.Texture2D,HX.DEFAULT_TEXTURE_2D.uploadData(a,1,1,!0),HX.DEFAULT_TEXTURE_2D.setFilter(HX.TextureFilter.NEAREST_NOMIP),HX.DEFAULT_TEXTURE_CUBE=new HX.TextureCube,HX.DEFAULT_TEXTURE_CUBE.uploadData([a,a,a,a,a,a],1,!0),HX.DEFAULT_TEXTURE_CUBE.setFilter(HX.TextureFilter.NEAREST_NOMIP);var s=new HX.PoissonDisk,o=new HX.PoissonSphere;s.generatePoints(64),o.generatePoints(64),HX.DEFAULT_POISSON_DISK=new Float32Array(128),HX.DEFAULT_POISSON_SPHERE=new Float32Array(192);for(var h=s.getPoints(),_=o.getPoints(),l=0;64>l;++l){var c=h[l];HX.DEFAULT_POISSON_DISK[2*l]=c.x,HX.DEFAULT_POISSON_DISK[2*l+1]=c.y,c=_[l],HX.DEFAULT_POISSON_SPHERE[3*l]=c.x,HX.DEFAULT_POISSON_SPHERE[3*l+1]=c.y,HX.DEFAULT_POISSON_SPHERE[3*l+2]=c.z}HX._init2DDitherTexture(32,32)},HX.initFromCanvas=function(canvas,options){var webglFlags={antialias:!1,premultipliedAlpha:!1},context=canvas.getContext("webgl",webglFlags)||canvas.getContext("experimental-webgl",webglFlags);if(options&&options.debug&&eval("context = WebGLDebugUtils.makeDebugContext(context);"),HX.initFromContext(context,options),!HX.GL)throw"WebGL not supported";HX.GL.clearColor(0,0,0,1)},HX.clear=function(){HX.GL.clear(HX.GL.COLOR_BUFFER_BIT|HX.GL.DEPTH_BUFFER_BIT|HX.GL.STENCIL_BUFFER_BIT)},HX.unbindTextures=function(){for(var t=0;t<HX._numActiveTextures;++t)HX.GL.activeTexture(HX.GL.TEXTURE0+t),HX.GL.bindTexture(HX.GL.TEXTURE_2D,null);HX._numActiveTextures=0},HX.setRenderTarget=function(t){t?(HX.GL.bindFramebuffer(HX.GL.FRAMEBUFFER,t._fbo),t._numColorTextures>1&&HX.EXT_DRAW_BUFFERS.drawBuffersWEBGL(t._drawBuffers)):HX.GL.bindFramebuffer(HX.GL.FRAMEBUFFER,null)},HX.enableAttributes=function(t){var e=HX._numActiveAttributes;if(t>e)for(var i=e;t>i;++i)HX.GL.enableVertexAttribArray(i);else if(e>t){t+=1;for(var i=t;e>i;++i)HX.GL.disableVertexAttribArray(i)}HX._numActiveAttributes=2},HX._initLights=function(){HX.LIGHT_TYPES=[HX.AmbientLight,HX.DirectionalLight,HX.PointLight].concat(HX.OPTIONS.customLights);for(var t=0;t<HX.LIGHT_TYPES.length;++t){var e=HX.LIGHT_TYPES[t],i=function(){var e=t;return function(){return e}};e.prototype.getTypeID=i()}},HX._init2DDitherTexture=function(t,e){HX.DEFAULT_2D_DITHER_TEXTURE=new HX.Texture2D;for(var i=t*e,r=1/i,n=[],a=0,s=[],o=0;i>o;++o)s.push(o/i);HX.shuffle(s);for(var o=0;i>o;++o){var h=s[o]*Math.PI*2,_=Math.cos(h),l=Math.sin(h);n[a++]=_,n[a++]=l,n[a++]=r+s[o],n[a++]=1}HX.DEFAULT_2D_DITHER_TEXTURE.uploadData(new Float32Array(n),t,e,!1,HX.GL.RGBA,HX.GL.FLOAT),HX.DEFAULT_2D_DITHER_TEXTURE.setFilter(HX.TextureFilter.NEAREST_NOMIP),HX.DEFAULT_2D_DITHER_TEXTURE.setWrapMode(HX.TextureWrapMode.REPEAT)},HX._initGLProperties=function(){HX.TextureFilter={},HX.TextureFilter.NEAREST={min:HX.GL.NEAREST_MIPMAP_NEAREST,mag:HX.GL.NEAREST},HX.TextureFilter.BILINEAR={min:HX.GL.LINEAR_MIPMAP_NEAREST,mag:HX.GL.LINEAR},HX.TextureFilter.TRILINEAR={min:HX.GL.LINEAR_MIPMAP_LINEAR,mag:HX.GL.LINEAR},HX.EXT_TEXTURE_FILTER_ANISOTROPIC&&(HX.TextureFilter.TRILINEAR_ANISOTROPIC={min:HX.GL.LINEAR_MIPMAP_LINEAR,mag:HX.GL.LINEAR}),HX.TextureFilter.NEAREST_NOMIP={min:HX.GL.NEAREST,mag:HX.GL.NEAREST},HX.TextureFilter.BILINEAR_NOMIP={min:HX.GL.LINEAR,mag:HX.GL.LINEAR},HX.TextureWrapMode={},HX.TextureWrapMode.REPEAT={s:HX.GL.REPEAT,t:HX.GL.REPEAT},HX.TextureWrapMode.CLAMP={s:HX.GL.CLAMP_TO_EDGE,t:HX.GL.CLAMP_TO_EDGE},HX.TextureWrapMode.DEFAULT=HX.TextureWrapMode.REPEAT,HX.TextureFilter.DEFAULT=HX.TextureFilter.TRILINEAR,HX.CullMode={NONE:null,BACK:HX.GL.BACK,FRONT:HX.GL.FRONT,ALL:HX.GL.FRONT_AND_BACK},HX.ElementType={POINTS:HX.GL.POINTS,LINES:HX.GL.LINES,LINE_STRIP:HX.GL.LINE_STRIP,LINE_LOOP:HX.GL.LINE_LOOP,TRIANGLES:HX.GL.TRIANGLES,TRIANGLE_STRIP:HX.GL.TRIANGLE_STRIP,TRIANGLE_FAN:HX.GL.TRIANGLE_FAN},HX.BlendFactor={ZERO:HX.GL.ZERO,ONE:HX.GL.ONE,SOURCE_COLOR:HX.GL.SRC_COLOR,ONE_MINUS_SOURCE_COLOR:HX.GL.ONE_MINUS_SRC_COLOR,DESTINATION_COLOR:HX.GL.DST_COLOR,ONE_MINUS_DESTINATION_COLOR:HX.GL.ONE_MINUS_DST_COLOR,SOURCE_ALPHA:HX.GL.SRC_ALPHA,ONE_MINUS_SOURCE_ALPHA:HX.GL.ONE_MINUS_SRC_ALPHA,DESTINATION_ALPHA:HX.GL.DST_ALPHA,ONE_MINUS_DESTINATION_ALPHA:HX.GL.ONE_MINUS_DST_ALPHA,SOURCE_ALPHA_SATURATE:HX.GL.SRC_ALPHA_SATURATE},HX.BlendOperation={ADD:HX.GL.FUNC_ADD,SUBTRACT:HX.GL.FUNC_SUBTRACT,REVERSE_SUBTRACT:HX.GL.FUNC_REVERSE_SUBTRACT}},HX.ShaderLibrary["lighting_blinn_phong_full.glsl"]="float hx_lightVisibility(in vec3 normal, in vec3 viewDir, float roughness, float nDotL)\n{\n	float nDotV = max(-dot(normal, viewDir), 0.0);\n	// roughness remapping, this is essentially: sqrt(2 * roughness * roughness / PI)\n	// this remaps beckman distribution roughness to SmithSchlick\n	roughness *= .63772;\n	float g1 = nDotV*(1.0 - roughness) + roughness;\n	float g2 = nDotL*(1.0 - roughness) + roughness;\n	return 1.0/(g1*g2);\n}\n\nfloat hx_blinnPhongDistribution(float roughness, vec3 normal, vec3 halfVector)\n{\n	float roughSqr = roughness*roughness;\n	roughSqr *= roughSqr;\n	float halfDotNormal = max(-dot(halfVector, normal), 0.0);\n	// the\n	return pow(halfDotNormal, 2.0/roughSqr - 2.0)/roughSqr;\n}\n\nvoid hx_lighting(in vec3 normal, in vec3 lightDir, in vec3 viewDir, in vec3 lightColor, vec3 specularNormalReflection, float roughness, out vec3 diffuseColor, out vec3 specularColor)\n{\n	float nDotL = max(-dot(lightDir, normal), 0.0);\n	vec3 irradiance = nDotL * lightColor;	// in fact irradiance / PI\n\n	vec3 halfVector = normalize(lightDir + viewDir);\n\n	float distribution = hx_blinnPhongDistribution(roughness, normal, halfVector);\n\n	float visibility = hx_lightVisibility(normal, lightDir, roughness, nDotL);\n\n	float halfDotLight = dot(halfVector, lightDir);\n	float cosAngle = 1.0 - halfDotLight;\n	// to the 5th power\n	float power = cosAngle*cosAngle;\n	power *= power;\n	power *= cosAngle;\n	vec3 fresnel = specularNormalReflection + (1.0 - specularNormalReflection)*power;\n\n	//approximated fresnel-based energy conservation\n	diffuseColor = irradiance;\n\n	specularColor = .25 * irradiance * fresnel * distribution * visibility;\n}",HX.ShaderLibrary["lighting_blinn_phong_simple.glsl"]="void hx_lighting(in vec3 normal, in vec3 lightDir, in vec3 viewDir, in vec3 lightColor, vec3 specularNormalReflection, float roughness, out vec3 diffuseColor, out vec3 specularColor)\n{\n	float nDotL = max(-dot(lightDir, normal), 0.0);\n	vec3 irradiance = nDotL * lightColor;	// in fact irradiance / PI\n\n	vec3 halfVector = normalize(lightDir + viewDir);\n\n	highp float roughSqr = roughness*roughness;\n	roughSqr *= roughSqr;\n	highp float halfDotNormal = max(-dot(halfVector, normal), 0.0);\n	highp float distribution = pow(halfDotNormal, 2.0/roughSqr - 2.0)/roughSqr;\n\n	float halfDotLight = dot(halfVector, lightDir);\n	float cosAngle = 1.0 - halfDotLight;\n	// to the 5th power\n	float power = cosAngle*cosAngle;\n	power *= power;\n	power *= cosAngle;\n	vec3 fresnel = specularNormalReflection + (1.0 - specularNormalReflection)*power;\n\n	//approximated fresnel-based energy conservation\n	diffuseColor = irradiance;\n\n	specularColor = .25 * irradiance * fresnel * distribution;\n}",HX.ShaderLibrary["lighting_ggx.glsl"]="float hx_lightVisibility(vec3 normal, vec3 viewDir, float roughness, float nDotL)\n{\n	float nDotV = max(-dot(normal, viewDir), 0.0);\n	// roughness remapping, this is essentially: sqrt(2 * roughness * roughness / PI)\n	// this remaps beckman distribution roughness to SmithSchlick\n	roughness *= .63772;\n	float g1 = nDotV*(1.0 - roughness) + roughness;\n	float g2 = nDotL*(1.0 - roughness) + roughness;\n	return 1.0/(g1*g2);\n}\n\nfloat hx_trowbridgeReitz(float roughness, vec3 normal, vec3 halfVector)\n{\n    float roughSqr = roughness*roughness;\n    float halfDotNormal = max(-dot(halfVector, normal), 0.0);\n    float denom = (halfDotNormal * halfDotNormal) * (roughSqr - 1.0) + 1.0;\n    return roughSqr / (denom * denom);\n}\n\nvoid hx_lighting(in vec3 normal, in vec3 lightDir, in vec3 viewDir, in vec3 lightColor, vec3 specularNormalReflection, float roughness, out vec3 diffuseColor, out vec3 specularColor)\n{\n	float nDotL = max(-dot(lightDir, normal), 0.0);\n	vec3 irradiance = nDotL * lightColor;	// in fact irradiance / PI\n\n	vec3 halfVector = normalize(lightDir + viewDir);\n\n	float distribution = hx_trowbridgeReitz(roughness, normal, halfVector);\n\n	float visibility = hx_lightVisibility(normal, lightDir, roughness, nDotL);\n\n	float halfDotLight = dot(halfVector, lightDir);\n	float cosAngle = 1.0 - halfDotLight;\n	// to the 5th power\n	float power = cosAngle*cosAngle;\n	power *= power;\n	power *= cosAngle;\n	vec3 fresnel = specularNormalReflection + (1.0 - specularNormalReflection)*power;\n\n	//approximated fresnel-based energy conservation\n	diffuseColor = irradiance;\n\n	specularColor = .25 * irradiance * fresnel * distribution * visibility;\n}",HX.ShaderLibrary["ambient_light_fragment.glsl"]="uniform vec3 lightColor;\n\nuniform sampler2D hx_gbufferColor;\n\n#ifdef USE_AO\nuniform sampler2D hx_source;\n#endif\n\nvarying vec2 uv;\n\nvoid main()\n{\n	vec3 colorSample = texture2D(hx_gbufferColor, uv).xyz;\n#ifdef USE_AO\n	float occlusionSample = texture2D(hx_source, uv).w;\n	colorSample *= occlusionSample;\n#endif\n\n	gl_FragColor = vec4(lightColor * colorSample, 0.0);\n}",HX.ShaderLibrary["ambient_light_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\n\nvoid main()\n{\n	uv = hx_texCoord;\n	gl_Position = hx_position;\n}",HX.ShaderLibrary["directional_light_fragment.glsl"]="uniform vec3 lightColor;\nuniform vec3 lightViewDirection;\n\nvarying vec2 uv;\nvarying vec3 viewDir;\n\nuniform sampler2D hx_gbufferColor;\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D hx_gbufferSpecular;\n\n#ifdef CAST_SHADOWS\n	uniform sampler2D hx_gbufferDepth;\n	uniform sampler2D shadowMap;\n\n	uniform float hx_cameraFrustumRange;\n	uniform float hx_cameraNearPlaneDistance;\n\n	uniform mat4 shadowMapMatrices[NUM_CASCADES];\n	uniform float splitDistances[NUM_CASCADES];\n	uniform float depthBias;\n\n	#if NUM_SHADOW_SAMPLES > 1\n		uniform sampler2D hx_dither2D;\n		uniform vec2 hx_dither2DTextureScale;\n\n		uniform vec2 shadowMapSoftnesses[NUM_CASCADES];\n		uniform vec2 hx_poissonDisk[NUM_SHADOW_SAMPLES];\n	#endif\n\n	float readDepth(vec2 uv)\n	{\n	#ifdef HX_NO_DEPTH_TEXTURES\n		return hx_RGBA8ToFloat(texture2D(shadowMap, uv));\n	#else\n		return texture2D(shadowMap, uv).x;\n	#endif\n	}\n\n	// view-space position\n	#if NUM_SHADOW_SAMPLES > 1\n	void getShadowMapCoord(in vec3 viewPos, out vec4 coord, out vec2 softness)\n	#else\n	void getShadowMapCoord(in vec3 viewPos, out vec4 coord)\n	#endif\n	{\n		mat4 shadowMapMatrix = shadowMapMatrices[NUM_CASCADES - 1];\n\n		#if NUM_CASCADES > 1\n		for (int i = 0; i < NUM_CASCADES - 1; ++i) {\n			if (viewPos.z < splitDistances[i]) {\n				shadowMapMatrix = shadowMapMatrices[i];\n				#if NUM_SHADOW_SAMPLES > 1\n					softness = shadowMapSoftnesses[i];\n				#endif\n				break;\n			}\n		}\n		#else\n			shadowMapMatrix = shadowMapMatrices[0];\n			#if NUM_SHADOW_SAMPLES > 1\n				softness = shadowMapSoftnesses[0];\n			#endif\n		#endif\n		coord = shadowMapMatrix * vec4(viewPos, 1.0);\n	}\n#endif\n\n\nvec3 hx_calculateLight(vec3 diffuseAlbedo, vec3 normal, vec3 lightDir, vec3 viewVector, vec3 normalSpecularReflectance, float roughness, float metallicness)\n{\n// start extractable code (for fwd)\n	vec3 diffuseReflection;\n	vec3 specularReflection;\n\n	hx_lighting(normal, lightDir, normalize(viewVector), lightColor, normalSpecularReflectance, roughness, diffuseReflection, specularReflection);\n\n	diffuseReflection *= diffuseAlbedo * (1.0 - metallicness);\n	vec3 totalReflection = diffuseReflection + specularReflection;\n\n	#ifdef CAST_SHADOWS\n		float depth = hx_sampleLinearDepth(hx_gbufferDepth, uv);\n		float viewZ = hx_cameraNearPlaneDistance + depth * hx_cameraFrustumRange;\n		vec3 viewPos = viewZ * viewVector;\n\n		vec4 shadowMapCoord;\n		#if NUM_SHADOW_SAMPLES > 1\n			vec2 radii;\n			getShadowMapCoord(viewPos, shadowMapCoord, radii);\n			float shadowTest = 0.0;\n			vec4 dither = texture2D(hx_dither2D, uv * hx_dither2DTextureScale);\n			dither = vec4(dither.x, -dither.y, dither.y, dither.x) * radii.xxyy;  // add radius scale\n			for (int i = 0; i < NUM_SHADOW_SAMPLES; ++i) {\n				vec2 offset;\n				offset.x = dot(dither.xy, hx_poissonDisk[i]);\n				offset.y = dot(dither.zw, hx_poissonDisk[i]);\n				float shadowSample = readDepth(shadowMapCoord.xy + offset);\n				float diff = shadowMapCoord.z - shadowSample - depthBias;\n				shadowTest += float(diff < 0.0);\n			}\n			shadowTest /= float(NUM_SHADOW_SAMPLES);\n		#else\n			getShadowMapCoord(viewPos, shadowMapCoord);\n			float shadowSample = readDepth(shadowMapCoord.xy);\n			float diff = shadowMapCoord.z - shadowSample - depthBias;\n			float shadowTest = float(diff < 0.0);\n		#endif\n		totalReflection *= shadowTest;\n\n	#endif\n\n    return totalReflection;\n}\n\nvoid main()\n{\n	vec4 colorSample = texture2D(hx_gbufferColor, uv);\n	vec4 normalSample = texture2D(hx_gbufferNormals, uv);\n	vec4 specularSample = texture2D(hx_gbufferSpecular, uv);\n	vec3 normal = hx_decodeNormal(normalSample);\n	vec3 normalSpecularReflectance;\n	float roughness;\n	float metallicness;\n\n	hx_decodeReflectionData(colorSample, specularSample, normalSpecularReflectance, roughness, metallicness);\n\n	vec3 totalReflection = hx_calculateLight(colorSample.xyz, normal, lightViewDirection, viewDir, normalSpecularReflectance, roughness, metallicness);\n\n	gl_FragColor = vec4(totalReflection, 0.0);\n\n}",HX.ShaderLibrary["directional_light_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\nvarying vec3 viewDir;\n\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n	uv = hx_texCoord;\n	viewDir = hx_getLinearDepthViewVector(hx_position.xy, hx_inverseProjectionMatrix);\n	gl_Position = hx_position;\n}",HX.ShaderLibrary["global_irradiance_probe_fragment.glsl"]="varying vec3 viewWorldDir;\nvarying vec2 uv;\n\nuniform sampler2D hx_gbufferColor;\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D hx_gbufferSpecular;\n#ifdef USE_AO\nuniform sampler2D hx_source;\n#endif\n\nuniform samplerCube irradianceProbeSampler;\n\nuniform mat4 hx_cameraWorldMatrix;\n\nvoid main()\n{\n	vec4 colorSample = texture2D(hx_gbufferColor, uv);\n	vec4 normalSample = texture2D(hx_gbufferNormals, uv);\n	vec4 specularSample = texture2D(hx_gbufferSpecular, uv);\n\n	vec3 normal = mat3(hx_cameraWorldMatrix) * hx_decodeNormal(normalSample);\n	vec3 totalLight = vec3(0.0);\n\n\n	#ifdef USE_AO\n		vec4 occlusionSample = texture2D(hx_source, uv);\n		colorSample.xyz *= occlusionSample.w;\n	#endif\n	vec4 irradianceSample = textureCube(irradianceProbeSampler, normal);\n	irradianceSample = hx_gammaToLinear(irradianceSample);\n	irradianceSample.xyz *= (1.0 - specularSample.z);\n	totalLight += irradianceSample.xyz * colorSample.xyz;\n\n	gl_FragColor = vec4(totalLight, 1.0);\n}",HX.ShaderLibrary["global_irradiance_probe_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nuniform mat4 hx_inverseViewProjectionMatrix;\nuniform vec3 hx_cameraWorldPosition;\n\nvarying vec3 viewWorldDir;\nvarying vec2 uv;\n\n// using rect mesh for rendering skyboxes!\nvoid main()\n{\n	vec4 unproj = hx_inverseViewProjectionMatrix * hx_position;\n	viewWorldDir = unproj.xyz / unproj.w - hx_cameraWorldPosition;\n	viewWorldDir.y = viewWorldDir.y;\n	vec4 pos = hx_position;\n	pos.z = 1.0;\n	gl_Position = pos;\n	uv = hx_texCoord;\n}",HX.ShaderLibrary["global_specular_probe_fragment.glsl"]="varying vec3 viewWorldDir;\nvarying vec2 uv;\n\nuniform samplerCube specularProbeSampler;\nuniform float numMips;\nuniform float mipOffset;\nuniform float maxMipFactor;\n\nuniform sampler2D hx_gbufferColor;\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D hx_gbufferSpecular;\n\n#ifdef USE_AO\nuniform sampler2D hx_source;\n#endif\n\nuniform mat4 hx_cameraWorldMatrix;\n\n// cheap geometric shadowing function, not at all physically correct\nfloat hx_reflectionVisibility(vec3 normal, vec3 reflection, float roughness)\n{\n	return 1.0 - roughness*roughness;\n}\n\nvoid main()\n{\n	vec4 colorSample = texture2D(hx_gbufferColor, uv);\n	vec4 normalSample = texture2D(hx_gbufferNormals, uv);\n	vec4 specularSample = texture2D(hx_gbufferSpecular, uv);\n	vec3 normal = mat3(hx_cameraWorldMatrix) * hx_decodeNormal(normalSample);\n	vec3 totalLight = vec3(0.0);\n\n	vec3 reflectedViewDir = reflect(normalize(viewWorldDir), normal);\n	vec3 normalSpecularReflectance;\n	float roughness;\n	float metallicness;\n	hx_decodeReflectionData(colorSample, specularSample, normalSpecularReflectance, roughness, metallicness);\n	#ifdef USE_TEX_LOD\n	// knald method:\n		float power = 2.0/(roughness * roughness) - 2.0;\n		float factor = (exp2(-10.0/sqrt(power)) - K0)/K1;\n		float mipLevel = numMips*(1.0 - clamp(factor/maxMipFactor, 0.0, 1.0));\n		vec4 specProbeSample = textureCubeLodEXT(specularProbeSampler, reflectedViewDir, mipLevel);\n	#else\n		vec4 specProbeSample = textureCube(specularProbeSampler, reflectedViewDir);\n	#endif\n	specProbeSample = hx_gammaToLinear(specProbeSample);\n	vec3 fresnel = hx_fresnel(normalSpecularReflectance, reflectedViewDir, normal);\n	// not physically correct, but attenuation is required to look good\n//	float attenuation = mix(1.0 - roughness, 1.0, metallicness);\n\n	float attenuation = mix(hx_reflectionVisibility(normal, reflectedViewDir, roughness), 1.0, metallicness);\n\n	fresnel *= attenuation;\n	totalLight += fresnel * specProbeSample.xyz;\n\n	#ifdef USE_AO\n		vec4 occlusionSample = texture2D(hx_source, uv);\n		totalLight *= occlusionSample.w;\n	#endif\n\n	gl_FragColor = vec4(totalLight, 1.0);\n}",HX.ShaderLibrary["global_specular_probe_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nuniform mat4 hx_inverseViewProjectionMatrix;\nuniform vec3 hx_cameraWorldPosition;\n\nvarying vec3 viewWorldDir;\nvarying vec2 uv;\n\nvoid main()\n{\n	vec4 unproj = hx_inverseViewProjectionMatrix * hx_position;\n	viewWorldDir = unproj.xyz / unproj.w - hx_cameraWorldPosition;\n	viewWorldDir.y = viewWorldDir.y;\n	vec4 pos = hx_position;\n	pos.z = 1.0;\n	gl_Position = pos;\n	uv = hx_texCoord;\n}",HX.ShaderLibrary["point_light_fullscreen_fragment.glsl"]="varying vec2 uv;\nvarying vec3 viewDir;\n\nuniform sampler2D hx_gbufferColor;\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D hx_gbufferSpecular;\nuniform sampler2D hx_gbufferDepth;\n\nuniform float hx_cameraFrustumRange;\nuniform float hx_cameraNearPlaneDistance;\n\nuniform vec3 lightColor[LIGHTS_PER_BATCH];\nuniform vec3 lightViewPosition[LIGHTS_PER_BATCH];\nuniform vec2 attenuationFixFactors[LIGHTS_PER_BATCH];\n\nvoid main()\n{\n	vec4 colorSample = texture2D(hx_gbufferColor, uv);\n	vec4 normalSample = texture2D(hx_gbufferNormals, uv);\n	vec4 specularSample = texture2D(hx_gbufferSpecular, uv);\n	vec3 normal = hx_decodeNormal(normalSample);\n	float depth = hx_sampleLinearDepth(hx_gbufferDepth, uv);\n	vec3 normalSpecularReflectance;\n	float roughness;\n	float metallicness;\n\n	hx_decodeReflectionData(colorSample, specularSample, normalSpecularReflectance, roughness, metallicness);\n\n	float absViewZ = hx_cameraNearPlaneDistance + depth * hx_cameraFrustumRange;\n	vec3 viewPosition = absViewZ * viewDir;\n\n	vec3 viewDirNorm = normalize(viewDir);\n\n\n	vec3 totalDiffuse = vec3(0.0);\n	vec3 totalSpecular = vec3(0.0);\n	vec3 diffuseReflection;\n	vec3 specularReflection;\n\n	for (int i = 0; i < LIGHTS_PER_BATCH; ++i) {\n		vec3 lightViewDirection = viewPosition - lightViewPosition[i];\n		float attenuation = 1.0/dot(lightViewDirection, lightViewDirection);\n		// normalize:\n		lightViewDirection *= sqrt(attenuation);\n\n		// rescale attenuation so that irradiance at bounding edge really is 0\n		attenuation = max(0.0, (attenuation - attenuationFixFactors[i].x) * attenuationFixFactors[i].y);\n		hx_lighting(normal, lightViewDirection, viewDirNorm, lightColor[i] * attenuation, normalSpecularReflectance, roughness, diffuseReflection, specularReflection);\n		totalDiffuse += diffuseReflection;\n		totalSpecular += specularReflection;\n	}\n	totalDiffuse *= colorSample.xyz * (1.0 - metallicness);\n	gl_FragColor = vec4(totalDiffuse + totalSpecular, 1.0);\n}",HX.ShaderLibrary["point_light_fullscreen_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\nvarying vec3 viewDir;\n\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n	uv = hx_texCoord;\n	viewDir = hx_getLinearDepthViewVector(hx_position.xy, hx_inverseProjectionMatrix);\n	gl_Position = hx_position;\n}",HX.ShaderLibrary["point_light_spherical_fragment.glsl"]="varying vec2 uv;\nvarying vec3 viewDir;\nvarying vec3 lightColorVar;\nvarying vec3 lightPositionVar;\nvarying vec2 attenuationFixVar;\n\nuniform sampler2D hx_gbufferColor;\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D hx_gbufferSpecular;\nuniform sampler2D hx_gbufferDepth;\n\nuniform float hx_cameraFrustumRange;\nuniform float hx_cameraNearPlaneDistance;\n\n\nvoid main()\n{\n	vec4 colorSample = texture2D(hx_gbufferColor, uv);\n	vec4 normalSample = texture2D(hx_gbufferNormals, uv);\n	vec4 specularSample = texture2D(hx_gbufferSpecular, uv);\n	float depth = hx_sampleLinearDepth(hx_gbufferDepth, uv);\n\n	float viewZ = hx_cameraNearPlaneDistance + depth * hx_cameraFrustumRange;\n	vec3 viewPosition = viewZ * viewDir;\n\n	vec3 normal = hx_decodeNormal(normalSample);\n	vec3 viewDirNorm = normalize(viewDir);\n\n	vec3 normalSpecularReflectance;\n	float roughness;\n	float metallicness;\n	hx_decodeReflectionData(colorSample, specularSample, normalSpecularReflectance, roughness, metallicness);\n	vec3 diffuseReflection;\n	vec3 specularReflection;\n\n	vec3 lightViewDirection = viewPosition - lightPositionVar;\n	float attenuation = 1.0/dot(lightViewDirection, lightViewDirection);\n	// normalize:\n	lightViewDirection *= sqrt(attenuation);\n\n	// rescale attenuation so that irradiance at bounding edge really is 0\n	attenuation = max(0.0, (attenuation - attenuationFixVar.x) * attenuationFixVar.y);\n	hx_lighting(normal, lightViewDirection, viewDirNorm, lightColorVar * attenuation, normalSpecularReflectance, roughness, diffuseReflection, specularReflection);\n\n	diffuseReflection *= colorSample.xyz * (1.0 - metallicness);\n	gl_FragColor = vec4(diffuseReflection + specularReflection, 0.0);\n}",HX.ShaderLibrary["point_light_spherical_vertex.glsl"]="attribute vec4 hx_position;\nattribute float hx_instanceID;\n\nuniform mat4 hx_viewMatrix;\nuniform mat4 hx_cameraWorldMatrix;\nuniform mat4 hx_projectionMatrix;\n\nuniform float lightRadius[LIGHTS_PER_BATCH];\nuniform vec3 lightWorldPosition[LIGHTS_PER_BATCH];\nuniform vec3 lightColor[LIGHTS_PER_BATCH];\nuniform vec2 attenuationFixFactors[LIGHTS_PER_BATCH];\n\nvarying vec2 uv;\nvarying vec3 viewDir;\nvarying vec3 lightColorVar;\nvarying vec3 lightPositionVar;\nvarying vec2 attenuationFixVar;\n\nvoid main()\n{\n	int instance = int(hx_instanceID);\n	vec4 worldPos = hx_position;\n	lightPositionVar = lightWorldPosition[instance];\n	lightColorVar = lightColor[instance];\n	attenuationFixVar = attenuationFixFactors[instance];\n	worldPos.xyz *= lightRadius[instance];\n	worldPos.xyz += lightPositionVar;\n\n	vec4 viewPos = hx_viewMatrix * worldPos;\n	vec4 proj = hx_projectionMatrix * viewPos;\n\n	lightPositionVar = (hx_viewMatrix * vec4(lightPositionVar, 1.0)).xyz;\n\n	viewDir = viewPos.xyz / viewPos.z;\n\n	/* render as flat disk, prevent clipping */\n	proj /= proj.w;\n	proj.z = 0.0;\n	uv = proj.xy/proj.w * .5 + .5;\n	gl_Position = proj;\n}",HX.ShaderLibrary["default_geometry_mrt_fragment.glsl"]="#if defined(COLOR_MAP) || defined(NORMAL_MAP)|| defined(SPECULAR_MAP)|| defined(ROUGHNESS_MAP)\nvarying vec2 texCoords;\n#endif\n\nvarying vec3 normal;\n\n#ifdef COLOR_MAP\nuniform sampler2D colorMap;\n#else\nuniform vec3 color;\n#endif\n\n#ifdef NORMAL_MAP\nvarying vec3 tangent;\nvarying vec3 bitangent;\n\nuniform sampler2D normalMap;\n#endif\n\nuniform float roughness;\nuniform float specularNormalReflection;\nuniform float metallicness;\n\n#if defined(SPECULAR_MAP) || defined(ROUGHNESS_MAP)\nuniform sampler2D specularMap;\n#endif\n\nvoid main()\n{\n    vec4 outputColor;\n    #ifdef COLOR_MAP\n        outputColor = texture2D(colorMap, texCoords);\n    #else\n        outputColor = vec4(color, 1.0);\n    #endif\n\n    float metallicnessOut = metallicness;\n    float specNormalReflOut = specularNormalReflection;\n    float roughnessOut = roughness;\n\n    vec3 fragNormal = normal;\n    #ifdef NORMAL_MAP\n        vec4 normalSample = texture2D(normalMap, texCoords);\n        mat3 TBN;\n        TBN[2] = normalize(normal);\n        TBN[0] = normalize(tangent);\n        TBN[1] = normalize(bitangent);\n\n        fragNormal = TBN * (normalSample.xyz * 2.0 - 1.0);\n\n        #ifdef NORMAL_ROUGHNESS_MAP\n            roughnessOut = 1.0 - (1.0 - roughnessOut) * normalSample.w;\n        #endif\n    #endif\n\n    #if defined(SPECULAR_MAP) || defined(ROUGHNESS_MAP)\n          vec4 specSample = texture2D(specularMap, texCoords);\n          roughnessOut = 1.0 - (1.0 - roughnessOut) * specularMap.x;\n\n          #ifdef SPECULAR_MAP\n              specNormalReflOut *= specularMap.y;\n              metallicnessOut *= specularMap.z;\n          #endif\n    #endif\n\n    // todo: should we linearize depth here instead?\n    hx_processGeometry(hx_gammaToLinear(outputColor), fragNormal, gl_FragCoord.z, metallicnessOut, specNormalReflOut, roughnessOut);\n}",HX.ShaderLibrary["default_geometry_mrt_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec3 hx_normal;\n\nuniform mat4 hx_wvpMatrix;\nuniform mat3 hx_normalWorldViewMatrix;\n\nvarying vec3 normal;\n\n#if defined(COLOR_MAP) || defined(NORMAL_MAP)|| defined(SPECULAR_MAP)|| defined(ROUGHNESS_MAP)\nattribute vec2 hx_texCoord;\nvarying vec2 texCoords;\n#endif\n\n#ifdef NORMAL_MAP\nattribute vec4 hx_tangent;\n\nvarying vec3 tangent;\nvarying vec3 bitangent;\n\nuniform mat4 hx_worldViewMatrix;\n#endif\n\n\nvoid main()\n{\n    gl_Position = hx_wvpMatrix * hx_position;\n    normal = hx_normalWorldViewMatrix * hx_normal;\n\n#ifdef NORMAL_MAP\n    tangent = mat3(hx_worldViewMatrix) * hx_tangent.xyz;\n    bitangent = cross(tangent, normal) * hx_tangent.w;\n#endif\n\n#if defined(COLOR_MAP) || defined(NORMAL_MAP)|| defined(SPECULAR_MAP)|| defined(ROUGHNESS_MAP)\n    texCoords = hx_texCoord;\n#endif\n}",HX.ShaderLibrary["default_refract_fragment.glsl"]="varying vec2 texCoords;\nvarying vec3 normal;\nvarying vec3 viewVector;\n\n#ifdef COLOR_MAP\nuniform sampler2D colorMap;\n#else\nuniform vec3 color;\n#endif\n\n#ifdef NORMAL_MAP\nvarying vec3 tangent;\nvarying vec3 bitangent;\n\nuniform sampler2D normalMap;\n#endif\n\n// when used as TRANSPARENT_DIFFUSE, hx_source is a copy of the render target:\nuniform sampler2D hx_source;\nuniform sampler2D hx_gbufferDepth;\n\nuniform mat4 hx_projectionMatrix;\nuniform mat4 hx_viewProjectionMatrix;\nuniform vec3 hx_cameraWorldPosition;\nuniform float hx_cameraNearPlaneDistance;\nuniform float hx_cameraFrustumRange;\n\nuniform float refractiveRatio;   // the ratio of refractive indices\n\nvoid main()\n{\n    vec4 outputColor;\n    #ifdef COLOR_MAP\n        outputColor = texture2D(colorMap, texCoords);\n    #else\n        outputColor = vec4(color, 1.0);\n    #endif\n\n    vec3 fragNormal = normal;\n    #ifdef NORMAL_MAP\n        vec4 normalSample = texture2D(normalMap, texCoords);\n        mat3 TBN;\n        TBN[2] = normalize(normal);\n        TBN[0] = normalize(tangent);\n        TBN[1] = normalize(bitangent);\n\n        fragNormal = TBN * (normalSample.xyz * 2.0 - 1.0);\n    #endif\n\n    // use the immediate background depth value for a distance estimate\n    float depth = hx_sampleLinearDepth(hx_gbufferDepth, texCoords);\n\n    // this can be done in vertex shader\n    float viewZ = hx_depthToViewZ(gl_FragCoord.z, hx_projectionMatrix);\n\n    vec3 viewDir = normalize(-viewVector);\n    vec3 refractionVector = refract(viewDir, fragNormal, refractiveRatio);\n    float distance = depth * hx_cameraFrustumRange - viewZ - hx_cameraNearPlaneDistance;\n    vec3 refractedPoint = hx_cameraWorldPosition - viewVector + refractionVector * distance;\n    vec4 samplePos = hx_viewProjectionMatrix * vec4(refractedPoint, 1.0);\n    samplePos.xy = samplePos.xy / samplePos.w * .5 + .5;\n\n    vec4 background = texture2D(hx_source, samplePos.xy);\n    gl_FragColor = outputColor * background;\n}",HX.ShaderLibrary["default_refract_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec3 hx_normal;\nattribute vec2 hx_texCoord;\n\nvarying vec3 normal;\nvarying vec2 texCoords;\nvarying vec3 viewVector;\n\nuniform mat4 hx_wvpMatrix;\nuniform mat4 hx_worldMatrix;\nuniform mat3 hx_normalWorldMatrix;\nuniform vec3 hx_cameraWorldPosition;\n\n#ifdef NORMAL_MAP\nattribute vec4 hx_tangent;\n\nvarying vec3 tangent;\nvarying vec3 bitangent;\n#endif\n\n\nvoid main()\n{\n    gl_Position = hx_wvpMatrix * hx_position;\n    normal = hx_normalWorldMatrix * hx_normal;\n\n#ifdef NORMAL_MAP\n    tangent = mat3(hx_worldMatrix) * hx_tangent.xyz;\n    bitangent = cross(tangent, normal) * hx_tangent.w;\n#endif\n\n    viewVector = hx_cameraWorldPosition - (hx_worldMatrix * hx_position).xyz;\n    texCoords = hx_texCoord;\n}",
HX.ShaderLibrary["default_skybox_fragment.glsl"]="varying vec3 viewWorldDir;\n\nuniform samplerCube hx_skybox;\n\nvoid main()\n{\n    vec4 color = textureCube(hx_skybox, viewWorldDir);\n    gl_FragColor = hx_gammaToLinear(color);\n}",HX.ShaderLibrary["default_skybox_vertex.glsl"]="attribute vec4 hx_position;\n\nuniform mat4 hx_inverseViewProjectionMatrix;\nuniform vec3 hx_cameraWorldPosition;\n\nvarying vec3 viewWorldDir;\n\n// using 2D quad for rendering skyboxes rather than 3D cube\nvoid main()\n{\n    vec4 unproj = hx_inverseViewProjectionMatrix * hx_position;\n    viewWorldDir = unproj.xyz / unproj.w - hx_cameraWorldPosition;\n    gl_Position = vec4(hx_position.xy, 1.0, 1.0);  // make sure it's drawn behind everything else\n}",HX.ShaderLibrary["bloom_blur_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D sourceTexture;\n\nuniform float gaussianWeights[NUM_SAMPLES];\n\nvoid main()\n{\n	vec4 total = vec4(0.0);\n	vec2 sampleUV = uv;\n	vec2 stepSize = DIRECTION / SOURCE_RES;\n	float totalWeight = 0.0;\n	for (int i = 0; i < NUM_SAMPLES; ++i) {\n		total += texture2D(sourceTexture, sampleUV) * gaussianWeights[i];\n		sampleUV += stepSize;\n	}\n	gl_FragColor = total;\n}",HX.ShaderLibrary["bloom_blur_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\n\nvoid main()\n{\n	uv = hx_texCoord - RADIUS * DIRECTION / SOURCE_RES;\n	gl_Position = hx_position;\n}",HX.ShaderLibrary["bloom_composite_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D hx_source;\nuniform sampler2D bloomTexture;\n\nvoid main()\n{\n	gl_FragColor = texture2D(hx_source, uv) + texture2D(bloomTexture, uv);\n}",HX.ShaderLibrary["bloom_composite_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\n\nvoid main()\n{\n	   uv = hx_texCoord;\n	   gl_Position = hx_position;\n}",HX.ShaderLibrary["bloom_threshold_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D hx_source;\n\nuniform float threshold;\n\nvoid main()\n{\n        vec4 color = texture2D(hx_source, uv);\n        float originalLuminance = .05 + hx_luminance(color);\n        float targetLuminance = max(originalLuminance - threshold, 0.0);\n        gl_FragColor = color * targetLuminance / originalLuminance;\n}\n",HX.ShaderLibrary["default_post_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\n\nvoid main()\n{\n	uv = hx_texCoord;\n	gl_Position = hx_position;\n}",HX.ShaderLibrary["fog_fragment.glsl"]="varying vec2 uv;\nvarying vec3 viewDir;\n\nuniform vec3 tint;\nuniform float density;\nuniform float startDistance;\n\nuniform float hx_cameraFrustumRange;\nuniform float hx_cameraNearPlaneDistance;\n\nuniform sampler2D hx_source;\nuniform sampler2D hx_gbufferDepth;\n\nvoid main()\n{\n	vec4 color = texture2D(hx_source, uv);\n	float depth = hx_sampleLinearDepth(hx_gbufferDepth, uv);\n	// do not fog up skybox\n	// this might actually solve itself due to depth map encoding\n	if (depth == 1.0) depth = -1.0;\n	float viewZ = hx_cameraNearPlaneDistance + depth * hx_cameraFrustumRange;\n\n	float distance = length(viewDir * viewZ);\n\n	distance -= startDistance;\n\n	float fog = clamp(exp2(-distance * density), 0.0, 1.0);\n	color.xyz = mix(tint, color.xyz, fog);\n	gl_FragColor = color;\n}",HX.ShaderLibrary["fog_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\nvarying vec3 viewDir;\n\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n	uv = hx_texCoord;\n	viewDir = hx_getLinearDepthViewVector(hx_position.xy, hx_inverseProjectionMatrix);\n	gl_Position = hx_position;\n}",HX.ShaderLibrary["fxaa_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D hx_source;\nuniform vec2 hx_rcpRenderTargetResolution;\nuniform float edgeThreshold;\nuniform float edgeThresholdMin;\nuniform float edgeSharpness;\n\nfloat luminanceHint(vec4 color)\n{\n	return .30/.59 * color.r + color.g;\n}\n\nvoid main()\n{\n	vec4 center = texture2D(hx_source, uv);\n	vec2 halfRes = vec2(hx_rcpRenderTargetResolution.x, hx_rcpRenderTargetResolution.y) * .5;\n	float topLeftLum = luminanceHint(texture2D(hx_source, uv + vec2(-halfRes.x, halfRes.y)));\n	float bottomLeftLum = luminanceHint(texture2D(hx_source, uv + vec2(-halfRes.x, -halfRes.y)));\n	float topRightLum = luminanceHint(texture2D(hx_source, uv + vec2(halfRes.x, halfRes.y)));\n	float bottomRightLum = luminanceHint(texture2D(hx_source, uv + vec2(halfRes.x, -halfRes.y)));\n\n	float centerLum = luminanceHint(center);\n	float minLum = min(min(topLeftLum, bottomLeftLum), min(topRightLum, bottomRightLum));\n	float maxLum = max(max(topLeftLum, bottomLeftLum), max(topRightLum, bottomRightLum));\n	float range = max(centerLum, maxLum) - min(centerLum, minLum);\n	float threshold = max(edgeThresholdMin, maxLum * edgeThreshold);\n	float applyFXAA = range < threshold? 0.0 : 1.0;\n\n	float diagDiff1 = bottomLeftLum - topRightLum;\n	float diagDiff2 = bottomRightLum - topLeftLum;\n	vec2 dir1 = normalize(vec2(diagDiff1 + diagDiff2, diagDiff1 - diagDiff2));\n	vec4 sampleNeg1 = texture2D(hx_source, uv - halfRes * dir1);\n	vec4 samplePos1 = texture2D(hx_source, uv + halfRes * dir1);\n\n	float minComp = min(abs(dir1.x), abs(dir1.y)) * edgeSharpness;\n	vec2 dir2 = clamp(dir1.xy / minComp, -2.0, 2.0) * 2.0;\n	vec4 sampleNeg2 = texture2D(hx_source, uv - hx_rcpRenderTargetResolution * dir2);\n	vec4 samplePos2 = texture2D(hx_source, uv + hx_rcpRenderTargetResolution * dir2);\n	vec4 tap1 = sampleNeg1 + samplePos1;\n	vec4 fxaa = (tap1 + sampleNeg2 + samplePos2) * .25;\n	float fxaaLum = luminanceHint(fxaa);\n	if ((fxaaLum < minLum) || (fxaaLum > maxLum))\n		fxaa = tap1 * .5;\n	gl_FragColor = mix(center, fxaa, applyFXAA);\n}",HX.ShaderLibrary["hbao_fragment.glsl"]="uniform float hx_cameraFrustumRange;\nuniform float hx_cameraNearPlaneDistance;\nuniform vec2 hx_renderTargetResolution;\nuniform vec2 hx_rcpRenderTargetResolution;\nuniform mat4 hx_projectionMatrix;\n\nuniform int numRays;\nuniform int numSamplesPerRay;\nuniform float strengthPerRay;\nuniform float halfSampleRadius;\nuniform float bias;\nuniform float rcpFallOffDistance;\n\nuniform sampler2D hx_gbufferDepth;\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D sampleDirTexture;\nuniform sampler2D ditherTexture;\n\nvarying vec2 uv;\nvarying vec3 viewDir;\nvarying vec3 frustumCorner;\n\nvec3 getViewPos(vec2 sampleUV)\n{\n    float depth = hx_sampleLinearDepth(hx_gbufferDepth, sampleUV);\n    float viewZ = depth * hx_cameraFrustumRange + hx_cameraNearPlaneDistance;\n    vec3 viewPos = frustumCorner * vec3(sampleUV * 2.0 - 1.0, 1.0);\n    return viewPos * viewZ;\n}\n\n// Retrieves the occlusion factor for a particular sample\nfloat getSampleOcclusion(vec2 sampleUV, vec3 centerViewPos, vec3 centerNormal, vec3 tangent, inout float topOcclusion)\n{\n    vec3 sampleViewPos = getViewPos(sampleUV);\n\n    // get occlusion factor based on candidate horizon elevation\n    vec3 horizonVector = sampleViewPos - centerViewPos;\n    float horizonVectorLength = length(horizonVector);\n\n    float occlusion;\n\n    // If the horizon vector points away from the tangent, make an estimate\n    if (dot(tangent, horizonVector) < 0.0)\n        occlusion = .5;\n    else\n        occlusion = dot(centerNormal, horizonVector) / horizonVectorLength;\n\n    // this adds occlusion only if angle of the horizon vector is higher than the previous highest one without branching\n    float diff = max(occlusion - topOcclusion, 0.0);\n    topOcclusion = max(occlusion, topOcclusion);\n\n    // attenuate occlusion contribution using distance function 1 - (d/f)^2\n    float distanceFactor = clamp(horizonVectorLength * rcpFallOffDistance, 0.0, 1.0);\n    distanceFactor = 1.0 - distanceFactor * distanceFactor;\n    return diff * distanceFactor;\n}\n\n// Retrieves the occlusion for a given ray\nfloat getRayOcclusion(vec2 direction, float jitter, vec2 projectedRadii, vec3 centerViewPos, vec3 centerNormal)\n{\n    // calculate the nearest neighbour sample along the direction vector\n    vec2 texelSizedStep = direction * hx_rcpRenderTargetResolution;\n    direction *= projectedRadii;\n\n    // gets the tangent for the current ray, this will be used to handle opposing horizon vectors\n    // Tangent is corrected with respect to face normal by projecting it onto the tangent plane defined by the normal\n    vec3 tangent = getViewPos(uv + texelSizedStep) - centerViewPos;\n    tangent -= dot(centerNormal, tangent) * centerNormal;\n\n    vec2 stepUV = direction.xy / float(NUM_SAMPLES_PER_RAY - 1);\n\n    // jitter the starting position for ray marching between the nearest neighbour and the sample step size\n    vec2 jitteredOffset = mix(texelSizedStep, stepUV, jitter);\n    //stepUV *= 1.0 + jitter * .1;\n    vec2 sampleUV = uv + jitteredOffset;\n\n    // top occlusion keeps track of the occlusion contribution of the last found occluder.\n    // set to bias value to avoid near-occluders\n    float topOcclusion = bias;\n    float occlusion = 0.0;\n\n    // march!\n    for (int step = 0; step < NUM_SAMPLES_PER_RAY; ++step) {\n        occlusion += getSampleOcclusion(sampleUV, centerViewPos, centerNormal, tangent, topOcclusion);\n        sampleUV += stepUV;\n    }\n\n    return occlusion;\n}\n\nvoid main()\n{\n    vec4 normalSample = texture2D(hx_gbufferNormals, uv);\n    vec3 centerNormal = hx_decodeNormal(normalSample);\n    float centerDepth = hx_sampleLinearDepth(hx_gbufferDepth, uv);\n    float viewZ = centerDepth * hx_cameraFrustumRange + hx_cameraNearPlaneDistance;\n    vec3 centerViewPos = viewZ * viewDir;\n\n    vec2 projectedRadii = -halfSampleRadius * vec2(hx_projectionMatrix[0][0], hx_projectionMatrix[1][1]) / centerViewPos.z;\n\n    // do not take more steps than there are pixels\n    float totalOcclusion = 0.0;\n\n    vec2 randomFactors = texture2D(ditherTexture, uv * hx_renderTargetResolution * .25).xy;\n\n    vec2 rayUV = vec2(0.0);\n    for (int i = 0; i < NUM_RAYS; ++i) {\n        rayUV.x = (float(i) + randomFactors.x) / float(NUM_RAYS);\n        vec2 sampleDir = texture2D(sampleDirTexture, rayUV).xy * 2.0 - 1.0;\n        totalOcclusion += getRayOcclusion(sampleDir, randomFactors.y, projectedRadii, centerViewPos, centerNormal);\n    }\n\n    totalOcclusion = 1.0 - clamp(strengthPerRay * totalOcclusion, 0.0, 1.0);\n    gl_FragColor = vec4(totalOcclusion);\n}",HX.ShaderLibrary["hbao_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nuniform mat4 hx_inverseProjectionMatrix;\n\nvarying vec2 uv;\nvarying vec3 viewDir;\nvarying vec3 frustumCorner;\n\nvoid main()\n{\n    uv = hx_texCoord;\n    viewDir = hx_getLinearDepthViewVector(hx_position.xy, hx_inverseProjectionMatrix);\n    frustumCorner = hx_getLinearDepthViewVector(vec2(1.0, 1.0), hx_inverseProjectionMatrix);\n    gl_Position = hx_position;\n}",HX.ShaderLibrary["ssao_fragment.glsl"]="uniform mat4 hx_projectionMatrix;\nuniform mat4 hx_cameraWorldMatrix;\nuniform vec2 hx_renderTargetResolution;\nuniform float hx_cameraFrustumRange;\n\nuniform float strengthPerSample;\nuniform float rcpFallOffDistance;\nuniform float sampleRadius;\nuniform vec3 samples[NUM_SAMPLES]; // w contains bias\n\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D hx_gbufferDepth;\nuniform sampler2D ditherTexture;\n\nvarying vec2 uv;\n\nvoid main()\n{\n    vec4 normalSample = texture2D(hx_gbufferNormals, uv);\n    vec3 centerNormal = hx_decodeNormal(normalSample);\n    float centerDepth = hx_sampleLinearDepth(hx_gbufferDepth, uv);\n    float totalOcclusion = 0.0;\n    vec3 dither = texture2D(ditherTexture, uv * hx_renderTargetResolution * .25).xyz;\n    vec3 randomPlaneNormal = normalize(dither - .5);\n    float w = -centerDepth * hx_cameraFrustumRange * hx_projectionMatrix[2][3] + hx_projectionMatrix[3][3];\n    vec3 sampleRadii;\n    sampleRadii.x = sampleRadius * .5 * hx_projectionMatrix[0][0] / w;\n    sampleRadii.y = sampleRadius * .5 * hx_projectionMatrix[1][1] / w;\n    sampleRadii.z = sampleRadius;\n\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        vec3 sampleOffset = reflect(samples[i], randomPlaneNormal);\n        vec3 normOffset = normalize(sampleOffset);\n        float cosFactor = dot(normOffset, centerNormal);\n        float sign = sign(cosFactor);\n        sampleOffset *= sign;\n        cosFactor *= sign;\n\n        vec3 scaledOffset = sampleOffset * sampleRadii;\n\n        vec2 samplePos = uv + scaledOffset.xy;\n        float occluderDepth = hx_sampleLinearDepth(hx_gbufferDepth, samplePos);\n        float diffZ = (centerDepth - occluderDepth) * hx_cameraFrustumRange;\n\n        // distanceFactor: from 1 to 0, near to far\n        float distanceFactor = clamp(diffZ * rcpFallOffDistance, 0.0, 1.0);\n        distanceFactor = 1.0 - distanceFactor;\n\n        // sampleOcclusion: 1 if occluding, 0 otherwise\n        float sampleOcclusion = float(diffZ > scaledOffset.z);\n        totalOcclusion += sampleOcclusion * distanceFactor * cosFactor;\n\n    }\n    gl_FragColor = vec4(1.0 - totalOcclusion * strengthPerSample);\n}",HX.ShaderLibrary["ssr_fragment.glsl"]='uniform sampler2D hx_gbufferColor;\nuniform sampler2D hx_gbufferNormals;\nuniform sampler2D hx_gbufferSpecular;\nuniform sampler2D hx_gbufferDepth;\nuniform sampler2D hx_source;\nuniform sampler2D hx_dither2D;\nuniform vec2 hx_dither2DTextureScale;\n\nvarying vec2 uv;\nvarying vec3 viewDir;\n\nuniform float hx_cameraNearPlaneDistance;\nuniform float hx_cameraFrustumRange;\nuniform float hx_rcpCameraFrustumRange;\nuniform vec2 hx_renderTargetResolution;\nuniform mat4 hx_projectionMatrix;\n\nuniform float maxDistance;\nuniform float stepSize;\n\n// cheap geometric shadowing function, not at all physically correct\nfloat hx_reflectionVisibility(vec3 normal, vec3 reflection, float roughness)\n{\n	return 1.0 - roughness*roughness;\n}\n\n// all in viewspace\n// 0 is start, 1 is end\nfloat raytrace(in vec3 ray0, in vec3 rayDir, out float hitZ, out vec2 hitUV)\n{\n    vec4 dither = texture2D(hx_dither2D, uv * hx_dither2DTextureScale);\n    // Clip to the near plane\n	float rayLength = ((ray0.z + rayDir.z * maxDistance) > -hx_cameraNearPlaneDistance) ?\n						(-hx_cameraNearPlaneDistance - ray0.z) / rayDir.z : maxDistance;\n\n    vec3 ray1 = ray0 + rayDir * rayLength;\n\n    // only need the w component for perspective correct interpolation\n    // need to get adjusted ray end\'s uv value\n    vec4 hom0 = hx_projectionMatrix * vec4(ray0, 1.0);\n    vec4 hom1 = hx_projectionMatrix * vec4(ray1, 1.0);\n    float rcpW0 = 1.0 / hom0.w;\n    float rcpW1 = 1.0 / hom1.w;\n\n    hom0 *= rcpW0;\n    hom1 *= rcpW1;\n\n    // expressed in pixels, so we can snap to 1\n    // need to figure out the ratio between 1 pixel and the entire line "width" (if primarily vertical, it\'s actually height)\n\n    // line dimensions in pixels:\n\n    vec2 pixelSize = (hom1.xy - hom0.xy) * hx_renderTargetResolution * .5;\n\n    // line-"width" = max(abs(pixelSize.x), abs(pixelSize.y))\n    // ratio pixel/width = 1 / max(abs(pixelSize.x), abs(pixelSize.y))\n\n    float stepRatio = 1.0 / max(abs(pixelSize.x), abs(pixelSize.y)) * stepSize;\n\n    vec2 uvEnd = hom1.xy * .5 + .5;\n\n    vec2 dUV = (uvEnd - uv) * stepRatio;\n    hitUV = uv;\n\n    // linear depth\n    float rayDepth = (-ray0.z - hx_cameraNearPlaneDistance) * hx_rcpCameraFrustumRange;\n    float rayPerspDepth0 = rayDepth * rcpW0;\n    float rayPerspDepth1 = (-ray1.z - hx_cameraNearPlaneDistance) * hx_rcpCameraFrustumRange * rcpW1;\n    float rayPerspDepth = rayPerspDepth0;\n    // could probably optimize this:\n    float dRayD = (rayPerspDepth1 - rayPerspDepth0) * stepRatio;\n\n    float rcpW = rcpW0;\n    float dRcpW = (rcpW1 - rcpW0) * stepRatio;\n    float sceneDepth = rayDepth;\n    float prevRayDepth, prevSceneDepth;\n\n    float amount = 0.0;\n\n    hitUV += dUV * dither.z;\n    rayPerspDepth += dRayD * dither.z;\n    rcpW += dRcpW * dither.z;\n//    rayDepth = rayPerspDepth / rcpW;\n\n    float sampleCount;\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n//        prevRayDepth = rayDepth;\n        // easier to think in positive Z\n        rayDepth = rayPerspDepth / rcpW;\n        // unprojected uv ray with refldir?\n\n//        prevSceneDepth = sceneDepth;\n        sceneDepth = hx_sampleLinearDepth(hx_gbufferDepth, hitUV);\n\n        if (rayDepth > sceneDepth + .001) {\n            // do not count beyond far plane intersections, depth = 0 due to encoding flaw\n            amount = float(sceneDepth > 0.01);\n            sampleCount = float(i);\n            break;\n        }\n\n        hitUV += dUV;\n        rayPerspDepth += dRayD;\n        rcpW += dRcpW;\n    }\n\n    // interpolation doesn\'t always work all that well around discontinuities\n//    float dr = (prevRayDepth - rayDepth);\n//    float ds = (prevSceneDepth - sceneDepth);\n\n//    float t = (rayDepth - sceneDepth) / (ds - dr);\n\n//    hitUV -= t * dUV;\n//    hitZ = (sceneDepth + ds * t) * hx_cameraFrustumRange;\n    hitZ = -hx_cameraNearPlaneDistance - sceneDepth * hx_cameraFrustumRange;\n\n    // TODO: fade out last samples\n    amount *= clamp((1.0 - (sampleCount - float(NUM_SAMPLES)) / float(NUM_SAMPLES)) * 5.0, 0.0, 1.0);\n    return amount;\n}\n\nvoid main()\n{\n    vec4 colorSample = hx_gammaToLinear(texture2D(hx_gbufferColor, uv));\n    vec4 specularSample = texture2D(hx_gbufferSpecular, uv);\n    float depth = hx_sampleLinearDepth(hx_gbufferDepth, uv);\n    vec3 normalSpecularReflectance;\n    float roughness;\n    float metallicness;\n    hx_decodeReflectionData(colorSample, specularSample, normalSpecularReflectance, roughness, metallicness);\n    vec4 normalSample = texture2D(hx_gbufferNormals, uv);\n    vec3 normal = hx_decodeNormal(normalSample);\n    vec3 reflDir = reflect(normalize(viewDir), normal);\n\n    vec3 fresnel = hx_fresnel(normalSpecularReflectance, reflDir, normal);\n    // not physically correct, but attenuation is required to look good\n    float attenuation = mix(hx_reflectionVisibility(normal, reflDir, roughness), 1.0, metallicness);\n\n    // step for every pixel\n\n    float absViewZ = hx_cameraNearPlaneDistance + depth * hx_cameraFrustumRange;\n    vec3 viewSpacePos = absViewZ * viewDir;\n\n    float hitZ = 0.0;\n    vec2 hitUV;\n    float amount = raytrace(viewSpacePos, reflDir, hitZ, hitUV);\n    float fadeFactor = clamp(-reflDir.z * 1000.0, 0.0, 1.0);\n\n    vec2 borderFactors = abs(hitUV * 2.0 - 1.0);\n    borderFactors = (1.0 - borderFactors) * 10.0;\n    fadeFactor *= clamp(borderFactors.x, 0.0, 1.0) * clamp(borderFactors.y, 0.0, 1.0);\n\n    float diff = viewSpacePos.z - hitZ;\n    fadeFactor *= smoothstep(-0.3, 0.0, diff);\n\n    vec4 reflColor = texture2D(hx_source, hitUV);\n    vec4 srcColor = texture2D(hx_source, uv);\n\n    float amountUsed = amount * fadeFactor;\n    gl_FragColor = vec4(srcColor.xyz + fresnel * attenuation * reflColor.xyz * amountUsed, amountUsed);\n}\n\n',HX.ShaderLibrary["ssr_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\nvarying vec3 viewDir;\n\nuniform mat4 hx_inverseProjectionMatrix;\n\nvoid main()\n{\n    uv = hx_texCoord;\n    viewDir = hx_getLinearDepthViewVector(hx_position.xy, hx_inverseProjectionMatrix);\n    gl_Position = hx_position;\n}",HX.ShaderLibrary["tonemap_filmic_fragment.glsl"]="// This approach is by Jim Hejl and Richard Burgess-Dawson\nvoid main()\n{\n	vec4 color = hx_getToneMapScaledColor();\n	vec3 x = max(vec3(0.0), color.xyz - 0.004);\n	gl_FragColor = vec4((x * (6.2 * x + .5))/(x * (6.2 * x + 1.7) + 0.06), 1.0);\n}",HX.ShaderLibrary["tonemap_reference_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D hx_source;\n\nvoid main()\n{\n	vec4 color = texture2D(hx_source, uv);\n	float l = log(.001 + hx_luminance(color));\n	gl_FragColor = vec4(l, l, l, 1.0);\n}",HX.ShaderLibrary["tonemap_reinhard_fragment.glsl"]="void main()\n{\n	vec4 color = hx_getToneMapScaledColor();\n	gl_FragColor = color / (1.0 + color);\n}",HX.ShaderLibrary["copy_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D sampler;\n\nvoid main()\n{\n    // extractChannel comes from a macro\n   gl_FragColor = vec4(extractChannels(texture2D(sampler, uv)));\n   gl_FragColor.a = 1.0;\n}\n",HX.ShaderLibrary["copy_to_gamma_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D sampler;\n\nvoid main()\n{\n   gl_FragColor = vec4(hx_linearToGamma(texture2D(sampler, uv).xyz), 1.0);\n}",HX.ShaderLibrary["copy_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\n\nvoid main()\n{\n    uv = hx_texCoord;\n    gl_Position = hx_position;\n}",HX.ShaderLibrary["debug_depth_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D sampler;\n\nvoid main()\n{\n   gl_FragColor = vec4(1.0 - hx_sampleLinearDepth(sampler, uv));\n}",HX.ShaderLibrary["debug_normals_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D sampler;\n\nvoid main()\n{\n   vec4 data = texture2D(sampler, uv);\n   vec3 normal = hx_decodeNormal(data);\n   gl_FragColor = vec4(normal * .5 + .5, 1.0);\n}",HX.ShaderLibrary["linearize_depth_fragment.glsl"]="varying vec2 uv;\n\nuniform sampler2D sampler;\nuniform mat4 hx_projectionMatrix;\nuniform float hx_rcpCameraFrustumRange;\n\nfloat readDepth(sampler2D sampler, vec2 uv)\n{\n	#ifdef HX_NO_DEPTH_TEXTURES\n		vec4 data = texture2D(sampler, uv);\n		return hx_RG8ToFloat(data.zw);\n    #else\n    	return texture2D(sampler, uv).x;\n    #endif\n}\n\nvoid main()\n{\n	float depth = readDepth(sampler, uv);\n	float linear = hx_depthToViewZ(depth, hx_projectionMatrix) * hx_rcpCameraFrustumRange;\n	gl_FragColor = hx_floatToRGBA8(linear);\n}",HX.ShaderLibrary["linearize_depth_vertex.glsl"]="attribute vec4 hx_position;\nattribute vec2 hx_texCoord;\n\nvarying vec2 uv;\n\nvoid main()\n{\n	uv = hx_texCoord;\n	gl_Position = hx_position;\n}",HX.ShaderLibrary["snippets_general.glsl"]="#if defined(HX_NO_MRT_GBUFFER_COLOR)\n#define hx_processGeometry(color, normal, depth, metallicness, specularNormalReflection, roughness) (gl_FragColor = color)\n#elif defined(HX_NO_MRT_GBUFFER_NORMALS)\n#define hx_processGeometry(color, normal, depth, metallicness, specularNormalReflection, roughness) (gl_FragColor = hx_encodeNormalDepth(normal, depth))\n#elif defined(HX_NO_MRT_GBUFFER_SPECULAR)\n#define hx_processGeometry(color, normal, depth, metallicness, specularNormalReflection, roughness) (gl_FragColor = hx_encodeSpecularData(metallicness, specularNormalReflection, roughness))\n#elif defined(HX_SHADOW_MAP_PASS)\n#define hx_processGeometry(color, normal, depth, metallicness, specularNormalReflection, roughness) (gl_FragColor = hx_floatToRGBA8(depth))\n#else\n#define hx_processGeometry(color, normal, depth, metallicness, specularNormalReflection, roughness) hx_processGeometryMRT(color, normal, depth, metallicness, specularNormalReflection, roughness, gl_FragData[0], gl_FragData[1], gl_FragData[2])\n#endif\n\n// see Aras' blog post: http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n// Only for 0 - 1\nvec4 hx_floatToRGBA8(float value)\n{\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * value;\n    enc = fract(enc);\n    return enc - enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n}\n\nfloat hx_RGBA8ToFloat(vec4 rgba)\n{\n    return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0));\n}\n\nvec2 hx_floatToRG8(float value)\n{\n    vec2 enc = vec2(1.0, 255.0) * value;\n    enc = fract(enc);\n    enc.x -= enc.y / 255.0;\n    return enc;\n}\n\nfloat hx_RG8ToFloat(vec2 rg)\n{\n    return dot(rg, vec2(1.0, 1.0/255.0));\n}\n\nvec4 hx_encodeNormalDepth(vec3 normal, float depth)\n{\n	#ifdef HX_NO_DEPTH_TEXTURES\n    	vec4 data;\n    	data.xy = normal.xy * .5 + .5;\n		data.zw = hx_floatToRG8(depth);\n		return data;\n	#else\n		return vec4(normal * .5 + .5, 1.0);\n    #endif\n}\n\nvec3 hx_decodeNormal(vec4 data)\n{\n    #ifdef HX_NO_DEPTH_TEXTURES\n    	vec3 normal;\n    	normal.xy = data.xy * 2.0 - 1.0;\n		normal.z = 1.0 - dot(normal.xy, normal.xy);\n		normal.z = sqrt(normal.z);\n		return normal;\n    #else\n    	return normalize(data.xyz - .5);\n    #endif\n}\n\nvec4 hx_encodeSpecularData(float metallicness, float specularNormalReflection, float roughness)\n{\n	return vec4(roughness, specularNormalReflection * 5.0, metallicness, 1.0);\n}\n\nvoid hx_processGeometryMRT(vec4 color, vec3 normal, float depth, float metallicness, float specularNormalReflection, float roughness, out vec4 colorData, out vec4 normalData, out vec4 specularData)\n{\n    colorData = color;\n	normalData = hx_encodeNormalDepth(normal, depth);\n    specularData = hx_encodeSpecularData(metallicness, specularNormalReflection, roughness);\n}\n\nvec4 hx_gammaToLinear(vec4 color)\n{\n    #ifdef HX_LINEAR_SPACE\n        color.x = pow(color.x, 2.2);\n        color.y = pow(color.y, 2.2);\n        color.z = pow(color.z, 2.2);\n    #endif\n    return color;\n}\n\nvec3 hx_gammaToLinear(vec3 color)\n{\n    #ifdef HX_LINEAR_SPACE\n        color.x = pow(color.x, 2.2);\n        color.y = pow(color.y, 2.2);\n        color.z = pow(color.z, 2.2);\n    #endif\n    return color;\n}\n\nvec4 hx_linearToGamma(vec4 linear)\n{\n    #ifdef HX_LINEAR_SPACE\n        linear.x = pow(linear.x, 0.45);\n        linear.y = pow(linear.y, 0.45);\n        linear.z = pow(linear.z, 0.45);\n    #endif\n    return linear;\n}\n\nvec3 hx_linearToGamma(vec3 linear)\n{\n    #ifdef HX_LINEAR_SPACE\n        linear.x = pow(linear.x, 0.45);\n        linear.y = pow(linear.y, 0.45);\n        linear.z = pow(linear.z, 0.45);\n    #endif\n    return linear;\n}\n\nfloat hx_sampleLinearDepth(sampler2D tex, vec2 uv)\n{\n    return hx_RGBA8ToFloat(texture2D(tex, uv));\n}\n\nvec3 hx_getFrustumVector(vec2 position, mat4 unprojectionMatrix)\n{\n    vec4 unprojNear = unprojectionMatrix * vec4(position, -1.0, 1.0);\n    vec4 unprojFar = unprojectionMatrix * vec4(position, 1.0, 1.0);\n    return unprojFar.xyz/unprojFar.w - unprojNear.xyz/unprojNear.w;\n}\n\n// view vector with z = 1, so we can use nearPlaneDist + linearDepth * (farPlaneDist - nearPlaneDist) as a scale factor to find view space position\nvec3 hx_getLinearDepthViewVector(vec2 position, mat4 unprojectionMatrix)\n{\n    vec4 unproj = unprojectionMatrix * vec4(position, 0.0, 1.0);\n    unproj /= unproj.w;\n    return -unproj.xyz / unproj.z;\n}\n\n// THIS IS FOR NON_LINEAR DEPTH!\nfloat hx_depthToViewZ(float depthSample, mat4 projectionMatrix)\n{\n    return -projectionMatrix[3][2] / (depthSample * 2.0 - 1.0 + projectionMatrix[2][2]);\n}\n\n\nvec3 hx_getNormalSpecularReflectance(float metallicness, float insulatorNormalSpecularReflectance, vec3 color)\n{\n    return mix(vec3(insulatorNormalSpecularReflectance), color, metallicness);\n}\n\n// for use when sampling gbuffer data for lighting\nvoid hx_decodeReflectionData(in vec4 colorSample, in vec4 specularSample, out vec3 normalSpecularReflectance, out float roughness, out float metallicness)\n{\n    //prevent from being 0\n    roughness = clamp(specularSample.x, .01, 1.0);\n	metallicness = specularSample.z;\n    normalSpecularReflectance = mix(vec3(specularSample.y * .2), colorSample.xyz, metallicness);\n}\n\nvec3 hx_fresnel(vec3 normalSpecularReflectance, vec3 lightDir, vec3 halfVector)\n{\n    float cosAngle = 1.0 - max(dot(halfVector, lightDir), 0.0);\n    // to the 5th power\n    float power = pow(cosAngle, 5.0);\n    return normalSpecularReflectance + (1.0 - normalSpecularReflectance) * power;\n}\n\nfloat hx_luminance(vec4 color)\n{\n    return dot(color.xyz, vec3(.30, 0.59, .11));\n}\n\nfloat hx_luminance(vec3 color)\n{\n    return dot(color, vec3(.30, 0.59, .11));\n}",HX.ShaderLibrary["snippets_tonemap.glsl"]="varying vec2 uv;\n\n#ifdef ADAPTIVE\nuniform sampler2D hx_luminanceMap;\nuniform float hx_luminanceMipLevel;\n#endif\n\nuniform float hx_exposure;\n\nuniform sampler2D hx_source;\n\n\nvec4 hx_getToneMapScaledColor()\n{\n    #ifdef ADAPTIVE\n    float referenceLuminance = exp(texture2DLodEXT(hx_luminanceMap, uv, hx_luminanceMipLevel).x);\n	float key = 1.03 - (2.0 / (2.0 + log(referenceLuminance + 1.0)/log(10.0)));\n	float exposure = key / referenceLuminance * hx_exposure;\n	#else\n	float exposure = hx_exposure;\n	#endif\n    return texture2D(hx_source, uv) * exposure;\n}",HX.Float2=function(t,e){this.x=t||0,this.y=e||0},HX.Float2.angle=function(t,e){return Math.acos(HX.dot2(t,e)/(t.length()*e.length()))},HX.Float2.distance=function(t,e){var i=t.x-e.x,r=t.y-e.y;return Math.sqrt(i*i+r*r)},HX.Float2.angleNormalized=function(t,e){return Math.acos(HX.dot2(t,e))},HX.Float2.sum=function(t,e){return new HX.Float2(t.x+e.x,t.y+e.y)},HX.Float2.scale=function(t,e){return new HX.Float2(t.x*e,t.y*e)},HX.Float2.prototype={constructor:HX.Float2,set:function(t,e){this.x=t,this.y=e},lengthSqr:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},normalize:function(){var t=1/this.length();this.x*=t,this.y*=t},clone:function(){return new HX.Float2(this.x,this.y)},add:function(t){this.x+=t.x,this.y+=t.y},subtract:function(t){this.x-=t.x,this.y-=t.y},scale:function(t){this.x*=t,this.y*=t},sum:function(t,e){this.x=t.x+e.x,this.y=t.y+e.y},difference:function(t,e){this.x=t.x-e.x,this.y=t.y-e.y},scaled:function(t,e){this.x=t*e.x,this.y=t*e.y},negate:function(){this.x=-this.x,this.y=-this.y},multiply:function(t){this.x*=t.x,this.y*=t.y},abs:function(){this.x=Math.abs(this.x),this.y=Math.abs(this.y)},lerp:function(t,e,i){var r=t.x,n=t.y;this.x=r+(e.x-r)*factor,this.y=n+(e.y-n)*factor},fromPolarCoordinates:function(t,e){this.x=t*Math.cos(e),this.y=t*Math.sin(e)},copyFrom:function(t){this.x=t.x,this.y=t.y},maximize:function(t){t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y)},minimize:function(t){t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y)}},HX.Float2.ZERO=new HX.Float2(0,0),HX.Float2.X_AXIS=new HX.Float2(1,0),HX.Float2.Y_AXIS=new HX.Float2(0,1),HX.PlaneSide={FRONT:1,BACK:-1,INTERSECTING:0},HX.Float4=function(t,e,i,r){this.x=t||0,this.y=e||0,this.z=i||0,this.w=void 0===r?1:r},HX.Float4.angle=function(t,e){return Math.acos(HX.dot3(t,e)/(t.length()*e.length()))},HX.Float4.distance=function(t,e){var i=t.x-e.x,r=t.y-e.y,n=t.z-e.z;return Math.sqrt(i*i+r*r+n*n)},HX.Float4.angleNormalized=function(t,e){return Math.acos(HX.dot3(t,e))},HX.Float4.sum=function(t,e){return new HX.Float4(t.x+e.x,t.y+e.y,t.z+e.z,t.w+e.w)},HX.Float4.scale=function(t,e){return new HX.Float4(t.x*e,t.y*e,t.z*e,t.w*e)},HX.Float4.prototype={constructor:HX.Float4,set:function(t,e,i,r){this.x=t,this.y=e,this.z=i,this.w=r},lengthSqr:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},normalize:function(){var t=1/this.length();this.x*=t,this.y*=t,this.z*=t},normalizeAsPlane:function(){var t=1/this.length();this.x*=t,this.y*=t,this.z*=t,this.w*=t},clone:function(){return new HX.Float4(this.x,this.y,this.z,this.w)},add:function(t){this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w},subtract:function(t){this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w},scale:function(t){this.x*=t,this.y*=t,this.z*=t,this.w*=t},sum:function(t,e){this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w},difference:function(t,e){this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w},scaled:function(t,e){this.x=t*e.x,this.y=t*e.y,this.z=t*e.z,this.w=t*e.w},negate:function(){this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w},multiply:function(t){this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w},homogeneousProject:function(){var t=1/w;this.x*=t,this.y*=t,this.z*=t,this.w=1},abs:function(){this.x=Math.abs(this.x),this.y=Math.abs(this.y),this.z=Math.abs(this.z),this.w=Math.abs(this.w)},cross:function(t,e){var i=t.x,r=t.y,n=t.z,a=e.x,s=e.y,o=e.z;this.x=r*o-n*s,this.y=n*a-i*o,this.z=i*s-r*a},lerp:function(t,e,i){var r=t.x,n=t.y,a=t.z,s=t.w;this.x=r+(e.x-r)*i,this.y=n+(e.y-n)*i,this.z=a+(e.z-a)*i,this.w=s+(e.w-s)*i},fromSphericalCoordinates:function(t,e,i){this.x=t*Math.sin(i)*Math.cos(e),this.y=t*Math.cos(i),this.z=t*Math.sin(i)*Math.sin(e),this.w=0},copyFrom:function(t){
this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w},maximize:function(t){t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y),t.z>this.z&&(this.z=t.z),t.w>this.w&&(this.w=t.w)},maximize3:function(t){t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y),t.z>this.z&&(this.z=t.z)},minimize:function(t){t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y),t.z<this.z&&(this.z=t.z),t.w<this.w&&(this.w=t.w)},minimize3:function(t){t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y),t.z<this.z&&(this.z=t.z)}},HX.Float4.ORIGIN_POINT=new HX.Float4(0,0,0,1),HX.Float4.ZERO=new HX.Float4(0,0,0,0),HX.Float4.X_AXIS=new HX.Float4(1,0,0,0),HX.Float4.Y_AXIS=new HX.Float4(0,1,0,0),HX.Float4.Z_AXIS=new HX.Float4(0,0,1,0),HX.Gaussian={estimateGaussianRadius:function(t,e){return Math.sqrt(-2*t*Math.log(e))}},HX.CenteredGaussianCurve=function(t){this._amplitude=1/Math.sqrt(2*t*Math.PI),this._expScale=-1/(2*t)},HX.CenteredGaussianCurve.prototype={getValueAt:function(t){return this._amplitude*Math.pow(Math.E,t*t*this._expScale)}},HX.CenteredGaussianCurve.fromRadius=function(t,e){e=e||.01;var i=t/Math.sqrt(-2*Math.log(e));return new HX.CenteredGaussianCurve(i*i)},HX.dot2=function(t,e){return t.x*e.x+t.y*e.y},HX.dot3=function(t,e){return t.x*e.x+t.y*e.y+t.z*e.z},HX.dot4=function(t,e){return t.x*e.x+t.y*e.y+t.z*e.z+t.w*e.w},HX.clamp=function(t,e,i){return e>t?e:t>i?i:t},HX.saturate=function(t){return HX.clamp(t,0,1)},HX.Matrix4x4=function(t,e,i,r,n,a,s,o,h,_,l,c,u,m,f,d){this._m=new HX.TypedArray(16),this._m[0]=void 0===t?1:0,this._m[1]=n||0,this._m[2]=h||0,this._m[3]=u||0,this._m[4]=e||0,this._m[5]=void 0===a?1:0,this._m[6]=_||0,this._m[7]=m||0,this._m[8]=i||0,this._m[9]=s||0,this._m[10]=void 0===l?1:0,this._m[11]=f||0,this._m[12]=r||0,this._m[13]=o||0,this._m[14]=c||0,this._m[15]=void 0===d?1:0},HX.Matrix4x4.prototype={constructor:HX.Matrix4x4,transform:function(t,e){var e=e||new HX.Float4,i=t.x,r=t.y,n=t.z,a=t.w,s=this._m;return e.x=s[0]*i+s[4]*r+s[8]*n+s[12]*a,e.y=s[1]*i+s[5]*r+s[9]*n+s[13]*a,e.z=s[2]*i+s[6]*r+s[10]*n+s[14]*a,e.w=s[3]*i+s[7]*r+s[11]*n+s[15]*a,e},transformPoint:function(t,e){var e=e||new HX.Float4,i=t.x,r=t.y,n=t.z,a=this._m;return e.x=a[0]*i+a[4]*r+a[8]*n+a[12],e.y=a[1]*i+a[5]*r+a[9]*n+a[13],e.z=a[2]*i+a[6]*r+a[10]*n+a[14],e.w=1,e},transformVector:function(t){var e=t.x,i=t.y,r=t.z;return new HX.Float4(this._m[0]*e+this._m[4]*i+this._m[8]*r,this._m[1]*e+this._m[5]*i+this._m[9]*r,this._m[2]*e+this._m[6]*i+this._m[10]*r,0)},transformExtent:function(t){var e=t.x,i=t.y,r=t.z,n=this._m[0],a=this._m[1],s=this._m[2],o=this._m[4],h=this._m[5],_=this._m[6],l=this._m[8],c=this._m[9],u=this._m[10];return 0>n&&(n=-n),0>a&&(a=-a),0>s&&(s=-s),0>o&&(o=-o),0>h&&(h=-h),0>_&&(_=-_),0>l&&(l=-l),0>c&&(c=-c),0>u&&(u=-u),new HX.Float4(n*e+o*i+l*r,a*e+h*i+c*r,s*e+_*i+u*r,0)},transformTo:function(t,e){var i=t.x,r=t.y,n=t.z,a=t.w,s=this._m[0]*i+this._m[4]*r+this._m[8]*n+this._m[12]*a,o=this._m[1]*i+this._m[5]*r+this._m[9]*n+this._m[13]*a,h=this._m[2]*i+this._m[6]*r+this._m[10]*n+this._m[14]*a,_=this._m[3]*i+this._m[7]*r+this._m[11]*n+this._m[15]*a;e.x=s,e.y=o,e.z=h,e.w=_},transformPointTo:function(t,e){var i=t.x,r=t.y,n=t.z,a=(t.w,this._m[0]*i+this._m[4]*r+this._m[8]*n+this._m[12]),s=this._m[1]*i+this._m[5]*r+this._m[9]*n+this._m[13],o=this._m[2]*i+this._m[6]*r+this._m[10]*n+this._m[14];e.x=a,e.y=s,e.z=o,e.w=1},transformVectorTo:function(t,e){var i=t.x,r=t.y,n=t.z,a=m00*i+m01*r+m02*n,s=m10*i+m11*r+m12*n,o=m20*i+m21*r+m22*n;e.x=a,e.y=s,e.z=o,e.w=0},transformExtentTo:function(t,e){var i=t.x,r=t.y,n=t.z,a=this._m[0],s=this._m[1],o=this._m[2],h=this._m[4],_=this._m[5],l=this._m[6],c=this._m[8],u=this._m[9],m=this._m[10];0>a&&(a=-a),0>s&&(s=-s),0>o&&(o=-o),0>h&&(h=-h),0>_&&(_=-_),0>l&&(l=-l),0>c&&(c=-c),0>u&&(u=-u),0>m&&(m=-m),e.x=a*i+h*r+c*n,e.y=s*i+_*r+u*n,e.z=o*i+l*r+m*n,e.w=0},copyFrom:function(t){this._m[0]=t._m[0],this._m[1]=t._m[1],this._m[2]=t._m[2],this._m[3]=t._m[3],this._m[4]=t._m[4],this._m[5]=t._m[5],this._m[6]=t._m[6],this._m[7]=t._m[7],this._m[8]=t._m[8],this._m[9]=t._m[9],this._m[10]=t._m[10],this._m[11]=t._m[11],this._m[12]=t._m[12],this._m[13]=t._m[13],this._m[14]=t._m[14],this._m[15]=t._m[15]},fromQuaternion:function(t){var e=t.x,i=t.y,r=t.z,n=t.w;this._m[0]=1-2*(i*i+r*r),this._m[1]=2*(e*i+n*r),this._m[2]=2*(e*r-n*i),this._m[3]=0,this._m[4]=2*(e*i-n*r),this._m[5]=1-2*(e*e+r*r),this._m[6]=2*(i*r+n*e),this._m[7]=0,this._m[8]=2*(e*r+n*i),this._m[9]=2*(i*r-n*e),this._m[10]=1-2*(e*e+i*i),this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=0,this._m[15]=1},product:function(t,e){var i=t._m[0],r=t._m[1],n=t._m[2],a=t._m[3],s=t._m[4],o=t._m[5],h=t._m[6],_=t._m[7],l=t._m[8],c=t._m[9],u=t._m[10],m=t._m[11],f=t._m[12],d=t._m[13],p=t._m[14],X=t._m[15],H=e._m[0],g=e._m[1],x=e._m[2],S=e._m[3],v=e._m[4],E=e._m[5],L=e._m[6],T=e._m[7],P=e._m[8],M=e._m[9],y=e._m[10],R=e._m[11],A=e._m[12],D=e._m[13],w=e._m[14],b=e._m[15];this._m[0]=i*H+s*g+l*x+f*S,this._m[1]=r*H+o*g+c*x+d*S,this._m[2]=n*H+h*g+u*x+p*S,this._m[3]=a*H+_*g+m*x+X*S,this._m[4]=i*v+s*E+l*L+f*T,this._m[5]=r*v+o*E+c*L+d*T,this._m[6]=n*v+h*E+u*L+p*T,this._m[7]=a*v+_*E+m*L+X*T,this._m[8]=i*P+s*M+l*y+f*R,this._m[9]=r*P+o*M+c*y+d*R,this._m[10]=n*P+h*M+u*y+p*R,this._m[11]=a*P+_*M+m*y+X*R,this._m[12]=i*A+s*D+l*w+f*b,this._m[13]=r*A+o*D+c*w+d*b,this._m[14]=n*A+h*D+u*w+p*b,this._m[15]=a*A+_*D+m*w+X*b},productAffine:function(t,e){var i=t._m[0],r=t._m[1],n=t._m[2],a=t._m[4],s=t._m[5],o=t._m[6],h=t._m[8],_=t._m[9],l=t._m[10],c=t._m[12],u=t._m[13],m=t._m[14],f=e._m[0],d=e._m[1],p=e._m[2],X=e._m[4],H=e._m[5],g=e._m[6],x=e._m[8],S=e._m[9],v=e._m[10],E=e._m[12],L=e._m[13],T=e._m[14];this._m[0]=i*f+a*d+h*p,this._m[1]=r*f+s*d+_*p,this._m[2]=n*f+o*d+l*p,this._m[4]=i*X+a*H+h*g,this._m[5]=r*X+s*H+_*g,this._m[6]=n*X+o*H+l*g,this._m[8]=i*x+a*S+h*v,this._m[9]=r*x+s*S+_*v,this._m[10]=n*x+o*S+l*v,this._m[12]=i*E+a*L+h*T+c,this._m[13]=r*E+s*L+_*T+u,this._m[14]=n*E+o*L+l*T+m},sum:function(t,e){this._m[0]=t._m[0]+e._m[0],this._m[1]=t._m[1]+e._m[1],this._m[2]=t._m[2]+e._m[3],this._m[3]=t._m[3]+e._m[3],this._m[4]=t._m[4]+e._m[4],this._m[5]=t._m[5]+e._m[5],this._m[6]=t._m[6]+e._m[6],this._m[7]=t._m[7]+e._m[7],this._m[8]=t._m[8]+e._m[8],this._m[9]=t._m[9]+e._m[9],this._m[10]=t._m[10]+e._m[10],this._m[11]=t._m[11]+e._m[11],this._m[12]=t._m[12]+e._m[12],this._m[13]=t._m[13]+e._m[13],this._m[14]=t._m[14]+e._m[14],this._m[15]=t._m[15]+e._m[15]},sumAffine:function(t,e){this._m[0]=t._m[0]+e._m[0],this._m[1]=t._m[1]+e._m[1],this._m[2]=t._m[2]+e._m[3],this._m[4]=t._m[4]+e._m[4],this._m[5]=t._m[5]+e._m[5],this._m[6]=t._m[6]+e._m[6],this._m[8]=t._m[8]+e._m[8],this._m[9]=t._m[9]+e._m[9],this._m[10]=t._m[10]+e._m[10]},difference:function(t,e){this._m[0]=t._m[0]-e._m[0],this._m[1]=t._m[1]-e._m[1],this._m[2]=t._m[2]-e._m[3],this._m[3]=t._m[3]-e._m[3],this._m[4]=t._m[4]-e._m[4],this._m[5]=t._m[5]-e._m[5],this._m[6]=t._m[6]-e._m[6],this._m[7]=t._m[7]-e._m[7],this._m[8]=t._m[8]-e._m[8],this._m[9]=t._m[9]-e._m[9],this._m[10]=t._m[10]-e._m[10],this._m[11]=t._m[11]-e._m[11],this._m[12]=t._m[12]-e._m[12],this._m[13]=t._m[13]-e._m[13],this._m[14]=t._m[14]-e._m[14],this._m[15]=t._m[15]-e._m[15]},differenceAffine:function(t,e){this._m[0]=t._m[0]-e._m[0],this._m[1]=t._m[1]-e._m[1],this._m[2]=t._m[2]-e._m[3],this._m[4]=t._m[4]-e._m[4],this._m[5]=t._m[5]-e._m[5],this._m[6]=t._m[6]-e._m[6],this._m[8]=t._m[8]-e._m[8],this._m[9]=t._m[9]-e._m[9],this._m[10]=t._m[10]-e._m[10]},rotationX:function(t){var e=Math.cos(t),i=Math.sin(t);this._m[0]=1,this._m[1]=0,this._m[2]=0,this._m[3]=0,this._m[4]=0,this._m[5]=e,this._m[6]=i,this._m[7]=0,this._m[8]=0,this._m[9]=-i,this._m[10]=e,this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=0,this._m[15]=1},rotationY:function(t){var e=Math.cos(t),i=Math.sin(t);this._m[0]=e,this._m[1]=0,this._m[2]=-i,this._m[3]=0,this._m[4]=0,this._m[5]=1,this._m[6]=0,this._m[7]=0,this._m[8]=i,this._m[9]=0,this._m[10]=e,this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=0,this._m[15]=1},rotationZ:function(t){var e=Math.cos(t),i=Math.sin(t);this._m[0]=e,this._m[1]=i,this._m[2]=0,this._m[3]=0,this._m[4]=-i,this._m[5]=e,this._m[6]=0,this._m[7]=0,this._m[8]=0,this._m[9]=0,this._m[10]=1,this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=0,this._m[15]=1},rotationAxisAngle:function(t,e){var i=Math.cos(e),r=Math.sin(e),n=1/t.length(),a=t.x*n,s=t.y*n,o=t.z*n,h=1-i;this._m[0]=h*a*a+i,this._m[1]=h*a*s+r*o,this._m[2]=h*a*o-r*s,this._m[3]=0,this._m[4]=h*a*s-r*o,this._m[5]=h*s*s+i,this._m[6]=h*s*o+r*a,this._m[7]=0,this._m[8]=h*a*o+r*s,this._m[9]=h*s*o-r*a,this._m[10]=h*o*o+i,this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=0,this._m[15]=1},rotationXYZ:function(t,e,i){var r=Math.cos(t),n=Math.sin(t),a=Math.cos(e),s=Math.sin(e),o=Math.cos(i),h=Math.sin(i);this._m[0]=a*o,this._m[1]=n*s*o-r*h,this._m[2]=r*s*o+n*h,this._m[3]=0,this._m[4]=a*h,this._m[5]=n*s*h+r*o,this._m[6]=r*s*h-n*o,this._m[7]=0,this._m[8]=-s,this._m[9]=n*a,this._m[10]=r*a,this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=0,this._m[15]=1},rotationPitchYawRoll:function(t,e,i){var r=Math.cos(-t),n=Math.cos(-e),a=Math.cos(i),s=Math.sin(-t),o=Math.sin(-e),h=Math.sin(i),_=-o*r,l=-s,c=n*r,u=-n*h-o*s*a,m=r*a,f=-o*h+s*a*n,d=m*c-f*l,p=f*_-u*c,X=u*l-m*_;this._m[0]=d,this._m[1]=p,this._m[2]=X,this._m[3]=0,this._m[4]=u,this._m[5]=m,this._m[6]=f,this._m[7]=0,this._m[8]=_,this._m[9]=l,this._m[10]=c,this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=0,this._m[15]=1},translation:function(t,e,i){this._m[0]=1,this._m[1]=0,this._m[2]=0,this._m[3]=0,this._m[4]=0,this._m[5]=1,this._m[6]=0,this._m[7]=0,this._m[8]=0,this._m[9]=0,this._m[10]=1,this._m[11]=0,this._m[12]=t,this._m[13]=e,this._m[14]=i,this._m[15]=1},scaleMatrix:function(t,e,i){this._m[0]=t,this._m[1]=0,this._m[2]=0,this._m[3]=0,this._m[4]=0,this._m[5]=e,this._m[6]=0,this._m[7]=0,this._m[8]=0,this._m[9]=0,this._m[10]=i,this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=0,this._m[15]=1},perspectiveProjection:function(t,e,i,r){var n=1/Math.tan(.5*t),a=n/e,s=1/(i-r);this._m[0]=a,this._m[1]=0,this._m[2]=0,this._m[3]=0,this._m[4]=0,this._m[5]=n,this._m[6]=0,this._m[7]=0,this._m[8]=0,this._m[9]=0,this._m[10]=(r+i)*s,this._m[11]=-1,this._m[12]=0,this._m[13]=0,this._m[14]=2*i*r*s,this._m[15]=0},orthographicOffCenterProjection:function(t,e,i,r,n,a){var s=1/(e-t),o=1/(i-r),h=1/(n-a);this._m[0]=2*s,this._m[1]=0,this._m[2]=0,this._m[3]=0,this._m[4]=0,this._m[5]=2*o,this._m[6]=0,this._m[7]=0,this._m[8]=0,this._m[9]=0,this._m[10]=2*h,this._m[11]=0,this._m[12]=-(t+e)*s,this._m[13]=-(i+r)*o,this._m[14]=(a+n)*h,this._m[15]=1},orthographicProjection:function(t,e,i,r){var n=Math.tan(.5*vFOV),a=n*aspectRatio,s=1/(i-r);this._m[0]=1/a,this._m[1]=0,this._m[2]=0,this._m[3]=0,this._m[4]=0,this._m[5]=1/n,this._m[6]=0,this._m[7]=0,this._m[8]=0,this._m[9]=0,this._m[10]=2*s,this._m[11]=0,this._m[12]=0,this._m[13]=0,this._m[14]=(r+i)*s,this._m[15]=1},scaled:function(t,e){this._m[0]=e._m[0]*t,this._m[1]=e._m[1]*t,this._m[2]=e._m[2]*t,this._m[3]=e._m[3]*t,this._m[4]=e._m[4]*t,this._m[5]=e._m[5]*t,this._m[6]=e._m[6]*t,this._m[7]=e._m[7]*t,this._m[8]=e._m[8]*t,this._m[9]=e._m[9]*t,this._m[10]=e._m[10]*t,this._m[11]=e._m[11]*t,this._m[12]=e._m[12]*t,this._m[13]=e._m[13]*t,this._m[14]=e._m[14]*t,this._m[15]=e._m[15]*t},add:function(t){this._m[0]+=t._m[0],this._m[1]+=t._m[1],this._m[2]+=t._m[2],this._m[3]+=t._m[3],this._m[4]+=t._m[4],this._m[5]+=t._m[5],this._m[6]+=t._m[6],this._m[7]+=t._m[7],this._m[8]+=t._m[8],this._m[9]+=t._m[9],this._m[10]+=t._m[10],this._m[11]+=t._m[11],this._m[12]+=t._m[12],this._m[13]+=t._m[13],this._m[14]+=t._m[14],this._m[15]+=t._m[15]},subtract:function(t){this._m[0]-=t._m[0],this._m[1]-=t._m[1],this._m[2]-=t._m[2],this._m[3]-=t._m[3],this._m[4]-=t._m[4],this._m[5]-=t._m[5],this._m[6]-=t._m[6],this._m[7]-=t._m[7],this._m[8]-=t._m[8],this._m[9]-=t._m[9],this._m[10]-=t._m[10],this._m[11]-=t._m[11],this._m[12]-=t._m[12],this._m[13]-=t._m[13],this._m[14]-=t._m[14],this._m[15]-=t._m[15]},clone:function(){return new HX.Matrix4x4(this._m[0],this._m[4],this._m[8],this._m[12],this._m[1],this._m[5],this._m[9],this._m[13],this._m[2],this._m[6],this._m[10],this._m[14],this._m[3],this._m[7],this._m[11],this._m[15])},transpose:function(){var t=this._m[1],e=this._m[2],i=this._m[3],r=this._m[6],n=this._m[7],a=this._m[11];this._m[1]=this._m[4],this._m[2]=this._m[8],this._m[3]=this._m[12],this._m[4]=t,this._m[6]=this._m[9],this._m[7]=this._m[13],this._m[8]=e,this._m[9]=r,this._m[11]=this._m[14],this._m[12]=i,this._m[13]=n,this._m[14]=a},determinant3x3:function(t,e){var i=0==e?4:0,r=2>e?8:4,n=3==e?8:12,a=0==t?1:0,s=2>t?2:1,o=3==t?2:3,h=this._m[i|s],_=this._m[s|r],l=this._m[n|s],c=this._m[i|o],u=this._m[r|o],m=this._m[o|n];return this._m[i|a]*(_*m-l*u)-this._m[r|a]*(h*m-l*c)+this._m[n|a]*(h*u-_*c)},cofactor:function(t,e){var i=1-((t+e&1)<<1);return i*this.determinant3x3(t,e)},getCofactorMatrix:function(t,e){for(var i=new HX.Matrix4x4,r=0;16>r;++r)i._m[r]=this.cofactor(3&r,r>>2);return i},getAdjugate:function(t,e){for(var i=new HX.Matrix4x4,r=0;16>r;++r)i._m[r]=this.cofactor(r>>2,3&r);return i},determinant:function(){return this._m[0]*this.determinant3x3(0,0)-this._m[4]*this.determinant3x3(0,1)+this._m[8]*this.determinant3x3(0,2)-this._m[12]*this.determinant3x3(0,3)},inverseOf:function(t){var e=1/t.determinant();this._m[0]=e*t.cofactor(0,0),this._m[1]=e*t.cofactor(0,1),this._m[2]=e*t.cofactor(0,2),this._m[3]=e*t.cofactor(0,3),this._m[4]=e*t.cofactor(1,0),this._m[5]=e*t.cofactor(1,1),this._m[6]=e*t.cofactor(1,2),this._m[7]=e*t.cofactor(1,3),this._m[8]=e*t.cofactor(2,0),this._m[9]=e*t.cofactor(2,1),this._m[10]=e*t.cofactor(2,2),this._m[11]=e*t.cofactor(2,3),this._m[12]=e*t.cofactor(3,0),this._m[13]=e*t.cofactor(3,1),this._m[14]=e*t.cofactor(3,2),this._m[15]=e*t.cofactor(3,3)},inverseAffineOf:function(t){var e=t._m[0],i=t._m[1],r=t._m[2],n=t._m[4],a=t._m[5],s=t._m[6],o=t._m[8],h=t._m[9],_=t._m[10],l=t._m[12],c=t._m[13],u=t._m[14],m=e*(a*_-h*s)-n*(i*_-h*r)+o*(i*s-a*r),f=1/m,d=(a*_-h*s)*f,p=(h*r-i*_)*f,X=(i*s-a*r)*f,H=(o*s-n*_)*f,g=(e*_-o*r)*f,x=(n*r-e*s)*f,S=(n*h-o*a)*f,v=(o*i-e*h)*f,E=(e*a-n*i)*f;this._m[0]=d,this._m[1]=p,this._m[2]=X,this._m[3]=0,this._m[4]=H,this._m[5]=g,this._m[6]=x,this._m[7]=0,this._m[8]=S,this._m[9]=v,this._m[10]=E,this._m[11]=0,this._m[12]=-d*l-H*c-S*u,this._m[13]=-p*l-g*c-v*u,this._m[14]=-X*l-x*c-E*u,this._m[15]=1},writeNormalMatrix:function(t){var e=this._m[0],i=this._m[1],r=this._m[2],n=this._m[4],a=this._m[5],s=this._m[6],o=this._m[8],h=this._m[9],_=this._m[10],l=e*(a*_-h*s)-this._m[4]*(i*_-h*r)+this._m[8]*(i*s-a*r),c=1/l;t[0]=(a*_-h*s)*c,t[1]=(o*s-n*_)*c,t[2]=(n*h-o*a)*c,t[3]=(h*r-i*_)*c,t[4]=(e*_-o*r)*c,t[5]=(o*i-e*h)*c,t[6]=(i*s-a*r)*c,t[7]=(n*r-e*s)*c,t[8]=(e*a-n*i)*c},invert:function(){var t=1/this.determinant(),e=t*this.cofactor(0,0),i=t*this.cofactor(0,1),r=t*this.cofactor(0,2),n=t*this.cofactor(0,3),a=t*this.cofactor(1,0),s=t*this.cofactor(1,1),o=t*this.cofactor(1,2),h=t*this.cofactor(1,3),_=t*this.cofactor(2,0),l=t*this.cofactor(2,1),c=t*this.cofactor(2,2),u=t*this.cofactor(2,3),m=t*this.cofactor(3,0),f=t*this.cofactor(3,1),d=t*this.cofactor(3,2),p=t*this.cofactor(3,3);this._m[0]=e,this._m[1]=i,this._m[2]=r,this._m[3]=n,this._m[4]=a,this._m[5]=s,this._m[6]=o,this._m[7]=h,this._m[8]=_,this._m[9]=l,this._m[10]=c,this._m[11]=u,this._m[12]=m,this._m[13]=f,this._m[14]=d,this._m[15]=p},invertAffine:function(){var t=this._m[0],e=this._m[1],i=this._m[2],r=this._m[4],n=this._m[5],a=this._m[6],s=this._m[8],o=this._m[9],h=this._m[10],_=this._m[12],l=this._m[13],c=this._m[14],u=t*(n*h-o*a)-r*(e*h-o*i)+s*(e*a-n*i),m=1/u,f=(n*h-o*a)*m,d=(o*i-e*h)*m,p=(e*a-n*i)*m,X=(s*a-r*h)*m,H=(t*h-s*i)*m,g=(r*i-t*a)*m,x=(r*o-s*n)*m,S=(s*e-t*o)*m,v=(t*n-r*e)*m;this._m[0]=f,this._m[1]=d,this._m[2]=p,this._m[4]=X,this._m[5]=H,this._m[6]=g,this._m[8]=x,this._m[9]=S,this._m[10]=v,this._m[12]=-f*_-X*l-x*c,this._m[13]=-d*_-H*l-S*c,this._m[14]=-p*_-g*l-v*c},append:function(t){this.product(this,t)},prepend:function(t){this.product(t,this)},appendAffine:function(t){this.productAffine(t,this)},prependAffine:function(t){this.productAffine(this,t)},add:function(t){this._m[0]+=t._m[0],this._m[1]+=t._m[1],this._m[2]+=t._m[2],this._m[3]+=t._m[3],this._m[4]+=t._m[4],this._m[5]+=t._m[5],this._m[6]+=t._m[6],this._m[7]+=t._m[7],this._m[8]+=t._m[8],this._m[9]+=t._m[9],this._m[10]+=t._m[10],this._m[11]+=t._m[11],this._m[12]+=t._m[12],this._m[13]+=t._m[13],this._m[14]+=t._m[14],this._m[15]+=t._m[15]},addAffine:function(t){this._m[0]+=t._m[0],this._m[1]+=t._m[1],this._m[2]+=t._m[2],this._m[4]+=t._m[4],this._m[5]+=t._m[5],this._m[6]+=t._m[6],this._m[8]+=t._m[8],this._m[9]+=t._m[9],this._m[10]+=t._m[10]},subtract:function(t){this._m[0]-=t._m[0],this._m[1]-=t._m[1],this._m[2]-=t._m[2],this._m[3]-=t._m[3],this._m[4]-=t._m[4],this._m[5]-=t._m[5],this._m[6]-=t._m[6],this._m[7]-=t._m[7],this._m[8]-=t._m[8],this._m[9]-=t._m[9],this._m[10]-=t._m[10],this._m[11]-=t._m[11],this._m[12]-=t._m[12],this._m[13]-=t._m[13],this._m[14]-=t._m[14],this._m[15]-=t._m[15]},subtractAffine:function(t){this._m[0]-=t._m[0],this._m[1]-=t._m[1],this._m[2]-=t._m[2],this._m[4]-=t._m[4],this._m[5]-=t._m[5],this._m[6]-=t._m[6],this._m[8]-=t._m[8],this._m[9]-=t._m[9],this._m[10]-=t._m[10]},appendScale:function(t,e,i){this._m[0]*=t,this._m[1]*=e,this._m[2]*=i,this._m[4]*=t,this._m[5]*=e,this._m[6]*=i,this._m[8]*=t,this._m[9]*=e,this._m[10]*=i,this._m[12]*=t,this._m[13]*=e,this._m[14]*=i},prependScale:function(t,e,i){this._m[0]*=t,this._m[1]*=t,this._m[2]*=t,this._m[3]*=t,this._m[4]*=e,this._m[5]*=e,this._m[6]*=e,this._m[7]*=e,this._m[8]*=i,this._m[9]*=i,this._m[10]*=i,this._m[11]*=i},appendTranslation:function(t,e,i){this._m[12]+=t,this._m[13]+=e,this._m[14]+=i},prependTranslation:function(t,e,i){this._m[12]+=this._m[0]*t+this._m[4]*e+this._m[8]*i,this._m[13]+=this._m[1]*t+this._m[5]*e+this._m[9]*i,this._m[14]+=this._m[2]*t+this._m[6]*e+this._m[10]*i,this._m[15]+=this._m[3]*t+this._m[7]*e+this._m[11]*i},appendRotationQuaternion:function(t){var e=t.x,i=t.y,r=t.z,n=t.w,a=1-2*(i*i+r*r),s=2*(e*i+n*r),o=2*(e*r-n*i),h=2*(e*i-n*r),_=1-2*(e*e+r*r),l=2*(i*r+n*e),c=2*(e*r+n*i),u=2*(i*r-n*e),m=1-2*(e*e+i*i),f=this._m[0],d=this._m[1],p=this._m[2],X=this._m[4],H=this._m[5],g=this._m[6],x=this._m[8],S=this._m[9],v=this._m[10],E=this._m[12],L=this._m[13],T=this._m[14];this._m[0]=a*f+h*d+c*p,this._m[1]=s*f+_*d+u*p,this._m[2]=o*f+l*d+m*p,this._m[4]=a*X+h*H+c*g,this._m[5]=s*X+_*H+u*g,this._m[6]=o*X+l*H+m*g,this._m[8]=a*x+h*S+c*v,this._m[9]=s*x+_*S+u*v,this._m[10]=o*x+l*S+m*v,this._m[12]=a*E+h*L+c*T,this._m[13]=s*E+_*L+u*T,this._m[14]=o*E+l*L+m*T},prependRotationQuaternion:function(t){var e=t.x,i=t.y,r=t.z,n=t.w,a=this._m[0],s=this._m[1],o=this._m[2],h=this._m[4],_=this._m[5],l=this._m[6],c=this._m[8],u=this._m[9],m=this._m[10],f=1-2*(i*i+r*r),d=2*(e*i+n*r),p=2*(e*r-n*i),X=2*(e*i-n*r),H=1-2*(e*e+r*r),g=2*(i*r+n*e),x=2*(e*r+n*i),S=2*(i*r-n*e),v=1-2*(e*e+i*i);this._m[0]=a*f+h*d+c*p,this._m[1]=s*f+_*d+u*p,this._m[2]=o*f+l*d+m*p,this._m[4]=a*X+h*H+c*g,this._m[5]=s*X+_*H+u*g,this._m[6]=o*X+l*H+m*g,this._m[8]=a*x+h*S+c*v,this._m[9]=s*x+_*S+u*v,this._m[10]=o*x+l*S+m*v},appendRotationAxisAngle:function(t,e){var i=Math.cos(e),r=Math.sin(e),n=1/t.length(),a=t.x*n,s=t.y*n,o=t.z*n,h=1-i,_=h*a*a+i,l=h*a*s+r*o,c=h*a*o-r*s,u=h*a*s-r*o,m=h*s*s+i,f=h*s*o+r*a,d=h*a*o+r*s,p=h*s*o-r*a,X=h*o*o+i,H=this._m[0],g=this._m[1],x=this._m[2],S=this._m[4],v=this._m[5],E=this._m[6],L=this._m[8],T=this._m[9],P=this._m[10],M=this._m[12],y=this._m[13],R=this._m[14];this._m[0]=_*H+u*g+d*x,this._m[1]=l*H+m*g+p*x,this._m[2]=c*H+f*g+X*x,this._m[4]=_*S+u*v+d*E,this._m[5]=l*S+m*v+p*E,this._m[6]=c*S+f*v+X*E,this._m[8]=_*L+u*T+d*P,this._m[9]=l*L+m*T+p*P,this._m[10]=c*L+f*T+X*P,this._m[12]=_*M+u*y+d*R,this._m[13]=l*M+m*y+p*R,this._m[14]=c*M+f*y+X*R},prependRotationAxisAngle:function(t,e){var i=Math.cos(e),r=Math.sin(e),n=1/t.length(),a=t.x*n,s=t.y*n,o=t.z*n,h=1-i,_=this._m[0],l=this._m[1],c=this._m[2],u=this._m[4],m=this._m[5],f=this._m[6],d=this._m[8],p=this._m[9],X=this._m[10],H=h*a*a+i,g=h*a*s+r*o,x=h*a*o-r*s,S=h*a*s-r*o,v=h*s*s+i,E=h*s*o+r*a,L=h*a*o+r*s,T=h*s*o-r*a,P=h*o*o+i;this._m[0]=_*H+u*g+d*x,this._m[1]=l*H+m*g+p*x,this._m[2]=c*H+f*g+X*x,this._m[4]=_*S+u*v+d*E,this._m[5]=l*S+m*v+p*E,this._m[6]=c*S+f*v+X*E,this._m[8]=_*L+u*T+d*P,this._m[9]=l*L+m*T+p*P,this._m[10]=c*L+f*T+X*P},getRow:function(t,e){return e||(e=new HX.Float4),e.x=this._m[t],e.y=this._m[4|t],e.z=this._m[8|t],e.w=this._m[12|t],e},setRow:function(t,e){this._m[t]=e.x,this._m[4|t]=e.y,this._m[8|t]=e.z,this._m[12|t]=e.w},getElement:function(t,e){return this._m[t|e<<2]},setElement:function(t,e,i){this._m[t|e<<2]=i},getColumn:function(t,e){return e||(e=new HX.Float4),t<<=2,e.x=this._m[t],e.y=this._m[1|t],e.z=this._m[2|t],e.w=this._m[3|t],e},setColumn:function(t,e){t<<=2,this._m[t]=e.x,this._m[1|t]=e.y,this._m[2|t]=e.z,this._m[3|t]=e.w},lookAt:function(t,e,i){var r=new HX.Float4;r.difference(e,t),r.normalize();var n=new HX.Float4;if(n.cross(i,r),Math.abs(n.lengthSqr())>1e-4)n.normalize();else{var a=new HX.Float4(i.x,i.z,i.y,0);n.cross(a,r),Math.abs(n.lengthSqr())<=1e-4&&(a.set(i.z,i.y,i.z,0),n.cross(a,r)),n.normalize()}var s=new HX.Float4;s.cross(r,n),this._m[0]=n.x,this._m[1]=n.y,this._m[2]=n.z,this._m[3]=0,this._m[4]=s.x,this._m[5]=s.y,this._m[6]=s.z,this._m[7]=0,this._m[8]=r.x,this._m[9]=r.y,this._m[10]=r.z,this._m[11]=0,this._m[12]=e.x,this._m[13]=e.y,this._m[14]=e.z,this._m[15]=1},compose:function(t){this.fromQuaternion(t.rotation);var e=t.scale,i=t.position;this.appendScale(e.x,e.y,e.z),this.appendTranslation(i.x,i.y,i.z)},decompose:function(t){t=t||new Transform;var e=this._m[0],i=this._m[1],r=this._m[2],n=this._m[4],a=this._m[5],s=this._m[6],o=this._m[8],h=this._m[9],_=this._m[10];return t.scale.x=Math.sqrt(e*e+i*i+r*r),t.scale.y=Math.sqrt(n*n+a*a+s*s),t.scale.z=Math.sqrt(o*o+h*h+_*_),t.rotation.fromMatrix(this),t.position.copyFrom(this.getColumn(3)),t}},HX.Matrix4x4.IDENTITY=new HX.Matrix4x4,HX.Matrix4x4.ZERO=new HX.Matrix4x4(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),HX.PoissonDisk=function(t,e,i,r){this._mode=void 0===t?HX.PoissonDisk.CIRCULAR:t,this._initialDistance=e||1,this._decayFactor=i||.99,this._maxTests=r||2e4,this._currentDistance=0,this._points=null,this.reset()},HX.PoissonDisk.SQUARE=0,HX.PoissonDisk.CIRCULAR=1,HX.PoissonDisk.prototype={getPoints:function(){return this._points},reset:function(){this._currentDistance=this._initialDistance,this._points=[]},generatePoints:function(t){for(var e=0;t>e;++e)this.generatePoint()},generatePoint:function(){for(;;){for(var t=0,e=this._currentDistance*this._currentDistance;t++<this._maxTests;){var i=this._getCandidate();if(this._isValid(i,e))return this._points.push(i),i}this._currentDistance*=this._decayFactor}},_getCandidate:function(){for(;;){var t=2*Math.random()-1,e=2*Math.random()-1;if(this._mode==HX.PoissonDisk.SQUARE||1>=t*t+e*e)return new HX.Float2(t,e)}},_isValid:function(t,e){for(var i=this._points.length,r=0;i>r;++r){var n=this._points[r],a=t.x-n.x,s=t.y-n.y;if(e>a*a+s*s)return!1}return!0}},HX.PoissonSphere=function(t,e,i,r){this._mode=void 0===t?HX.PoissonSphere.CIRCULAR:t,this._initialDistance=e||1,this._decayFactor=i||.99,this._maxTests=r||2e4,this._currentDistance=0,this._points=null,this.reset()},HX.PoissonSphere.BOX=0,HX.PoissonSphere.CIRCULAR=1,HX.PoissonSphere.prototype={getPoints:function(){return this._points},reset:function(){this._currentDistance=this._initialDistance,this._points=[]},generatePoints:function(t){for(var e=0;t>e;++e)this.generatePoint()},generatePoint:function(){for(;;){for(var t=0,e=this._currentDistance*this._currentDistance;t++<this._maxTests;){var i=this._getCandidate();if(this._isValid(i,e))return this._points.push(i),i}this._currentDistance*=this._decayFactor}},_getCandidate:function(){for(;;){var t=2*Math.random()-1,e=2*Math.random()-1,i=2*Math.random()-1;if(this._mode==HX.PoissonSphere.BOX||1>=t*t+e*e+i*i)return new HX.Float4(t,e,i,0)}},_isValid:function(t,e){for(var i=this._points.length,r=0;i>r;++r){var n=this._points[r],a=t.x-n.x,s=t.y-n.y,o=t.z-n.z;if(e>a*a+s*s+o*o)return!1}return!0}},HX.Quaternion=function(){this.x=0,this.y=0,this.z=0,this.w=1},HX.Quaternion.fromAxisAngle=function(t,e){var i=new HX.Quaternion;return i.fromAxisAngle(t,e),i},HX.Quaternion.fromPitchYawRoll=function(t,e,i){var r=new HX.Quaternion;return r.fromPitchYawRoll(t,e,i),r},HX.Quaternion.prototype={fromAxisAngle:function(t,e){var i=Math.sin(.5*e)/t.length();this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(.5*e)},fromPitchYawRoll:function(t,e,i){var r=new HX.Matrix4x4;r.fromPitchYawRoll(t,e,i),this.fromMatrix(r)},fromMatrix:function(t){var e=t._m[0],i=t._m[5],r=t._m[10],n=e+i+r;if(n>0){n+=1;var a=1/Math.sqrt(n)*.5;this.x=a*(t._m[6]-t._m[9]),this.y=a*(t._m[8]-t._m[2]),this.z=a*(t._m[1]-t._m[4]),this.w=a*n}else if(e>i&&e>r){n=e-i-r+1;var a=1/Math.sqrt(n)*.5;this.x=a*n,this.y=a*(t._m[1]+t._m[4]),this.z=a*(t._m[8]+t._m[2]),this.w=a*(t._m[6]-t._m[9])}else if(i>r){n=i-e-r+1;var a=1/Math.sqrt(n)*.5;this.x=a*(t._m[1]+t._m[4]),this.y=a*n,this.z=a*(t._m[6]+t._m[9]),this.w=a*(t._m[8]-t._m[2])}else{n=r-e-i+1;var a=1/Math.sqrt(n)*.5;this.x=a*(t._m[8]+t._m[2]),this.y=a*(t._m[6]+t._m[9]),this.z=a*n,this.w=a*(t._m[1]-t._m[4])}},rotate:function(t){var e=t.x,i=t.y,r=t.z,n=-this.x*e-this.y*i-this.z*r,a=w*e+this.y*r-this.z*i,s=w*i-this.x*r+this.z*e,o=w*r+this.x*i-this.y*e;return new HX.Float4(-n*this.x+a*this.w-s*this.z+o*this.y,-n*this.y+a*this.z+s*this.w-o*this.x,-n*this.z-a*this.y+s*this.x+o*this.w,t.w)},lerp:function(t,e,i){var r=t.w,n=t.x,a=t.y,s=t.z,o=e.w,h=e.x,_=e.y,l=e.z;0>r*o+n*h+a*_+s*l&&(o=-o,h=-h,_=-_,l=-l),this.x=n+i*(h-n),this.y=a+i*(_-a),this.z=s+i*(l-s),this.w=r+i*(o-r),this.normalize()},slerp:function(t,e,i){var r=t.w,n=t.x,a=t.y,s=t.z,o=e.w,h=e.x,_=e.y,l=e.z,c=r*o+n*h+a*_+s*l;if(0>c&&(c=-c,o=-o,h=-h,_=-_,l=-l),.95>c){var u=Math.acos(c),m=i*u;this.x=h-n*c,this.y=_-a*c,this.z=l-s*c,this.w=o-r*c,this.normalize();var f=Math.cos(m),d=Math.sin(m);this.x=n*f+this.x*d,this.y=a*f+this.y*d,this.z=s*f+this.z*d,this.w=r*f+this.w*d}else this.x=n+i*(h-n),this.y=a+i*(_-a),this.z=s+i*(l-s),this.w=r+i*(o-r),this.normalize()},negate:function(){this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w},set:function(t,e,i,r){this.x=t,this.y=e,this.z=i,this.w=r},normSquared:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},norm:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},normalize:function(){var t=1/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=t,this.y*=t,this.z*=t,this.w*=t},conjugateOf:function(t){this.x=-t.x,this.y=-t.y,this.z=-t.z,this.w=t.w},inverseOf:function(t){var e=t.x,i=t.y,r=t.z,n=t.w,a=1/(e*e+i*i+r*r+n*n);this.x=-e*a,this.y=-i*a,this.z=-r*a,this.w=n*a},invert:function(t){var e=this.x,i=this.y,r=this.z,n=this.w,a=1/(e*e+i*i+r*r+n*n);this.x=-e*a,this.y=-i*a,this.z=-r*a,this.w=n*a},product:function(t,e){var i=t.w,r=t.x,n=t.y,a=t.z,s=e.w,o=e.x,h=e.y,_=e.z;this.x=i*o+r*s+n*_-a*h,this.y=i*h-r*_+n*s+a*o,this.z=i*_+r*h-n*o+a*s,this.w=i*s-r*o-n*h-a*_},append:function(t){this.product(t,this)},prepend:function(t){this.product(this,t)}},HX.Transform=function(){this._position=new HX.Float4(0,0,0,1),this._rotation=new HX.Quaternion,this._scale=new HX.Float4(1,1,1,1),this._matrix=new HX.Matrix4x4,this._changeListener=new HX.PropertyListener,this._changeListener.add(this._position,"x"),this._changeListener.add(this._position,"y"),this._changeListener.add(this._position,"z"),this._changeListener.add(this._rotation,"x"),this._changeListener.add(this._rotation,"y"),this._changeListener.add(this._rotation,"z"),this._changeListener.add(this._rotation,"w"),this._changeListener.add(this._scale,"x"),this._changeListener.add(this._scale,"y"),this._changeListener.add(this._scale,"z"),this._changeListener.onChange.bind(this,this._invalidateTransformationMatrix)},HX.Transform.prototype={get position(){return this._position},set position(t){this._position.copyFrom(t)},get rotation(){return this._rotation},set rotation(t){this._rotation.copyFrom(t)},get scale(){return this._scale},set scale(t){this._scale.copyFrom(t)},lookAt:function(t){this._matrix.lookAt(t,this._position,HX.Float4.Y_AXIS),this._applyMatrix()},copyFrom:function(t){this._changeListener.enabled=!1,this.position.copyFrom(t.position),this.rotation.copyFrom(t.rotation),this.scale.copyFrom(t.scale),this._changeListener.enabled=!0},getTransformationMatrix:function(){return this._matrixInvalid&&this._updateTransformationMatrix(),this._matrix},setTransformationMatrix:function(t){this._matrix.copyFrom(t),this._applyMatrix()},_invalidateTransformationMatrix:function(){this._matrixInvalid=!0},_updateTransformationMatrix:function(){this._matrix.compose(this),this._matrixInvalid=!1},_applyMatrix:function(){this._matrixInvalid=!1,this._changeListener.enabled=!1,this._matrix.decompose(this),this._changeListener.enabled=!0}},HX.shuffle=function(t){for(var e,i,r=t.length;0!==r;)i=Math.floor(Math.random()*r),r-=1,e=t[r],t[r]=t[i],t[i]=e;return t},HX.BoundingVolume=function(t){this._type=t,this._expanse=HX.BoundingVolume.EXPANSE_EMPTY,this._minimumX=0,this._minimumY=0,this._minimumZ=0,this._maximumX=0,this._maximumY=0,this._maximumZ=0,this._halfExtentX=0,this._halfExtentY=0,this._halfExtentZ=0,this._centerX=0,this._centerY=0,this._centerZ=0},HX.BoundingVolume.EXPANSE_EMPTY=0,HX.BoundingVolume.EXPANSE_INFINITE=1,HX.BoundingVolume.EXPANSE_FINITE=2,HX.BoundingVolume._testAABBToSphere=function(t,e){var i=e._maximumX,r=e._maximumY,n=e._maximumZ,a=t._minimumX,s=t._minimumY,o=t._minimumZ,h=e._halfExtentX,_=this._centerX,l=this._centerY,c=this._centerZ,u=0;if(a>_){var m=_-a;u+=m*m}else if(_>i){var m=_-i;u+=m*m}if(s>l){var m=l-s;u+=m*m}else if(l>r){var m=l-r;u+=m*m}if(o>c){var m=c-o;u+=m*m}else if(c>n){var m=c-n;u+=m*m}return h*h>u},HX.BoundingVolume.prototype={getExpanse:function(){return this._expanse},type:function(){return this._type},growToIncludeMesh:function(t){throw"Abstract method!"},growToIncludeBound:function(t){throw"Abstract method!"},growToIncludeMinMax:function(t,e){throw"Abstract method!"},clear:function(t){this._minimumX=this._minimumY=this._minimumZ=0,this._maximumX=this._maximumY=this._maximumZ=0,this._centerX=this._centerY=this._centerZ=0,this._halfExtentX=this._halfExtentY=this._halfExtentZ=0,this._expanse=void 0===t?HX.BoundingVolume.EXPANSE_EMPTY:t},getMinimum:function(){return new HX.Float4(this._minimumX,this._minimumY,this._minimumZ,1)},getMaximum:function(){return new HX.Float4(this._maximumX,this._maximumY,this._maximumZ,1)},getCenter:function(){return new HX.Float4(this._centerX,this._centerY,this._centerZ,1)},getHalfExtent:function(){return new HX.Float4(this._halfExtentX,this._halfExtentY,this._halfExtentZ,0)},getRadius:function(){throw"Abstract method!"},transformFrom:function(t,e){throw"Abstract method!"},intersectsConvexSolid:function(t,e){throw"Abstract method!"},intersectsBound:function(t){throw"Abstract method!"},classifyAgainstPlane:function(t){throw"Abstract method!"},createDebugModelInstance:function(){throw"Abstract method!"},getDebugModelInstance:function(){return void 0===this._type._debugModel&&(this._type._debugModel=this.createDebugModelInstance()),this._type._debugModel},getDebugMaterial:function(){if(void 0===HX.BoundingVolume._debugMaterial){var t=new DOMParser,e=t.parseFromString(HX.BoundingVolume._debugMaterialXML,"text/xml");HX.BoundingVolume._debugMaterial=HX.Material.parseFromXML(e)}return HX.BoundingVolume._debugMaterial}},HX.BoundingAABB=function(){HX.BoundingVolume.call(this,HX.BoundingAABB)},HX.BoundingAABB.prototype=Object.create(HX.BoundingVolume.prototype),HX.BoundingAABB.prototype.growToIncludeMesh=function(t){if(this._expanse!==HX.BoundingVolume.EXPANSE_INFINITE){var e,i,r,n,a,s,o=t.getVertexAttribute("hx_position"),h=o.offset,_=t.getVertexStride(),l=t._vertexData,c=l.length;for(this._expanse===HX.BoundingVolume.EXPANSE_EMPTY?(n=e=l[h],a=i=l[h+1],s=r=l[h+2],h+=_):(e=this._minimumX,i=this._minimumY,r=this._minimumZ,n=this._maximumX,a=this._maximumY,s=this._maximumZ);c>h;h+=_){var u=l[h],m=l[h+1],f=l[h+2];u>n?n=u:e>u&&(e=u),m>a?a=m:i>m&&(i=m),f>s?s=f:r>f&&(r=f)}this._minimumX=e,
this._minimumY=i,this._minimumZ=r,this._maximumX=n,this._maximumY=a,this._maximumZ=s,this._expanse=HX.BoundingVolume.EXPANSE_FINITE,this._updateCenterAndExtent()}},HX.BoundingAABB.prototype.growToIncludeBound=function(t){t._expanse!==HX.BoundingVolume.EXPANSE_EMPTY&&this._expanse!==HX.BoundingVolume.EXPANSE_INFINITE&&(t._expanse===HX.BoundingVolume.EXPANSE_INFINITE?this._expanse=HX.BoundingVolume.EXPANSE_INFINITE:this._expanse==HX.BoundingVolume.EXPANSE_EMPTY?(this._minimumX=t._minimumX,this._minimumY=t._minimumY,this._minimumZ=t._minimumZ,this._maximumX=t._maximumX,this._maximumY=t._maximumY,this._maximumZ=t._maximumZ,this._expanse=HX.BoundingVolume.EXPANSE_FINITE):(t._minimumX<this._minimumX&&(this._minimumX=t._minimumX),t._minimumY<this._minimumY&&(this._minimumY=t._minimumY),t._minimumZ<this._minimumZ&&(this._minimumZ=t._minimumZ),t._maximumX>this._maximumX&&(this._maximumX=t._maximumX),t._maximumY>this._maximumY&&(this._maximumY=t._maximumY),t._maximumZ>this._maximumZ&&(this._maximumZ=t._maximumZ)),this._updateCenterAndExtent())},HX.BoundingAABB.prototype.growToIncludeMinMax=function(t,e){this._expanse!==HX.BoundingVolume.EXPANSE_INFINITE&&(this._expanse==HX.BoundingVolume.EXPANSE_EMPTY?(this._minimumX=t.x,this._minimumY=t.y,this._minimumZ=t.z,this._maximumX=e.x,this._maximumY=e.y,this._maximumZ=e.z,this._expanse=HX.BoundingVolume.EXPANSE_FINITE):(t.x<this._minimumX&&(this._minimumX=t.x),t.y<this._minimumY&&(this._minimumY=t.y),t.z<this._minimumZ&&(this._minimumZ=t.z),e.x>this._maximumX&&(this._maximumX=e.x),e.y>this._maximumY&&(this._maximumY=e.y),e.z>this._maximumZ&&(this._maximumZ=e.z)),this._updateCenterAndExtent())},HX.BoundingAABB.prototype.transformFrom=function(t,e){if(t._expanse==HX.BoundingVolume.EXPANSE_INFINITE||t._expanse==HX.BoundingVolume.EXPANSE_EMPTY)this.clear(t._expanse);else{var i=e._m,r=i[0],n=i[1],a=i[2],s=i[4],o=i[5],h=i[6],_=i[8],l=i[9],c=i[10],u=t._centerX,m=t._centerY,f=t._centerZ;this._centerX=r*u+s*m+_*f+i[12],this._centerY=n*u+o*m+l*f+i[13],this._centerZ=a*u+h*m+c*f+i[14],0>r&&(r=-r),0>n&&(n=-n),0>a&&(a=-a),0>s&&(s=-s),0>o&&(o=-o),0>h&&(h=-h),0>_&&(_=-_),0>l&&(l=-l),0>c&&(c=-c),u=t._halfExtentX,m=t._halfExtentY,f=t._halfExtentZ,this._halfExtentX=r*u+s*m+_*f,this._halfExtentY=n*u+o*m+l*f,this._halfExtentZ=a*u+h*m+c*f,this._minimumX=this._centerX-this._halfExtentX,this._minimumY=this._centerY-this._halfExtentY,this._minimumZ=this._centerZ-this._halfExtentZ,this._maximumX=this._centerX+this._halfExtentX,this._maximumY=this._centerY+this._halfExtentY,this._maximumZ=this._centerZ+this._halfExtentZ,this._expanse=t._expanse}},HX.BoundingAABB.prototype.intersectsConvexSolid=function(t,e){if(this._expanse==HX.BoundingVolume.EXPANSE_INFINITE)return!0;if(this._expanse==HX.BoundingVolume.EXPANSE_EMPTY)return!1;for(var i=this._minimumX,r=this._minimumY,n=this._minimumZ,a=this._maximumX,s=this._maximumY,o=this._maximumZ,h=0;e>h;++h){var _=t[h],l=_.x,c=_.y,u=_.z,m=_.w,f=0>l?i:a,d=0>c?r:s,p=0>u?n:o,X=l*f+c*d+u*p+m;if(0>X)return!1}return!0},HX.BoundingAABB.prototype.intersectsBound=function(t){return this._expanse==HX.BoundingVolume.EXPANSE_EMPTY||t._expanse==HX.BoundingVolume.EXPANSE_EMPTY?!1:this._expanse==HX.BoundingVolume.EXPANSE_INFINITE||t._expanse==HX.BoundingVolume.EXPANSE_INFINITE?!0:t._type===this._type?this._maximumX>t._minimumX&&this._minimumX<t._maximumX&&this._maximumY>t._minimumY&&this._minimumY<t._maximumY&&this._maximumZ>t._minimumZ&&this._minimumZ<t._maximumZ:HX.BoundingVolume._testAABBToSphere(this,t)},HX.BoundingAABB.prototype.classifyAgainstPlane=function(t){var e=t.x,i=t.y,r=t.z,n=n,a=e*this._centerX+i*this._centerY+r*this._centerZ+n;0>e&&(e=-e),0>i&&(i=-i),0>r&&(r=-r);var s=e*this._halfExtentX+i*this._halfExtentY+r*this._halfExtentZ;return a>s?HX.PlaneSide.FRONT:-s>a?HX.PlaneSide.BACK:HX.PlaneSide.INTERSECTING},HX.BoundingAABB.prototype.setExplicit=function(t,e){this._minimumX=t.x,this._minimumY=t.y,this._minimumZ=t.z,this._maximumX=e.x,this._maximumY=e.y,this._maximumZ=e.z,this._expanse=HX.BoundingVolume.EXPANSE_FINITE,this._updateCenterAndExtent()},HX.BoundingAABB.prototype._updateCenterAndExtent=function(){var t=this._minimumX,e=this._minimumY,i=this._minimumZ,r=this._maximumX,n=this._maximumY,a=this._maximumZ;this._centerX=.5*(t+r),this._centerY=.5*(e+n),this._centerZ=.5*(i+a),this._halfExtentX=.5*(r-t),this._halfExtentY=.5*(n-e),this._halfExtentZ=.5*(a-i)},HX.BoundingAABB.prototype.getRadius=function(){return Math.sqrt(this._halfExtentX*this._halfExtentX+this._halfExtentY*this._halfExtentY+this._halfExtentZ*this._halfExtentZ)},HX.BoundingAABB.prototype.createDebugModelInstance=function(){return new HX.ModelInstance(HX.BoxPrimitive.create({doubleSided:!0}),[this.getDebugMaterial()])},HX.BoundingSphere=function(){HX.BoundingVolume.call(this,HX.BoundingSphere)},HX.BoundingSphere.prototype=Object.create(HX.BoundingVolume.prototype),HX.BoundingSphere.prototype.setExplicit=function(t,e){this._centerX=t.x,this._centerY=t.y,this._centerZ=t.z,this._halfExtentX=this._halfExtentY=this._halfExtentZ=e,this._expanse=HX.BoundingVolume.EXPANSE_FINITE,this._updateMinAndMax()},HX.BoundingSphere.prototype.growToIncludeMesh=function(t){if(this._expanse!==HX.BoundingVolume.EXPANSE_INFINITE){var e,i,r,n,a,s,o=t.getVertexAttribute("hx_position"),h=o.offset,_=t.getVertexStride(),l=o._vertexData,c=l.length();for(this._expanse===HX.BoundingVolume.EXPANSE_EMPTY?(n=e=l[h],a=i=l[h+1],s=r=l[h+2],h+=_):(e=this._minimumX,i=this._minimumY,r=this._minimumZ,n=this._maximumX,a=this._maximumY,s=this._maximumZ);c>h;h+=_){var u=l[h],m=l[h+1],f=l[h+2];u>n?n=u:e>u&&(e=u),m>a?a=m:i>m&&(i=m),f>s?s=f:r>f&&(r=f)}var d=.5*(n+e),p=.5*(a+i),X=.5*(s+r),H=0;for(h=o.offset;c>h;h+=_){var g=d-l[h],x=p-l[h+1],S=X-l[h+2],v=g*g+x*x+S*S;v>H&&(H=v)}this._centerX=d,this._centerY=p,this._centerZ=X;var E=Math.sqrt(H);this._halfExtentX=E,this._halfExtentY=E,this._halfExtentZ=E,this._expanse=HX.BoundingVolume.EXPANSE_FINITE,this._updateMinAndMax()}},HX.BoundingSphere.prototype.growToIncludeBound=function(t){if(t._expanse!==HX.BoundingVolume.EXPANSE_EMPTY&&this._expanse!==HX.BoundingVolume.EXPANSE_INFINITE){if(t._expanse===HX.BoundingVolume.EXPANSE_INFINITE)this._expanse=HX.BoundingVolume.EXPANSE_INFINITE;else if(expanse==HX.BoundingVolume.EXPANSE_EMPTY)this._centerX=t._centerX,this._centerY=t._centerY,this._centerZ=t._centerZ,t._type==this._type?(this._halfExtentX=t._halfExtentX,this._halfExtentY=t._halfExtentY,this._halfExtentZ=t._halfExtentZ):this._halfExtentX=this._halfExtentY=this._halfExtentZ=t.getRadius(),this._expanse=HX.BoundingVolume.EXPANSE_FINITE;else{var e=this._minimumX,i=this._minimumY,r=this._minimumZ,n=this._maximumX,a=this._maximumY,s=this._maximumZ;t._maximumX>n&&(n=t._maximumX),t._maximumY>a&&(a=t._maximumY),t._maximumZ>s&&(s=t._maximumZ),t._minimumX<e&&(e=t._minimumX),t._minimumY<i&&(i=t._minimumY),t._minimumZ<r&&(r=t._minimumZ),this._centerX=.5*(e+n),this._centerY=.5*(i+a),this._centerZ=.5*(r+s);var o=n-this._centerX,h=a-this._centerY,_=s-this._centerZ,l=Math.sqrt(o*o+h*h+_*_);this._halfExtentX=this._halfExtentY=this._halfExtentZ=l}this._updateMinAndMax()}},HX.BoundingSphere.prototype.growToIncludeMinMax=function(t,e){var i=new HX.BoundingAABB;i.growToIncludeMinMax(t,e),this.growToIncludeBound(i)},HX.BoundingSphere.prototype.getRadius=function(){return this._halfExtentX},HX.BoundingSphere.prototype.transformFrom=function(t,e){if(t._expanse==HX.BoundingVolume.EXPANSE_INFINITE||t._expanse==HX.BoundingVolume.EXPANSE_EMPTY)this.clear(t._expanse);else{var i=e._m,r=i[0],n=i[1],a=i[2],s=i[4],o=i[5],h=i[6],_=i[8],l=i[9],c=i[10],u=t._centerX,m=t._centerY,f=t._centerZ;this._centerX=r*u+s*m+_*f+i[12],this._centerY=n*u+o*m+l*f+i[13],this._centerZ=a*u+h*m+c*f+i[14],0>r&&(r=-r),0>n&&(n=-n),0>a&&(a=-a),0>s&&(s=-s),0>o&&(o=-o),0>h&&(h=-h),0>_&&(_=-_),0>l&&(l=-l),0>c&&(c=-c),u=t._halfExtentX,m=t._halfExtentY,f=t._halfExtentZ;var d=r*u+s*m+_*f,p=n*u+o*m+l*f,X=a*u+h*m+c*f,H=Math.sqrt(d*d+p*p+X*X);this._halfExtentX=this._halfExtentY=this._halfExtentZ=H,this._minimumX=this._centerX-this._halfExtentX,this._minimumY=this._centerY-this._halfExtentY,this._minimumZ=this._centerZ-this._halfExtentZ,this._maximumX=this._centerX+this._halfExtentX,this._maximumY=this._centerX+this._halfExtentY,this._maximumZ=this._centerX+this._halfExtentZ,this._expanse=HX.BoundingVolume.EXPANSE_FINITE}},HX.BoundingSphere.prototype.intersectsConvexSolid=function(t,e){if(this._expanse==HX.BoundingVolume.EXPANSE_INFINITE)return!0;if(this._expanse==HX.BoundingVolume.EXPANSE_EMPTY)return!1;for(var i=this._centerX,r=this._centerY,n=this._centerZ,a=-this._halfExtentX,s=0;e>s;++s){var o=t[s],h=o.x*i+o.y*r+o.z*n+o.w;if(a>h)return!1}return!0},HX.BoundingSphere.prototype.intersectsBound=function(t){if(this._expanse==HX.BoundingVolume.EXPANSE_EMPTY||t._expanse==HX.BoundingVolume.EXPANSE_EMPTY)return!1;if(this._expanse==HX.BoundingVolume.EXPANSE_INFINITE||t._expanse==HX.BoundingVolume.EXPANSE_INFINITE)return!0;if(t._type===this._type){var e=this._centerX-t._centerX,i=this._centerY-t._centerY,r=this._centerZ-t._centerZ,n=this._halfExtentX+t._halfExtentX;return n*n>e*e+i*i+r*r}return HX.BoundingVolume._testAABBToSphere(t,this)},HX.BoundingSphere.prototype.classifyAgainstPlane=function(t){var e=t.x*this._centerX+t.y*this._centerY+t.z*this._centerZ+t.w,i=this._halfExtentX;return e>i?HX.PlaneSide.FRONT:-i>e?HX.PlaneSide.BACK:HX.PlaneSide.INTERSECTING},HX.BoundingSphere.prototype._updateMinAndMax=function(){var t=this._centerX,e=this._centerY,i=this._centerZ,r=this._halfExtentX;this._minimumX=t-r,this._minimumY=e-r,this._minimumZ=i-r,this._maximumX=t+r,this._maximumY=e+r,this._maximumZ=i+r},HX.BoundingSphere.prototype.createDebugModelInstance=function(){return new HX.ModelInstance(HX.SpherePrimitive.create({doubleSided:!0}),[this.getDebugMaterial()])},HX.FixedAABB=function(){HX.BoundingAABB.call(this)},HX.FixedAABB.prototype=Object.create(HX.BoundingAABB.prototype),HX.BoundingVolume._debugMaterialXML='\r\n<?xml version="1.0" encoding="UTF-8"?>\n\r\n<material>\n\r\n    <shaders>\n\r\n        <shader id="vertexShader">\n\r\n            void main()\n\r\n            {\n\r\n                gl_Position = hx_wvpMatrix * hx_position;\n\r\n            }\n\r\n        </shader>\n\r\n        <shader id="fragmentShader">\n\r\n            uniform vec4 color;\n\r\n            \n\r\n            void main()\n\r\n            {\n\r\n                gl_FragColor = color;\n\r\n            }\n\r\n        </shader>\n\r\n    </shaders>\n\r\n    <passes>\n\r\n        <preEffect>\n\r\n            <element>lines</element>\n\r\n            <vertex>vertexShader</vertex>\n\r\n            <fragment>fragmentShader</fragment>\n\r\n        </preEffect>\n\r\n    </passes>\n\r\n    <uniforms>\n\r\n        <color value="1.0, 0.0, 1.0, 1.0"/>\n\r\n    </uniforms>\n\r\n</material>',HX.Color=function(t,e,i,r){this.set(t,e,i,r)},HX.Color.prototype={set:function(t,e,i,r){void 0===t?(this.a=1,this.r=1,this.g=1,this.b=1):void 0===e?(this.a=1,this.r=((16711680&t)>>>16)/255,this.g=((65280&t)>>>8)/255,this.b=(255&t)/255):(this.r=t,this.g=e,this.b=i,this.a=void 0===r?1:r)},hex:function(){var t=255*Math.min(this.r,1),e=255*Math.min(this.g,1),i=255*Math.min(this.b,1);return t<<16|e<<8|i},luminance:function(){return.3*this.r+.59*this.g+.11*this.b},gammaToLinear:function(t){return t=t||new HX.Color,t.r=Math.pow(this.r,2.2),t.g=Math.pow(this.g,2.2),t.b=Math.pow(this.b,2.2),t.a=this.a,t},linearToGamma:function(t){return t=t||new HX.Color,t.r=Math.pow(this.r,.454545),t.g=Math.pow(this.g,.454545),t.b=Math.pow(this.b,.454545),t.a=this.a,t}},HX.IndexBuffer=function(){this._buffer=HX.GL.createBuffer()},HX.IndexBuffer.prototype={constructor:HX.IndexBuffer,uploadData:function(t,e){void 0===e&&(e=HX.GL.STATIC_DRAW),this.bind(),HX.GL.bufferData(HX.GL.ELEMENT_ARRAY_BUFFER,t,e)},dispose:function(){this._buffer&&(HX.GL.deleteBuffer(this._buffer),this._buffer=0)},bind:function(){HX.GL.bindBuffer(HX.GL.ELEMENT_ARRAY_BUFFER,this._buffer)}},HX.PropertyListener=function(){this._enabled=!0,this.onChange=new HX.Signal,this._targets=[]},HX.PropertyListener.prototype={get enabled(){return this._enabled},set enabled(t){this._enabled=t},add:function(t,e){var i=this._targets.length;this._targets.push({object:t,propertyName:e,value:t[e]});var r=this,n=r._targets[i];Object.defineProperty(t,e,{get:function(){return n.value},set:function(t){t!==n.value&&(n.value=t,r._enabled&&r.onChange.dispatch())}})},remove:function(t,e){for(var i=0;i<this._targets.length;++i){var r=this._targets[i];r.object===t&&r.propertyName===e&&(delete r.object[r.propertyName],r.object[r.propertyName]=r.value,this._targets.splice(i--,1))}}},HX.Signal=function(){this._listeners=[],this._lookUp={}},HX.Signal.prototype={bind:function(t,e){this._lookUp[e]=this._listeners.length,this._listeners.push(e.bind(t))},unbind:function(t){var e=this._lookUp[t];this._listeners.splice(e,1),delete this._lookUp[t]},dispatch:function(){for(var t=this._listeners.length,e=0;t>e;++e)this._listeners[e]()}},HX.URLLoader=function(){this._params=void 0,this._data=null,this._timeout=5e3,this._method="GET",this._type=HX.URLLoader.DATA_TEXT},HX.URLLoader.ERROR_TIME_OUT=408,HX.URLLoader.METHOD_GET="get",HX.URLLoader.METHOD_POST="post",HX.URLLoader.DATA_TEXT=0,HX.URLLoader.DATA_BINARY=1,HX.URLLoader.prototype={getType:function(){return this._type},setType:function(t){this._type=t},getData:function(){return this._data},getMethod:function(){return this._method},setMethod:function(t){this._method=t},getTimeoutDuration:function(){return this._timeout},setTimeoutDuration:function(t){this._timeout=t},setParameters:function(t){this._params=t},load:function(t){var e=new XMLHttpRequest;e.open(this._method,t,!0),e.timeout=this._timeout;var i=this;e.ontimeout=function(){i.onError(HX.URLLoader.ERROR_TIME_OUT)},e.onreadystatechange=function(){var t=this.DONE||4;this.readyState===t&&(200==this.status?(this._data=this._type==HX.URLLoader.DATA_TEXT?e.responseText:e.response,i.onComplete&&i.onComplete(this._data)):i.onError&&i.onError(this.status))},e.send(this._params)},onComplete:function(t){},onError:function(t){}},HX.VertexBuffer=function(){this._buffer=HX.GL.createBuffer()},HX.VertexBuffer.prototype={constructor:HX.VertexBuffer,uploadData:function(t,e){void 0===e&&(e=HX.GL.STATIC_DRAW),this.bind(),HX.GL.bufferData(HX.GL.ARRAY_BUFFER,t,e)},dispose:function(){this._buffer&&(HX.GL.deleteBuffer(this._buffer),this._buffer=0)},bind:function(){HX.GL.bindBuffer(HX.GL.ARRAY_BUFFER,this._buffer)}},HX.Shader=function(t,e,i,r){this._ready=!1,this._vertexShader=null,this._fragmentShader=null,this._program=null,t&&e&&this.init(t,e,i,r)},HX.Shader.ID_COUNTER=0,HX.Shader.prototype={constructor:HX.Shader,isReady:function(){return this._ready},init:function(t,e,i,r){if(i=(i||"")+"\n",r=(r||"")+"\n",t=i+HX.GLSLIncludeGeneral+t,e=r+HX.GLSLIncludeGeneral+e,this._vertexShader=HX.GL.createShader(HX.GL.VERTEX_SHADER),!this._initShader(this._vertexShader,t)){if(this.dispose(),HX.OPTIONS.throwOnShaderError)throw new Error("Failed generating vertex shader: \n"+t);return void console.warn("Failed generating vertex shader")}if(this._fragmentShader=HX.GL.createShader(HX.GL.FRAGMENT_SHADER),!this._initShader(this._fragmentShader,e)){if(this.dispose(),HX.OPTIONS.throwOnShaderError)throw new Error("Failed generating fragment shader: \n"+e);return void console.warn("Failed generating fragment shader:")}if(this._program=HX.GL.createProgram(),HX.GL.attachShader(this._program,this._vertexShader),HX.GL.attachShader(this._program,this._fragmentShader),HX.GL.linkProgram(this._program),!HX.GL.getProgramParameter(this._program,HX.GL.LINK_STATUS)){if(this.dispose(),HX.OPTIONS.throwOnShaderError)throw new Error("Error in program linking:"+HX.GL.getProgramInfoLog(this._program));return void console.warn("Error in program linking:"+HX.GL.getProgramInfoLog(this._program))}this._ready=!0},updateRenderState:function(){HX.GL.useProgram(this._program)},_initShader:function(t,e){return HX.GL.shaderSource(t,e),HX.GL.compileShader(t),HX.GL.getShaderParameter(t,HX.GL.COMPILE_STATUS)?!0:(console.warn(HX.GL.getShaderInfoLog(t)),console.log(e),!1)},dispose:function(){HX.GL.deleteShader(this._vertexShader),HX.GL.deleteShader(this._fragmentShader),HX.GL.deleteProgram(this._program),this._ready=!1},getProgram:function(){return this._program},getVertexAttributeIndex:function(t){return HX.GL.getAttribLocation(this._program,t)}},HX.TextureSlot=function(){this.location=-1,this.texture=null},HX.TransparencyMode={OPAQUE:0,ALPHA:1,ADDITIVE:2,NUM_MODES:3},HX.MaterialPass=function(t){this._shader=t,this._textureSlots=[],this._uniforms={},this._elementType=HX.ElementType.TRIANGLES,this._cullMode=HX.CullMode.BACK,this._blending=!1,this._blendSource=HX.BlendFactor.ONE,this._blendDest=HX.BlendFactor.ZERO,this._blendOperator=HX.BlendOperation.ADD,this._gbuffer=null,this._enabled=!0,this._storeUniforms()},HX.MaterialPass.GEOMETRY_PASS=0,HX.MaterialPass.POST_LIGHT_PASS=1,HX.MaterialPass.POST_PASS=2,HX.MaterialPass.NUM_PASS_TYPES=3,HX.MaterialPass.GEOMETRY_COLOR_PASS=HX.MaterialPass.GEOMETRY_PASS,HX.MaterialPass.GEOMETRY_NORMAL_PASS=HX.MaterialPass.NUM_PASS_TYPES,HX.MaterialPass.GEOMETRY_SPECULAR_PASS=HX.MaterialPass.NUM_PASS_TYPES+1,HX.MaterialPass.SHADOW_MAP_PASS=-1,HX.MaterialPass.prototype={constructor:HX.MaterialPass,getShader:function(){return this._shader},setElementType:function(t){this._elementType=t},getElementType:function(){return this._elementType},setCullMode:function(t){this._cullMode=t},getCullMode:function(){return this._cullMode},disableBlendMode:function(){this._blending=!1},setBlendMode:function(t,e,i){this._blending=!0,this._blendSource=t,this._blendDest=e,this._blendOperator=i},assignSourceBuffer:function(t){this._sourceSlot&&(this._sourceSlot.texture=t)},assignGBuffer:function(t){this._gbuffer!=t&&(this._gbuffer=t,this.setTexture("hx_gbufferColor",t[0]),this.setTexture("hx_gbufferNormals",t[1]),this.setTexture("hx_gbufferSpecular",t[2]),this.setTexture("hx_gbufferDepth",t[3]))},updateRenderState:function(){this._shader.updateRenderState();for(var t=this._textureSlots.length,e=0;t>e;++e){var i=this._textureSlots[e],r=i.texture;r.isReady()?r.bind(e):r._default.bind(e)}},_storeUniforms:function(){for(var t=HX.GL.getProgramParameter(this._shader._program,HX.GL.ACTIVE_UNIFORMS),e=0;t>e;++e){var i=HX.GL.getActiveUniform(this._shader._program,e),r=i.name,n=HX.GL.getUniformLocation(this._shader._program,r);this._uniforms[r]={type:i.type,location:n,size:i.size}}},getTextureSlot:function(t){if(!this._uniforms.hasOwnProperty(t))return null;HX.GL.useProgram(this._shader._program);var e=this._uniforms[t];if(e){for(var i=e.location,r=null,n=this._textureSlots.length,a=0;n>a;++a)if(this._textureSlots[a].location===i){r=this._textureSlots[a];break}return null==r&&(r=new HX.TextureSlot,this._textureSlots.push(r),HX.GL.uniform1i(i,a),r.location=i),r}},setTexture:function(t,e){var i=this.getTextureSlot(t);i&&(i.texture=e)},getUniformLocation:function(t){return this._uniforms.hasOwnProperty(t)?this._uniforms[t].location:void 0},setUniformArray:function(t,e){if(t+="[0]",this._uniforms.hasOwnProperty(t)){var i=this._uniforms[t];switch(HX.GL.useProgram(this._shader._program),i.type){case HX.GL.FLOAT:HX.GL.uniform1fv(i.location,e);break;case HX.GL.FLOAT_VEC2:HX.GL.uniform2fv(i.location,e);break;case HX.GL.FLOAT_VEC3:HX.GL.uniform3fv(i.location,e);break;case HX.GL.FLOAT_VEC4:HX.GL.uniform4fv(i.location,e);break;case HX.GL.INT:HX.GL.uniform1iv(i.location,e);break;case HX.GL.INT_VEC2:HX.GL.uniform2iv(i.location,e);break;case HX.GL.INT_VEC3:HX.GL.uniform3iv(i.location,e);break;case HX.GL.INT_VEC4:HX.GL.uniform1iv(i.location,e);break;case HX.GL.BOOL:HX.GL.uniform1bv(i.location,e);break;case HX.GL.BOOL_VEC2:HX.GL.uniform2bv(i.location,e);break;case HX.GL.BOOL_VEC3:HX.GL.uniform3bv(i.location,e);break;case HX.GL.BOOL_VEC4:HX.GL.uniform4bv(i.location,e);break;default:throw"Unsupported uniform format for setting. May be a todo."}}},setUniform:function(t,e){if(this._uniforms.hasOwnProperty(t)){var i=this._uniforms[t];switch(HX.GL.useProgram(this._shader._program),i.type){case HX.GL.FLOAT:HX.GL.uniform1f(i.location,e);break;case HX.GL.FLOAT_VEC2:HX.GL.uniform2f(i.location,e.x,e.y);break;case HX.GL.FLOAT_VEC3:HX.GL.uniform3f(i.location,e.x||e.r,e.y||e.g,e.z||e.b);break;case HX.GL.FLOAT_VEC4:HX.GL.uniform4f(i.location,e.x||e.r,e.y||e.g,e.z||e.b,e.w||e.a);break;case HX.GL.INT:HX.GL.uniform1i(i.location,e);break;case HX.GL.INT_VEC2:HX.GL.uniform2i(i.location,e.x,e.y);break;case HX.GL.INT_VEC3:HX.GL.uniform3i(i.location,e.x,e.y,e.z);break;case HX.GL.INT_VEC4:HX.GL.uniform1i(i.location,e.x,e.y,e.z,e.w);break;case HX.GL.BOOL:HX.GL.uniform1i(i.location,e);break;case HX.GL.BOOL_VEC2:HX.GL.uniform2i(i.location,e.x,e.y);break;case HX.GL.BOOL_VEC3:HX.GL.uniform3i(i.location,e.x,e.y,e.z);break;case HX.GL.BOOL_VEC4:HX.GL.uniform4i(i.location,e.x,e.y,e.z,e.w);break;default:throw"Unsupported uniform format for setting. May be a todo."}}},isEnabled:function(){return this._enabled},setEnabled:function(t){this._enabled=t}},HX.Material=function(){this._transparencyMode=HX.TransparencyMode.OPAQUE,this._opaquePasses=new Array(HX.Material.NUM_PASS_TYPES),this._renderOrderHint=++HX.Material.ID_COUNTER,this._renderOrder=0,this.onChange=new HX.Signal,this._textures={},this._uniforms={},this._lightingModelID=1},HX.Material.parseFromXML=function(t){var e=new HX.Material;return HX.Material._parseXMLTo(t,e),e},HX.Material._parseXMLTo=function(t,e){HX.Material._parsePassFromXML(t,HX.MaterialPass.GEOMETRY_PASS,"geometry",e),HX.Material._parsePassFromXML(t,HX.MaterialPass.POST_LIGHT_PASS,"preEffect",e),HX.Material._parsePassFromXML(t,HX.MaterialPass.POST_PASS,"post",e);var i=t.getElementsByTagName("uniforms")[0];if(i)for(var r=i.firstChild;r;){if("#text"!=r.nodeName){var n=r.getAttribute("value").split(",");1==n.length?e.setUniform(r.nodeName,Number(n[0]),!1):e.setUniform(r.nodeName,{x:Number(n[0]),y:Number(n[1]),z:Number(n[2]),w:Number(n[3])},!1)}r=r.nextSibling}e.setTexture("hx_dither2D",HX.DEFAULT_2D_DITHER_TEXTURE)},HX.Material._translateProperty=function(t){return HX.Material._properties||(HX.Material._properties={back:HX.GL.BACK,front:HX.CullMode.FRONT,both:HX.CullMode.ALL,none:null,lines:HX.ElementType.LINES,points:HX.ElementType.POINTS,triangles:HX.ElementType.TRIANGLES,one:HX.BlendFactor.ONE,zero:HX.BlendFactor.ZERO,sourceColor:HX.BlendFactor.SOURCE_COLOR,oneMinusSourceColor:HX.BlendFactor.ONE_MINUS_SOURCE_COLOR,sourceAlpha:HX.BlendFactor.SOURCE_ALPHA,oneMinusSourceAlpha:HX.BlendFactor.ONE_MINUS_SOURCE_ALPHA,destinationAlpha:HX.BlendFactor.DST_ALPHA,oneMinusDestinationAlpha:HX.BlendFactor.ONE_MINUS_DESTINATION_ALPHA,destinationColor:HX.BlendFactor.DESTINATION_COLOR,sourceAlphaSaturate:HX.BlendFactor.SOURCE_ALPHA_SATURATE,add:HX.BlendOperation.ADD,subtract:HX.BlendOperation.SUBTRACT,reverseSubtract:HX.BlendOperation.REVERSE_SUBTRACT}),HX.Material._properties[t]},HX.Material._decodeHTML=function(t){var e=document.createElement("div");return e.innerHTML=t,0===e.childNodes.length?"":e.childNodes[0].nodeValue},HX.Material._addParsedPass=function(t,e,i,r,n,a,s,o){o&&(o="#define "+o+"\n");var h=new HX.Shader(t,e,o,o),_=new HX.MaterialPass(h);if(i&&_.setElementType(HX.Material._translateProperty(i.innerHTML)),r&&_.setCullMode(HX.Material._translateProperty(r.innerHTML)),n){var l=n.getElementsByTagName("source")[0],c=n.getElementsByTagName("destination")[0],u=n.getElementsByTagName("operator")[0];l=l?HX.Material._translateProperty(l.innerHTML):HX.GL.ONE,c=c?HX.Material._translateProperty(c.innerHTML):HX.GL.ZERO,u=l?HX.Material._translateProperty(u.innerHTML):HX.GL.FUNC_ADD,_.setBlendMode(l,c,u)}a.setPass(s,_)},HX.Material._parsePassFromXML=function(t,e,i,r){var n=t.getElementsByTagName("common")[0];n=n?n.innerHTML:"";var a=t.getElementsByTagName(i);if(void 0!==a&&0!==a.length){var s=a[0],o=s.getElementsByTagName("vertex")[0].innerHTML,h=s.getElementsByTagName("fragment")[0].innerHTML,_=s.getElementsByTagName("element")[0],l=s.getElementsByTagName("cullmode")[0],c=s.getElementsByTagName("blend")[0],u=n+t.querySelector("[id="+o+"]").innerHTML,m=n+t.querySelector("[id="+h+"]").innerHTML;u=HX.Material._decodeHTML(u),m=HX.Material._decodeHTML(m),e===HX.MaterialPass.GEOMETRY_PASS&&(HX.EXT_DRAW_BUFFERS?this._addParsedPass(u,m,_,l,c,r,e):(this._addParsedPass(u,m,_,l,c,r,HX.MaterialPass.GEOMETRY_COLOR_PASS,"HX_NO_MRT_GBUFFER_COLOR"),this._addParsedPass(u,m,_,l,c,r,HX.MaterialPass.GEOMETRY_NORMAL_PASS,"HX_NO_MRT_GBUFFER_NORMALS"),this._addParsedPass(u,m,_,l,c,r,HX.MaterialPass.GEOMETRY_SPECULAR_PASS,"HX_NO_MRT_GBUFFER_SPECULAR")),-1!==HX.MaterialPass.SHADOW_MAP_PASS&&this._addParsedPass(u,m,_,l,c,r,HX.MaterialPass.SHADOW_MAP_PASS,"HX_SHADOW_MAP_PASS"))}},HX.Material.ID_COUNTER=0,HX.Material.prototype={constructor:HX.Material,get renderOrder(){return this._renderOrder},set renderOrder(t){this._renderOrder=t},getPass:function(t){return this._opaquePasses[t]},setPass:function(t,e){if(this._opaquePasses[t]=e,e){for(var i in this._textures)this._textures.hasOwnProperty(i)&&e.setTexture(i,this._textures[i]);for(var r in this._uniforms)this._uniforms.hasOwnProperty(r)&&("]"==r.charAt(r.length-1)?e.setUniformArray(r.substr(0,r.length-3),this._uniforms[r]):e.setUniform(r,this._uniforms[r]))}this.onChange.dispatch()},hasPass:function(t){return!!this._opaquePasses[t]},setTexture:function(t,e){this._textures[t]=e;for(var i=0;i<HX.MaterialPass.NUM_PASS_TYPES;++i)this.hasPass(i)&&this._opaquePasses[i].setTexture(t,e)},setUniform:function(t,e,i){if(void 0===i&&(i=!0),i||!this._uniforms.hasOwnProperty(t)){this._uniforms[t]=e;for(var r=0;r<HX.MaterialPass.NUM_PASS_TYPES;++r)this._opaquePasses[r]&&this._opaquePasses[r].setUniform(t,e)}},setUniformArray:function(t,e,i){if(void 0===i&&(i=!0),i||!this._uniforms.hasOwnProperty(t+"[0]")){this._uniforms[t+"[0]"]=e;for(var r=0;r<HX.MaterialPass.NUM_PASS_TYPES;++r)this._opaquePasses[r]&&this._opaquePasses[r].setUniformArray(t,e)}}},HX.FileMaterial=function(t,e,i){HX.Material.call(this);var r=new HX.URLLoader,n=this;r.onComplete=function(t){var i=new DOMParser,r=i.parseFromString(t,"text/xml");HX.Material._parseXMLTo(r,n),e&&e()},r.onError=function(e){console.warn("Failed loading "+t+". Error code: "+e),i&&i(e)},r.load(t)},HX.FileMaterial.prototype=Object.create(HX.Material.prototype),HX.SceneNode=function(){HX.Transform.call(this),this._effects=null,this._worldTransformMatrix=new HX.Matrix4x4,this._worldBoundsInvalid=!0,this._matrixInvalid=!0,this._worldMatrixInvalid=!0,this._parent=null,this._worldBounds=this._createBoundingVolume(),this._debugBounds=null,this._renderOrderHint=0},HX.SceneNode.prototype=Object.create(HX.Transform.prototype),Object.defineProperty(HX.SceneNode.prototype,"effects",{get:function(){return this._effects},set:function(t){this._effects=t}}),HX.SceneNode.prototype.setTransformationMatrix=function(t){HX.Transform.prototype.setTransformationMatrix.call(this,t),this._invalidateWorldTransformationMatrix()},HX.SceneNode.prototype.getWorldMatrix=function(){return this._worldMatrixInvalid&&this._updateWorldTransformationMatrix(),this._worldTransformMatrix},HX.SceneNode.prototype.getWorldBounds=function(){return this._worldBoundsInvalid&&(this._updateWorldBounds(),this._worldBoundsInvalid=!1),this._worldBounds},HX.SceneNode.prototype.acceptVisitor=function(t){this._effects&&t.visitEffects(this._effects,this),this._debugBounds&&this._debugBounds.acceptVisitor(t)},HX.SceneNode.prototype.getShowDebugBounds=function(){return null!==this._debugBounds},HX.SceneNode.prototype.setShowDebugBounds=function(t){this.getShowDebugBounds()!==t&&(t?(this._debugBounds=new HX.ModelNode(this._worldBounds.getDebugModelInstance()),this._debugBounds.setTransform(null),this._updateDebugBounds()):this._debugBounds=null)},HX.SceneNode.prototype._invalidateTransformationMatrix=function(){HX.Transform.prototype._invalidateTransformationMatrix.call(this),this._invalidateWorldTransformationMatrix()},HX.SceneNode.prototype._invalidateWorldTransformationMatrix=function(){this._worldMatrixInvalid=!0,this._invalidateWorldBounds()},HX.SceneNode.prototype._invalidateWorldBounds=function(t){this._worldBoundsInvalid||(this._worldBoundsInvalid=!0,t!==!1&&this._parent&&this._parent._invalidateWorldBounds())},HX.SceneNode.prototype._updateWorldBounds=function(){this._debugBounds&&this._updateDebugBounds()},HX.SceneNode.prototype._updateDebugBounds=function(){var t=this._debugBounds.getTransformationMatrix(),e=this._worldBounds;t.scaleMatrix(2*e._halfExtentX,2*e._halfExtentY,2*e._halfExtentZ),t.appendTranslation(e._centerX,e._centerY,e._centerZ),this._debugBounds.setTransformationMatrix(t)},HX.SceneNode.prototype._updateTransformationMatrix=function(){HX.Transform.prototype._updateTransformationMatrix.call(this),this._invalidateWorldBounds()},HX.SceneNode.prototype._updateWorldTransformationMatrix=function(){this._parent?this._worldTransformMatrix.product(this._parent.getWorldMatrix(),this.getTransformationMatrix()):this._worldTransformMatrix.copyFrom(this.getTransformationMatrix()),this._worldMatrixInvalid=!1},HX.SceneNode.prototype._createBoundingVolume=function(){return new HX.BoundingAABB},HX.BoundingHierarchyNode=function(){HX.SceneNode.call(this),this._children=[]},HX.BoundingHierarchyNode.prototype=Object.create(HX.SceneNode.prototype),HX.BoundingHierarchyNode.prototype.attach=function(t){if(t._parent)throw"Child is already parented!";t._parent=this,this._children.push(t),this._invalidateWorldBounds()},HX.BoundingHierarchyNode.prototype.detach=function(t){var e=this._children.indexOf(t);if(0>e)throw"Trying to remove a scene object that is not a child";t._parent=null,this._children.splice(e,1),this._invalidateWorldBounds()},HX.BoundingHierarchyNode.prototype.numChildren=function(){return this._children.length},HX.BoundingHierarchyNode.prototype.getChild=function(t){return this._children[t]},HX.BoundingHierarchyNode.prototype.acceptVisitor=function(t){HX.SceneNode.prototype.acceptVisitor.call(this,t);for(var e=this._children.length,i=0;e>i;++i){var r=this._children[i];t.qualifies(r)&&r.acceptVisitor(t)}},HX.BoundingHierarchyNode.prototype._invalidateWorldTransformationMatrix=function(){HX.SceneNode.prototype._invalidateWorldTransformationMatrix.call(this);for(var t=this._children.length,e=0;t>e;++e)this._children[e]._invalidateWorldTransformationMatrix()},HX.BoundingHierarchyNode.prototype._updateWorldBounds=function(){this._worldBounds.clear();for(var t=this._children.length,e=0;t>e;++e)this._worldBounds.growToIncludeBound(this._children[e].getWorldBounds());HX.SceneNode.prototype._updateWorldBounds.call(this)},HX.Scene=function(t){this._rootNode=t||new HX.BoundingHierarchyNode,this._skybox=null},HX.Scene.prototype={constructor:HX.Scene,get skybox(){return this._skybox},set skybox(t){this._skybox=t},get effects(){return this._rootNode._effects},set effects(t){this._rootNode._effects=t},attach:function(t){this._rootNode.attach(t)},detach:function(t){this._rootNode.detach(t)},numChildren:function(){return this._rootNode.numChildren()},getChild:function(t){return this._rootNode.getChild(t)},contains:function(t){this._rootNode.contains(t)},acceptVisitor:function(t){t.visitScene(this),this._rootNode.acceptVisitor(t)}},HX.ModelNode=function(t){HX.SceneNode.call(this),this.setModelInstance(t)},HX.ModelNode.prototype=Object.create(HX.SceneNode.prototype),HX.ModelNode.prototype.acceptVisitor=function(t){HX.SceneNode.prototype.acceptVisitor.call(this,t),t.visitModelInstance(this._modelInstance,this.getWorldMatrix(),this.getWorldBounds())},HX.ModelNode.prototype.getModelInstance=function(){return this._modelInstance},HX.ModelNode.prototype.setModelInstance=function(t){this._modelInstance&&this._modelInstance.onChange.unbind(this,HX.ModelNode.prototype._invalidateWorldBounds),this._modelInstance=t,this._modelInstance.onChange.bind(this,HX.ModelNode.prototype._invalidateWorldBounds),this._invalidateWorldBounds()},HX.ModelNode.prototype._updateWorldBounds=function(){this._modelInstance&&this._worldBounds.transformFrom(this._modelInstance.getLocalBounds(),this.getWorldMatrix()),
HX.SceneNode.prototype._updateWorldBounds.call(this)},HX.Light=function(){HX.SceneNode.call(this),this._type=this.getTypeID(),this._intensity=3.1415,this._luminanceBound=1/255,this._color=new HX.Color(1,1,1),this._scaledIrradiance=new HX.Color,this._castShadows=!1,this._updateScaledIrradiance()},HX.Light.prototype=Object.create(HX.SceneNode.prototype),HX.Light.prototype.getTypeID=function(){throw"Light is not registered! Be sure to pass the light type into the customLights array upon Helix initialization."},HX.Light.prototype.acceptVisitor=function(t){HX.SceneNode.prototype.acceptVisitor.call(this,t),t.visitLight(this)},Object.defineProperty(HX.Light.prototype,"intensity",{get:function(){return this._intensity},set:function(t){this._intensity=t,this._updateScaledIrradiance()}}),Object.defineProperty(HX.Light.prototype,"color",{get:function(){return this._color},set:function(t){this._color=isNaN(t)?t:new HX.Color(t),this._updateScaledIrradiance()}}),HX.Light.prototype.activate=function(t,e,i){},HX.Light.prototype.renderBatch=function(t,e,i,r,n){throw"Abstract method!"},HX.Light.prototype.getLuminanceBound=function(){return this._luminanceBound},HX.Light.prototype.setLuminanceBound=function(t){this._luminanceBound=t,this._invalidateWorldBounds()},HX.Light.prototype.luminance=function(){return this._color.luminance()*this._intensity},HX.Light.prototype._updateScaledIrradiance=function(){var t=this._intensity/Math.PI;HX.OPTIONS.useLinearSpace?this._color.gammaToLinear(this._scaledIrradiance):(this._scaledIrradiance.r=this._color.r,this._scaledIrradiance.g=this._color.g,this._scaledIrradiance.b=this._color.b),this._scaledIrradiance.r*=t,this._scaledIrradiance.g*=t,this._scaledIrradiance.b*=t,this._invalidateWorldBounds()},HX.RenderItem=function(){this.worldMatrix=null,this.meshInstance=null,this.material=null,this.pass=null,this.camera=null,this.uniformSetters=null,this.renderOrderHint=0},HX.RenderItem.prototype={draw:function(){if(this.uniformSetters)for(var t=this.uniformSetters.length,e=0;t>e;++e)this.uniformSetters[e].execute(this.worldMatrix,this.camera);HX.GL.drawElements(this.pass._elementType,this.meshInstance._mesh.numIndices(),HX.GL.UNSIGNED_SHORT,0)}},HX.SceneVisitor=function(){},HX.SceneVisitor.prototype={collect:function(t,e){},qualifies:function(t){},visitLight:function(t){},visitModelInstance:function(t,e){},visitScene:function(t){},visitEffects:function(t,e){}},HX.Renderer=function(){},HX.Renderer.prototype={constructor:HX.Renderer,render:function(t,e,i){},dispose:function(){},_renderPass:function(t,e,i,r){for(var n=e.length,a=null,s=null,o=null,r=r||0,h=r;n>h;++h){var _=e[h],l=_.material;if(void 0!==i&&l._transparencyMode!==i)return h;var c=l._lightingModelID<<1|l._transparencyMode;HX.GL.stencilFunc(HX.GL.ALWAYS,c,255);var u=_.meshInstance,m=_.pass,f=m._shader;f!==a&&(f.updateRenderState(),a=f),m!==s&&(this._switchPass(s,m),s=m,o=null),o!=u._mesh&&(u.updateRenderState(t),o=u._mesh),_.draw()}return s&&s._blending&&HX.GL.disable(HX.GL.BLEND),n},_switchPass:function(t,e){t&&t._cullMode===t._cullMode||(e._cullMode===HX.CullMode.NONE?HX.GL.disable(HX.GL.CULL_FACE):(HX.GL.enable(HX.GL.CULL_FACE),HX.GL.cullFace(e._cullMode))),t&&t._blending===t._blending||(e._blending?(HX.GL.enable(HX.GL.BLEND),HX.GL.blendFunc(e._blendSource,e._blendDest),HX.GL.blendEquation(e._blendOperator)):HX.GL.disable(HX.GL.BLEND)),e.updateRenderState()}},HX.DebugRenderMode={DEBUG_NONE:0,DEBUG_COLOR:1,DEBUG_NORMALS:2,DEBUG_METALLICNESS:3,DEBUG_SPECULAR_NORMAL_REFLECTION:4,DEBUG_ROUGHNESS:5,DEBUG_DEPTH:6,DEBUG_LIGHT_ACCUM:7,DEBUG_AO:8},HX.ScreenRenderer=function(){HX.Renderer.call(this),this._viewportX=0,this._viewportY=0,this._viewportWidth=0,this._viewportHeight=0,this._copyTexture=new HX.CopyChannelsShader,this._copyXChannel=new HX.CopyChannelsShader("x"),this._copyYChannel=new HX.CopyChannelsShader("y"),this._copyZChannel=new HX.CopyChannelsShader("z"),this._copyWChannel=new HX.CopyChannelsShader("w"),this._debugDepth=new HX.DebugDepthShader,this._debugNormals=new HX.DebugNormalsShader,this._applyGamma=new HX.ApplyGammaShader,this._gammaApplied=!1,this._linearizeDepthShader=new HX.LinearizeDepthShader,this._rectMesh=HX.RectMesh.create({alignment:HX.PlanePrimitive.ALIGN_XY}),this._renderCollector=new HX.RenderCollector,this._gbufferFBO=null,this._linearDepthFBO=null,this._hdrSourceIndex=0,this._hdrTargets=null,this._hdrTargetsDepth=null,this._depthBuffer=null,this._aoEffect=null,this._localReflections=null,this._passSourceTexture=null,this._createGBuffer(),this._createHDRBuffers(),this._debugMode=HX.DebugRenderMode.DEBUG_NONE,this._camera=null},HX.ScreenRenderer.prototype=Object.create(HX.Renderer.prototype),Object.defineProperty(HX.ScreenRenderer.prototype,"debugMode",{get:function(){return this._debugMode},set:function(t){this._debugMode=t}}),Object.defineProperty(HX.ScreenRenderer.prototype,"ambientOcclusion",{get:function(){return this._aoEffect},set:function(t){this._aoEffect=t,this._aoEffect.setMesh(this._rectMesh)}}),Object.defineProperty(HX.ScreenRenderer.prototype,"localReflections",{get:function(){return this._localReflections},set:function(t){this._localReflections=t,this._localReflections.setMesh(this._rectMesh)}}),HX.ScreenRenderer.prototype.setViewportRect=function(t,e,i,r){(this._viewportWidth!=i||this._viewportHeight!=r)&&(this._updateGBuffer(i,r),this._updateHDRBuffers(i,r)),this._viewportX=0,this._viewportY=0,this._viewportWidth=i,this._viewportHeight=r},HX.ScreenRenderer.prototype.render=function(t,e,i){this._gammaApplied=!1,this._passSourceTexture=null,this._hdrSourceIndex=0,this._camera=t,this._scene=e,HX.GL.enable(HX.GL.DEPTH_TEST),HX.GL.enable(HX.GL.CULL_FACE),HX.GL.cullFace(HX.GL.BACK),HX.GL.depthFunc(HX.GL.LESS),t._setRenderTargetResolution(this._viewportWidth,this._viewportHeight),this._renderCollector.collect(t,e),this._renderShadowCasters(),this._renderOpaques(i),this._renderPostPass(HX.MaterialPass.POST_LIGHT_PASS),this._renderPostPass(HX.MaterialPass.POST_PASS,!0),this._renderTransparents(),HX.GL.disable(HX.GL.CULL_FACE),HX.GL.disable(HX.GL.DEPTH_TEST),this._renderToScreen(i)},HX.ScreenRenderer.prototype._renderShadowCasters=function(){-1===HX.MaterialPass.SHADOW_MAP_PASS&&HX.GL.colorMask(!1,!1,!1,!1);for(var t=this._renderCollector.getShadowCasters(),e=t.length,i=0;e>i;++i)t[i].render(this._camera,this._scene);-1===HX.MaterialPass.SHADOW_MAP_PASS&&HX.GL.colorMask(!0,!0,!0,!0)},HX.ScreenRenderer.prototype._renderOpaques=function(t){HX.GL.viewport(this._viewportX,this._viewportY,this._viewportWidth,this._viewportHeight),HX.GL.enable(HX.GL.STENCIL_TEST),HX.GL.stencilOp(HX.GL.REPLACE,HX.GL.KEEP,HX.GL.REPLACE),HX.GL.clearColor(0,0,0,1),this._renderToGBuffer(),HX.GL.disable(HX.GL.STENCIL_TEST),this._linearizeDepth(),HX.GL.disable(HX.GL.BLEND),null!==this._aoEffect&&this._renderEffect(this._aoEffect,t),HX.GL.viewport(this._viewportX,this._viewportY,this._viewportWidth,this._viewportHeight),this._renderLightAccumulation(t,HX.TransparencyMode.OPAQUE)},HX.ScreenRenderer.prototype._renderTransparents=function(){for(var t=[],e=HX.EXT_DRAW_BUFFERS?[HX.MaterialPass.GEOMETRY_PASS]:[HX.MaterialPass.GEOMETRY_COLOR_PASS,HX.MaterialPass.GEOMETRY_NORMAL_PASS,HX.MaterialPass.GEOMETRY_SPECULAR_PASS],i=e.length,r=0;i>r;++r)t[r]=this._renderCollector.getTransparentRenderList(e[r]);this._renderCollector.getTransparentRenderList(HX.MaterialPass.GEOMETRY_PASS);var n=t[0].length;HX.GL.clear(HX.GL.STENCIL_BUFFER_BIT);for(var a=0;n>a;++a){var s=t[0][a].material._transparencyMode;HX.GL.enable(HX.GL.STENCIL_TEST),HX.GL.stencilOp(HX.GL.REPLACE,HX.GL.KEEP,HX.GL.REPLACE);for(var r=0;i>r;++r){HX.setRenderTarget(HX.EXT_DRAW_BUFFERS?this._gbufferFBO:this._gbufferSingleFBOs[r]);var o=e[r],h=t[r][a],_=h.meshInstance,l=h.pass;l._shader.updateRenderState(),this._switchPass(null,l),_.updateRenderState(o),h.draw()}switch(HX.GL.disable(HX.GL.STENCIL_TEST),this._linearizeDepth(),this._renderLightAccumulation(0,s),HX.GL.enable(HX.GL.BLEND),HX.GL.blendEquation(HX.GL.FUNC_ADD),HX.setRenderTarget(this._hdrTargets[this._hdrSourceIndex]),s){case HX.TransparencyMode.ADDITIVE:HX.GL.blendFunc(HX.GL.ONE,HX.GL.ONE),this._copyTexture.execute(this._rectMesh,this._hdrBuffers[1-this._hdrSourceIndex]);break;case HX.TransparencyMode.ALPHA:HX.GL.blendFunc(HX.GL.SOURCE_ALPHA,HX.GL.ONE_MINUS_SOURCE_ALPHA)}HX.GL.disable(HX.GL.BLEND)}},HX.ScreenRenderer.prototype._renderToGBufferMultiPass=function(){for(var t=HX.GL.COLOR_BUFFER_BIT|HX.GL.DEPTH_BUFFER_BIT|HX.GL.STENCIL_BUFFER_BIT,e=[HX.MaterialPass.GEOMETRY_COLOR_PASS,HX.MaterialPass.GEOMETRY_NORMAL_PASS,HX.MaterialPass.GEOMETRY_SPECULAR_PASS],i=0;3>i;++i)HX.setRenderTarget(this._gbufferSingleFBOs[i]),HX.GL.clear(t),this._renderPass(e[i]),0==i&&(t=HX.GL.COLOR_BUFFER_BIT,HX.GL.depthFunc(HX.GL.EQUAL))},HX.ScreenRenderer.prototype._renderToGBuffer=function(){HX.EXT_DRAW_BUFFERS?this._renderToGBufferMRT():this._renderToGBufferMultiPass()},HX.ScreenRenderer.prototype._renderToGBufferMRT=function(){HX.setRenderTarget(this._gbufferFBO),HX.GL.clear(HX.GL.COLOR_BUFFER_BIT|HX.GL.DEPTH_BUFFER_BIT|HX.GL.STENCIL_BUFFER_BIT),this._renderPass(HX.MaterialPass.GEOMETRY_PASS)},HX.ScreenRenderer.prototype._renderToGBufferMultiPass=function(){for(var t=HX.GL.COLOR_BUFFER_BIT|HX.GL.DEPTH_BUFFER_BIT|HX.GL.STENCIL_BUFFER_BIT,e=[HX.MaterialPass.GEOMETRY_COLOR_PASS,HX.MaterialPass.GEOMETRY_NORMAL_PASS,HX.MaterialPass.GEOMETRY_SPECULAR_PASS],i=0;3>i;++i)HX.setRenderTarget(this._gbufferSingleFBOs[i]),HX.GL.clear(t),this._renderPass(e[i]),0==i&&(t=HX.GL.COLOR_BUFFER_BIT,HX.GL.depthFunc(HX.GL.EQUAL))},HX.ScreenRenderer.prototype._linearizeDepth=function(){HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.disable(HX.GL.CULL_FACE),HX.setRenderTarget(this._linearDepthFBO),this._linearizeDepthShader.execute(this._rectMesh,HX.EXT_DEPTH_TEXTURE?this._depthBuffer:this._gbuffer[1],this._camera)},HX.ScreenRenderer.prototype._renderEffect=function(t,e){this._gammaApplied=this._gammaApplied||t._outputsGamma,this._hdrSourceIndex=t.render(this,e)},HX.ScreenRenderer.prototype._renderToScreen=function(t){switch(this._debugMode){case HX.DebugRenderMode.DEBUG_COLOR:HX.setRenderTarget(null),this._copyTexture.execute(this._rectMesh,this._gbuffer[0]);break;case HX.DebugRenderMode.DEBUG_NORMALS:HX.setRenderTarget(null),this._debugNormals.execute(this._rectMesh,this._gbuffer[1]);break;case HX.DebugRenderMode.DEBUG_METALLICNESS:HX.setRenderTarget(null),this._copyXChannel.execute(this._rectMesh,this._gbuffer[2]);break;case HX.DebugRenderMode.DEBUG_SPECULAR_NORMAL_REFLECTION:HX.setRenderTarget(null),this._copyYChannel.execute(this._rectMesh,this._gbuffer[2]);break;case HX.DebugRenderMode.DEBUG_ROUGHNESS:HX.setRenderTarget(null),this._copyZChannel.execute(this._rectMesh,this._gbuffer[2]);break;case HX.DebugRenderMode.DEBUG_DEPTH:HX.setRenderTarget(null),this._debugDepth.execute(this._rectMesh,this._gbuffer[3]);break;case HX.DebugRenderMode.DEBUG_LIGHT_ACCUM:HX.setRenderTarget(null),this._applyGamma.execute(this._rectMesh,this._hdrBuffers[this._hdrSourceIndex]);break;case HX.DebugRenderMode.DEBUG_AO:HX.setRenderTarget(null),this._copyWChannel.execute(this._rectMesh,this._aoEffect.getAOTexture());break;default:this._composite(t)}},HX.ScreenRenderer.prototype._composite=function(t){this._renderEffects(t,this._renderCollector._effects),this._renderEffects(t,this._camera._effects),HX.setRenderTarget(null),this._gammaApplied?this._copyTexture.execute(this._rectMesh,this._hdrBuffers[this._hdrSourceIndex]):this._applyGamma.execute(this._rectMesh,this._hdrBuffers[this._hdrSourceIndex])},HX.ScreenRenderer.prototype._renderLightAccumulation=function(t,e){HX.GL.disable(HX.GL.CULL_FACE),HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.depthMask(!1),HX.GL.enable(HX.GL.BLEND),HX.GL.blendFunc(HX.GL.ONE,HX.GL.ONE),HX.GL.blendEquation(HX.GL.FUNC_ADD),HX.GL.enable(HX.GL.STENCIL_TEST),HX.GL.stencilOp(HX.GL.KEEP,HX.GL.KEEP,HX.GL.KEEP);var i=1,r=i<<1|e;HX.GL.stencilFunc(HX.GL.EQUAL,r,255);var n=e?1-this._hdrSourceIndex:this._hdrSourceIndex;HX.setRenderTarget(this._hdrTargetsDepth[n]),HX.GL.clear(HX.GL.COLOR_BUFFER_BIT),this._renderDirectLights(),this._renderGlobalIllumination(t),HX.GL.disable(HX.GL.BLEND),HX.GL.disable(HX.GL.STENCIL_TEST),HX.GL.depthMask(!0)},HX.ScreenRenderer.prototype._renderDirectLights=function(){for(var t=this._renderCollector.getLights(),e=t.length,i=void 0,r=0,n=this._camera,a=this._gbuffer,s=this._aoEffect?this._aoEffect.getAOTexture():null;e>r;){var o=t[r];o._type!==i&&(o.activate(n,a,s),i=o._type),r=o.renderBatch(t,r,n,a,s)}},HX.ScreenRenderer.prototype._renderGlobalIllumination=function(t){var e=this._aoEffect?this._aoEffect.getAOTexture():null;HX.GL.disable(HX.GL.CULL_FACE),this._renderCollector._globalIrradianceProbe&&this._renderCollector._globalIrradianceProbe.render(this._camera,this._gbuffer,e),null!=this._localReflections&&(HX.GL.disable(HX.GL.BLEND),this._renderEffect(this._localReflections,t),HX.setRenderTarget(this._hdrTargets[this._hdrSourceIndex]),HX.GL.enable(HX.GL.BLEND),HX.GL.blendFunc(HX.GL.ONE_MINUS_DST_ALPHA,HX.GL.ONE)),this._renderCollector._globalSpecularProbe&&this._renderCollector._globalSpecularProbe.render(this._camera,this._gbuffer,e)},HX.ScreenRenderer.prototype._renderPass=function(t,e){e=e||this._renderCollector.getOpaqueRenderList(t),HX.Renderer.prototype._renderPass.call(this,t,e)},HX.ScreenRenderer.prototype._copySource=function(){var t=this._hdrBuffers[this._hdrSourceIndex],e=1-this._hdrSourceIndex;HX.setRenderTarget(this._hdrTargets[e]),HX.GL.disable(HX.GL.BLEND),HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.disable(HX.GL.CULL_FACE),this._copyTexture.execute(this._rectMesh,t),this._passSourceTexture=this._hdrBuffers[e]},HX.ScreenRenderer.prototype._renderPostPass=function(t,e){var i=this._renderCollector.getOpaqueRenderList(t),r=this._renderCollector.getTransparentRenderList(t);(0!==i.length||0!==r.length)&&(e&&this._copySource(),HX.setRenderTarget(this._hdrTargetsDepth[this._hdrSourceIndex]),HX.GL.disable(HX.GL.STENCIL_TEST),HX.GL.enable(HX.GL.CULL_FACE),HX.GL.enable(HX.GL.DEPTH_TEST),HX.GL.depthFunc(HX.GL.LEQUAL),this._renderPass(t,this._renderCollector.getOpaqueRenderList(t)),this._renderPass(t,this._renderCollector.getTransparentRenderList(t)))},HX.ScreenRenderer.prototype._renderEffects=function(t,e){if(e&&0!=e.length){HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.disable(HX.GL.CULL_FACE);for(var i=e.length,r=0;i>r;++r){var n=e[r];n.isSupported()&&(n.setMesh(this._rectMesh),this._renderEffect(n,t))}}},HX.ScreenRenderer.prototype._createGBuffer=function(){HX.EXT_DEPTH_TEXTURE?(this._depthBuffer=new HX.Texture2D,this._depthBuffer.setFilter(HX.TextureFilter.BILINEAR_NOMIP),this._depthBuffer.setWrapMode(HX.TextureWrapMode.CLAMP)):this._depthBuffer=new HX.ReadOnlyDepthBuffer,this._gbuffer=[];for(var t=0;4>t;++t)this._gbuffer[t]=new HX.Texture2D,this._gbuffer[t].setFilter(HX.TextureFilter.BILINEAR_NOMIP),this._gbuffer[t].setWrapMode(HX.TextureWrapMode.CLAMP);this._gbufferSingleFBOs=[];for(var t=0;3>t;++t)this._gbufferSingleFBOs[t]=new HX.FrameBuffer([this._gbuffer[t]],this._depthBuffer);this._createGBufferFBO(),this._linearDepthFBO=new HX.FrameBuffer(this._gbuffer[3],null)},HX.ScreenRenderer.prototype._createGBufferFBO=function(){if(HX.EXT_DRAW_BUFFERS){var t=[this._gbuffer[0],this._gbuffer[1],this._gbuffer[2]];this._gbufferFBO=new HX.FrameBuffer(t,this._depthBuffer)}},HX.ScreenRenderer.prototype._createHDRBuffers=function(){this._hdrBuffers=[new HX.Texture2D,new HX.Texture2D],this._hdrTargets=[],this._hdrTargetsDepth=[];for(var t=0;t<this._hdrBuffers.length;++t)this._hdrBuffers[t].setFilter(HX.TextureFilter.BILINEAR_NOMIP),this._hdrBuffers[t].setWrapMode(HX.TextureWrapMode.CLAMP),this._hdrTargets[t]=new HX.FrameBuffer([this._hdrBuffers[t]]),this._hdrTargetsDepth[t]=new HX.FrameBuffer([this._hdrBuffers[t]],this._depthBuffer)},HX.ScreenRenderer.prototype._updateGBuffer=function(t,e){HX.EXT_DEPTH_TEXTURE?this._depthBuffer.initEmpty(t,e,HX.GL.DEPTH_STENCIL,HX.EXT_DEPTH_TEXTURE.UNSIGNED_INT_24_8_WEBGL):this._depthBuffer.init(t,e);for(var i=0;i<this._gbuffer.length;++i)this._gbuffer[i].initEmpty(t,e,HX.GL.RGBA,HX.GL.UNSIGNED_BYTE);for(var i=0;i<this._gbufferSingleFBOs.length;++i)this._gbufferSingleFBOs[i].init();this._updateGBufferFBO(),this._linearDepthFBO.init()},HX.ScreenRenderer.prototype._updateGBufferFBO=function(){HX.EXT_DRAW_BUFFERS&&this._gbufferFBO.init()},HX.ScreenRenderer.prototype._updateHDRBuffers=function(t,e){for(var i=0;i<this._hdrBuffers.length;++i)this._hdrBuffers[i].initEmpty(t,e,HX.GL.RGBA,HX.HDR_FORMAT),this._hdrTargets[i].init(),this._hdrTargetsDepth[i].init()},HX.ScreenRenderer.prototype.dispose=function(){this._applyGamma.dispose(),this._copyTexture.dispose(),this._copyXChannel.dispose(),this._copyYChannel.dispose(),this._copyZChannel.dispose(),this._copyWChannel.dispose(),this._rectMesh.dispose();for(var t=0;t<this._hdrBuffers.length;++t)this._hdrBuffers[t].dispose(),this._hdrTargets[t].dispose(),this._hdrTargetsDepth[t].dispose();for(var t=0;t<this._gbuffer.length;++t)this._gbuffer[t].dispose();for(var t=0;t<this._gbufferSingleFBOs.length;++t)this._gbufferSingleFBOs[t].dispose();this._gbufferFBO&&this._gbufferFBO.dispose()},HX.ScreenRenderer.prototype._switchPass=function(t,e){e.assignGBuffer(this._gbuffer),this._passSourceTexture&&e.setTexture("hx_source",this._passSourceTexture),HX.Renderer.prototype._switchPass.call(this,t,e)},HX.EffectPass=function(t,e,i,r,n){t=t||HX.ShaderLibrary.get("default_post_vertex.glsl");var a=new HX.Shader(t,e,r,n);HX.MaterialPass.call(this,a),this._uniformSetters=HX.UniformSetter.getSetters(this._shader),this._gbuffer=null,this._mesh=null,this._vertexLayout=null,void 0!=i&&this.setMesh(i),this.setTexture("hx_dither2D",HX.DEFAULT_2D_DITHER_TEXTURE),this._sourceSlot=this.getTextureSlot("hx_source")},HX.EffectPass.prototype=Object.create(HX.MaterialPass.prototype),HX.EffectPass.prototype.setMesh=function(t){this._mesh!=t&&(this._mesh=t,this._vertexLayout=new HX.VertexLayout(this._mesh,this))},HX.EffectPass.prototype.updateRenderState=function(){HX.MaterialPass.prototype.updateRenderState.call(this),this._mesh._vertexBuffer.bind(),this._mesh._indexBuffer.bind();for(var t=this._vertexLayout,e=t.attributes,i=e.length,r=0;i>r;++r){var n=e[r];HX.GL.vertexAttribPointer(n.index,n.numComponents,HX.GL.FLOAT,!1,n.stride,n.offset)}HX.enableAttributes(t._numAttributes)},HX.EffectPass.prototype.updateGlobalState=function(t,e,i){this._shader.updateRenderState(),this._sourceSlot&&(this._sourceSlot.texture=i),this.assignGBuffer(e);for(var r=this._uniformSetters.length,n=0;r>n;++n)this._uniformSetters[n].execute(null,t)},HX.Effect=function(){this._isSupported=!0,this._opaquePasses=[],this._mesh=null,this._hdrSourceIndex=-1,this._outputsGamma=!1},HX.Effect.prototype={isSupported:function(){return this._isSupported},getPass:function(t){return this._opaquePasses[t]},render:function(t,e){return this._camera=t._camera,this._gbuffer=t._gbuffer,this._hdrSourceIndex=t._hdrSourceIndex,this._hdrSources=t._hdrBuffers,this._hdrTargets=t._hdrTargets,this._hdrSource=this._hdrSources[this._hdrSourceIndex],this._hdrTarget=this._hdrTargets[1-this._hdrSourceIndex],this.draw(e),this._hdrSourceIndex},draw:function(t){for(var e=this._opaquePasses.length,i=0;e>i;++i)HX.setRenderTarget(this._hdrTarget),this._drawPass(this._opaquePasses[i]),this._swapHDRBuffers()},_drawPass:function(t){t.updateGlobalState(this._camera,this._gbuffer,this._hdrSource),t.updateRenderState(),HX.GL.drawElements(HX.GL.TRIANGLES,6,HX.GL.UNSIGNED_SHORT,0)},_swapHDRBuffers:function(){this._hdrTarget=this._hdrTargets[this._hdrSourceIndex],this._hdrSourceIndex=1-this._hdrSourceIndex,this._hdrSource=this._hdrSources[this._hdrSourceIndex]},removePass:function(t){var e=this._opaquePasses.indexOf(t);this._opaquePasses.splice(e,1)},addPass:function(t){this._opaquePasses.push(t)},numPasses:function(){return this._opaquePasses.length},setUniform:function(t,e){for(var i=this._opaquePasses.length,r=0;i>r;++r)this._opaquePasses[r]&&this._opaquePasses[r].setUniform(t,e)},setMesh:function(t){if(this._mesh!=t){this._mesh=t;for(var e=this._opaquePasses.length,i=0;e>i;++i)this._opaquePasses[i]&&this._opaquePasses[i].setMesh(t)}}},HX.GLSLIncludeGeneral="precision mediump float;\n\n"+HX.ShaderLibrary.get("snippets_general.glsl")+"\n\n",HX.UniformSetter={},HX.UniformSetter.getSetters=function(t){return void 0===HX.UniformSetter._table&&HX.UniformSetter._init(),HX.UniformSetter._findSetters(t)},HX.UniformSetter._findSetters=function(t){var e=[];for(var i in HX.UniformSetter._table){var r=HX.GL.getUniformLocation(t._program,i);if(null!=r){var n=new HX.UniformSetter._table[i];e.push(n),n.location=r}}return e},HX.UniformSetter._init=function(){HX.UniformSetter._table={},HX.UniformSetter._table.hx_worldMatrix=HX.WorldMatrixSetter,HX.UniformSetter._table.hx_worldViewMatrix=HX.WorldViewMatrixSetter,HX.UniformSetter._table.hx_wvpMatrix=HX.WorldViewProjectionSetter,HX.UniformSetter._table.hx_viewMatrix=HX.ViewMatrixSetter,HX.UniformSetter._table.hx_projectionMatrix=HX.ProjectionSetter,HX.UniformSetter._table.hx_inverseProjectionMatrix=HX.InverseProjectionSetter,HX.UniformSetter._table.hx_inverseWVPMatrix=HX.InverseWVPSetter,HX.UniformSetter._table.hx_viewProjectionMatrix=HX.ViewProjectionSetter,HX.UniformSetter._table.hx_inverseViewProjectionMatrix=HX.InverseViewProjectionSetter,HX.UniformSetter._table.hx_normalWorldMatrix=HX.NormalWorldMatrixSetter,HX.UniformSetter._table.hx_normalWorldViewMatrix=HX.NormalWorldViewMatrixSetter,HX.UniformSetter._table.hx_cameraWorldPosition=HX.CameraWorldPosSetter,HX.UniformSetter._table.hx_cameraWorldMatrix=HX.CameraWorldMatrixSetter,HX.UniformSetter._table.hx_cameraFrustumRange=HX.CameraFrustumRangeSetter,HX.UniformSetter._table.hx_rcpCameraFrustumRange=HX.RCPCameraFrustumRangeSetter,HX.UniformSetter._table.hx_cameraNearPlaneDistance=HX.CameraNearPlaneDistanceSetter,HX.UniformSetter._table.hx_cameraFarPlaneDistance=HX.CameraFarPlaneDistanceSetter,HX.UniformSetter._table.hx_renderTargetResolution=HX.RenderTargetResolutionSetter,HX.UniformSetter._table.hx_rcpRenderTargetResolution=HX.RCPRenderTargetResolutionSetter,HX.UniformSetter._table.hx_dither2DTextureScale=HX.Dither2DTextureScaleSetter,HX.UniformSetter._table["hx_poissonDisk[0]"]=HX.PoissonDiskSetter},HX.WorldMatrixSetter=function(){},HX.WorldMatrixSetter.prototype.execute=function(t,e){HX.GL.uniformMatrix4fv(this.location,!1,t._m)},HX.ViewProjectionSetter=function(){},HX.ViewProjectionSetter.prototype.execute=function(t,e){var i=e.getViewProjectionMatrix();HX.GL.uniformMatrix4fv(this.location,!1,i._m)},HX.InverseViewProjectionSetter=function(){},HX.InverseViewProjectionSetter.prototype.execute=function(t,e){var i=e.getInverseViewProjectionMatrix();HX.GL.uniformMatrix4fv(this.location,!1,i._m)},HX.InverseWVPSetter=function(){},HX.InverseWVPSetter.prototype.execute=function(t,e){var i=e.getInverseViewProjectionMatrix();HX.GL.uniformMatrix4fv(this.location,!1,i._m)},HX.ProjectionSetter=function(){},HX.ProjectionSetter.prototype.execute=function(t,e){var i=e.getProjectionMatrix();HX.GL.uniformMatrix4fv(this.location,!1,i._m)},HX.InverseProjectionSetter=function(){},HX.InverseProjectionSetter.prototype.execute=function(t,e){var i=e.getInverseProjectionMatrix();HX.GL.uniformMatrix4fv(this.location,!1,i._m)},HX.WorldViewProjectionSetter=function(){this._matrix=new HX.Matrix4x4},HX.WorldViewProjectionSetter.prototype.execute=function(t,e){this._matrix.product(e.getViewProjectionMatrix(),t),HX.GL.uniformMatrix4fv(this.location,!1,this._matrix._m)},HX.WorldViewMatrixSetter=function(){this._matrix=new HX.Matrix4x4},HX.WorldViewMatrixSetter.prototype.execute=function(t,e){this._matrix.product(e.getViewMatrix(),t),HX.GL.uniformMatrix4fv(this.location,!1,this._matrix._m)},HX.NormalWorldMatrixSetter=function(){this._data=new Float32Array(9)},HX.NormalWorldMatrixSetter.prototype.execute=function(t,e){t.writeNormalMatrix(this._data),HX.GL.uniformMatrix3fv(this.location,!1,this._data)},HX.NormalWorldViewMatrixSetter=function(){this._matrix=new HX.Matrix4x4,this._data=new Float32Array(9)},HX.NormalWorldViewMatrixSetter.prototype.execute=function(t,e){this._matrix.product(e.getViewMatrix(),t),this._matrix.writeNormalMatrix(this._data),HX.GL.uniformMatrix3fv(this.location,!1,this._data)},HX.CameraWorldPosSetter=function(){},HX.CameraWorldPosSetter.prototype.execute=function(t,e){var i=e.getWorldMatrix()._m;HX.GL.uniform3f(this.location,i[12],i[13],i[14])},HX.CameraWorldMatrixSetter=function(){},HX.CameraWorldMatrixSetter.prototype.execute=function(t,e){var i=e.getWorldMatrix();HX.GL.uniformMatrix4fv(this.location,!1,i._m)},HX.CameraFrustumRangeSetter=function(){},HX.CameraFrustumRangeSetter.prototype.execute=function(t,e){HX.GL.uniform1f(this.location,e.getFarDistance()-e.getNearDistance())},HX.RCPCameraFrustumRangeSetter=function(){},HX.RCPCameraFrustumRangeSetter.prototype.execute=function(t,e){HX.GL.uniform1f(this.location,1/(e.getFarDistance()-e.getNearDistance()))},HX.CameraNearPlaneDistanceSetter=function(){},HX.CameraNearPlaneDistanceSetter.prototype.execute=function(t,e){HX.GL.uniform1f(this.location,e.getNearDistance())},HX.CameraFarPlaneDistanceSetter=function(){},HX.CameraFarPlaneDistanceSetter.prototype.execute=function(t,e){HX.GL.uniform1f(this.location,e.getFarDistance())},HX.ViewMatrixSetter=function(){},HX.ViewMatrixSetter.prototype.execute=function(t,e){var i=e.getViewMatrix();HX.GL.uniformMatrix4fv(this.location,!1,i._m)},HX.RenderTargetResolutionSetter=function(){},HX.RenderTargetResolutionSetter.prototype.execute=function(t,e){HX.GL.uniform2f(this.location,e._renderTargetWidth,e._renderTargetHeight)},HX.RCPRenderTargetResolutionSetter=function(){},HX.RCPRenderTargetResolutionSetter.prototype.execute=function(t,e){HX.GL.uniform2f(this.location,1/e._renderTargetWidth,1/e._renderTargetHeight)},HX.Dither2DTextureScaleSetter=function(){},HX.Dither2DTextureScaleSetter.prototype.execute=function(t,e){HX.GL.uniform2f(this.location,e._renderTargetWidth/HX.DEFAULT_2D_DITHER_TEXTURE.width(),e._renderTargetHeight/HX.DEFAULT_2D_DITHER_TEXTURE.height())},HX.PoissonDiskSetter=function(){},HX.PoissonDiskSetter.prototype.execute=function(t,e){HX.GL.uniform2fv(this.location,HX.DEFAULT_POISSON_DISK)},HX.PBRMaterial=function(){HX.Material.call(this),this._passesInvalid=!0,this._color=new HX.Color(1,1,1,1),this._colorMap=null,this._normalMap=null,this._specularMap=null,this._specularMapMode=HX.SPECULAR_MAP_ROUGHNESS_ONLY,this._metallicness=0,this._roughness=.3,this._specularNormalReflection=.027,this._refractiveRatio=.9,this._transparent=!1,this._refract=!1,this.metallicness=this._metallicness,this.roughness=this._roughness,this.specularNormalReflection=this._specularNormalReflection,this.refractiveRatio=this._refractiveRatio},HX.PBRMaterial.SPECULAR_MAP_ROUGHNESS_ONLY=1,HX.PBRMaterial.SPECULAR_MAP_ALL=2,HX.PBRMaterial.SPECULAR_MAP_SHARE_NORMAL_MAP=3,HX.PBRMaterial.prototype=Object.create(HX.Material.prototype),HX.PBRMaterial.prototype.getPass=function(t){return this._passesInvalid&&this._updatePasses(),HX.Material.prototype.getPass.call(this,t)},HX.PBRMaterial.prototype._clearPasses=function(){for(var t=0;t<HX.MaterialPass.NUM_PASS_TYPES;++t)this.setPass(t,null)},HX.PBRMaterial.prototype._updatePasses=function(){this._clearPasses();var t=this._generateColorDefines(),e=this._generateNormalDefines(),i=this._generateSpecularDefines();if(this._transparent)if(this._refract){var r=e+t;this._initPass(HX.MaterialPass.POST_PASS,r,"default_refract_vertex.glsl","default_refract_fragment.glsl")}else{var r="#define HX_NO_MRT_GBUFFER_COLOR\n"+e+t,n=this._initPass(HX.MaterialPass.POST_LIGHT_PASS,r,"default_geometry_mrt_vertex.glsl","default_geometry_mrt_fragment.glsl");n.setBlendMode(HX.BlendFactor.ZERO,HX.BlendFactor.SOURCE_COLOR,HX.BlendOperation.ADD)}var a;if(HX.EXT_DRAW_BUFFERS){var r=t+e+i;a=this._initPass(HX.MaterialPass.GEOMETRY_PASS,r,"default_geometry_mrt_vertex.glsl","default_geometry_mrt_fragment.glsl")}else t="#define HX_NO_MRT_GBUFFER_COLOR\n"+t,e="#define HX_NO_MRT_GBUFFER_NORMALS\n"+e,i="#define HX_NO_MRT_GBUFFER_SPECULAR\n"+i,a=this._initPass(HX.MaterialPass.GEOMETRY_COLOR_PASS,t,"default_geometry_mrt_vertex.glsl","default_geometry_mrt_fragment.glsl"),this._initPass(HX.MaterialPass.GEOMETRY_NORMAL_PASS,e,"default_geometry_mrt_vertex.glsl","default_geometry_mrt_fragment.glsl"),this._initPass(HX.MaterialPass.GEOMETRY_SPECULAR_PASS,i,"default_geometry_mrt_vertex.glsl","default_geometry_mrt_fragment.glsl");if(-1!==HX.MaterialPass.SHADOW_MAP_PASS){var r="#define HX_SHADOW_MAP_PASS\n";this._initPass(HX.MaterialPass.SHADOW_MAP_PASS,r,"default_geometry_mrt_vertex.glsl","default_geometry_mrt_fragment.glsl")}this.setUniform("color",this._color),this._colorMap&&this.setTexture("colorMap",this._colorMap),this._normalMap&&this.setTexture("normalMap",this._normalMap),this._specularMap&&this.setTexture("specularMap",this._specularMap),this._transparent&&(a.setUniform("color",new HX.Color(0,0,0,1)),a.setTexture("colorMap",null)),this._passesInvalid=!1},HX.PBRMaterial.prototype._generateColorDefines=function(){return this._colorMap?"#define COLOR_MAP\n":""},HX.PBRMaterial.prototype._generateNormalDefines=function(){return this._normalMap?"#define NORMAL_MAP\n":""},HX.PBRMaterial.prototype._generateSpecularDefines=function(){switch(this._specularMapMode){case HX.PBRMaterial.SPECULAR_MAP_ROUGHNESS_ONLY:return this._specularMap?"#define ROUGHNESS_MAP\n":"";case HX.PBRMaterial.SPECULAR_MAP_ALL:return this._specularMap?"#define SPECULAR_MAP\n":"";default:return"#define NORMAL_ROUGHNESS_MAP\n"}},HX.PBRMaterial.prototype._initPass=function(t,e,i,r){var n=HX.ShaderLibrary.get(i),a=HX.ShaderLibrary.get(r),s=new HX.Shader(n,a,e,e),o=new HX.MaterialPass(s);return this.setPass(t,o),o},Object.defineProperty(HX.PBRMaterial.prototype,"color",{get:function(){return this._color},set:function(t){this._color=isNaN(t)?t:new HX.Color(t),this.setUniform("color",this._color)}}),Object.defineProperty(HX.PBRMaterial.prototype,"colorMap",{get:function(){return this._colorMap},set:function(t){!!this._colorMap!=!!t&&(this._passesInvalid=!0),!this._passesInvalid&&t&&this.setTexture("colorMap",t),this._colorMap=t}}),Object.defineProperty(HX.PBRMaterial.prototype,"normalMap",{get:function(){return this._normalMap},set:function(t){!!this._normalMap!=!!t&&(this._passesInvalid=!0),!this._passesInvalid&&t&&this.setTexture("normalMap",t),this._normalMap=t}}),Object.defineProperty(HX.PBRMaterial.prototype,"specularMap",{get:function(){return this._specularMap},set:function(t){!!this._normalMap!=!!t&&(this._passesInvalid=!0),!this._passesInvalid&&t&&this.setTexture("specularMap",t),this._specularMap=t}}),Object.defineProperty(HX.PBRMaterial.prototype,"specularMapMode",{get:function(){return this._specularMapMode},set:function(t){this._specularMapMode!=t&&(this._passesInvalid=!0),this._specularMapMode=t}}),Object.defineProperty(HX.PBRMaterial.prototype,"metallicness",{get:function(){return this._metallicness},set:function(t){this._metallicness=HX.saturate(t),this.setUniform("metallicness",this._metallicness)}}),Object.defineProperty(HX.PBRMaterial.prototype,"specularNormalReflection",{get:function(){return this._specularNormalReflection},set:function(t){this._specularNormalReflection=HX.saturate(t),this.setUniform("specularNormalReflection",this._specularNormalReflection)}}),Object.defineProperty(HX.PBRMaterial.prototype,"roughness",{get:function(){return this._roughness},set:function(t){this._roughness=HX.saturate(t),this.setUniform("roughness",this._roughness)}}),Object.defineProperty(HX.PBRMaterial.prototype,"transparent",{get:function(){return this._transparent},set:function(t){this._transparent!==t&&(this._passesInvalid=!0),this._transparent=t,this._transparencyMode=t?HX.TransparencyMode.ADDITIVE:HX.TransparencyMode.OPAQUE}}),Object.defineProperty(HX.PBRMaterial.prototype,"refract",{get:function(){return this._refract},set:function(t){!!this._refract!=!!t&&(this._passesInvalid=!0),this._refract=HX.saturate(t)}}),Object.defineProperty(HX.PBRMaterial.prototype,"refractiveRatio",{
get:function(){return this._refractiveRatio},set:function(t){this._refractiveRatio=t,this.setUniform("refractiveRatio",t)}}),HX.SkyboxMaterial=function(t){HX.Material.call(this);var e=HX.ShaderLibrary.get("default_skybox_vertex.glsl"),i=HX.ShaderLibrary.get("default_skybox_fragment.glsl"),r=new HX.Shader(e,i),n=new HX.MaterialPass(r);n.setCullMode(HX.CullMode.NONE),this.setPass(HX.MaterialPass.POST_LIGHT_PASS,n),this.setTexture("hx_skybox",t)},HX.SkyboxMaterial.prototype=Object.create(HX.Material.prototype),HX.AmbientLight=function(){HX.Light.call(this),HX.Light._rectMesh=HX.Light._rectMesh||new HX.RectMesh.create,this._colorLocation=null,this._lightPass=null,this._useAO=!1,this.color=new HX.Color(.1,.1,.1)},HX.AmbientLight.prototype=Object.create(HX.Light.prototype),HX.AmbientLight.prototype.activate=function(t,e,i){var r=null!=i;this._lightPass&&this._useAO==r||(this._useAO=r,this._initLightPass()),HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.disable(HX.GL.CULL_FACE),this._lightPass.updateGlobalState(t,e,i),this._lightPass.updateRenderState()},HX.AmbientLight.prototype.renderBatch=function(t,e,i,r,n){this._occlusion=n;for(var a=0,s=0,o=0,h=t.length,_=e;h>_;++_){var l=t[_],c=l._scaledIrradiance;if(l._type!=this._type)break;a+=c.r,s+=c.g,o+=c.b}return HX.GL.uniform3f(this._colorLocation,a,s,o),HX.GL.drawElements(HX.GL.TRIANGLES,6,HX.GL.UNSIGNED_SHORT,0),_},HX.AmbientLight.prototype._updateWorldBounds=function(){this._worldBounds.clear(HX.BoundingVolume.EXPANSE_INFINITE),HX.Light.prototype._updateWorldBounds.call(this)},HX.AmbientLight.prototype._initLightPass=function(){var t={};this._useAO&&(t.USE_AO=1);var e=new HX.EffectPass(HX.ShaderLibrary.get("ambient_light_vertex.glsl"),HX.ShaderLibrary.get("ambient_light_fragment.glsl",t),HX.Light._rectMesh);this._colorLocation=e.getUniformLocation("lightColor"),this._lightPass=e},HX.Frustum=function(){this._planes=new Array(6),this._corners=new Array(8);for(var t=0;6>t;++t)this._planes[t]=new HX.Float4;for(var t=0;8>t;++t)this._corners[t]=new HX.Float4},HX.Frustum.PLANE_LEFT=0,HX.Frustum.PLANE_RIGHT=1,HX.Frustum.PLANE_BOTTOM=2,HX.Frustum.PLANE_TOP=3,HX.Frustum.PLANE_NEAR=4,HX.Frustum.PLANE_FAR=5,HX.Frustum.CLIP_SPACE_CORNERS=[new HX.Float4(-1,-1,-1,1),new HX.Float4(1,-1,-1,1),new HX.Float4(1,1,-1,1),new HX.Float4(-1,1,-1,1),new HX.Float4(-1,-1,1,1),new HX.Float4(1,-1,1,1),new HX.Float4(1,1,1,1),new HX.Float4(-1,1,1,1)],HX.Frustum.prototype={getPlanes:function(){return this._planes},getCorners:function(){return this._corners},update:function(t,e){this._updatePlanes(t),this._updateCorners(e)},_updatePlanes:function(t){var e=t.getRow(0),i=t.getRow(1),r=t.getRow(2),n=t.getRow(3);this._planes[HX.Frustum.PLANE_LEFT].sum(n,e),this._planes[HX.Frustum.PLANE_RIGHT].difference(n,e),this._planes[HX.Frustum.PLANE_BOTTOM].sum(n,i),this._planes[HX.Frustum.PLANE_TOP].difference(n,i),this._planes[HX.Frustum.PLANE_NEAR].sum(n,r),this._planes[HX.Frustum.PLANE_FAR].difference(n,r);for(var a=0;6>a;++a)this._planes[a].normalizeAsPlane()},_updateCorners:function(t){for(var e=0;8>e;++e){var i=this._corners[e];t.transformTo(HX.Frustum.CLIP_SPACE_CORNERS[e],i),i.scale(1/i.w)}}},HX.Camera=function(){HX.SceneNode.call(this),this._renderTargetWidth=0,this._renderTargetHeight=0,this._viewProjectionMatrixInvalid=!0,this._viewProjectionMatrix=new HX.Matrix4x4,this._inverseProjectionMatrix=new HX.Matrix4x4,this._inverseViewProjectionMatrix=new HX.Matrix4x4,this._projectionMatrix=new HX.Matrix4x4,this._viewMatrix=new HX.Matrix4x4,this._projectionMatrixDirty=!0,this._nearDistance=.1,this._farDistance=1e3,this._frustum=new HX.Frustum,this.position.set(0,0,1)},HX.Camera.prototype=Object.create(HX.SceneNode.prototype),HX.Camera.prototype.getViewProjectionMatrix=function(){return this._viewProjectionMatrixInvalid&&this._updateViewProjectionMatrix(),this._viewProjectionMatrix},HX.Camera.prototype.getFrustum=function(){return this._viewProjectionMatrixInvalid&&this._updateViewProjectionMatrix(),this._frustum},HX.Camera.prototype.getInverseViewProjectionMatrix=function(){return this._viewProjectionMatrixInvalid&&this._updateViewProjectionMatrix(),this._inverseViewProjectionMatrix},HX.Camera.prototype.getInverseProjectionMatrix=function(){return this._projectionMatrixDirty&&this._updateProjectionMatrix(),this._inverseProjectionMatrix},HX.Camera.prototype.getProjectionMatrix=function(){return this._projectionMatrixDirty&&this._updateProjectionMatrix(),this._projectionMatrix},HX.Camera.prototype.getViewMatrix=function(){return this._viewProjectionMatrixInvalid&&this._updateViewProjectionMatrix(),this._viewMatrix},HX.Camera.prototype.getNearDistance=function(){return this._nearDistance},HX.Camera.prototype.setNearDistance=function(t){this._nearDistance=t,this._invalidateProjectionMatrix()},HX.Camera.prototype.getFarDistance=function(){return this._farDistance},HX.Camera.prototype.setFarDistance=function(t){this._farDistance=t,this._invalidateProjectionMatrix()},HX.Camera.prototype._setRenderTargetResolution=function(t,e){this._renderTargetWidth=t,this._renderTargetHeight=e},HX.Camera.prototype._invalidateViewProjectionMatrix=function(){this._viewProjectionMatrixInvalid=!0},HX.Camera.prototype._invalidateWorldTransformationMatrix=function(){HX.SceneNode.prototype._invalidateWorldTransformationMatrix.call(this),this._invalidateViewProjectionMatrix()},HX.Camera.prototype._updateViewProjectionMatrix=function(){this._viewMatrix.inverseAffineOf(this.getWorldMatrix()),this._viewProjectionMatrix.product(this.getProjectionMatrix(),this._viewMatrix),this._inverseProjectionMatrix.inverseOf(this._projectionMatrix),this._inverseViewProjectionMatrix.inverseOf(this._viewProjectionMatrix),this._frustum.update(this._viewProjectionMatrix,this._inverseViewProjectionMatrix),this._viewProjectionMatrixInvalid=!1},HX.Camera.prototype._invalidateProjectionMatrix=function(){this._projectionMatrixDirty=!0,this._invalidateViewProjectionMatrix()},HX.Camera.prototype._updateProjectionMatrix=function(){throw"Abstract method!"},HX.Camera.prototype._updateWorldBounds=function(){this._worldBounds.clear(HX.BoundingVolume.EXPANSE_INFINITE)},HX.PerspectiveCamera=function(){HX.Camera.call(this),this._vFOV=1.047198,this._aspectRatio=0},HX.PerspectiveCamera.prototype=Object.create(HX.Camera.prototype),HX.PerspectiveCamera.prototype.getVerticalFOV=function(){return this._vFOV},HX.PerspectiveCamera.prototype.setVerticalFOV=function(t){this._nearDistance=t,this._invalidateProjectionMatrix()},HX.PerspectiveCamera.prototype._setAspectRatio=function(t){this._aspectRatio!=t&&(this._aspectRatio=t,this._invalidateProjectionMatrix())},HX.PerspectiveCamera.prototype._setRenderTargetResolution=function(t,e){HX.Camera.prototype._setRenderTargetResolution.call(this,t,e),this._setAspectRatio(t/e)},HX.PerspectiveCamera.prototype._updateProjectionMatrix=function(){this._projectionMatrix.perspectiveProjection(this._vFOV,this._aspectRatio,this._nearDistance,this._farDistance),this._projectionMatrixDirty=!1},HX.OrthographicOffCenterCamera=function(){HX.Camera.call(this),this._left=-1,this._right=1,this._top=1,this._bottom=-1},HX.OrthographicOffCenterCamera.prototype=Object.create(HX.Camera.prototype),HX.OrthographicOffCenterCamera.prototype.setBounds=function(t,e,i,r){this._left=t,this._right=e,this._top=i,this._bottom=r,this._invalidateProjectionMatrix()},HX.OrthographicOffCenterCamera.prototype._updateProjectionMatrix=function(){this._projectionMatrix.orthographicOffCenterProjection(this._left,this._right,this._top,this._bottom,this._nearDistance,this._farDistance),this._projectionMatrixDirty=!1},HX.DirectionalLight=function(){HX.Light.call(this),HX.Light._rectMesh=HX.Light._rectMesh||new HX.RectMesh.create,this._numCascades=1,this._shadowMapSize=1024,this._numShadowSamples=1,this.shadowSoftness=.02,this.depthBias=.02,this.direction=new HX.Float4(-1,-1,-1,0),this._matrixData=null,this._shadowSoftnessData=null,this._dirLocation=null,this._colorLocation=null,this._splitDistancesLocation=null,this._shadowMatrixLocation=null,this._depthBiasLocation=null,this._shadowSoftnessLocation=null},HX.DirectionalLight.prototype=Object.create(HX.Light.prototype),Object.defineProperty(HX.DirectionalLight.prototype,"castShadows",{get:function(){return this._castShadows},set:function(t){this._castShadows!=t&&(this._castShadows=t,t?this._shadowMapRenderer=new HX.CascadeShadowMapRenderer(this,this._numCascades,this._shadowMapSize):(this._shadowMapRenderer.dispose(),this._shadowMapRenderer=null),this._invalidateLightPass())}}),Object.defineProperty(HX.DirectionalLight.prototype,"numCascades",{get:function(){return this._numCascades},set:function(t){t>4&&(console.warn("set numCascades called with value greater than 4. Real value will be set to 4."),t=4),this._numCascades=t,this._castShadows&&this._invalidateLightPass(),this._shadowMapRenderer&&this._shadowMapRenderer.setNumCascades(t)}}),Object.defineProperty(HX.DirectionalLight.prototype,"shadowMapSize",{get:function(){return this._shadowMapSize},set:function(t){this._shadowMapSize=t,this._shadowMapRenderer&&this._shadowMapRenderer.setShadowMapSize(t)}}),Object.defineProperty(HX.DirectionalLight.prototype,"numShadowSamples",{get:function(){return this._numShadowSamples},set:function(t){1>t&&(t=1,console.warn("setNumShadowSamples called with value smaller than 1. Real value will be set to 1.")),this._numShadowSamples=t,this._castShadows&&this._invalidateLightPass()}}),Object.defineProperty(HX.DirectionalLight.prototype,"direction",{get:function(){var t=this.getWorldMatrix().getColumn(2);return t.x=-t.x,t.y=-t.y,t.z=-t.z,t},set:function(t){var e=new HX.Matrix4x4,i=this.getWorldMatrix().getColumn(3),r=HX.Float4.sum(t,i);e.lookAt(r,i,HX.Float4.Y_AXIS),this.setTransformationMatrix(e)}}),HX.DirectionalLight.prototype.activate=function(t,e,i){},HX.DirectionalLight.prototype.renderBatch=function(t,e,i,r,n){this._lightPass||this._initLightPass(),this._lightPass.updateGlobalState(i,r,n),this._lightPass.updateRenderState();var a=t[e],s=i.getViewMatrix().transform(a.direction),o=a._scaledIrradiance;if(HX.GL.uniform3f(this._dirLocation,s.x,s.y,s.z),HX.GL.uniform3f(this._colorLocation,o.r,o.g,o.b),this._castShadows){var h=this._shadowMapRenderer.getSplitDistances();HX.GL.uniform1fv(this._splitDistancesLocation,new Float32Array(h)),HX.GL.uniform1f(this._depthBiasLocation,a.depthBias);for(var _=0,l=0,c=this._numCascades,u=0;c>u;++u){var m=new HX.Matrix4x4;m.product(this._shadowMapRenderer.getShadowMatrix(u),i.getWorldMatrix());for(var f=m._m,d=0;16>d;++d)this._matrixData[_++]=f[d];this._numShadowSamples>1&&(this._shadowSoftnessData[l++]=f[0]*this.shadowSoftness*.5,this._shadowSoftnessData[l++]=f[5]*this.shadowSoftness*.5)}HX.GL.uniformMatrix4fv(this._shadowMatrixLocation,!1,this._matrixData),this._numShadowSamples>1&&HX.GL.uniform2fv(this._shadowSoftnessLocation,this._shadowSoftnessData)}return HX.GL.drawElements(HX.GL.TRIANGLES,6,HX.GL.UNSIGNED_SHORT,0),e+1},HX.DirectionalLight.prototype._updateWorldBounds=function(){this._worldBounds.clear(HX.BoundingVolume.EXPANSE_INFINITE),HX.Light.prototype._updateWorldBounds.call(this)},HX.DirectionalLight.prototype._initLightPass=function(){var t={};this._castShadows&&(t.CAST_SHADOWS=1,t.NUM_CASCADES=this._numCascades,t.NUM_SHADOW_SAMPLES=this._numShadowSamples);var e=HX.ShaderLibrary.get("directional_light_vertex.glsl",t),i=HX.LIGHTING_MODEL.getGLSL()+"\n"+HX.ShaderLibrary.get("directional_light_fragment.glsl",t),r=new HX.EffectPass(e,i,HX.Light._rectMesh);this._dirLocation=r.getUniformLocation("lightViewDirection"),this._colorLocation=r.getUniformLocation("lightColor"),this._lightPass=r,this._castShadows&&(this._matrixData=new Float32Array(16*this._numCascades),this._lightPass.setTexture("shadowMap",this._shadowMapRenderer._shadowMap),this._splitDistancesLocation=this._lightPass.getUniformLocation("splitDistances[0]"),this._shadowMatrixLocation=this._lightPass.getUniformLocation("shadowMapMatrices[0]"),this._depthBiasLocation=this._lightPass.getUniformLocation("depthBias"),this._numShadowSamples>1&&(this._shadowSoftnessLocation=this._lightPass.getUniformLocation("shadowMapSoftnesses[0]"),this._shadowSoftnessData=new Float32Array(2*this._numCascades)))},HX.DirectionalLight.prototype._invalidateLightPass=function(){this._lightPass&&(this._lightPass._shader.dispose(),this._lightPass=null,this._dirLocation=null,this._colorLocation=null,this._splitDistancesLocation=null,this._shadowMatrixLocation=null,this._depthBiasLocation=null,this._shadowSoftnessLocation=null,this._matrixData=null)},HX.GlobalSpecularProbe=function(t){this._texture=t,HX.GlobalSpecularProbe._rectMesh=HX.GlobalSpecularProbe._rectMesh||new HX.RectMesh.create,this._pass=this._initPass(),this._usingAO=!1},HX.GlobalSpecularProbe.powerRange0=98e-5,HX.GlobalSpecularProbe.powerRange1=.9921,HX.GlobalSpecularProbe.prototype=Object.create(HX.Light.prototype),HX.GlobalSpecularProbe.prototype.render=function(t,e,i){var r=null!=i;if(this._usingAO==r&&this._pass||(this._usingAO=r,this._pass=this._initPass()),HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.disable(HX.GL.CULL_FACE),this._pass.updateGlobalState(t,e,i),this._pass.updateRenderState(),this._texture){var n=Math.floor(Math.log(this._texture.size())/Math.log(2)),a=0;HX.GL.uniform1f(this._numMipsLocation,n-a)}HX.GL.drawElements(HX.GL.TRIANGLES,6,HX.GL.UNSIGNED_SHORT,0)},HX.GlobalSpecularProbe.prototype._updateWorldBounds=function(){this._worldBounds.clear(HX.BoundingVolume.EXPANSE_INFINITE),HX.Light.prototype._updateWorldBounds.call(this)},HX.GlobalSpecularProbe.prototype._initPass=function(){var t,e={};HX.EXT_SHADER_TEXTURE_LOD&&(t="#extension GL_EXT_shader_texture_lod : require",e.USE_TEX_LOD=1),this._usingAO&&(e.USE_AO=1),e.K0=HX.GlobalSpecularProbe.powerRange0,e.K1=HX.GlobalSpecularProbe.powerRange1;var i=new HX.EffectPass(HX.ShaderLibrary.get("global_specular_probe_vertex.glsl"),HX.ShaderLibrary.get("global_specular_probe_fragment.glsl",e),HX.GlobalSpecularProbe._rectMesh,null,t);this._numMipsLocation=i.getUniformLocation("numMips"),i.setTexture("specularProbeSampler",this._texture);var r=.0014,n=2/(r*r)-2,a=(Math.pow(2,-10/Math.sqrt(n))-HX.GlobalSpecularProbe.powerRange0)/HX.GlobalSpecularProbe.powerRange1;return i.setUniform("maxMipFactor",a),i},HX.GlobalIrradianceProbe=function(t){this._texture=t,HX.GlobalIrradianceProbe._rectMesh=HX.GlobalIrradianceProbe._rectMesh||new HX.RectMesh.create,this._usingAO=!1},HX.GlobalIrradianceProbe.prototype=Object.create(HX.Light.prototype),HX.GlobalIrradianceProbe.prototype.render=function(t,e,i){var r=null!=i;this._usingAO==r&&this._pass||(this._usingAO=r,this._pass=this._initPass()),HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.disable(HX.GL.CULL_FACE),this._pass.updateGlobalState(t,e,i),this._pass.updateRenderState(),HX.GL.drawElements(HX.GL.TRIANGLES,6,HX.GL.UNSIGNED_SHORT,0)},HX.GlobalIrradianceProbe.prototype._updateWorldBounds=function(){this._worldBounds.clear(HX.BoundingVolume.EXPANSE_INFINITE),HX.Light.prototype._updateWorldBounds.call(this)},HX.GlobalIrradianceProbe.prototype._initPass=function(){var t={};this._usingAO&&(t.USE_AO=1);var e=new HX.EffectPass(HX.ShaderLibrary.get("global_irradiance_probe_vertex.glsl"),HX.ShaderLibrary.get("global_irradiance_probe_fragment.glsl",t),HX.GlobalIrradianceProbe._rectMesh);return e.setTexture("irradianceProbeSampler",this._texture),e},HX.PointLight=function(){HX.Light.call(this),HX.Light._rectMesh=HX.Light._rectMesh||new HX.RectMesh.create,HX.PointLight._sphereMesh=HX.PointLight._sphereMesh||new HX.Mesh(HX.MeshBatch.create(new HX.SpherePrimitive.createMeshData({invert:!0,numSegmentsW:HX.PointLight.SPHERE_SEGMENTS_W,numSegmentsH:HX.PointLight.SPHERE_SEGMENTS_H}),HX.PointLight.LIGHTS_PER_BATCH)),void 0===HX.PointLight._fullScreenLightPasses&&this._initLightPasses(),HX.PointLight._positionData=new Float32Array(3*HX.PointLight.LIGHTS_PER_BATCH),HX.PointLight._colorData=new Float32Array(3*HX.PointLight.LIGHTS_PER_BATCH),HX.PointLight._attenuationData=new Float32Array(2*HX.PointLight.LIGHTS_PER_BATCH),HX.PointLight._radiusData=new Float32Array(HX.PointLight.LIGHTS_PER_BATCH),this._luminanceBound=1/255,this._attenuationFix=1,this._radius=1},HX.PointLight.LIGHTS_PER_BATCH=20,HX.PointLight.SPHERE_SEGMENTS_W=16,HX.PointLight.SPHERE_SEGMENTS_H=10,HX.PointLight.NUM_SPHERE_INDICES=HX.PointLight.SPHERE_SEGMENTS_W*HX.PointLight.SPHERE_SEGMENTS_H*6,HX.PointLight.prototype=Object.create(HX.Light.prototype),HX.PointLight.prototype.activate=function(t,e,i){HX.GL.disable(HX.GL.DEPTH_TEST),this._camera=t,this._gbuffer=e,this._occlusion=i,HX.PointLight._sphericalLightPass.updateGlobalState(t,e,i)},HX.PointLight.prototype.renderBatch=function(t,e,i,r,n){var a=t[e]._renderOrderHint<0;return a?this._renderFullscreenBatch(t,e,i):this._renderSphereBatch(t,e,i)},HX.PointLight.prototype._renderSphereBatch=function(t,e,i){HX.PointLight._sphericalLightPass.updateRenderState(),HX.GL.enable(HX.GL.CULL_FACE);var r=e+HX.PointLight.LIGHTS_PER_BATCH;r>t.length&&(r=t.length);for(var n=HX.PointLight._positionData,a=HX.PointLight._colorData,s=HX.PointLight._attenuationData,o=HX.PointLight._radiusData,h=new HX.Float4,_=i.getViewMatrix(),l=0,c=0,u=0,m=e;r>m;++m){var f=t[m];if(f._type!=this._type||f._renderOrderHint<0)r=m;else{f.getWorldMatrix().getColumn(3,h),_.transformPoint(h,h);var d=f._scaledIrradiance;n[u]=h.x,a[u++]=d.r,n[u]=h.y,a[u++]=d.g,n[u]=h.z,a[u++]=d.b,s[c++]=f._attenuationFix,s[c++]=1/(1-f._attenuationFix),o[l++]=2*f._radius*1.0001}}return HX.GL.uniform3fv(HX.PointLight._sphericalPositionLocation,n),HX.GL.uniform3fv(HX.PointLight._sphericalColorLocation,a),HX.GL.uniform2fv(HX.PointLight._sphericalAttenuationFixFactorsLocation,s),HX.GL.uniform1fv(HX.PointLight._sphericalLightRadiusLocation,o),HX.GL.drawElements(HX.GL.TRIANGLES,HX.PointLight.NUM_SPHERE_INDICES*(r-e),HX.GL.UNSIGNED_SHORT,0),r},HX.PointLight.prototype.initFullScreenPass=function(t){var e={LIGHTS_PER_BATCH:t+1},i=new HX.EffectPass(HX.ShaderLibrary.get("point_light_fullscreen_vertex.glsl",e),HX.LIGHTING_MODEL.getGLSL()+HX.ShaderLibrary.get("point_light_fullscreen_fragment.glsl",e),HX.Light._rectMesh);HX.PointLight._fullScreenPositionLocations[t]=i.getUniformLocation("lightViewPosition[0]"),HX.PointLight._fullScreenColorLocations[t]=i.getUniformLocation("lightColor[0]"),HX.PointLight._fullScreenAttenuationFixFactorsLocations[t]=i.getUniformLocation("attenuationFixFactors[0]"),HX.PointLight._fullScreenLightPasses[t]=i},HX.PointLight.prototype._renderFullscreenBatch=function(t,e,i){HX.GL.disable(HX.GL.CULL_FACE);var r=e+HX.PointLight.LIGHTS_PER_BATCH;r>t.length&&(r=t.length);for(var n=HX.PointLight._positionData,a=HX.PointLight._colorData,s=HX.PointLight._attenuationData,o=new HX.Float4,h=i.getViewMatrix(),_=0,l=0,c=e;r>c;++c){var u=t[c];if(u._type==this._type){u.getWorldMatrix().getColumn(3,o),h.transformPoint(o,o);var m=u._scaledIrradiance;n[_]=o.x,a[_++]=m.r,n[_]=o.y,a[_++]=m.g,n[_]=o.z,a[_++]=m.b,s[l++]=u._attenuationFix,s[l++]=1/(1-u._attenuationFix)}else r=c}var f=c-e-1;return HX.PointLight._fullScreenLightPasses[f]||this.initFullScreenPass(f),HX.PointLight._fullScreenLightPasses[f].updateGlobalState(i,this._gbuffer,this._occlusion),HX.PointLight._fullScreenLightPasses[f].updateRenderState(),HX.GL.uniform3fv(HX.PointLight._fullScreenPositionLocations[f],n),HX.GL.uniform3fv(HX.PointLight._fullScreenColorLocations[f],a),HX.GL.uniform2fv(HX.PointLight._fullScreenAttenuationFixFactorsLocations[f],s),HX.GL.drawElements(HX.GL.TRIANGLES,6,HX.GL.UNSIGNED_SHORT,0),r},HX.PointLight.prototype._updateScaledIrradiance=function(){HX.Light.prototype._updateScaledIrradiance.call(this),this._attenuationFix=this._luminanceBound/this._intensity,this._radius=Math.sqrt(1/this._attenuationFix),this._invalidateWorldBounds()},HX.PointLight.prototype._createBoundingVolume=function(){return new HX.BoundingSphere},HX.PointLight.prototype._updateWorldBounds=function(){this._worldBounds.setExplicit(this.getWorldMatrix().getColumn(3),this._radius),HX.Light.prototype._updateWorldBounds.call(this)},HX.PointLight.prototype.getRadius=function(){return this._worldBounds.getRadius()},HX.PointLight.prototype._initLightPasses=function(){HX.PointLight._fullScreenLightPasses=[],HX.PointLight._fullScreenPositionLocations=[],HX.PointLight._fullScreenColorLocations=[],HX.PointLight._fullScreenAttenuationFixFactorsLocations=[];var t={LIGHTS_PER_BATCH:HX.PointLight.LIGHTS_PER_BATCH},e=new HX.EffectPass(HX.ShaderLibrary.get("point_light_spherical_vertex.glsl",t),HX.LIGHTING_MODEL.getGLSL()+HX.ShaderLibrary.get("point_light_spherical_fragment.glsl",t),HX.PointLight._sphereMesh);HX.PointLight._sphericalLightPass=e,HX.PointLight._sphericalPositionLocation=e.getUniformLocation("lightViewPosition[0]"),HX.PointLight._sphericalColorLocation=e.getUniformLocation("lightColor[0]"),HX.PointLight._sphericalAttenuationFixFactorsLocation=e.getUniformLocation("attenuationFixFactors[0]"),HX.PointLight._sphericalLightRadiusLocation=e.getUniformLocation("lightRadius[0]")},HX.Skybox=function(t){t instanceof HX.Material||(t=new HX.SkyboxMaterial(t)),this._modelInstance=new HX.ModelInstance(HX.PlanePrimitive.create({alignment:HX.PlanePrimitive.ALIGN_XY,width:2,height:2}),t),this._globalSpecularProbe=null,this._globalIrradianceProbe=null},HX.Skybox.prototype={getGlobalSpecularProbe:function(){return this._globalSpecularProbe},setGlobalSpecularProbe:function(t){this._globalSpecularProbe=t},getGlobalIrradianceProbe:function(){return this._globalIrradianceProbe},setGlobalIrradianceProbe:function(t){this._globalIrradianceProbe=t}},HX.MeshBatch={create:function(t,e){var i=HX.MeshData.createDefaultBatchEmpty(),r=[],n=[],a=t._vertexData,s=t._indexData,o=a.length,h=0,_=0;i.vertexUsage=t.vertexUsage,i.indexUsage=t.vertexUsage;for(var l=0;e>l;++l){var c=_/HX.MeshData.DEFAULT_BATCHED_VERTEX_SIZE;o=a.length;for(var u=0;o>u;){for(var m=0;m<HX.MeshData.DEFAULT_VERTEX_SIZE;++m)r[_++]=a[u++];r[_++]=l}for(o=s.length,u=0;o>u;++u)n[h++]=s[u]+c}return i.setVertexData(r),i.setIndexData(n),i}},HX.MeshData=function(){this._vertexStride=0,this._vertexData=void 0,this._indexData=void 0,this.vertexUsage=HX.GL.STATIC_DRAW,this.indexUsage=HX.GL.STATIC_DRAW,this._vertexAttributes=[]},HX.MeshData.DEFAULT_VERTEX_SIZE=12,HX.MeshData.DEFAULT_BATCHED_VERTEX_SIZE=13,HX.MeshData.createDefaultEmpty=function(){var t=new HX.MeshData;return t.addVertexAttribute("hx_position",3),t.addVertexAttribute("hx_normal",3),t.addVertexAttribute("hx_tangent",4),t.addVertexAttribute("hx_texCoord",2),t},HX.MeshData.createDefaultBatchEmpty=function(){var t=new HX.MeshData;return t.addVertexAttribute("hx_position",3),t.addVertexAttribute("hx_normal",3),t.addVertexAttribute("hx_tangent",4),t.addVertexAttribute("hx_texCoord",2),t.addVertexAttribute("hx_instanceID",1),t},HX.MeshData.prototype={constructor:HX.MeshData,setVertexData:function(t){this._vertexData=new Float32Array(t)},setIndexData:function(t){this._indexData=new Uint16Array(t)},addVertexAttribute:function(t,e){var i=this._vertexStride;this._vertexStride+=e,this._vertexAttributes.push({name:t,offset:i,numComponents:e})},getVertexAttribute:function(t){for(var e=this._vertexAttributes.length,i=0;e>i;++i)if(this._vertexAttributes[i].name===t)return this._vertexAttributes[i]},getVertexStride:function(){return this._vertexStride}},HX.Mesh=function(t){this._vertexBuffer=new HX.VertexBuffer,this._indexBuffer=new HX.IndexBuffer,this._vertexBuffer.uploadData(t._vertexData,t.vertexUsage),this._indexBuffer.uploadData(t._indexData,t.indexUsage),this._numIndices=t._indexData.length,this._vertexStride=t.getVertexStride(),this._vertexAttributes=t._vertexAttributes,this._renderOrderHint=++HX.Mesh.ID_COUNTER},HX.Mesh.ID_COUNTER=0,HX.Mesh.prototype={constructor:HX.Mesh,dispose:function(){this._vertexBuffer.dispose(),this._indexBuffer.dispose()},numIndices:function(){return this._numIndices},numVertexAttributes:function(){return this._vertexAttributes.length},getVertexStride:function(){return this._vertexStride},getVertexAttribute:function(t){return this._vertexAttributes[t]}},HX.ModelData=function(){this._meshDataList=[]},HX.ModelData.prototype={constructor:HX.ModelData,numMeshes:function(){return this._meshDataList.length},getMeshData:function(t){return this._meshDataList[t]},addMeshData:function(t){this._meshDataList.push(t)}},HX.Model=function(t){this._localBounds=new HX.BoundingAABB,this.onChange=new HX.Signal,t?(this._meshes=null,this._setModelData(t)):this._meshes=[]},HX.Model.prototype={constructor:HX.Model,numMeshes:function(){return this._meshes.length},getMesh:function(t){return this._meshes[t]},dispose:function(){if(this._meshes)for(var t=0;t<this._meshes.length;++t)this._meshes[t].dispose()},getLocalBounds:function(){return this._localBounds},_setModelData:function(t){this.dispose(),this._localBounds.clear(),this._meshes=[];for(var e=0;e<t.numMeshes();++e){var i=t.getMeshData(e);this._localBounds.growToIncludeMesh(i),this._meshes.push(new HX.Mesh(i))}this.onChange.dispatch()}},HX.FileModel=function(t){HX.Model.call(this);var e=this,i=function(t){e._setModelData(t)};HX.ModelParser.parse(t,i)},HX.FileModel.prototype=Object.create(HX.Model.prototype),HX.VertexLayout=function(t,e){var i=e.getShader();this.attributes=[],this._numAttributes=-1;for(var r=t.getVertexStride(),n=0;n<t.numVertexAttributes();++n){var a=t.getVertexAttribute(n),s=i.getVertexAttributeIndex(a.name);this._numAttributes=Math.max(this._numAttributes,s),s>=0&&this.attributes.push({index:s,offset:4*a.offset,numComponents:a.numComponents,stride:4*r})}++this._numAttributes},HX.VertexLayout.prototype={constructor:HX.VertexLayout},HX.MeshInstance=function(t,e){this._mesh=t,this._meshMaterialLinkInvalid=!1,this.material=e},HX.MeshInstance.prototype={constructor:HX.MeshInstance,get material(){return this._material},set material(t){this._material&&this._material.onChange.unbind(this._onMaterialChange),this._material=t,this._material&&this._material.onChange.bind(this,this._onMaterialChange),this._linkMeshWithMaterial()},updateRenderState:function(t){this._meshMaterialLinkInvalid&&this._linkMeshWithMaterial(),this._mesh._vertexBuffer.bind(),this._mesh._indexBuffer.bind();for(var e=this._vertexLayouts[t],i=e.attributes,r=i.length,n=0;r>n;++n){var a=i[n];HX.GL.vertexAttribPointer(a.index,a.numComponents,HX.GL.FLOAT,!1,a.stride,a.offset)}HX.enableAttributes(e._numAttributes)},_initVertexLayouts:function(){this._vertexLayouts=new Array(HX.MaterialPass.NUM_PASS_TYPES);for(var t=0;t<HX.MaterialPass.NUM_PASS_TYPES;++t){var e=this._material.getPass(t);e&&(this._vertexLayouts[t]=new HX.VertexLayout(this._mesh,e))}},_linkMeshWithMaterial:function(){this._initVertexLayouts(),this._uniformSetters=new Array(HX.MaterialPass.NUM_PASS_TYPES);for(var t=0;t<HX.MaterialPass.NUM_PASS_TYPES;++t)if(this._material.hasPass(t)){var e=this._material.getPass(t);this._uniformSetters[t]=HX.UniformSetter.getSetters(e._shader)}this._meshMaterialLinkInvalid=!1},_onMaterialChange:function(){this._meshMaterialLinkInvalid=!0}},HX.ModelInstance=function(t,e){this._model=t,this._meshInstances=[],this._castShadows=!0,this.onChange=new HX.Signal,this._model.onChange.bind(this,this._onModelChange),this._materials=e instanceof Array?e:[e],this._onModelChange()},HX.ModelInstance.prototype={constructor:HX.ModelInstance,getModel:function(){return this._model},get castShadows(){return this._castShadows},set castShadows(t){this._castShadows=t},numMeshInstances:function(){return this._meshInstances.length},getMeshInstance:function(t){return this._meshInstances[t]},getLocalBounds:function(){return this._model.getLocalBounds()},_addMeshInstance:function(t,e){this._meshInstances.push(new HX.MeshInstance(t,e))},_onModelChange:function(){for(var t=this._materials.length-1,e=0;e<this._model.numMeshes();++e)this._addMeshInstance(this._model.getMesh(e),this._materials[Math.min(e,t)]);this.onChange.dispatch()}},HX.BoxPrimitive={},HX.BoxPrimitive._createMeshData=function(t){var e,i=t.numSegmentsW||1,r=t.numSegmentsH||1,n=t.numSegmentsD||1,a=t.width||1,s=t.height||a,o=t.depth||a,h=t.scaleU||1,_=t.scaleV||1,l=t.invert?-1:1,c=void 0===t.doubleSided?!1:t.doubleSided,u=HX.MeshData.DEFAULT_VERTEX_SIZE,m=new HX.MeshData.createDefaultEmpty,f=6,d=[],p=[],X=0,H=1/i,g=1/r,x=1/n,S=.5*a,v=.5*s,E=.5*o;e=X+(i+1)*(r+1)*u;for(var L=0;r>=L;++L){var T=L*g,P=s*T-v;0>l&&(T=1-T);for(var M=0;i>=M;++M){var y=M*H,R=a*y-S;0>l&&(y=1-y),d[X]=R*l,d[X+1]=P*l,d[X+2]=E*l,d[X+3]=0,d[X+4]=0,d[X+5]=1,d[X+6]=1,d[X+7]=0,d[X+8]=0,d[X+9]=1,d[X+10]=y*h,d[X+11]=T*_,d[e]=-R*l,d[e+1]=P*l,d[e+2]=-E*l,d[e+3]=0,d[e+4]=0,d[e+5]=-1,d[e+6]=-1,d[e+7]=0,d[e+8]=0,d[X+9]=1,d[e+10]=y*h,d[e+11]=T*_,X+=u,e+=u}}X=e,e=X+(n+1)*(r+1)*u;for(var L=0;r>=L;++L)for(var T=L*g,P=s*T-v,A=0;n>=A;++A){var y=A*x,D=o*y-E;d[X]=-S,d[X+1]=P,d[X+2]=D*l,d[X+3]=-l,d[X+4]=0,d[X+5]=0,d[X+6]=0,d[X+7]=0,d[X+8]=l,d[X+9]=1,d[X+10]=y*h,d[X+11]=T*_,d[e]=S,d[e+1]=P,d[e+2]=-D*l,d[e+3]=l,d[e+4]=0,d[e+5]=0,d[e+6]=0,d[e+7]=0,d[e+8]=-l,d[X+9]=1,d[e+10]=y*h,d[e+11]=T*_,X+=u,e+=u}X=e,e=X+(i+1)*(n+1)*u;for(var A=0;n>=A;++A)for(var T=A*x,D=o*T-E,M=0;i>=M;++M){var y=M*H,R=a*y-S;d[X]=R,d[X+1]=v,d[X+2]=-D*l,d[X+3]=0,d[X+4]=l,d[X+5]=0,d[X+6]=1,d[X+7]=0,d[X+8]=0,d[X+9]=1,d[X+10]=y*h,d[X+11]=T*_,d[e]=R,d[e+1]=-v,d[e+2]=D*l,d[e+3]=0,d[e+4]=-l,d[e+5]=0,d[e+6]=1,d[e+7]=0,d[e+8]=0,d[X+9]=1,d[e+10]=y*h,d[e+11]=T*_,X+=u,e+=u}for(var w=0,b=0,G=0;f>G;++G){for(var C=2==G||3==G?n:i,O=4==G||5==G?n:r,N=0;O>N;++N)for(var F=0;C>F;++F){var B=C+1,I=w+F+N*B;p[b]=I,p[b+1]=I+B+1,p[b+2]=I+B,p[b+3]=I,p[b+4]=I+1,p[b+5]=I+B+1,b+=6}w+=(C+1)*(O+1)}if(c)for(var U=0,V=b;V>U;)p[b+U]=p[U],p[b+U+1]=p[U+2],p[b+U+2]=p[U+1],p[b+U+3]=p[U+3],p[b+U+4]=p[U+5],p[b+U+5]=p[U+4],U+=6;return m.setVertexData(d),m.setIndexData(p),m},HX.BoxPrimitive.createMesh=function(t){var e=HX.BoxPrimitive._createMeshData(t);return new HX.Mesh(e)},HX.BoxPrimitive.create=function(t){t=t||{};var e=HX.BoxPrimitive._createMeshData(t),i=new HX.ModelData;return i.addMeshData(e),new HX.Model(i)},HX.PlanePrimitive={},HX.PlanePrimitive.ALIGN_XZ=1,HX.PlanePrimitive.ALIGN_XY=2,HX.PlanePrimitive.ALIGN_YZ=3,HX.PlanePrimitive.create=function(t){t=t||{};var e=t.alignment||HX.PlanePrimitive.ALIGN_XZ,i=t.numSegmentsW||1,r=t.numSegmentsH||1,n=t.width||1,a=t.height||1,s=t.scaleU||1,o=t.scaleV||1,h=void 0===t.doubleSided?!1:t.doubleSided,_=HX.MeshData.DEFAULT_VERTEX_SIZE,l=new HX.MeshData.createDefaultEmpty,c=r*i*6,u=(r+1)*(i+1);h&&(c*=2,u*=2);var m=new Array(u*_),f=new Array(c),d=0,p=0,X=1/i,H=1/r,g=0,x=0,S=0,v=0,E=0,L=0,T=0,P=0,M=0,y=0,R=0,A=0,D=0;e==HX.PlanePrimitive.ALIGN_XY?(L=-1,T=1,y=1):e==HX.PlanePrimitive.ALIGN_XZ?(E=1,T=-1,R=1):(v=1,M=1,y=1);for(var w=0;r>=w;++w)for(var b=(w*H-.5)*a,G=0;i>=G;++G){var C=(G*X-.5)*n;if(e==HX.PlanePrimitive.ALIGN_XY?(g=C,x=b,A=1-G*X,D=w*H):e==HX.PlanePrimitive.ALIGN_XZ?(g=C,S=b,A=1-G*X,D=w*H):(x=b,S=C,A=1-G*X,D=w*H),A*=s,D*=o,m[d]=g,m[d+1]=x,m[d+2]=S,m[d+3]=v,m[d+4]=E,m[d+5]=L,m[d+6]=T,m[d+7]=P,m[d+8]=M,m[d+9]=1,m[d+10]=A,m[d+11]=D,d+=_,h&&(m[d]=g,m[d+1]=x,m[d+2]=S,m[d+3]=-v,m[d+4]=-E,m[d+5]=-L,m[d+6]=-T,m[d+7]=-P,m[d+8]=-M,m[d+9]=1,m[d+10]=1-A,m[d+11]=D,d+=_),G!=i&&w!=r){var O=i+1,N=G+w*O,F=h?1:0;f[p]=N<<F,f[p+1]=N+O<<F,f[p+2]=N+O+1<<F,f[p+3]=N<<F,f[p+4]=N+O+1<<F,f[p+5]=N+1<<F,p+=6,h&&(f[p]=(N+O+1<<F)+1,f[p+1]=(N+O<<F)+1,f[p+2]=(N<<F)+1,f[p+3]=(N+1<<F)+1,f[p+4]=(N+O+1<<F)+1,f[p+5]=(N<<F)+1,p+=6)}}l.setVertexData(m),l.setIndexData(f);var B=new HX.ModelData;return B.addMeshData(l),new HX.Model(B)},HX.RectMesh={},HX.RectMesh.create=function(){var t=new HX.MeshData;return t.addVertexAttribute("hx_position",2),t.addVertexAttribute("hx_texCoord",2),t.setVertexData([-1,1,0,1,1,1,1,1,1,-1,1,0,-1,-1,0,0]),t.setIndexData([0,1,2,0,2,3]),new HX.Mesh(t)},HX.SpherePrimitive={},HX.SpherePrimitive.createMeshData=function(t){for(var e=t.numSegmentsW||16,i=t.numSegmentsH||10,r=t.radius||.5,n=t.scaleU||1,a=t.scaleV||1,s=t.invert?-1:1,o=void 0===t.doubleSided?!1:t.doubleSided,h=HX.MeshData.DEFAULT_VERTEX_SIZE,_=new HX.MeshData.createDefaultEmpty,l=i*e*6,c=(i+1)*(e+1),u=new Array(c*h),m=new Array(l),f=0,d=0,p=1/e,X=1/i,H=0;i>=H;++H){var g=H*X,x=g*Math.PI,S=-Math.cos(x),v=Math.sin(x);0>s&&(g=1-g);for(var E=0;e>=E;++E){
var L=E*p,T=L*Math.PI*2;s&&(L=1-L);var P=Math.cos(T)*v*s,M=S*s,y=Math.sin(T)*v*s;u[f]=P*r,u[f+1]=M*r,u[f+2]=y*r,u[f+3]=P*s,u[f+4]=M*s,u[f+5]=y*s,u[f+6]=-y,u[f+7]=0,u[f+8]=P,u[f+9]=1,u[f+10]=1-L*n,u[f+11]=g*a,f+=h}}for(var H=0;i>H;++H)for(var E=0;e>E;++E){var R=e+1,A=E+H*R;m[d]=A,m[d+1]=A+R,m[d+2]=A+R+1,m[d+3]=A,m[d+4]=A+R+1,m[d+5]=A+1,d+=6,o&&(m[d]=A,m[d+1]=A+R+1,m[d+2]=A+R,m[d+3]=A,m[d+4]=A+1,m[d+5]=A+R+1)}return _.setVertexData(u),_.setIndexData(m),_},HX.SpherePrimitive.createMesh=function(t){var e=HX.SpherePrimitive.createMeshData(t);return new HX.Mesh(e)},HX.SpherePrimitive.create=function(t){t=t||{};var e=HX.SpherePrimitive.createMeshData(t),i=new HX.ModelData;return i.addMeshData(e),new HX.Model(i)},HX.FrameBuffer=function(t,e){if(t&&void 0===t[0]&&(t=[t]),this._colorTextures=t,this._numColorTextures=this._colorTextures?this._colorTextures.length:0,this._depthBuffer=e,this._colorTextures&&this._numColorTextures>1){this._drawBuffers=new Array(this._numColorTextures);for(var i=0;i<this._numColorTextures;++i)this._drawBuffers[i]=HX.EXT_DRAW_BUFFERS.COLOR_ATTACHMENT0_WEBGL+i}else this._drawBuffers=null;this._fbo=HX.GL.createFramebuffer()},HX.FrameBuffer.prototype={constructor:HX.FrameBuffer,width:function(){return this._width},height:function(){return this._height},init:function(){HX.setRenderTarget(this),this._colorTextures?(this._width=this._colorTextures[0]._width,this._height=this._colorTextures[0]._height):(this._width=this._depthBuffer._width,this._height=this._depthBuffer._height);for(var t=0;t<this._numColorTextures;++t){var e=this._colorTextures[t];HX.EXT_DRAW_BUFFERS?HX.GL.framebufferTexture2D(HX.GL.FRAMEBUFFER,HX.EXT_DRAW_BUFFERS.COLOR_ATTACHMENT0_WEBGL+t,HX.GL.TEXTURE_2D,e._texture,0):HX.GL.framebufferTexture2D(HX.GL.FRAMEBUFFER,HX.GL.COLOR_ATTACHMENT0+t,HX.GL.TEXTURE_2D,e._texture,0)}this._depthBuffer&&(this._depthBuffer instanceof HX.Texture2D?HX.GL.framebufferTexture2D(HX.GL.FRAMEBUFFER,HX.GL.DEPTH_STENCIL_ATTACHMENT,HX.GL.TEXTURE_2D,this._depthBuffer._texture,0):(HX.GL.bindRenderbuffer(HX.GL.RENDERBUFFER,this._depthBuffer._renderBuffer),HX.GL.framebufferRenderbuffer(HX.GL.FRAMEBUFFER,HX.GL.DEPTH_STENCIL_ATTACHMENT,HX.GL.RENDERBUFFER,this._depthBuffer._renderBuffer)));var i=HX.GL.checkFramebufferStatus(HX.GL.FRAMEBUFFER);switch(i){case HX.GL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:console.warn("Failed to initialize FBO: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");break;case HX.GL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:console.warn("Failed to initialize FBO: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");break;case HX.GL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:console.warn("Failed to initialize FBO: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");break;case HX.GL.FRAMEBUFFER_UNSUPPORTED:console.warn("Failed to initialize FBO: FRAMEBUFFER_UNSUPPORTED")}HX.setRenderTarget(null)},dispose:function(){HX.GL.deleteFramebuffer(this._fbo)}},HX.ReadOnlyDepthBuffer=function(){this._renderBuffer=HX.GL.createRenderbuffer()},HX.ReadOnlyDepthBuffer.prototype={constructor:HX.FrameBuffer,width:function(){return this._width},height:function(){return this._height},init:function(t,e){this._width=t,this._height=e,HX.GL.bindRenderbuffer(HX.GL.RENDERBUFFER,this._renderBuffer),HX.GL.renderbufferStorage(HX.GL.RENDERBUFFER,HX.GL.DEPTH_STENCIL,t,e)},dispose:function(){HX.GL.deleteRenderBuffer(this._fbo)}},HX.Texture2D=function(){this._default=HX.DEFAULT_TEXTURE_2D,this._texture=HX.GL.createTexture(),this._width=0,this._height=0,this.bind(),HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.GL.TEXTURE_MIN_FILTER,HX.TextureFilter.DEFAULT.min),HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.GL.TEXTURE_MAG_FILTER,HX.TextureFilter.DEFAULT.mag),HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.GL.TEXTURE_WRAP_S,HX.TextureWrapMode.DEFAULT.s),HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.GL.TEXTURE_WRAP_T,HX.TextureWrapMode.DEFAULT.t),HX.EXT_TEXTURE_FILTER_ANISOTROPIC&&HX.DEFAULT_TEXTURE_MAX_ANISOTROPY>0&&HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.EXT_TEXTURE_FILTER_ANISOTROPIC.TEXTURE_MAX_ANISOTROPY_EXT,HX.DEFAULT_TEXTURE_MAX_ANISOTROPY),this._isReady=!1},HX.Texture2D.prototype={constructor:HX.Texture2D,dispose:function(){HX.GL.deleteTexture(this._texture),this._isReady=!1},generateMipmap:function(){this.bind(),HX.GL.generateMipmap(HX.GL.TEXTURE_2D)},setFilter:function(t){this.bind(),HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.GL.TEXTURE_MIN_FILTER,t.min),HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.GL.TEXTURE_MAG_FILTER,t.mag)},setWrapMode:function(t){this.bind(),HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.GL.TEXTURE_WRAP_S,t.s),HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.GL.TEXTURE_WRAP_T,t.t)},setMaxAnisotropy:function(t){HX.EXT_TEXTURE_FILTER_ANISOTROPIC&&HX.GL.texParameteri(HX.GL.TEXTURE_2D,HX.EXT_TEXTURE_FILTER_ANISOTROPIC.TEXTURE_MAX_ANISOTROPY_EXT,t)},width:function(){return this._width},height:function(){return this._height},initEmpty:function(t,e,i,r){i=i||HX.GL.RGBA,r=r||HX.GL.UNSIGNED_BYTE,this.bind(),this._width=t,this._height=e,HX.GL.texImage2D(HX.GL.TEXTURE_2D,0,i,t,e,0,i,r,null),this._isReady=!0,HX.GL.bindTexture(HX.GL.TEXTURE_2D,null)},uploadData:function(t,e,i,r,n,a){this._width=e,this._height=i,n=n||HX.GL.RGBA,a=a||HX.GL.UNSIGNED_BYTE,r=void 0===r?!1:r,this.bind(),HX.GL.texImage2D(HX.GL.TEXTURE_2D,0,n,e,i,0,n,a,t),r&&HX.GL.generateMipmap(HX.GL.TEXTURE_2D),this._isReady=!0,HX.GL.bindTexture(HX.GL.TEXTURE_2D,null)},uploadImage:function(t,e,i,r,n,a){this._width=e,this._height=i,n=n||HX.GL.RGBA,a=a||HX.GL.UNSIGNED_BYTE,r=void 0===r?!0:r,this.bind(),t&&HX.GL.pixelStorei(HX.GL.UNPACK_FLIP_Y_WEBGL,1),HX.GL.texImage2D(HX.GL.TEXTURE_2D,0,n,n,a,t),r&&HX.GL.generateMipmap(HX.GL.TEXTURE_2D),this._isReady=!0,HX.GL.bindTexture(HX.GL.TEXTURE_2D,null)},isReady:function(){return this._isReady},bind:function(t){void 0!==t&&HX.GL.activeTexture(HX.GL.TEXTURE0+t),HX.GL.bindTexture(HX.GL.TEXTURE_2D,this._texture),t>HX._numActiveTextures&&(HX._numActiveTextures=t)}},HX.FileTexture2D=function(t,e,i,r){HX.Texture2D.call(this),this.initEmpty(1,1),e=void 0===e?!0:e;var n=new Image,a=this;n.onload=function(){a.uploadImage(n,n.naturalWidth,n.naturalHeight,e),i&&i()},n.onError=function(){console.warn("Failed loading texture '"+t+"'"),r&&r()},n.src=t},HX.FileTexture2D.prototype=Object.create(HX.Texture2D.prototype),HX.TextureCube=function(){this._default=HX.DEFAULT_TEXTURE_CUBE,this._texture=HX.GL.createTexture(),this._size=0,this.bind(),HX.GL.texParameteri(HX.GL.TEXTURE_CUBE_MAP,HX.GL.TEXTURE_MIN_FILTER,HX.TextureFilter.DEFAULT.min),HX.GL.texParameteri(HX.GL.TEXTURE_CUBE_MAP,HX.GL.TEXTURE_MAG_FILTER,HX.TextureFilter.DEFAULT.mag),HX.EXT_TEXTURE_FILTER_ANISOTROPIC&&HX.DEFAULT_TEXTURE_MAX_ANISOTROPY>0&&HX.GL.texParameteri(HX.GL.TEXTURE_CUBE_MAP,HX.EXT_TEXTURE_FILTER_ANISOTROPIC.TEXTURE_MAX_ANISOTROPY_EXT,HX.DEFAULT_TEXTURE_MAX_ANISOTROPY),this._isReady=!1},HX.TextureCube.prototype={constructor:HX.TextureCube,dispose:function(){HX.GL.deleteTexture(this._texture),this._isReady=!1},generateMipmap:function(){this.bind(),HX.GL.generateMipmap(HX.GL.TEXTURE_CUBE_MAP)},setFilter:function(t){this.bind(),HX.GL.texParameteri(HX.GL.TEXTURE_CUBE_MAP,HX.GL.TEXTURE_MIN_FILTER,t.min),HX.GL.texParameteri(HX.GL.TEXTURE_CUBE_MAP,HX.GL.TEXTURE_MAG_FILTER,t.mag)},size:function(){return this._size},initEmpty:function(t,e,i){e=e||HX.GL.RGBA,i=i||HX.GL.UNSIGNED_BYTE,this._size=t,this.bind(),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_X,0,e,t,t,0,e,i,null),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_X,0,e,t,t,0,e,i,null),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_Y,0,e,t,t,0,e,i,null),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,0,e,t,t,0,e,i,null),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_Z,0,e,t,t,0,e,i,null),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_Z,0,e,t,t,0,e,i,null),this._isReady=!0,HX.GL.bindTexture(HX.GL.TEXTURE_2D,null)},uploadData:function(t,e,i,r,n){this._size=e,r=r||HX.GL.RGBA,n=n||HX.GL.UNSIGNED_BYTE,i=void 0===i?!0:i,this.bind(),HX.GL.pixelStorei(HX.GL.UNPACK_FLIP_Y_WEBGL,0),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_X,0,r,e,e,0,r,n,t[0]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_X,0,r,e,e,0,r,n,t[1]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_Y,0,r,e,e,0,r,n,t[2]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,0,r,e,e,0,r,n,t[3]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_Z,0,r,e,e,0,r,n,t[4]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_Z,0,r,e,e,0,r,n,t[5]),i&&HX.GL.generateMipmap(HX.GL.TEXTURE_CUBE_MAP),this._isReady=!0,HX.GL.bindTexture(HX.GL.TEXTURE_CUBE_MAP,null)},uploadImages:function(t,e,i,r){e=void 0===e?!0:e,this.uploadImagesToMipLevel(t,0,i,r),e&&(this.bind(),HX.GL.generateMipmap(HX.GL.TEXTURE_CUBE_MAP)),this._isReady=!0,HX.GL.bindTexture(HX.GL.TEXTURE_CUBE_MAP,null)},uploadImagesToMipLevel:function(t,e,i,r){i=i||HX.GL.RGBA,r=r||HX.GL.UNSIGNED_BYTE,0==e&&(this._size=t[0].naturalWidth),this.bind(),HX.GL.pixelStorei(HX.GL.UNPACK_FLIP_Y_WEBGL,0),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_X,e,i,i,r,t[0]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_X,e,i,i,r,t[1]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_Y,e,i,i,r,t[2]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,e,i,i,r,t[3]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_POSITIVE_Z,e,i,i,r,t[4]),HX.GL.texImage2D(HX.GL.TEXTURE_CUBE_MAP_NEGATIVE_Z,e,i,i,r,t[5]),HX.GL.bindTexture(HX.GL.TEXTURE_CUBE_MAP,null)},isReady:function(){return this._isReady},bind:function(t){void 0!==t&&HX.GL.activeTexture(HX.GL.TEXTURE0+t),HX.GL.bindTexture(HX.GL.TEXTURE_CUBE_MAP,this._texture),t>HX._numActiveTextures&&(HX._numActiveTextures=t)}},HX.FileTextureCube=function(t,e,i,r){HX.TextureCube.call(this),e=void 0===e?!0:e;for(var n=[],a=this,s=0;6>s;++s){var o=new Image;o.nextID=s+1,o.onload=5>s?function(){n[this.nextID].src=t[this.nextID]}:function(){a.uploadImages(n,this.naturalWidth,e),i&&i()},o.onError=function(){console.warn("Failed loading texture '"+url+"'"),r&&r()},n[s]=o}n[0].src=t[0]},HX.FileTextureCube.prototype=Object.create(HX.TextureCube.prototype),HX.MippedTextureCube=function(t,e,i,r,n){HX.TextureCube.call(this);var a=[],s=this,o=6*i,h=[],_="/"===t.charAt(-1)?"":"/";t+=_;for(var l=0;i>l;++l){var c=t+l+"/";h.push(c+"posX."+e),h.push(c+"negX."+e),h.push(c+"posY."+e),h.push(c+"negY."+e),h.push(c+"posZ."+e),h.push(c+"negZ."+e)}for(var l=0;o>l;++l){var u=new Image;u.nextID=l+1,u.onload=o-1>l?function(){a[this.nextID].src=h[this.nextID]}:function(){for(var t=0;i>t;++t)s.uploadImagesToMipLevel(a.slice(6*t,6*t+6),t);s._isReady=!0,r&&r()},u.onError=function(){console.warn("Failed loading texture '"+url+"'"),n&&n()},a[l]=u}a[0].src=h[0]},HX.MippedTextureCube.prototype=Object.create(HX.TextureCube.prototype),HX.CascadeShadowCasterCollector=function(t){HX.SceneVisitor.call(this),this._renderCameras=null,this._bounds=new HX.BoundingAABB,this._numCascades=t,this._cullPlanes=null,this._numCullPlanes=0,this._renderLists=[],this._passType=null},HX.CascadeShadowCasterCollector.prototype=Object.create(HX.SceneVisitor.prototype),HX.CascadeShadowCasterCollector.prototype.getRenderList=function(t){return this._renderLists[t]},HX.CascadeShadowCasterCollector.prototype.collect=function(t,e){this._passType=-1===HX.MaterialPass.SHADOW_MAP_PASS?HX.MaterialPass.GEOMETRY_PASS:HX.MaterialPass.SHADOW_MAP_PASS,this._collectorCamera=t,this._bounds.clear();for(var i=0;i<this._numCascades;++i)this._renderLists[i]=[];e.acceptVisitor(this)},HX.CascadeShadowCasterCollector.prototype.getBounds=function(){return this._bounds},HX.CascadeShadowCasterCollector.prototype.setRenderCameras=function(t){this._renderCameras=t},HX.CascadeShadowCasterCollector.prototype.setCullPlanes=function(t,e){this._cullPlanes=t,this._numCullPlanes=e},HX.CascadeShadowCasterCollector.prototype.visitModelInstance=function(t,e,i){if(0!=t._castShadows){this._bounds.growToIncludeBound(i);for(var r=this._passType,n=this._numCascades,a=t.numMeshInstances(),s=n-1,o=s;o>=0;--o){var h=this._renderLists[o],_=this._renderCameras[o];if(o==s||i.intersectsConvexSolid(this._cullPlanes,this._numCullPlanes))for(var l=0;a>l;++l){var c=t.getMeshInstance(l),u=c.material;if(u.hasPass(r)){var m=new HX.RenderItem;m.pass=u.getPass(r),m.meshInstance=c,m.worldMatrix=e,m.camera=_,m.material=u,m.uniformSetters=c._uniformSetters[r],h.push(m)}}else o=0}}},HX.CascadeShadowCasterCollector.prototype.qualifies=function(t){return t.getWorldBounds().intersectsConvexSolid(this._cullPlanes,this._numCullPlanes)},HX.CascadeShadowMapRenderer=function(t,e,i){HX.Renderer.call(this),this._light=t,this._numCascades=e||3,this._numCascades>4&&(this._numCascades=4),this._shadowMapSize=i||1024,this._shadowMapInvalid=!0,this._fbo=null,this._depthBuffer=null,this._shadowMap=new HX.Texture2D,this._shadowMap.setFilter(HX.TextureFilter.NEAREST_NOMIP),this._shadowMap.setWrapMode(HX.TextureWrapMode.CLAMP),this._shadowMatrices=[new HX.Matrix4x4,new HX.Matrix4x4,new HX.Matrix4x4,new HX.Matrix4x4],this._transformToUV=[new HX.Matrix4x4,new HX.Matrix4x4,new HX.Matrix4x4,new HX.Matrix4x4],this._inverseLightMatrix=new HX.Matrix4x4,this._splitRatios=null,this._splitDistances=null,this._shadowMapCameras=null,this._collectorCamera=new HX.OrthographicOffCenterCamera,this._minZ=0,this._numCullPlanes=0,this._cullPlanes=[],this._localBounds=new HX.BoundingAABB,this._casterCollector=new HX.CascadeShadowCasterCollector(this._numCascades),this._initSplitRatios(),this._initCameras(),this._viewports=[]},HX.CascadeShadowMapRenderer.prototype=Object.create(HX.Renderer.prototype),HX.CascadeShadowMapRenderer.prototype.setNumCascades=function(t){this._numCascades!=t&&(this._numCascades=t,this._invalidateShadowMap(),this._initSplitRatios(),this._initCameras(),this._casterCollector=new HX.CascadeShadowCasterCollector(t))},HX.CascadeShadowMapRenderer.prototype.setShadowMapSize=function(t){this._setShadowMapSize!=t&&(this._setShadowMapSize=t,this._invalidateShadowMap())},HX.CascadeShadowMapRenderer.prototype.render=function(t,e){this._shadowMapInvalid&&this._initShadowMap(),this._inverseLightMatrix.inverseAffineOf(this._light.getWorldMatrix()),this._updateCollectorCamera(t),this._updateSplitDistances(t),this._updateCullPlanes(t),this._collectShadowCasters(e),this._updateCascadeCameras(t,this._casterCollector.getBounds()),HX.setRenderTarget(this._fbo);var i;-1===HX.MaterialPass.SHADOW_MAP_PASS?(HX.GL.clear(HX.GL.DEPTH_BUFFER_BIT),i=HX.MaterialPass.GEOMETRY_COLOR_PASS):(HX.GL.clearColor(1,1,1,1),HX.clear(),i=HX.MaterialPass.SHADOW_MAP_PASS);for(var r=0;r<this._numCascades;++r){var n=this._viewports[r];HX.GL.viewport(n.x,n.y,n.width,n.height),this._renderPass(i,this._casterCollector.getRenderList(r))}},HX.CascadeShadowMapRenderer.prototype._updateCollectorCamera=function(t){var e=t.getFrustum()._corners,i=new HX.Float4,r=new HX.Float4,n=new HX.Float4;this._inverseLightMatrix.transformPointTo(e[0],i),r.copyFrom(i);for(var a=1;8>a;++a)this._inverseLightMatrix.transformPointTo(e[a],n),i.minimize(n),r.maximize(n);this._minZ=i.z,this._collectorCamera.getTransformationMatrix().copyFrom(this._light.getWorldMatrix()),this._collectorCamera._invalidateWorldTransformationMatrix(),this._collectorCamera.setBounds(i.x,r.x+1,r.y+1,i.y),this._collectorCamera._setRenderTargetResolution(this._shadowMap._width,this._shadowMap._height)},HX.CascadeShadowMapRenderer.prototype._updateSplitDistances=function(t){for(var e=t.getNearDistance(),i=t.getFarDistance()-e,r=0;r<this._numCascades;++r)this._splitDistances[r]=e+this._splitRatios[r]*i},HX.CascadeShadowMapRenderer.prototype._updateCascadeCameras=function(t,e){this._localBounds.transformFrom(e,this._inverseLightMatrix);for(var i=this._localBounds.getMinimum(),r=this._localBounds.getMaximum(),n=1,a=new HX.Float4,s=new HX.Float4,o=new HX.Float4,h=new HX.Float4,_=t.getFrustum().getCorners(),l=0;l<this._numCascades;++l){var c=this._splitRatios[l],u=this._shadowMapCameras[l];u.setNearDistance(-r.z),u.getTransformationMatrix().copyFrom(this._light.getWorldMatrix()),u._invalidateWorldTransformationMatrix();for(var m=0;4>m;++m){var f=_[m],d=_[m+4];s.x=f.x+(d.x-f.x)*c,s.y=f.y+(d.y-f.y)*c,s.z=f.z+(d.z-f.z)*c,this._inverseLightMatrix.transformPointTo(f,a),this._inverseLightMatrix.transformPointTo(s,s),0==m?(o.copyFrom(a),h.copyFrom(a)):(o.minimize(a),h.maximize(a)),o.minimize(s),h.maximize(s)}o.z=Math.max(this._minZ,o.z);var p=Math.max(o.x,i.x),X=Math.min(h.x,r.x),H=Math.max(o.y,i.y),g=Math.min(h.y,r.y),x=X-p,S=g-H;x=Math.ceil(x/n)*n,S=Math.ceil(S/n)*n,x=Math.max(x,n),S=Math.max(S,n);var v=this._shadowMap._width/x*.5,E=this._shadowMap._height/S*.5;p=Math.floor(p*v)/v,H=Math.floor(H*E)/E,X=p+x,g=H+S;var L=0;u.setBounds(p-L,X+L,g+L,H-L),u.setFarDistance(-o.z),u._setRenderTargetResolution(this._shadowMap._width,this._shadowMap._height),this._shadowMatrices[l].product(this._transformToUV[l],u.getViewProjectionMatrix())}},HX.CascadeShadowMapRenderer.prototype._updateCullPlanes=function(t){for(var e=this._collectorCamera.getFrustum(),i=e._planes,r=0;4>r;++r)this._cullPlanes[r]=i[r];this._numCullPlanes=4,e=t.getFrustum(),i=e._planes;for(var n=this._light.direction,a=0;6>a;++a){var s=i[a];HX.dot3(s,n)<-.001&&(this._cullPlanes[this._numCullPlanes++]=s)}},HX.CascadeShadowMapRenderer.prototype._collectShadowCasters=function(t){this._casterCollector.setCullPlanes(this._cullPlanes,this._numCullPlanes),this._casterCollector.setRenderCameras(this._shadowMapCameras),this._casterCollector.collect(this._collectorCamera,t)},HX.CascadeShadowMapRenderer.prototype.getSplitDistances=function(){return this._splitDistances},HX.CascadeShadowMapRenderer.prototype.getShadowMatrix=function(t){return this._shadowMatrices[t]},HX.CascadeShadowMapRenderer.prototype.dispose=function(){HX.Renderer.call.dispose(this),this._depthBuffer&&(this._depthBuffer.dispose(),this._depthBuffer=null),this._shadowMap.dispose(),this._shadowMap=null},HX.CascadeShadowMapRenderer.prototype._invalidateShadowMap=function(){this._shadowMapInvalid=!0},HX.CascadeShadowMapRenderer.prototype._initShadowMap=function(){var t=this._numCascades>1?2:1,e=Math.ceil(this._numCascades/2),i=this._shadowMapSize*t,r=this._shadowMapSize*e;HX.EXT_DEPTH_TEXTURE?(this._shadowMap.initEmpty(i,r,HX.GL.DEPTH_STENCIL,HX.EXT_DEPTH_TEXTURE.UNSIGNED_INT_24_8_WEBGL),this._fbo||(this._fbo=new HX.FrameBuffer(null,this._shadowMap))):(this._shadowMap.initEmpty(i,r,HX.GL.RGBA,HX.GL.UNSIGNED_BYTE),this._depthBuffer||(this._depthBuffer=new HX.ReadOnlyDepthBuffer),this._fbo||(this._fbo=new HX.FrameBuffer(this._shadowMap,this._depthBuffer)),this._depthBuffer.init(i,r)),this._fbo.init(),this._shadowMapInvalid=!1,this._viewports=[],this._viewports.push({x:0,y:0,width:this._shadowMapSize,height:this._shadowMapSize}),this._viewports.push({x:this._shadowMapSize,y:0,width:this._shadowMapSize,height:this._shadowMapSize}),this._viewports.push({x:0,y:this._shadowMapSize,width:this._shadowMapSize,height:this._shadowMapSize}),this._viewports.push({x:this._shadowMapSize,y:this._shadowMapSize,width:this._shadowMapSize,height:this._shadowMapSize}),this._initViewportMatrices(1/t,1/e)},HX.CascadeShadowMapRenderer.prototype._initSplitRatios=function(){var t=1;this._splitRatios=[],this._splitDistances=[0,0,0,0];for(var e=this._numCascades-1;e>=0;--e)this._splitRatios[e]=t,this._splitDistances[e]=0,t*=.4},HX.CascadeShadowMapRenderer.prototype._initCameras=function(){this._shadowMapCameras=[];for(var t=this._numCascades-1;t>=0;--t)this._shadowMapCameras[t]=new HX.OrthographicOffCenterCamera},HX.CascadeShadowMapRenderer.prototype._initViewportMatrices=function(t,e){for(var i=0;4>i;++i)this._transformToUV[i].scaleMatrix(.5,.5,.5),this._transformToUV[i].appendTranslation(.5,.5,.5),this._transformToUV[i].appendScale(t,e,1);this._transformToUV[1].appendTranslation(.5,0,0),this._transformToUV[2].appendTranslation(0,.5,0),this._transformToUV[3].appendTranslation(.5,.5,0)},HX.BlinnPhongSimpleLightingModel={getGLSL:function(){return HX.ShaderLibrary.get("lighting_blinn_phong_simple.glsl")+"\n\n"}},HX.BlinnPhongFullLightingModel={getGLSL:function(){return HX.ShaderLibrary.get("lighting_blinn_phong_full.glsl")+"\n\n"}},HX.GGXLightingModel={getGLSL:function(){return HX.ShaderLibrary.get("lighting_ggx.glsl")+"\n\n"}},HX.RenderCollector=function(){HX.SceneVisitor.call(this),this._opaquePasses=new Array(HX.MaterialPass.NUM_PASS_TYPES),this._transparentPasses=new Array(HX.MaterialPass.NUM_PASS_TYPES),this._camera=null,this._cameraZAxis=new HX.Float4,this._frustum=null,this._lights=null,this._shadowCasters=null,this._effects=null,this._globalSpecularProbe=null,this._globalIrradianceProbe=null},HX.RenderCollector.prototype=Object.create(HX.SceneVisitor.prototype),HX.RenderCollector.prototype.getOpaqueRenderList=function(t){return this._opaquePasses[t]},HX.RenderCollector.prototype.getTransparentRenderList=function(t){return this._transparentPasses[t]},HX.RenderCollector.prototype.getLights=function(){return this._lights},HX.RenderCollector.prototype.getShadowCasters=function(){return this._shadowCasters},HX.RenderCollector.prototype.getEffects=function(){return this._effects},HX.RenderCollector.prototype.getGlobalSpecularProbe=function(){return this._globalSpecularProbe},HX.RenderCollector.prototype.getGlobalIrradianceProbe=function(){return this._globalIrradianceProbe},HX.RenderCollector.prototype.collect=function(t,e){this._camera=t,t.getWorldMatrix().getColumn(2,this._cameraZAxis),this._frustum=t.getFrustum(),this._nearPlane=this._frustum._planes[HX.Frustum.PLANE_NEAR],this._reset(),e.acceptVisitor(this),this._opaquePasses[HX.MaterialPass.GEOMETRY_PASS].sort(this._sortOpaques),this._opaquePasses[HX.MaterialPass.POST_PASS].sort(this._sortOpaques),this._transparentPasses[HX.MaterialPass.GEOMETRY_PASS].sort(this._sortTransparents),this._transparentPasses[HX.MaterialPass.POST_PASS].sort(this._sortTransparents),HX.EXT_DRAW_BUFFERS||(this._copyLegacyPasses(this._opaquePasses),this._copyLegacyPasses(this._transparentPasses)),this._lights.sort(this._sortLights)},HX.RenderCollector.prototype.qualifies=function(t){return t.getWorldBounds().intersectsConvexSolid(this._frustum._planes,6)},HX.RenderCollector.prototype.visitScene=function(t){var e=t._skybox;e&&(this.visitModelInstance(e._modelInstance,t._rootNode.getWorldMatrix(),t._rootNode.getWorldBounds()),this._globalSpecularProbe=e.getGlobalSpecularProbe(),this._globalIrradianceProbe=e.getGlobalIrradianceProbe())},HX.RenderCollector.prototype.visitEffects=function(t,e){if(e!=this._camera)for(var i=t.length,r=0;i>r;++r)this._effects.push(t[r])},HX.RenderCollector.prototype.visitModelInstance=function(t,e,i){for(var r=t.numMeshInstances(),n=0;r>n;++n)for(var a=t.getMeshInstance(n),s=a.material,o=0;o<HX.MaterialPass.NUM_PASS_TYPES;++o){var h=s.getPass(o);if(h&&h._enabled){var _=s._transparencyMode===HX.TransparencyMode.OPAQUE?this._opaquePasses:this._transparentPasses,l=new HX.RenderItem;l.material=s,l.pass=h,l.meshInstance=a,l.renderOrderHint=i._centerX*this._cameraZAxis.x+i._centerY*this._cameraZAxis.y+i._centerZ*this._cameraZAxis.z,l.worldMatrix=e,l.camera=this._camera,l.uniformSetters=a._uniformSetters[o],_[o].push(l)}}},HX.RenderCollector.prototype.visitLight=function(t){this._lights.push(t),t._castShadows&&this._shadowCasters.push(t._shadowMapRenderer);var e=t.getWorldBounds(),i=this._nearPlane;t._renderOrderHint=e._centerX*i.x+e._centerY*i.y+e._centerZ*i.z+i.w-e.getRadius()},HX.RenderCollector.prototype._reset=function(){for(var t=0;t<HX.MaterialPass.NUM_PASS_TYPES;++t)this._opaquePasses[t]=[];for(var t=0;t<HX.MaterialPass.NUM_PASS_TYPES;++t)this._transparentPasses[t]=[];this._lights=[],this._shadowCasters=[],this._effects=[],this._globalIrradianceProbe=null,this._globalSpecularProbe=null},HX.RenderCollector.prototype._sortTransparents=function(t,e){return e.renderOrderHint-t.renderOrderHint},HX.RenderCollector.prototype._sortOpaques=function(t,e){var i;return i=t.material._renderOrder-e.material._renderOrder,0!==i?i:(i=t.pass._shader._renderOrderHint-e.pass._shader._renderOrderHint,0!==i?i:(i=t.material._renderOrderHint-e.material._renderOrderHint,0!==i?i:t.renderOrderHint-e.renderOrderHint))},HX.RenderCollector.prototype._sortLights=function(t,e){return t._type==e._type?t._castShadows==e._castShadows?t._renderOrderHint-e._renderOrderHint:t._castShadows?1:-1:t._type-e._type},HX.RenderCollector.prototype._copyLegacyPasses=function(t){for(var e=t[HX.MaterialPass.GEOMETRY_COLOR_PASS],i=t[HX.MaterialPass.GEOMETRY_NORMAL_PASS],r=t[HX.MaterialPass.GEOMETRY_SPECULAR_PASS],n=e.length,a=0,s=0,o=0;n>o;++o){var h=e[o],_=h.meshInstance,l=h.material;if(l.hasPass(HX.MaterialPass.GEOMETRY_NORMAL_PASS)){var c=new HX.RenderItem;c.pass=l.getPass(HX.MaterialPass.GEOMETRY_NORMAL_PASS),c.uniformSetters=_._uniformSetters[HX.MaterialPass.GEOMETRY_NORMAL_PASS],c.material=h.material,c.renderOrderHint=h.renderOrderHint,c.meshInstance=h.meshInstance,c.worldMatrix=h.worldMatrix,c.camera=this._camera,i[a++]=c}if(l.hasPass(HX.MaterialPass.GEOMETRY_SPECULAR_PASS)){var u=new HX.RenderItem;u.pass=l.getPass(HX.MaterialPass.GEOMETRY_SPECULAR_PASS),u.uniformSetters=_._uniformSetters[HX.MaterialPass.GEOMETRY_SPECULAR_PASS],u.material=h.material,u.renderOrderHint=h.renderOrderHint,u.meshInstance=h.meshInstance,u.worldMatrix=h.worldMatrix,u.camera=this._camera,r[s++]=u}}},HX.CustomCopyShader=function(t){HX.Shader.call(this),this.init(HX.ShaderLibrary.get("copy_vertex.glsl"),t),this._textureLocation=HX.GL.getUniformLocation(this._program,"sampler"),this._positionAttributeLocation=HX.GL.getAttribLocation(this._program,"hx_position"),this._texCoordAttributeLocation=HX.GL.getAttribLocation(this._program,"hx_texCoord"),HX.GL.useProgram(this._program),HX.GL.uniform1i(this._textureLocation,0)},HX.CustomCopyShader.prototype=Object.create(HX.Shader.prototype),HX.CustomCopyShader.prototype.execute=function(t,e){HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.disable(HX.GL.CULL_FACE),t._vertexBuffer.bind(),t._indexBuffer.bind(),this.updateRenderState(),e.bind(0),HX.GL.vertexAttribPointer(this._positionAttributeLocation,2,HX.GL.FLOAT,!1,16,0),HX.GL.vertexAttribPointer(this._texCoordAttributeLocation,2,HX.GL.FLOAT,!1,16,8),HX.enableAttributes(2),HX.GL.drawElements(HX.GL.TRIANGLES,6,HX.GL.UNSIGNED_SHORT,0)},HX.CopyChannelsShader=function(t){t=t||"xyzw";var e="#define extractChannels(src) ((src)."+t+")\n";HX.CustomCopyShader.call(this,e+HX.ShaderLibrary.get("copy_fragment.glsl"))},HX.CopyChannelsShader.prototype=Object.create(HX.CustomCopyShader.prototype),HX.DebugDepthShader=function(){HX.CustomCopyShader.call(this,HX.ShaderLibrary.get("debug_depth_fragment.glsl"))},HX.DebugDepthShader.prototype=Object.create(HX.CustomCopyShader.prototype),HX.ApplyGammaShader=function(){HX.CustomCopyShader.call(this,HX.ShaderLibrary.get("copy_to_gamma_fragment.glsl"))},HX.ApplyGammaShader.prototype=Object.create(HX.CustomCopyShader.prototype),HX.DebugNormalsShader=function(){HX.CustomCopyShader.call(this,HX.ShaderLibrary.get("debug_normals_fragment.glsl"))},HX.DebugNormalsShader.prototype=Object.create(HX.CustomCopyShader.prototype),HX.LinearizeDepthShader=function(){HX.Shader.call(this),this.init(HX.ShaderLibrary.get("linearize_depth_vertex.glsl"),HX.ShaderLibrary.get("linearize_depth_fragment.glsl")),this._textureLocation=HX.GL.getUniformLocation(this._program,"sampler"),this._rcpFrustumRangeLocation=HX.GL.getUniformLocation(this._program,"hx_rcpCameraFrustumRange"),this._projectionLocation=HX.GL.getUniformLocation(this._program,"hx_projectionMatrix"),this._positionAttributeLocation=HX.GL.getAttribLocation(this._program,"hx_position"),this._texCoordAttributeLocation=HX.GL.getAttribLocation(this._program,"hx_texCoord"),HX.GL.useProgram(this._program),HX.GL.uniform1i(this._textureLocation,0)},HX.LinearizeDepthShader.prototype=Object.create(HX.Shader.prototype),HX.LinearizeDepthShader.prototype.execute=function(t,e,i){HX.GL.disable(HX.GL.DEPTH_TEST),HX.GL.disable(HX.GL.CULL_FACE),t._vertexBuffer.bind(),t._indexBuffer.bind(),this.updateRenderState(),e.bind(0),HX.GL.vertexAttribPointer(this._positionAttributeLocation,2,HX.GL.FLOAT,!1,16,0),HX.GL.vertexAttribPointer(this._texCoordAttributeLocation,2,HX.GL.FLOAT,!1,16,8),HX.GL.uniform1f(this._rcpFrustumRangeLocation,1/(i.getNearDistance()-i.getFarDistance())),HX.GL.uniformMatrix4fv(this._projectionLocation,!1,i.getProjectionMatrix()._m),HX.enableAttributes(2),HX.GL.drawElements(HX.GL.TRIANGLES,6,HX.GL.UNSIGNED_SHORT,0)},HX.BloomThresholdPass=function(){HX.EffectPass.call(this,null,HX.ShaderLibrary.get("bloom_threshold_fragment.glsl")),this.setThresholdLuminance(1)},HX.BloomThresholdPass.prototype=Object.create(HX.EffectPass.prototype),HX.BloomThresholdPass.prototype.setThresholdLuminance=function(t){this._thresholdLuminance=t,this.setUniform("threshold",t)},HX.BloomThresholdPass.prototype.getThresholdLuminance=function(){return this._thresholdLuminance},HX.BloomBlurPass=function(t,e,i,r,n,a){this._initWeights(t,e);var s={SOURCE_RES:"vec2(float("+n+"), float("+a+"))",RADIUS:"float("+Math.ceil(.5*this._kernelSize)+")",DIRECTION:"vec2("+i+", "+r+")",NUM_SAMPLES:this._kernelSize},o=HX.ShaderLibrary.get("bloom_blur_vertex.glsl",s),h=HX.ShaderLibrary.get("bloom_blur_fragment.glsl",s);HX.EffectPass.call(this,o,h),this.setUniformArray("gaussianWeights",new Float32Array(this._weights))},HX.BloomBlurPass.prototype=Object.create(HX.EffectPass.prototype),HX.BloomBlurPass.prototype._initWeights=function(t,e){this._kernelSize=0,this._weights=[];for(var i=[],r=0;r<t.length;++r){var n=Math.ceil(.5*t[r]),a=Math.ceil(t[r]);a>this._kernelSize&&(this._kernelSize=a),i[r]=HX.CenteredGaussianCurve.fromRadius(n)}for(var n=Math.ceil(.5*this._kernelSize),s=0;s<this._kernelSize;++s){this._weights[s]=0;for(var r=0;r<t.length;++r)this._weights[s]+=i[r].getValueAt(s-n)*e[r]}},HX.BloomCompositePass=function(){HX.EffectPass.call(this,HX.ShaderLibrary.get("bloom_composite_vertex.glsl"),HX.ShaderLibrary.get("bloom_composite_fragment.glsl"))},HX.BloomCompositePass.prototype=Object.create(HX.EffectPass.prototype),HX.BloomEffect=function(t,e){HX.Effect.call(this),this._downScale=4,this._targetWidth=-1,this._targetHeight=-1,this._thresholdPass=new HX.BloomThresholdPass,this._compositePass=new HX.BloomCompositePass,this.addPass(this._thresholdPass),this.addPass(null),this.addPass(null),this.addPass(this._compositePass),this._thresholdMaps=[],this._thresholdFBOs=[];for(var i=0;2>i;++i)this._thresholdMaps[i]=new HX.Texture2D,this._thresholdMaps[i].setFilter(HX.TextureFilter.BILINEAR_NOMIP),this._thresholdMaps[i].setWrapMode(HX.TextureWrapMode.CLAMP),this._thresholdFBOs[i]=new HX.FrameBuffer([this._thresholdMaps[i]]);this._blurSizes=t||[512,256],HX.EXT_HALF_FLOAT_TEXTURES_LINEAR&&HX.EXT_HALF_FLOAT_TEXTURES?this._weights=e||[.05,.05]:(this._weights=e||[1.5,5],this.setThresholdLuminance(.9)),this._compositePass.setTexture("bloomTexture",this._thresholdMaps[0])},HX.BloomEffect.prototype=Object.create(HX.Effect.prototype),HX.BloomEffect.prototype.setThresholdLuminance=function(t){this._thresholdLuminance=t,this.setUniform("threshold",t)},HX.BloomEffect.prototype._initTextures=function(){for(var t=0;2>t;++t)this._thresholdMaps[t].initEmpty(Math.ceil(this._targetWidth/this._downScale),Math.ceil(this._targetHeight/this._downScale),HX.GL.RGB,HX.HDR_FORMAT),this._thresholdFBOs[t].init()},HX.BloomEffect.prototype._initBlurPass=function(){for(var t=[],e=[],i=this._blurSizes.length,r=0;i>r;++r)t[r]=this._blurSizes[r]/this._downScale,e[r]=this._blurSizes[r]/this._downScale;var n=this._targetWidth/this._downScale,a=this._targetHeight/this._downScale;this._opaquePasses[1]=new HX.BloomBlurPass(t,this._weights,1,0,n,a),this._opaquePasses[2]=new HX.BloomBlurPass(e,this._weights,0,1,n,a),this._opaquePasses[1].setTexture("sourceTexture",this._thresholdMaps[0]),this._opaquePasses[2].setTexture("sourceTexture",this._thresholdMaps[1]);var s=this._mesh;s&&(this._mesh=null,this.setMesh(s))},HX.BloomEffect.prototype.draw=function(t){(this._hdrTarget._width!=this._targetWidth||this._hdrTarget._height!=this._targetHeight)&&(this._targetWidth=this._hdrTarget._width,this._targetHeight=this._hdrTarget._height,this._initTextures(),this._initBlurPass());var e=0;HX.GL.viewport(0,0,this._thresholdMaps[0]._width,this._thresholdMaps[0]._height);

for(var i=0;3>i;++i)HX.setRenderTarget(this._thresholdFBOs[e]),this._drawPass(this._opaquePasses[i]),e=1-e;HX.setRenderTarget(this._hdrTarget),HX.GL.viewport(0,0,this._targetWidth,this._targetHeight),this._drawPass(this._compositePass),this._swapHDRBuffers()},HX.BloomEffect.prototype.dispose=function(){for(var t=0;2>t;++t)this._thresholdFBOs[t].dispose(),this._thresholdMaps[t].dispose();this._thresholdFBOs=null,this._thresholdMaps=null},HX.BloomEffect.prototype.getThresholdLuminance=function(){return this.getPass(0).getThresholdLuminance()},HX.BloomEffect.prototype.setThresholdLuminance=function(t){return this.getPass(0).setThresholdLuminance(t)},HX.SeparableGaussianBlurPass=function(t,e,i,r,n,a){n&&(a=a||n),r=r||"hx_source",t=Math.round(t);var s=HX.SeparableGaussianBlurPass.getVertexShader(t,e,i,n,a),o=HX.SeparableGaussianBlurPass.getFragmentShader(t,e,i,r,n,a);HX.EffectPass.call(this,s,o),this._initWeights(t)},HX.SeparableGaussianBlurPass.prototype=Object.create(HX.EffectPass.prototype),HX.SeparableGaussianBlurPass.prototype._initWeights=function(t){for(var e=Math.floor(.5*t),i=[],r=HX.CenteredGaussianCurve.fromRadius(e),n=0;t>n;++n)i[n]=r.getValueAt(n-e);this.setUniformArray("gaussianWeights",new Float32Array(i))},HX.GaussianBlurEffect=function(t,e){HX.Effect.call(this),this.addPass(new HX.SeparableGaussianBlurPass(t,1,0)),this.addPass(new HX.SeparableGaussianBlurPass(e,0,1))},HX.GaussianBlurEffect.prototype=Object.create(HX.Effect.prototype),HX.DirectionalBlurPass=function(t,e,i,r,n,a){t=Math.round(t),n&&(a=a||n),r=r||"hx_source",HX.EffectPass.call(this,HX.DirectionalBlurPass.getVertexShader(t,e,i),HX.DirectionalBlurPass.getFragmentShader(t,e,i,r,n,a))},HX.DirectionalBlurPass.prototype=Object.create(HX.EffectPass.prototype),HX.DirectionalBlurEffect=function(t,e,i){HX.Effect.call(this),this.addPass(new HX.DirectionalBlurPass(t,e,i))},HX.DirectionalBlurEffect.prototype=Object.create(HX.Effect.prototype),HX.BoxBlurEffect=function(t,e){HX.Effect.call(this),this.addPass(new HX.DirectionalBlurPass(t,1,0)),this.addPass(new HX.DirectionalBlurPass(e,0,1))},HX.BoxBlurEffect.prototype=Object.create(HX.Effect.prototype),HX.DirectionalBlurPass.getVertexShader=function(t,e,i,r,n){var a;return a=r?"vec2(float("+r+"), float("+n+"))":"hx_renderTargetResolution","#define SOURCE_RES "+a+"\n\r\n            #define NUM_SAMPLES "+Math.ceil(t/2)+"\n\r\n            #define DIRECTION vec2("+e+", "+i+")\n\r\n    \n\r\n    attribute vec4 hx_position;\n\r\n    attribute vec2 hx_texCoord;\n\r\n    \n\r\n    uniform vec2 hx_renderTargetResolution;\n\r\n    \n\r\n    varying vec2 uv;\n\r\n    \n\r\n    void main()\n\r\n    {\n\r\n            vec2 firstPixel = floor(hx_texCoord * SOURCE_RES - DIRECTION * float(NUM_SAMPLES));\r\n            uv = (firstPixel - .5) / SOURCE_RES;\n\r\n            gl_Position = hx_position;\n\r\n    }"},HX.DirectionalBlurPass.getFragmentShader=function(t,e,i,r,n,a){var s;return s=n?"vec2(float("+n+"), float("+a+"))":"hx_renderTargetResolution","#define SOURCE_RES "+s+"\n\r\n            #define NUM_SAMPLES "+Math.ceil(t/2)+"\n\r\n            #define DIRECTION vec2("+2*e+", "+2*i+")\n\r\n            \n\r\n            varying vec2 uv;\n\r\n            \n"+(n?"":"uniform vec2 hx_renderTargetResolution;\n")+"\n\r\n            uniform sampler2D "+r+";\n\r\n            \n\r\n            void main()\n\r\n            {\n\r\n                vec4 total = vec4(0.0);\n\r\n                vec2 sampleUV = uv;\n\r\n                vec2 stepSize = DIRECTION / SOURCE_RES;\n\r\n                for (int i = 0; i < NUM_SAMPLES; ++i) {\n\r\n                    total += texture2D("+r+", sampleUV);\n\r\n                    sampleUV += stepSize;\n\r\n                }\n\r\n                gl_FragColor = total / float(NUM_SAMPLES);\n\r\n            \n\r\n            }"},HX.SeparableGaussianBlurPass.getVertexShader=function(t,e,i,r,n){var a;return a=r?"vec2(float("+r+"), float("+n+"))":"hx_renderTargetResolution","#define SOURCE_RES "+a+"\n\r\n             #define RADIUS float("+Math.ceil(.5*t)+")\n\r\n             #define DIRECTION vec2("+e+", "+i+")\n\r\n    precision mediump float;\n\r\n    \n\r\n    attribute vec4 hx_position;\n\r\n    attribute vec2 hx_texCoord;\n\r\n    \n\r\n    varying vec2 uv;\n\r\n    \n"+(r?"":"uniform vec2 hx_renderTargetResolution;\n")+"\n\r\n    void main()\n\r\n    {\n\r\n            uv = hx_texCoord - RADIUS * DIRECTION / SOURCE_RES;\n\r\n            gl_Position = hx_position;\n\r\n    }"},HX.SeparableGaussianBlurPass.getFragmentShader=function(t,e,i,r,n,a){var s;return s=n?"vec2(float("+n+"), float("+a+"))":"hx_renderTargetResolution","#define SOURCE_RES "+s+"\n\r\n            #define NUM_SAMPLES "+t+"\n\r\n            #define DIRECTION vec2("+e+", "+i+")\n\r\n            \n\r\n            varying vec2 uv;\n\r\n            \n"+(n?"":"uniform vec2 hx_renderTargetResolution;\n")+"\n\r\n            uniform sampler2D "+r+";\n\r\n            \n\r\n            uniform float gaussianWeights[NUM_SAMPLES];\n\r\n            \n\r\n            void main()\n\r\n            {\n\r\n                vec4 total = vec4(0.0);\n\r\n                vec2 sampleUV = uv;\n\r\n                vec2 stepSize = DIRECTION / SOURCE_RES;\n\r\n                float totalWeight = 0.0;\n\r\n                for (int i = 0; i < NUM_SAMPLES; ++i) {\n\r\n                    total += texture2D("+r+", sampleUV) * gaussianWeights[i];\n\r\n                    sampleUV += stepSize;\n\r\n                }\n\r\n                gl_FragColor = total;\n\r\n            \n\r\n            }"},HX.CopyTexturePass=function(){HX.EffectPass.call(this,null,HX.ShaderLib.get("copy_fragment.glsl"))},HX.CopyTexturePass.prototype=Object.create(HX.EffectPass.prototype),HX.CopyTexturePass.prototype.setSourceTexture=function(t){this.setTexture("sampler",t)},HX.FogEffect=function(t,e,i,r){HX.Effect.call(this),this.addPass(new HX.EffectPass(HX.ShaderLibrary.get("fog_vertex.glsl"),HX.ShaderLibrary.get("fog_fragment.glsl"))),this.density=void 0===t?.001:t,this.tint=void 0===e?new HX.Color(1,1,1,1):e,this.startDistance=void 0===i?0:i,this.height=void 0===r?1e3:r},HX.FogEffect.prototype=Object.create(HX.Effect.prototype),Object.defineProperty(HX.FogEffect.prototype,"density",{get:function(){return this._density},set:function(t){this._density=t,this.setUniform("density",t)}}),Object.defineProperty(HX.FogEffect.prototype,"tint",{get:function(){return this._tint},set:function(t){this._tint=t,this.setUniform("tint",{x:t.r,y:t.g,z:t.b})}}),Object.defineProperty(HX.FogEffect.prototype,"startDistance",{get:function(){return this._startDistance},set:function(t){this._startDistance=t,this.setUniform("startDistance",t)}}),HX.FXAA=function(){HX.Effect.call(this),this.addPass(new HX.EffectPass(null,HX.ShaderLibrary.get("fxaa_fragment.glsl"))),this.setUniform("edgeThreshold",1/8),this.setUniform("edgeThresholdMin",1/16),this.setUniform("edgeSharpness",4)},HX.FXAA.prototype=Object.create(HX.Effect.prototype),HX.HBAO=function(t,e){t=t||4,e=e||4,t>32&&(t=32),e>32&&(e=32),this._numRays=t,this._strength=1,this._bias=.01,this._fallOffDistance=1,this._radius=.5,this._sampleDirTexture=null,this._ditherTexture=null,HX.Effect.call(this),this.addPass(this._aoPass=new HX.EffectPass(HX.ShaderLibrary.get("hbao_vertex.glsl"),HX.ShaderLibrary.get("hbao_fragment.glsl",{NUM_RAYS:t,NUM_SAMPLES_PER_RAY:e}))),this.addPass(this._blurPassX=new HX.DirectionalBlurPass(4,1,0)),this.addPass(this._blurPassY=new HX.DirectionalBlurPass(4,0,1)),this._initSampleDirTexture(),this._initDitherTexture(),this._aoPass.setUniform("strengthPerRay",this._strength/this._numRays),this._aoPass.setUniform("rcpFallOffDistance",1/this._fallOffDistance),this._aoPass.setUniform("halfSampleRadius",.5*this._radius),this._aoPass.setUniform("bias",this._bias),this._aoPass.setTexture("ditherTexture",this._ditherTexture),this._aoPass.setTexture("sampleDirTexture",this._sampleDirTexture),this._aoTexture=new HX.Texture2D,this._aoTexture.setFilter(HX.TextureFilter.BILINEAR_NOMIP),this._aoTexture.setWrapMode(HX.TextureWrapMode.CLAMP),this._fbo=new HX.FrameBuffer(this._aoTexture)},HX.HBAO.prototype=Object.create(HX.Effect.prototype),HX.HBAO.prototype.getAOTexture=function(){return this._aoTexture},Object.defineProperty(HX.HBAO.prototype,"sampleRadius",{get:function(){return this._radius},set:function(t){this._radius=t,this._aoPass.setUniform("halfSampleRadius",.5*this._radius)}}),Object.defineProperty(HX.HBAO.prototype,"fallOffDistance",{get:function(){this._fallOffDistance=value},set:function(t){this._fallOffDistance=t,this._aoPass.setUniform("rcpFallOffDistance",1/this._fallOffDistance)}}),Object.defineProperty(HX.HBAO.prototype,"strength",{get:function(){return this._strength},set:function(t){this._strength=t,this._aoPass.setUniform("strengthPerRay",this._strength/this._numRays)}}),Object.defineProperty(HX.HBAO.prototype,"bias",{get:function(){return this._bias},set:function(t){this._bias=t,this._aoPass.setUniform("bias",this._bias)}}),HX.HBAO.prototype._initTargetTexture=function(t,e){this._aoTexture.initEmpty(t,e),this._fbo.init()},HX.HBAO.prototype.draw=function(t){var e=this._hdrTarget.width(),i=this._hdrTarget.height();(e!=this._aoTexture.width()||i!=this._aoTexture.height())&&this._initTargetTexture(e,i),HX.setRenderTarget(this._hdrTarget),this._drawPass(this._aoPass),this._swapHDRBuffers(),HX.setRenderTarget(this._hdrTarget),this._drawPass(this._blurPassX),this._swapHDRBuffers(),HX.setRenderTarget(this._fbo),this._drawPass(this._blurPassY)},HX.HBAO.prototype._initSampleDirTexture=function(){this._sampleDirTexture=new HX.Texture2D;for(var t=[],e=0,i=0;256>i;++i){var r=i/256*2*Math.PI,n=.5*Math.cos(r)+.5,a=.5*Math.sin(r)+.5;t[e]=Math.round(255*n),t[e+1]=Math.round(255*a),t[e+2]=0,t[e+3]=255,e+=4}this._sampleDirTexture.uploadData(new Uint8Array(t),256,1,!1),this._sampleDirTexture.setFilter(HX.TextureFilter.NEAREST_NOMIP),this._sampleDirTexture.setWrapMode(HX.TextureWrapMode.REPEAT)},HX.HBAO.prototype._initDitherTexture=function(){this._ditherTexture=new HX.Texture2D;var t,e=[],i=0,r=[],n=[];for(t=0;16>t;++t)r.push(t/16),n.push(t/15);HX.shuffle(r),HX.shuffle(n),t=0;for(var a=0;4>a;++a)for(var s=0;4>s;++s){var o=r[t],h=n[t];++t,e[i]=Math.round(255*o),e[i+1]=Math.round(255*h),e[i+2]=0,e[i+3]=255,i+=4}this._ditherTexture.uploadData(new Uint8Array(e),4,4,!1),this._ditherTexture.setFilter(HX.TextureFilter.NEAREST_NOMIP),this._ditherTexture.setWrapMode(HX.TextureWrapMode.REPEAT)},HX.ScreenSpaceReflections=function(t){HX.Effect.call(this),t=t||5,this._numSamples=t;var e={NUM_SAMPLES:t},i="#extension GL_OES_standard_derivatives : enable",r=HX.ShaderLibrary.get("ssr_vertex.glsl",e),n=HX.ShaderLibrary.get("ssr_fragment.glsl",e),a=new HX.EffectPass(r,n,null,null,i);this.addPass(a),this.stepSize=Math.max(500/t,1),this.maxDistance=500},HX.ScreenSpaceReflections.prototype=Object.create(HX.Effect.prototype),Object.defineProperty(HX.ScreenSpaceReflections.prototype,"stepSize",{get:function(){return this._stepSize},set:function(t){this._stepSize=t,this.setUniform("stepSize",t)}}),Object.defineProperty(HX.ScreenSpaceReflections.prototype,"maxDistance",{get:function(){return this._stepSize},set:function(t){this._stepSize=t,this.setUniform("maxDistance",t)}}),HX.SSAO=function(t){t=t||8,t>64&&(t=64),this._numSamples=t,this._strength=1,this._fallOffDistance=1,this._radius=.5,this._ditherTexture=null,HX.Effect.call(this),this.addPass(this._ssaoPass=new HX.EffectPass(null,HX.ShaderLibrary.get("ssao_fragment.glsl",{NUM_SAMPLES:t}))),this.addPass(this._blurPassX=new HX.DirectionalBlurPass(4,1,0)),this.addPass(this._blurPassY=new HX.DirectionalBlurPass(4,0,1)),this._initSamples(),this._initDitherTexture(),this._ssaoPass.setUniform("strengthPerSample",2*this._strength/this._numSamples),this._ssaoPass.setUniform("rcpFallOffDistance",1/this._fallOffDistance),this._ssaoPass.setUniform("sampleRadius",this._radius),this._ssaoPass.setTexture("ditherTexture",this._ditherTexture),this._ssaoTexture=new HX.Texture2D,this._ssaoTexture.setFilter(HX.TextureFilter.BILINEAR_NOMIP),this._ssaoTexture.setWrapMode(HX.TextureWrapMode.CLAMP),this._fbo=new HX.FrameBuffer(this._ssaoTexture)},HX.SSAO.prototype=Object.create(HX.Effect.prototype),HX.SSAO.prototype.getAOTexture=function(){return this._ssaoTexture},Object.defineProperty(HX.SSAO.prototype,"sampleRadius",{get:function(){return this._radius},set:function(t){this._radius=t,this._ssaoPass.setUniform("sampleRadius",this._radius)}}),Object.defineProperty(HX.SSAO.prototype,"fallOffDistance",{get:function(){this._fallOffDistance=value},set:function(t){this._fallOffDistance=t,this._ssaoPass.setUniform("rcpFallOffDistance",1/this._fallOffDistance)}}),Object.defineProperty(HX.SSAO.prototype,"strength",{get:function(){return this._strength},set:function(t){this._strength=t,this._ssaoPass.setUniform("strengthPerSample",2*this._strength/this._numSamples)}}),HX.SSAO.prototype._initSamples=function(){for(var t=[],e=0,i=HX.DEFAULT_POISSON_SPHERE,r=0;r<this._numSamples;++r){var n=i[3*r],a=i[3*r+1],s=i[3*r+2];t[e++]=Math.pow(n,6),t[e++]=Math.pow(a,6),t[e++]=Math.pow(s,6)}this._ssaoPass.setUniformArray("samples",new Float32Array(t))},HX.SSAO.prototype._initTargetTexture=function(t,e){this._ssaoTexture.initEmpty(t,e),this._fbo.init()},HX.SSAO.prototype.draw=function(t){var e=this._hdrTarget.width(),i=this._hdrTarget.height();(e!=this._ssaoTexture.width()||i!=this._ssaoTexture.height())&&this._initTargetTexture(e,i),HX.setRenderTarget(this._hdrTarget),this._drawPass(this._ssaoPass),this._swapHDRBuffers(),HX.setRenderTarget(this._hdrTarget),this._drawPass(this._blurPassX),this._swapHDRBuffers(),HX.setRenderTarget(this._fbo),this._drawPass(this._blurPassY)},HX.SSAO.prototype._initDitherTexture=function(){this._ditherTexture=new HX.Texture2D;var t=[64,29,75,255,202,68,43,255,23,170,68,255,161,209,36,255,93,45,218,255,231,84,186,255,52,186,211,255,190,225,179,255,82,108,9,255,195,35,70,255,136,235,60,255,249,162,120,255,5,92,134,255,118,19,194,255,59,219,184,255,172,146,245,255];this._ditherTexture.uploadData(new Uint8Array(t),4,4,!1),this._ditherTexture.setFilter(HX.TextureFilter.NEAREST_NOMIP),this._ditherTexture.setWrapMode(HX.TextureWrapMode.REPEAT)},HX.ToneMapEffect=function(t){return this._adaptive=void 0===t?!1:t,!this._adaptive||HX.EXT_SHADER_TEXTURE_LOD&&HX.EXT_HALF_FLOAT_TEXTURES?(HX.Effect.call(this),this._toneMapPass=this._createToneMapPass(),this._adaptive&&(this.addPass(new HX.EffectPass(null,HX.ShaderLibrary.get("tonemap_reference_fragment.glsl"))),this._luminanceMap=new HX.Texture2D,this._luminanceMap.initEmpty(256,256,HX.GL.RGBA,HX.EXT_HALF_FLOAT_TEXTURES.HALF_FLOAT_OES),this._luminanceFBO=new HX.FrameBuffer([this._luminanceMap]),this._luminanceFBO.init(),this._adaptationRate=500,this._toneMapPass.setTexture("hx_luminanceMap",this._luminanceMap),this._toneMapPass.setUniform("hx_luminanceMipLevel",Math.log(this._luminanceMap._width)/Math.log(2))),this.addPass(this._toneMapPass),void(this.exposure=0)):(console.log("Warning: adaptive tone mapping not supported, using non-adaptive"),void(this._adaptive=!1))},HX.ToneMapEffect.prototype=Object.create(HX.Effect.prototype),HX.ToneMapEffect.prototype._createToneMapPass=function(){throw new Error("Abstract method called!")},HX.ToneMapEffect.prototype.dispose=function(){HX.Effect.prototype.dispose.call(this),this._luminanceFBO.dispose(),this._luminanceMap.dispose()},HX.ToneMapEffect.prototype.draw=function(t){if(this._adaptive){if(!this._isSupported)return;var e=this._adaptationRate>0?t/this._adaptationRate:1;e>1&&(e=1),HX.GL.enable(HX.GL.BLEND),HX.GL.blendFunc(HX.GL.CONSTANT_ALPHA,HX.GL.ONE_MINUS_CONSTANT_ALPHA),HX.GL.blendColor(1,1,1,e),HX.setRenderTarget(this._luminanceFBO),HX.GL.viewport(0,0,this._luminanceFBO._width,this._luminanceFBO._height),this._drawPass(this._opaquePasses[0]),this._luminanceMap.generateMipmap(),HX.GL.disable(HX.GL.BLEND)}HX.setRenderTarget(this._hdrTarget),HX.GL.viewport(0,0,this._hdrTarget._width,this._hdrTarget._height),this._drawPass(this._toneMapPass),this._swapHDRBuffers()},Object.defineProperty(HX.ToneMapEffect.prototype,"exposure",{get:function(){return this._exposure},set:function(t){this._exposure=t,this._isSupported&&this._toneMapPass.setUniform("hx_exposure",Math.pow(2,t))}}),Object.defineProperty(HX.ToneMapEffect.prototype,"adaptationRate",{get:function(){return this._adaptationRate},set:function(t){this._adaptationRate=t}}),HX.ReinhardToneMapEffect=function(t){HX.ToneMapEffect.call(this,t)},HX.ReinhardToneMapEffect.prototype=Object.create(HX.ToneMapEffect.prototype),HX.ReinhardToneMapEffect.prototype._createToneMapPass=function(){var t,e={};return this._adaptive&&(e.ADAPTIVE=1,t="#extension GL_EXT_shader_texture_lod : require"),new HX.EffectPass(null,HX.ShaderLibrary.get("snippets_tonemap.glsl",e)+"\n"+HX.ShaderLibrary.get("tonemap_reinhard_fragment.glsl"),null,null,t)},HX.FilmicToneMapEffect=function(t){HX.ToneMapEffect.call(this,t),this._outputsGamma=!0},HX.FilmicToneMapEffect.prototype=Object.create(HX.ToneMapEffect.prototype),HX.FilmicToneMapEffect.prototype._createToneMapPass=function(){var t,e={};return this._adaptive&&(e.ADAPTIVE=1,t="#extension GL_EXT_shader_texture_lod : require"),new HX.EffectPass(null,HX.ShaderLibrary.get("snippets_tonemap.glsl",e)+"\n"+HX.ShaderLibrary.get("tonemap_filmic_fragment.glsl"),null,null,t)},HX.ModelParser={_registeredParsers:[]},HX.ModelParser.registerParser=function(t,e){HX.ModelParser._registeredParsers[t]=e},HX.ModelParser.getParser=function(t){var e=t.lastIndexOf("."),i=t.substr(e+1).toLowerCase();return new HX.ModelParser._registeredParsers[i]},HX.ModelParser.parse=function(t,e,i){var r=HX.ModelParser.getParser(t),n=new HX.URLLoader;n.setType(r.dataType()),n.onComplete=function(t){r.parse(t,e,i)},n.onError=function(e){console.warn("Failed loading "+t+". Error code: "+e),i&&i(e)},n.load(t)},HX.OBJParser=function(){this._groupData=[],this._vertices=[],this._normals=[],this._uvs=[],this._modelData=null,this._hasNormals=!1},HX.OBJParser.prototype={dataType:function(){return HX.URLLoader.DATA_TEXT},parse:function(t,e){var i=t.split("\n"),r=i.length;this._pushNewGroup("default");for(var n=0;r>n;++n)this._parseLine(i[n]);this._translateModelData(),e(this._modelData)},_parseLine:function(t){if(0!=t.length&&"#"!=t.charAt(0)){var e=t.split(" ");switch(e[0]){case"usemtl":this._pushNewGroup();break;case"v":this._vertices.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"vt":this._uvs.push(parseFloat(e[1]),parseFloat(e[2]));break;case"vn":this._normals.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"o":this._pushNewGroup(e[1]);break;case"g":this._pushNewGroup(e[1]);break;case"f":this._parseFaceData(e);break;default:console.log("OBJ tag ignored or unsupported: "+e[0])}}},_pushNewGroup:function(t){this._activeGroup=new HX.OBJParser.GroupData,this._activeGroup.name=t||"Group"+this._groupData.length,this._groupData.push(this._activeGroup)},_parseFaceData:function(t){for(var e=new HX.OBJParser.FaceData,i=t.length,r=1;i>r;++r){var n=new HX.OBJParser.FaceVertexData;e.vertices.push(n);var a=t[r].split("/"),s=3*(a[0]-1);n.posX=this._vertices[s],n.posY=this._vertices[s+1],n.posZ=this._vertices[s+2],a.length>1&&(s=2*(a[1]-1),n.uvU=this._uvs[s],n.uvV=this._uvs[s+1],a.length>2&&(s=3*(a[2]-1),this._hasNormals=!0,n.normalX=this._normals[s],n.normalY=this._normals[s+1],n.normalZ=this._normals[s+2]))}this._activeGroup.faces.push(e),this._activeGroup.numIndices+=4==t.length?3:6},_translateModelData:function(){this._modelData=new HX.ModelData;for(var t=this._groupData.length,e=0;t>e;++e){var i=this._groupData[e];0!=i.numIndices&&this._modelData.addMeshData(this._translateMeshData(i))}},_translateMeshData:function(t){for(var e=HX.MeshData.createDefaultEmpty(),i=[],r=new Array(t.numIndices),n=0,a=0,s=t.faces,o=s.length,h=0;o>h;++h){for(var _=s[h],l=_.vertices,c=l.length,u=0;c>u;++u){var m=l[u],f=m.getHash();i.hasOwnProperty(f)||(i[f]={index:n++,vertex:m})}r[a]=i[l[0].getHash()].index,r[a+1]=i[l[1].getHash()].index,r[a+2]=i[l[2].getHash()].index,a+=3,4==c&&(r[a]=i[l[0].getHash()].index,r[a+1]=i[l[2].getHash()].index,r[a+2]=i[l[3].getHash()].index,a+=3)}var d=new Array(n*HX.MeshData.DEFAULT_VERTEX_SIZE);for(var f in i)if(i.hasOwnProperty(f)){var p=i[f],X=p.vertex,H=p.index*HX.MeshData.DEFAULT_VERTEX_SIZE;d[H]=X.posX,d[H+1]=X.posY,d[H+2]=X.posZ,d[H+3]=X.normalX,d[H+4]=X.normalY,d[H+5]=X.normalZ,d[H+6]=0,d[H+7]=0,d[H+8]=0,d[H+9]=1,d[H+10]=X.uvU,d[H+11]=X.uvV}e.setVertexData(d),e.setIndexData(r);var g=HX.NormalTangentGenerator.MODE_TANGENTS;this._hasNormals||(g|=HX.NormalTangentGenerator.MODE_NORMALS);var x=new HX.NormalTangentGenerator;return x.generate(e,g,!0),e}},HX.ModelParser.registerParser("obj",HX.OBJParser),HX.OBJParser.FaceVertexData=function(){this.posX=0,this.posY=0,this.posZ=0,this.uvU=0,this.uvV=0,this.normalX=0,this.normalY=0,this.normalZ=0,this._hash=""},HX.OBJParser.FaceVertexData.prototype={getHash:function(){return this._hash||(this._hash=this.posX+"/"+this.posY+"/"+this.posZ+"/"+this.uvU+"/"+this.uvV+"/"+this.normalX+"/"+this.normalY+"/"+this.normalZ+"/"),this._hash}},HX.OBJParser.FaceData=function(){this.vertices=[]},HX.OBJParser.GroupData=function(){this.numIndices=0,this.faces=[],this.name=""},HX.FPSCounter=function(t){this._numFrames=t||1,this._frames=[],this._maxFPS=void 0,this._minFPS=void 0,this._currentFPS=0,this._averageFPS=0,this._runningSum=0;for(var e=0;e<this._numFrames;++e)this._frames[e]=0;this._index=0},HX.FPSCounter.prototype={update:function(t){this._currentFPS=1e3/t,this._runningSum-=this._frames[this._index],this._runningSum+=this._currentFPS,this._averageFPS=this._runningSum/this._numFrames,this._frames[this._index++]=this._currentFPS,this._index==this._numFrames&&(this._index=0),(void 0===this._maxFPS||this._currentFPS>this._maxFPS)&&(this._maxFPS=this._currentFPS),(void 0===this._minFPS||this._currentFPS<this._minFPS)&&(this._minFPS=this._currentFPS)},getLastFrameFPS:function(){return Math.round(this._currentFPS)},getAverageFPS:function(){return Math.round(this._averageFPS)},getMaxFPS:function(){return Math.round(this._maxFPS)},getMinFPS:function(){return Math.round(this._minFPS)},reset:function(){this._maxFPS=void 0,this._minFPS=void 0}},function(){for(var t=0,e=["ms","moz","webkit","o"],i=0;i<e.length&&!window.requestAnimationFrame;++i)window.requestAnimationFrame=window[e[i]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[e[i]+"CancelAnimationFrame"]||window[e[i]+"CancelRequestAnimationFrame"];window.requestAnimationFrame||(window.requestAnimationFrame=function(e,i){var r=(new Date).getTime(),n=Math.max(0,16-(r-t)),a=window.setTimeout(function(){e(r+n)},n);return t=r+n,a}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(t){clearTimeout(t)})}(),HX.FrameTicker=function(){this._isRunning=!1,this._callback=void 0,this._dt=0,this._currentTime=0},HX.FrameTicker.prototype={constructor:HX.FrameTicker,start:function(t){this._callback=t,this._currentTime=this._getTime(),this._isRunning=!0,this._tick(),this._tick._this=this},stop:function(){this._isRunning=!1},get dt(){return this._dt},get time(){return this._currentTime},_tick:function(){if(this._isRunning){self.requestAnimationFrame(this._tick.bind(this));var t=this._getTime();this._dt=t-this._currentTime,this._dt!==this._dt&&(this._dt=0),this._currentTime=t,this._callback()}},_getTime:function(){return void 0===self.performance||void 0==self.performance.now?Date.now():self.performance.now()}},HX.NormalTangentGenerator=function(){this._meshData=null,this._mode=0,this._positionOffset=0,this._normalOffset=0,this._tangentOffset=0,this._faceNormals=null,this._faceTangents=null,this._faceBitangents=null},HX.NormalTangentGenerator.MODE_NORMALS=1,HX.NormalTangentGenerator.MODE_TANGENTS=2,HX.NormalTangentGenerator.prototype={generate:function(t,e,i){void 0===i&&(i=!0),this._mode=void 0===e?HX.NormalTangentGenerator.MODE_NORMALS|HX.NormalTangentGenerator.MODE_TANGENTS:e,this._meshData=t,this._positionOffset=t.getVertexAttribute("hx_position").offset,this._normalOffset=t.getVertexAttribute("hx_normal").offset,this._tangentOffset=t.getVertexAttribute("hx_tangent").offset,this._uvOffset=t.getVertexAttribute("hx_texCoord").offset,this._vertexStride=t.getVertexStride(),this._calculateFaceVectors(i),this._calculateVertexVectors()},_calculateFaceVectors:function(t){var e=this._meshData._indexData.length;0!=(this._mode&HX.NormalTangentGenerator.MODE_NORMALS)&&(this._faceNormals=new Array(e)),0!=(this._mode&HX.NormalTangentGenerator.MODE_TANGENTS)&&(this._faceTangents=new Array(e),this._faceBitangents=new Array(e));for(var i=new HX.Float4,r=new HX.Float4,n=new HX.Float4,a=new HX.Float4,s=new HX.Float4,o=new HX.Float4,h=new HX.Float2,_=new HX.Float2,l=new HX.Float2,c=new HX.Float2,u=new HX.Float2,m=0;e>m;m+=3)this._getFloat3At(m,this._positionOffset,a),this._getFloat3At(m+1,this._positionOffset,s),this._getFloat3At(m+2,this._positionOffset,o),this._getFloat2At(m,this._uvOffset,h),this._getFloat2At(m+1,this._uvOffset,_),this._getFloat2At(m+2,this._uvOffset,l),this._faceNormals&&(s.subtract(a),o.subtract(a),i.cross(s,o),t||i.normalize(),this._faceNormals[m]=i.x,this._faceNormals[m+1]=i.y,this._faceNormals[m+2]=i.z),this._faceTangents&&(c.difference(_,h),u.difference(l,h),r.scaled(u.y,s),n.scaled(c.y,o),i.difference(r,n),i.normalize(),this._faceTangents[m]=i.x,this._faceTangents[m+1]=i.y,this._faceTangents[m+2]=i.z,r.scaled(u.x,s),n.scaled(c.x,o),i.difference(n,r),this._faceBitangents[m]=i.x,this._faceBitangents[m+1]=i.y,this._faceBitangents[m+2]=i.z)},_calculateVertexVectors:function(){this._zeroVectors();for(var t=this._faceTangents?[]:0,e=this._meshData._indexData,i=this._meshData._vertexData,r=e.length,n=0;r>n;++n){var a=e[n],s=this._normalOffset+a*this._vertexStride,o=this._tangentOffset+a*this._vertexStride,h=3*a,_=3*Math.floor(n/3);this._faceNormals&&(i[s]+=this._faceNormals[_],i[s+1]+=this._faceNormals[_+1],i[s+2]+=this._faceNormals[_+2]),this._faceTangents&&(i[o]+=this._faceTangents[_],i[o+1]+=this._faceTangents[_+1],i[o+2]+=this._faceTangents[_+2],t[h]+=this._faceBitangents[_],t[h+1]+=this._faceBitangents[_+1],t[h+2]+=this._faceBitangents[_+2]),o+=this._vertexStride}this._normalize(t)},_zeroVectors:function(){for(var t=this._meshData._vertexData,e=t.length/this._vertexStride,i=this._normalOffset,r=this._tangentOffset,n=0;e>n;++n)this._mode&HX.NormalTangentGenerator.MODE_NORMALS&&(t[i]=0,t[i+1]=0,t[i+2]=0),this._mode&HX.NormalTangentGenerator.MODE_TANGENTS&&(t[r]=0,t[r+1]=0,t[r+2]=0),i+=this._vertexStride,r+=this._vertexStride},_normalize:function(t){for(var e=this._meshData._vertexData,i=e.length/this._vertexStride,r=this._normalOffset,n=this._tangentOffset,a=0,s=new HX.Float4,o=new HX.Float4,h=new HX.Float4,_=new HX.Float4,l=0;i>l;++l)s.x=e[r],s.y=e[r+1],s.z=e[r+2],this._mode&HX.NormalTangentGenerator.MODE_NORMALS&&(s.normalize(),e[r]=s.x,e[r+1]=s.y,e[r+2]=s.z),this._mode&HX.NormalTangentGenerator.MODE_TANGENTS&&(o.x=e[n],o.y=e[n+1],o.z=e[n+2],o.normalize(),h.x=t[a],h.y=t[a+1],h.z=t[a+2],_.cross(o,s),e[n]=o.x,e[n+1]=o.y,e[n+2]=o.z,e[n+3]=HX.dot3(h,_)>0?1:-1),r+=this._vertexStride,n+=this._vertexStride},_getFloat3At:function(t,e,i){var r=this._meshData._indexData,n=e+r[t]*this._vertexStride;i.x=this._meshData._vertexData[n],i.y=this._meshData._vertexData[n+1],i.z=this._meshData._vertexData[n+2]},_getFloat2At:function(t,e,i){var r=this._meshData._indexData,n=e+r[t]*this._vertexStride;i.x=this._meshData._vertexData[n],i.y=this._meshData._vertexData[n+1]}};